# pyright: reportIncompatibleMethodOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: Gst
Date: 2025-12-27
"""
# we disable method override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401

import _gi_gst  # type: ignore
import _thread
import builtins
import typing

# gi.repository imports needed by this Stub
from gi.repository import GLib
from gi.repository import GObject
###############################################################
# Functions
###############################################################

@staticmethod
def buffer_get_max_memory() -> int:
    """
    Gets the maximum amount of memory blocks that a buffer can hold. This is a
    compile time constant that can be queried with the function.

    When more memory blocks are added, existing memory blocks will be merged
    together to make room for the new block.
    """
    ...

@staticmethod
def caps_features_from_string(
    features: str,
) -> CapsFeatures | None:
    """
    Creates a Gst.CapsFeatures from a string representation.
    """
    ...

@staticmethod
def caps_from_string(
    string: str,
) -> Caps | None:
    """
    Converts `caps` from a string representation.

    The implementation of serialization up to 1.20 would lead to unexpected results
    when there were nested Gst.Caps / Gst.Structure deeper than one level.
    """
    ...

@staticmethod
def core_error_quark() -> int: ...
@staticmethod
def debug_add_log_function(
    func: LogFunction,
    *user_data: object | None,
) -> None:
    """
    Adds the logging function to the list of logging functions.
    Be sure to use #G_GNUC_NO_INSTRUMENT on that function, it is needed.
    """
    ...

@staticmethod
def debug_add_ring_buffer_logger(
    max_size_per_thread: int,
    thread_timeout: int,
) -> None:
    """
    Adds a memory ringbuffer based debug logger that stores up to
    `max_size_per_thread` bytes of logs per thread and times out threads after
    `thread_timeout` seconds of inactivity.

    Logs can be fetched with `Gst.debug_ring_buffer_logger_get_logs` and the
    logger can be removed again with `Gst.debug_remove_ring_buffer_logger`.
    Only one logger at a time is possible.
    """
    ...

@staticmethod
def debug_bin_to_dot_data(
    bin: Bin,
    details: DebugGraphDetails,
) -> str:
    """
    To aid debugging applications one can use this method to obtain the whole
    network of gstreamer elements that form the pipeline into a dot file.
    This data can be processed with graphviz to get an image.
    """
    ...

@staticmethod
def debug_bin_to_dot_file(
    bin: Bin,
    details: DebugGraphDetails,
    file_name: str,
) -> None:
    """
    To aid debugging applications one can use this method to write out the whole
    network of gstreamer elements that form the pipeline into a dot file.
    This file can be processed with graphviz to get an image.

    ``` shell
     dot -Tpng -oimage.png graph_lowlevel.dot
    ```
    """
    ...

@staticmethod
def debug_bin_to_dot_file_with_ts(
    bin: Bin,
    details: DebugGraphDetails,
    file_name: str,
) -> None:
    """
    This works like `Gst.debug_bin_to_dot_file`, but adds the current timestamp
    to the filename, so that it can be used to take multiple snapshots.
    """
    ...

@staticmethod
def debug_construct_term_color(
    colorinfo: int,
) -> str:
    """
    Constructs a string that can be used for getting the desired color in color
    terminals.
    You need to free the string after use.
    """
    ...

@staticmethod
def debug_construct_win_color(
    colorinfo: int,
) -> int:
    """
    Constructs an integer that can be used for getting the desired color in
    windows' terminals (cmd.exe). As there is no mean to underline, we simply
    ignore this attribute.

    This function returns 0 on non-windows machines.
    """
    ...

@staticmethod
def debug_get_all_categories() -> list:
    """
    Returns a snapshot of a all categories that are currently in use . This list
    may change anytime.
    The caller has to free the list after use.
    """
    ...

@staticmethod
def debug_get_color_mode() -> DebugColorMode:
    """
    Changes the coloring mode for debug output.
    """
    ...

@staticmethod
def debug_get_default_threshold() -> DebugLevel:
    """
    Returns the default threshold that is used for new categories.
    """
    ...

@staticmethod
def debug_get_stack_trace(
    flags: StackTraceFlags,
) -> str | None: ...
@staticmethod
def debug_is_active() -> bool:
    """
    Checks if debugging output is activated.
    """
    ...

@staticmethod
def debug_is_colored() -> bool:
    """
    Checks if the debugging output should be colored.
    """
    ...

@staticmethod
def debug_level_get_name(
    level: DebugLevel,
) -> str:
    """
    Get the string representation of a debugging level
    """
    ...

@staticmethod
def debug_log_default(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    object: GObject.Object | None,
    message: DebugMessage,
    user_data: object | None = None,
) -> None:
    """
    The default logging handler used by GStreamer. Logging functions get called
    whenever a macro like GST_DEBUG or similar is used. By default this function
    is setup to output the message and additional info to stderr (or the log file
    specified via the GST_DEBUG_FILE environment variable) as received via
    `user_data`.

    You can add other handlers by using `Gst.debug_add_log_function`.
    And you can remove this handler by calling
    gst_debug_remove_log_function(gst_debug_log_default);
    """
    ...

@staticmethod
def debug_log_get_line(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    object: GObject.Object | None,
    message: DebugMessage,
) -> str:
    """
    Returns the string representation for the specified debug log message
    formatted in the same way as `Gst.debug_log_default` (the default handler),
    without color. The purpose is to make it easy for custom log output
    handlers to get a log output that is identical to what the default handler
    would write out.
    """
    ...

@staticmethod
def debug_log_id_literal(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    id: str | None,
    message_string: str,
) -> None:
    """
    Logs the given message using the currently registered debugging handlers.
    """
    ...

@staticmethod
def debug_log_literal(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    object: GObject.Object | None,
    message_string: str,
) -> None:
    """
    Logs the given message using the currently registered debugging handlers.
    """
    ...

@staticmethod
def debug_print_object(
    ptr: object | None = None,
) -> str:
    """
    Returns a string that represents `ptr`. This is safe to call with
    GstStructure, GstCapsFeatures, GstMiniObject s (e.g. GstCaps,
    GstBuffer or GstMessage), and GObjects (e.g. GstElement or GstPad).

    The string representation is meant to be used for debugging purposes and
    might change between GStreamer versions.

    Passing other kind of pointers might or might not work and is generally
    unsafe to do.
    """
    ...

@staticmethod
def debug_print_segment(
    segment: Segment | None = None,
) -> str:
    """
    Returns a string that represents `segments`.

    The string representation is meant to be used for debugging purposes and
    might change between GStreamer versions.
    """
    ...

@staticmethod
def debug_print_stack_trace() -> None:
    """
    If libunwind, glibc backtrace or DbgHelp are present
    a stack trace is printed.
    """
    ...

@staticmethod
def debug_remove_log_function(
    func: LogFunction | None = None,
) -> int:
    """
    Removes all registered instances of the given logging functions.
    """
    ...

@staticmethod
def debug_remove_log_function_by_data(
    data: object | None = None,
) -> int:
    """
    Removes all registered instances of log functions with the given user data.
    """
    ...

@staticmethod
def debug_remove_ring_buffer_logger() -> None:
    """
    Removes any previously added ring buffer logger with
    `Gst.debug_add_ring_buffer_logger`.
    """
    ...

@staticmethod
def debug_ring_buffer_logger_get_logs() -> list:
    """
    Fetches the current logs per thread from the ring buffer logger. See
    `Gst.debug_add_ring_buffer_logger` for details.
    """
    ...

@staticmethod
def debug_set_active(
    active: bool,
) -> None:
    """
    If activated, debugging messages are sent to the debugging
    handlers.
    It makes sense to deactivate it for speed issues.
    > This function is not threadsafe. It makes sense to only call it
    during initialization.
    """
    ...

@staticmethod
def debug_set_color_mode(
    mode: DebugColorMode,
) -> None:
    """
    Changes the coloring mode for debug output.

    This function may be called before `Gst.init`.
    """
    ...

@staticmethod
def debug_set_color_mode_from_string(
    mode: str,
) -> None:
    """
    Changes the coloring mode for debug output.

    This function may be called before `Gst.init`.
    """
    ...

@staticmethod
def debug_set_colored(
    colored: bool,
) -> None:
    """
    Sets or unsets the use of coloured debugging output.
    Same as gst_debug_set_color_mode () with the argument being
    being GST_DEBUG_COLOR_MODE_ON or GST_DEBUG_COLOR_MODE_OFF.

    This function may be called before `Gst.init`.
    """
    ...

@staticmethod
def debug_set_default_threshold(
    level: DebugLevel,
) -> None:
    """
    Sets the default threshold to the given level and updates all categories to
    use this threshold.

    This function may be called before `Gst.init`.
    """
    ...

@staticmethod
def debug_set_threshold_for_name(
    name: str,
    level: DebugLevel,
) -> None:
    """
    Sets all categories which match the given glob style pattern to the given
    level.
    """
    ...

@staticmethod
def debug_set_threshold_from_string(
    list: str,
    reset: bool,
) -> None:
    """
    Sets the debug logging wanted in the same form as with the GST_DEBUG
    environment variable. You can use wildcards such as `*`, but note that
    the order matters when you use wild cards, e.g. `foosrc:6,*src:3,*:2` sets
    everything to log level 2.
    """
    ...

@staticmethod
def debug_unset_threshold_for_name(
    name: str,
) -> None:
    """
    Resets all categories with the given name back to the default level.
    """
    ...

@staticmethod
def dynamic_type_register(
    plugin: Plugin,
    type: GObject.GType,
) -> bool:
    """
    Registers a new Gst.DynamicTypeFactory in the registry
    """
    ...

@staticmethod
def error_get_message(
    domain: int,
    code: int,
) -> str:
    """
    Get a string describing the error message in the current locale.
    """
    ...

@staticmethod
def event_type_get_flags(
    type: EventType,
) -> EventTypeFlags:
    """
    Gets the Gst.EventTypeFlags associated with `type`.
    """
    ...

@staticmethod
def event_type_get_name(
    type: EventType,
) -> str:
    """
    Get a printable name for the given event type. Do not modify or free.
    """
    ...

@staticmethod
def event_type_to_quark(
    type: EventType,
) -> int:
    """
    Get the unique quark for the given event type.
    """
    ...

@staticmethod
def event_type_to_sticky_ordering(
    type: EventType,
) -> int:
    """
    Converts the Gst.EventType to an unsigned integer that
    represents the ordering of sticky events when re-sending them.
    A lower value represents a higher-priority event.
    """
    ...

@staticmethod
def filename_to_uri(
    filename: str,
) -> str | None:
    """
    Similar to `g_filename_to_uri`, but attempts to handle relative file paths
    as well. Before converting `filename` into an URI, it will be prefixed by
    the current working directory if it is a relative path, and then the path
    will be canonicalised so that it doesn't contain any './' or '../' segments.

    On Windows `filename` should be in UTF-8 encoding.
    """
    ...

@staticmethod
def flow_get_name(
    ret: FlowReturn,
) -> str:
    """
    Gets a string representing the given flow return.
    """
    ...

@staticmethod
def flow_to_quark(
    ret: FlowReturn,
) -> int:
    """
    Get the unique quark for the given GstFlowReturn.
    """
    ...

@staticmethod
def format_get_by_nick(
    nick: str,
) -> Format:
    """
    Return the format registered with the given nick.
    """
    ...

@staticmethod
def format_get_details(
    format: Format,
) -> FormatDefinition | None:
    """
    Get details about the given format.
    """
    ...

@staticmethod
def format_get_name(
    format: Format,
) -> str | None:
    """
    Get a printable name for the given format. Do not modify or free.
    """
    ...

@staticmethod
def format_iterate_definitions() -> Iterator:
    """
    Iterate all the registered formats. The format definition is read
    only.
    """
    ...

@staticmethod
def format_register(
    nick: str,
    description: str,
) -> Format:
    """
    Create a new GstFormat based on the nick or return an
    already registered format with that nick.
    """
    ...

@staticmethod
def format_to_quark(
    format: Format,
) -> int:
    """
    Get the unique quark for the given format.
    """
    ...

@staticmethod
def formats_contains(
    formats: list,
    format: Format,
) -> bool:
    """
    See if the given format is inside the format array.
    """
    ...

@staticmethod
def get_main_executable_path() -> str | None:
    """
    This helper is mostly helpful for plugins that need to
    inspect the folder of the main executable to determine
    their set of features.

    When a plugin is initialized from the gst-plugin-scanner
    external process, the returned path will be the same as from the
    parent process.
    """
    ...

@staticmethod
def is_caps_features(
    obj: object | None = None,
) -> bool:
    """
    Checks if `obj` is a Gst.CapsFeatures
    """
    ...

@staticmethod
def is_initialized() -> bool:
    """
    Use this function to check if GStreamer has been initialized with `Gst.init`
    or `Gst.init_check`.
    """
    ...

@staticmethod
def library_error_quark() -> int: ...
@staticmethod
def message_type_get_name(
    type: MessageType,
) -> str:
    """
    Get a printable name for the given message type. Do not modify or free.
    """
    ...

@staticmethod
def message_type_to_quark(
    type: MessageType,
) -> int:
    """
    Get the unique quark for the given message type.
    """
    ...

@staticmethod
def meta_api_type_aggregate_params(
    api: GObject.GType,
    aggregated_params: Structure,
    params0: Structure,
    params1: Structure,
) -> bool:
    """
    When a element like `tee` decides the allocation, each downstream element may
    fill different parameters and pass them to `Gst.Query.add_allocation_meta`.
    In order to keep these parameters, a merge operation is needed. This
    aggregate function can combine the parameters from `params0` and `param1`, and
    write the result back into `aggregated_params`.
    """
    ...

@staticmethod
def meta_api_type_get_tags(
    api: GObject.GType,
) -> list: ...
@staticmethod
def meta_api_type_has_tag(
    api: GObject.GType,
    tag: int,
) -> bool:
    """
    Check if `api` was registered with `tag`.
    """
    ...

@staticmethod
def meta_api_type_register(
    api: str,
    tags: list,
) -> GObject.GType:
    """
    Register and return a GType for the `api` and associate it with
    `tags`.
    """
    ...

@staticmethod
def meta_api_type_set_params_aggregator(
    api: GObject.GType,
    aggregator: AllocationMetaParamsAggregator,
) -> None:
    """
    This function sets the aggregator function for a specific API type.
    """
    ...

@staticmethod
def meta_deserialize(
    buffer: Buffer,
    data: int,
    size: int,
) -> tuple[Meta | None, int]:
    """
    Recreate a Gst.Meta from serialized data returned by
    `Gst.Meta.serialize` and add it to `buffer`.

    Note that the meta must have been previously registered by calling one of
    `gst_*_meta_get_info ()` functions.

    `consumed` is set to the number of bytes that can be skipped from `data` to
    find the next meta serialization, if any. In case of parsing error that does
    not allow to determine that size, `consumed` is set to 0.
    """
    ...

@staticmethod
def meta_get_info(
    impl: str,
) -> MetaInfo | None:
    """
    Lookup a previously registered meta info structure by its implementation name
    `impl`.
    """
    ...

@staticmethod
def meta_register_custom(
    name: str,
    tags: list,
    transform_func: CustomMetaTransformFunction | None = None,
    *user_data: object | None,
) -> MetaInfo:
    """
    Register a new custom Gst.Meta implementation, backed by an opaque
    structure holding a Gst.Structure.

    The registered info can be retrieved later with `Gst.Meta.get_info` by using
    `name` as the key.

    The backing Gst.Structure can be retrieved with
    `Gst.CustomMeta.get_structure`, its mutability is conditioned by the
    writability of the buffer the meta is attached to.

    When `transform_func` is None, the meta and its backing Gst.Structure
    will always be copied when the transform operation is copy, other operations
    are discarded, copy regions are ignored.
    """
    ...

@staticmethod
def meta_register_custom_simple(
    name: str,
) -> MetaInfo:
    """
    Simplified version of `Gst.Meta.register_custom`, with no tags and no
    transform function.
    """
    ...

@staticmethod
def mini_object_replace(
    olddata: MiniObject | None = None,
    newdata: MiniObject | None = None,
) -> tuple[bool, MiniObject | None]:
    """
    Atomically modifies a pointer to point to a new mini-object.
    The reference count of `olddata` is decreased and the reference count of
    `newdata` is increased.

    Either `newdata` and the value pointed to by `olddata` may be None.
    """
    ...

@staticmethod
def mini_object_take(
    olddata: MiniObject,
    newdata: MiniObject,
) -> tuple[bool, MiniObject]:
    """
    Modifies a pointer to point to a new mini-object. The modification
    is done atomically. This version is similar to `Gst.MiniObject.replace`
    except that it does not increase the refcount of `newdata` and thus
    takes ownership of `newdata`.

    Either `newdata` and the value pointed to by `olddata` may be None.
    """
    ...

@staticmethod
def pad_mode_get_name(
    mode: PadMode,
) -> str:
    """
    Return the name of a pad mode, for use in debug messages mostly.
    """
    ...

@staticmethod
def param_spec_array(
    name: str,
    nick: str,
    blurb: str,
    element_spec: GObject.ParamSpec,
    flags: GObject.ParamFlags,
) -> GObject.ParamSpec:
    """
    This function creates a GstArray GParamSpec for use by objects/elements
    that want to expose properties of GstArray type. This function is
    typically * used in connection with `g_object_class_install_property` in a
    GObjects's instance_init function.
    """
    ...

@staticmethod
def param_spec_fraction(
    name: str,
    nick: str,
    blurb: str,
    min_num: int,
    min_denom: int,
    max_num: int,
    max_denom: int,
    default_num: int,
    default_denom: int,
    flags: GObject.ParamFlags,
) -> GObject.ParamSpec | None:
    """
    This function creates a fraction GParamSpec for use by objects/elements
    that want to expose properties of fraction type. This function is typically
    used in connection with `g_object_class_install_property` in a GObjects's
    instance_init function.
    """
    ...

@staticmethod
def parent_buffer_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def parent_buffer_meta_get_info() -> MetaInfo:
    """
    Gets the global Gst.MetaInfo describing  the Gst.ParentBufferMeta meta.
    """
    ...

@staticmethod
def parse_bin_from_description(
    bin_description: str,
    ghost_unlinked_pads: bool,
) -> Bin:
    """
    This is a convenience wrapper around `Gst.parse_launch` to create a
    Gst.Bin from a gst-launch-style pipeline description. See
    `Gst.parse_launch` and the gst-launch man page for details about the
    syntax. Ghost pads on the bin for unlinked source or sink pads
    within the bin can automatically be created (but only a maximum of
    one ghost pad for each direction will be created; if you expect
    multiple unlinked source pads or multiple unlinked sink pads
    and want them all ghosted, you will have to create the ghost pads
    yourself).
    """
    ...

@staticmethod
def parse_bin_from_description_full(
    bin_description: str,
    ghost_unlinked_pads: bool,
    context: ParseContext | None,
    flags: ParseFlags,
) -> Element:
    """
    This is a convenience wrapper around `Gst.parse_launch` to create a
    Gst.Bin from a gst-launch-style pipeline description. See
    `Gst.parse_launch` and the gst-launch man page for details about the
    syntax. Ghost pads on the bin for unlinked source or sink pads
    within the bin can automatically be created (but only a maximum of
    one ghost pad for each direction will be created; if you expect
    multiple unlinked source pads or multiple unlinked sink pads
    and want them all ghosted, you will have to create the ghost pads
    yourself).
    """
    ...

@staticmethod
def parse_error_quark() -> int:
    """
    Get the error quark used by the parsing subsystem.
    """
    ...

@staticmethod
def parse_launch(
    pipeline_description: str,
) -> Element:
    """
    Create a new pipeline based on command line syntax.
    Please note that you might get a return value that is not None even though
    the `error` is set. In this case there was a recoverable parsing error and you
    can try to play the pipeline.

    To create a sub-pipeline (bin) for embedding into an existing pipeline
    use `Gst.parse_bin_from_description`.
    """
    ...

@staticmethod
def parse_launch_full(
    pipeline_description: str,
    context: ParseContext | None,
    flags: ParseFlags,
) -> Element:
    """
    Create a new pipeline based on command line syntax.
    Please note that you might get a return value that is not None even though
    the `error` is set. In this case there was a recoverable parsing error and you
    can try to play the pipeline.

    To create a sub-pipeline (bin) for embedding into an existing pipeline
    use `Gst.parse_bin_from_description_full`.
    """
    ...

@staticmethod
def parse_launchv(
    argv: list,
) -> Element:
    """
    Create a new element based on command line syntax.
    `error` will contain an error message if an erroneous pipeline is specified.
    An error does not mean that the pipeline could not be constructed.
    """
    ...

@staticmethod
def parse_launchv_full(
    argv: list,
    context: ParseContext | None,
    flags: ParseFlags,
) -> Element:
    """
    Create a new element based on command line syntax.
    `error` will contain an error message if an erroneous pipeline is specified.
    An error does not mean that the pipeline could not be constructed.
    """
    ...

@staticmethod
def plugin_error_quark() -> int:
    """
    Get the error quark.
    """
    ...

@staticmethod
def preset_get_app_dir() -> str | None:
    """
    Gets the directory for application specific presets if set by the
    application.
    """
    ...

@staticmethod
def preset_set_app_dir(
    app_dir: str,
) -> bool:
    """
    Sets an extra directory as an absolute path that should be considered when
    looking for presets. Any presets in the application dir will shadow the
    system presets.
    """
    ...

@staticmethod
def protection_filter_systems_by_available_decryptors(
    system_identifiers: list,
) -> list | None:
    """
    Iterates the supplied list of UUIDs and checks the GstRegistry for
    all the decryptors supporting one of the supplied UUIDs.
    """
    ...

@staticmethod
def protection_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def protection_meta_get_info() -> MetaInfo: ...
@staticmethod
def protection_select_system(
    system_identifiers: list,
) -> str | None:
    """
    Iterates the supplied list of UUIDs and checks the GstRegistry for
    an element that supports one of the supplied UUIDs. If more than one
    element matches, the system ID of the highest ranked element is selected.
    """
    ...

@staticmethod
def query_type_get_flags(
    type: QueryType,
) -> QueryTypeFlags:
    """
    Gets the Gst.QueryTypeFlags associated with `type`.
    """
    ...

@staticmethod
def query_type_get_name(
    type: QueryType,
) -> str:
    """
    Get a printable name for the given query type. Do not modify or free.
    """
    ...

@staticmethod
def query_type_to_quark(
    type: QueryType,
) -> int:
    """
    Get the unique quark for the given query type.
    """
    ...

@staticmethod
def reference_timestamp_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def reference_timestamp_meta_get_info() -> MetaInfo:
    """
    Gets the global Gst.MetaInfo describing the Gst.ReferenceTimestampMeta meta.
    """
    ...

@staticmethod
def resource_error_quark() -> int: ...
@staticmethod
def segtrap_is_enabled() -> bool:
    """
    Some functions in the GStreamer core might install a custom SIGSEGV handler
    to better catch and report errors to the application. Currently this feature
    is enabled by default when loading plugins.

    Applications might want to disable this behaviour with the
    `Gst.segtrap_set_enabled` function. This is typically done if the application
    wants to install its own handler without GStreamer interfering.
    """
    ...

@staticmethod
def segtrap_set_enabled(
    enabled: bool,
) -> None:
    """
    Applications might want to disable/enable the SIGSEGV handling of
    the GStreamer core. See `Gst.segtrap_is_enabled` for more information.
    """
    ...

@staticmethod
def state_change_get_name(
    transition: StateChange,
) -> str:
    """
    Gets a string representing the given state transition.
    """
    ...

@staticmethod
def stream_error_quark() -> int: ...
@staticmethod
def stream_type_get_name(
    stype: StreamType,
) -> str:
    """
    Get a descriptive string for a given Gst.StreamType
    """
    ...

@staticmethod
def structure_take(
    oldstr_ptr: Structure | None = None,
    newstr: Structure | None = None,
) -> tuple[bool, Structure | None]:
    """
    Atomically modifies a pointer to point to a new structure.
    The Gst.Structure `oldstr_ptr` is pointing to is freed and
    `newstr` is taken ownership over.

    Either `newstr` and the value pointed to by `oldstr_ptr` may be None.

    It is a programming error if both `newstr` and the value pointed to by
    `oldstr_ptr` refer to the same, non-None structure.
    """
    ...

@staticmethod
def tag_exists(
    tag: str,
) -> bool:
    """
    Checks if the given type is already registered.
    """
    ...

@staticmethod
def tag_get_description(
    tag: str,
) -> str:
    """
    Returns the human-readable description of this tag, You must not change or
    free this string.
    """
    ...

@staticmethod
def tag_get_flag(
    tag: str,
) -> TagFlag:
    """
    Gets the flag of `tag`.
    """
    ...

@staticmethod
def tag_get_nick(
    tag: str,
) -> str:
    """
    Returns the human-readable name of this tag, You must not change or free
    this string.
    """
    ...

@staticmethod
def tag_get_type(
    tag: str,
) -> GObject.GType:
    """
    Gets the GType used for this tag.
    """
    ...

@staticmethod
def tag_is_fixed(
    tag: str,
) -> bool:
    """
    Checks if the given tag is fixed. A fixed tag can only contain one value.
    Unfixed tags can contain lists of values.
    """
    ...

@staticmethod
def tag_list_copy_value(
    list: TagList,
    tag: str,
) -> tuple[bool, GObject.Value]:
    """
    Copies the contents for the given tag into the value,
    merging multiple values into one if multiple values are associated
    with the tag.
    You must `g_value_unset` the value after use.
    """
    ...

@staticmethod
def tag_merge_strings_with_comma(
    src: GObject.Value,
) -> GObject.Value:
    """
    This is a convenience function for the func argument of `Gst.tag_register`.
    It concatenates all given strings using a comma. The tag must be registered
    as a G_TYPE_STRING or this function will fail.
    """
    ...

@staticmethod
def tag_merge_use_first(
    src: GObject.Value,
) -> GObject.Value:
    """
    This is a convenience function for the func argument of `Gst.tag_register`.
    It creates a copy of the first value from the list.
    """
    ...

@staticmethod
def toc_entry_type_get_nick(
    type: TocEntryType,
) -> str:
    """
    Converts `type` to a string representation.
    """
    ...

@staticmethod
def tracing_get_active_tracers() -> list:
    """
    Get a list of all active tracer objects owned by the tracing framework for
    the entirety of the run-time of the process or till `Gst.deinit` is called.
    """
    ...

@staticmethod
def tracing_register_hook(
    tracer: Tracer,
    detail: str,
    func: GObject.Callback,  # type: ignore
) -> None:
    """
    Register `func` to be called when the trace hook `detail` is getting invoked.
    Use None for `detail` to register to all hooks.
    """
    ...

@staticmethod
def type_find_register(
    plugin: Plugin | None,
    name: str,
    rank: int,
    func: TypeFindFunction,
    extensions: str | None = None,
    possible_caps: Caps | None = None,
    *data: object | None,
) -> bool:
    """
    Registers a new typefind function to be used for typefinding. After
    registering this function will be available for typefinding.
    This function is typically called during an element's plugin initialization.
    """
    ...

@staticmethod
def type_is_plugin_api(
    type: GObject.GType,
) -> tuple[bool, PluginAPIFlags]:
    """
    Checks if `type` is plugin API. See `Gst.type_mark_as_plugin_api` for
    details.
    """
    ...

@staticmethod
def type_mark_as_plugin_api(
    type: GObject.GType,
    flags: PluginAPIFlags,
) -> None:
    """
    Marks `type` as plugin API. This should be called in `class_init` of
    elements that expose new types (i.e. enums, flags or internal GObjects) via
    properties, signals or pad templates.

    Types exposed by plugins are not automatically added to the documentation
    as they might originate from another library and should in that case be
    documented via that library instead.

    By marking a type as plugin API it will be included in the documentation of
    the plugin that defines it.
    """
    ...

@staticmethod
def update_registry() -> bool:
    """
    Forces GStreamer to re-scan its plugin paths and update the default
    plugin registry.

    Applications will almost never need to call this function, it is only
    useful if the application knows new plugins have been installed (or old
    ones removed) since the start of the application (or, to be precise, the
    first call to `Gst.init`) and the application wants to make use of any
    newly-installed plugins without restarting the application.

    Applications should assume that the registry update is neither atomic nor
    thread-safe and should therefore not have any dynamic pipelines running
    (including the playbin and decodebin elements) and should also not create
    any elements or access the GStreamer registry while the update is in
    progress.

    Note that this function may block for a significant amount of time.
    """
    ...

@deprecated("deprecated")
@staticmethod
def uri_construct(
    protocol: str,
    location: str,
) -> str:
    """
    Constructs a URI for a given valid protocol and location.

    Free-function: g_free
    """
    ...

@staticmethod
def uri_error_quark() -> int: ...
@staticmethod
def uri_from_string(
    uri: str,
) -> Uri | None:
    """
    Parses a URI string into a new Gst.Uri object. Will return None if the URI
    cannot be parsed.
    """
    ...

@staticmethod
def uri_from_string_escaped(
    uri: str,
) -> Uri | None:
    """
    Parses a URI string into a new Gst.Uri object. Will return None if the URI
    cannot be parsed. This is identical to `Gst.Uri.from_string` except that
    the userinfo and fragment components of the URI will not be unescaped while
    parsing.

    Use this when you need to extract a username and password from the userinfo
    such as https://user:password`example`.com since either may contain
    a URI-escaped ':' character. `Gst.Uri.from_string` will unescape the entire
    userinfo component, which will make it impossible to know which ':'
    delineates the username and password.

    The same applies to the fragment component of the URI, such as
    https://example.com/path#fragment which may contain a URI-escaped '#'.
    """
    ...

@staticmethod
def uri_get_location(
    uri: str,
) -> str | None:
    """
    Extracts the location out of a given valid URI, ie. the protocol and "://"
    are stripped from the URI, which means that the location returned includes
    the hostname if one is specified. The returned string must be freed using
    `g_free`.

    Free-function: g_free
    """
    ...

@staticmethod
def uri_get_protocol(
    uri: str,
) -> str | None:
    """
    Extracts the protocol out of a given valid URI. The returned string must be
    freed using `g_free`.
    """
    ...

@staticmethod
def uri_has_protocol(
    uri: str,
    protocol: str,
) -> bool:
    """
    Checks if the protocol of a given valid URI matches `protocol`.
    """
    ...

@staticmethod
def uri_is_valid(
    uri: str,
) -> bool:
    """
    Tests if the given string is a valid URI identifier. URIs start with a valid
    scheme followed by ":" and maybe a string identifying the location.
    """
    ...

@staticmethod
def uri_join_strings(
    base_uri: str,
    ref_uri: str,
) -> str | None:
    """
    This is a convenience function to join two URI strings and return the result.
    The returned string should be `g_free`'d after use.
    """
    ...

@staticmethod
def uri_protocol_is_supported(
    type: URIType,
    protocol: str,
) -> bool:
    """
    Checks if an element exists that supports the given URI protocol. Note
    that a positive return value does not imply that a subsequent call to
    `Gst.Element.make_from_uri` is guaranteed to work.
    """
    ...

@staticmethod
def uri_protocol_is_valid(
    protocol: str,
) -> bool:
    """
    Tests if the given string is a valid protocol identifier. Protocols
    must consist of alphanumeric characters, '+', '-' and '.' and must
    start with a alphabetic character. See RFC 3986 Section 3.1.
    """
    ...

@staticmethod
def util_array_binary_search(
    array: object | None,
    num_elements: int,
    element_size: int,
    search_func: GLib.CompareDataFunc,  # type: ignore
    mode: SearchMode,
    search_data: object | None = None,
    *user_data: object | None,
) -> object | None:
    """
    Searches inside `array` for `search_data` by using the comparison function
    `search_func`. `array` must be sorted ascending.

    As `search_data` is always passed as second argument to `search_func` it's
    not required that `search_data` has the same type as the array elements.

    The complexity of this search function is O(log (num_elements)).
    """
    ...

@staticmethod
def util_ceil_log2(
    v: int,
) -> int:
    """
    Returns smallest integral value not less than log2(v).
    """
    ...

@staticmethod
def util_double_to_fraction(
    src: float,
) -> tuple[int, int]:
    """
    Transforms a #gdouble to a fraction and simplifies
    the result.
    """
    ...

@staticmethod
def util_dump_buffer(
    buf: Buffer,
) -> None:
    """
    Dumps the buffer memory into a hex representation. Useful for debugging.
    """
    ...

@staticmethod
def util_dump_mem(
    mem: list,
    size: int,
) -> None:
    """
    Dumps the memory block into a hex representation. Useful for debugging.
    """
    ...

@staticmethod
def util_filename_compare(
    a: str,
    b: str,
) -> int:
    """
    Compares the given filenames using natural ordering.
    """
    ...

@staticmethod
def util_floor_log2(
    v: int,
) -> int:
    """
    Returns smallest integral value not bigger than log2(v).
    """
    ...

@staticmethod
def util_fraction_add(
    a_n: int,
    a_d: int,
    b_n: int,
    b_d: int,
) -> tuple[bool, int, int]:
    """
    Adds the fractions `a_n`/`a_d` and `b_n`/`b_d` and stores
    the result in `res_n` and `res_d`.
    """
    ...

@staticmethod
def util_fraction_compare(
    a_n: int,
    a_d: int,
    b_n: int,
    b_d: int,
) -> int:
    """
    Compares the fractions `a_n`/`a_d` and `b_n`/`b_d` and returns
    -1 if a < b, 0 if a = b and 1 if a > b.
    """
    ...

@staticmethod
def util_fraction_multiply(
    a_n: int,
    a_d: int,
    b_n: int,
    b_d: int,
) -> tuple[bool, int, int]:
    """
    Multiplies the fractions `a_n`/`a_d` and `b_n`/`b_d` and stores
    the result in `res_n` and `res_d`.
    """
    ...

@staticmethod
def util_fraction_multiply_int64(
    a_n: int,
    a_d: int,
    b_n: int,
    b_d: int,
) -> tuple[bool, int, int]:
    """
    Multiplies the fractions `a_n`/`a_d` and `b_n`/`b_d` and stores
    the result in `res_n` and `res_d`.
    """
    ...

@staticmethod
def util_fraction_to_double(
    src_n: int,
    src_d: int,
) -> float:
    """
    Transforms a fraction to a #gdouble.
    """
    ...

@staticmethod
def util_gdouble_to_guint64(
    value: float,
) -> int: ...
@staticmethod
def util_get_object_array(
    object: GObject.Object,
    name: str,
) -> tuple[bool, GObject.ValueArray]:
    """
    Get a property of type Gst.TYPE_ARRAY and transform it into a
    GValueArray. This allow language bindings to get GST_TYPE_ARRAY
    properties which are otherwise not an accessible type.
    """
    ...

@staticmethod
def util_get_timestamp() -> int:
    """
    Get a timestamp as GstClockTime to be used for interval measurements.
    The timestamp should not be interpreted in any other way.
    """
    ...

@staticmethod
def util_greatest_common_divisor(
    a: int,
    b: int,
) -> int:
    """
    Calculates the greatest common divisor of `a`
    and `b`.
    """
    ...

@staticmethod
def util_greatest_common_divisor_int64(
    a: int,
    b: int,
) -> int:
    """
    Calculates the greatest common divisor of `a`
    and `b`.
    """
    ...

@staticmethod
def util_group_id_next() -> int:
    """
    Return a constantly incrementing group id.

    This function is used to generate a new group-id for the
    stream-start event.

    This function never returns Gst.GROUP_ID_INVALID (which is 0)
    """
    ...

@staticmethod
def util_guint64_to_gdouble(
    value: int,
) -> float: ...
@staticmethod
def util_seqnum_compare(
    s1: int,
    s2: int,
) -> int:
    """
    Compare two sequence numbers, handling wraparound.

    The current implementation just returns (gint32)(`s1` - `s2`).
    """
    ...

@staticmethod
def util_seqnum_next() -> int:
    """
    Return a constantly incrementing sequence number.

    This function is used internally to GStreamer to be able to determine which
    events and messages are "the same". For example, elements may set the seqnum
    on a segment-done message to be the same as that of the last seek event, to
    indicate that event and the message correspond to the same segment.

    This function never returns Gst.SEQNUM_INVALID (which is 0).
    """
    ...

@staticmethod
def util_set_object_arg(
    object: GObject.Object,
    name: str,
    value: str,
) -> None:
    """
    Converts the string value to the type of the objects argument and
    sets the argument with it.

    Note that this function silently returns if `object` has no property named
    `name` or when `value` cannot be converted to the type of the property.
    """
    ...

@staticmethod
def util_set_object_array(
    object: GObject.Object,
    name: str,
    array: GObject.ValueArray,
) -> bool:
    """
    Transfer a GValueArray to Gst.TYPE_ARRAY and set this value on the
    specified property name. This allow language bindings to set GST_TYPE_ARRAY
    properties which are otherwise not an accessible type.
    """
    ...

@staticmethod
def util_set_value_from_string(
    value_str: str,
) -> GObject.Value:
    """
    Converts the string to the type of the value and
    sets the value with it.

    Note that this function is dangerous as it does not return any indication
    if the conversion worked or not.
    """
    ...

@staticmethod
def util_simplify_fraction(
    numerator: int,
    denominator: int,
    n_terms: int,
    threshold: int,
) -> None:
    """
    Calculates the simpler representation of `numerator` and `denominator` and
    update both values with the resulting simplified fraction.

    Simplify a fraction using a simple continued fraction decomposition.
    The idea here is to convert fractions such as 333333/10000000 to 1/30
    using 32 bit arithmetic only. The algorithm is not perfect and relies
    upon two arbitrary parameters to remove non-significative terms from
    the simple continued fraction decomposition. Using 8 and 333 for
    `n_terms` and `threshold` respectively seems to give nice results.
    """
    ...

@staticmethod
def util_uint64_scale(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale `val` by the rational number `num` / `denom`, avoiding overflows and
    underflows and without loss of precision.

    This function can potentially be very slow if val and num are both
    greater than G_MAXUINT32.
    """
    ...

@staticmethod
def util_uint64_scale_ceil(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale `val` by the rational number `num` / `denom`, avoiding overflows and
    underflows and without loss of precision.

    This function can potentially be very slow if val and num are both
    greater than G_MAXUINT32.
    """
    ...

@staticmethod
def util_uint64_scale_int(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale `val` by the rational number `num` / `denom`, avoiding overflows and
    underflows and without loss of precision.  `num` must be non-negative and
    `denom` must be positive.
    """
    ...

@staticmethod
def util_uint64_scale_int_ceil(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale `val` by the rational number `num` / `denom`, avoiding overflows and
    underflows and without loss of precision.  `num` must be non-negative and
    `denom` must be positive.
    """
    ...

@staticmethod
def util_uint64_scale_int_round(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale `val` by the rational number `num` / `denom`, avoiding overflows and
    underflows and without loss of precision.  `num` must be non-negative and
    `denom` must be positive.
    """
    ...

@staticmethod
def util_uint64_scale_round(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale `val` by the rational number `num` / `denom`, avoiding overflows and
    underflows and without loss of precision.

    This function can potentially be very slow if val and num are both
    greater than G_MAXUINT32.
    """
    ...

@staticmethod
def value_can_compare(
    value1: GObject.Value,
    value2: GObject.Value,
) -> bool:
    """
    Determines if `value1` and `value2` can be compared.
    """
    ...

@staticmethod
def value_can_intersect(
    value1: GObject.Value,
    value2: GObject.Value,
) -> bool:
    """
    Determines if intersecting two values will produce a valid result.
    Two values will produce a valid intersection if they have the same
    type.
    """
    ...

@staticmethod
def value_can_subtract(
    minuend: GObject.Value,
    subtrahend: GObject.Value,
) -> bool:
    """
    Checks if it's possible to subtract `subtrahend` from `minuend`.
    """
    ...

@staticmethod
def value_can_union(
    value1: GObject.Value,
    value2: GObject.Value,
) -> bool:
    """
    Determines if `value1` and `value2` can be non-trivially unioned.
    Any two values can be trivially unioned by adding both of them
    to a GstValueList.  However, certain types have the possibility
    to be unioned in a simpler way.  For example, an integer range
    and an integer can be unioned if the integer is a subset of the
    integer range.  If there is the possibility that two values can
    be unioned, this function returns True.
    """
    ...

@staticmethod
def value_compare(
    value1: GObject.Value,
    value2: GObject.Value,
) -> int:
    """
    Compares `value1` and `value2`.  If `value1` and `value2` cannot be
    compared, the function returns GST_VALUE_UNORDERED.  Otherwise,
    if `value1` is greater than `value2`, GST_VALUE_GREATER_THAN is returned.
    If `value1` is less than `value2`, GST_VALUE_LESS_THAN is returned.
    If the values are equal, GST_VALUE_EQUAL is returned.
    """
    ...

@staticmethod
def value_deserialize(
    src: str,
) -> tuple[bool, GObject.Value]:
    """
    Tries to deserialize a string into the type specified by the given GValue.
    If the operation succeeds, True is returned, False otherwise.
    """
    ...

@staticmethod
def value_deserialize_with_pspec(
    src: str,
    pspec: GObject.ParamSpec | None = None,
) -> tuple[bool, GObject.Value]:
    """
    Tries to deserialize a string into the type specified by the given GValue.
    `pspec` may be used to guide the deserializing of nested members.
    If the operation succeeds, True is returned, False otherwise.
    """
    ...

@staticmethod
def value_fixate(
    dest: GObject.Value,
    src: GObject.Value,
) -> bool:
    """
    Fixate `src` into a new value `dest`.
    For ranges, the first element is taken. For lists and arrays, the
    first item is fixated and returned.
    If `src` is already fixed, this function returns False.
    """
    ...

@staticmethod
def value_fraction_multiply(
    product: GObject.Value,
    factor1: GObject.Value,
    factor2: GObject.Value,
) -> bool:
    """
    Multiplies the two GValue items containing a GST_TYPE_FRACTION and sets
    `product` to the product of the two fractions.
    """
    ...

@staticmethod
def value_fraction_subtract(
    dest: GObject.Value,
    minuend: GObject.Value,
    subtrahend: GObject.Value,
) -> bool:
    """
    Subtracts the `subtrahend` from the `minuend` and sets `dest` to the result.
    """
    ...

@staticmethod
def value_get_bitmask(
    value: GObject.Value,
) -> int:
    """
    Gets the bitmask specified by `value`.
    """
    ...

@staticmethod
def value_get_caps(
    value: GObject.Value,
) -> Caps:
    """
    Gets the contents of `value`. The reference count of the returned
    Gst.Caps will not be modified, therefore the caller must take one
    before getting rid of the `value`.
    """
    ...

@staticmethod
def value_get_caps_features(
    value: GObject.Value,
) -> CapsFeatures:
    """
    Gets the contents of `value`.
    """
    ...

@staticmethod
def value_get_double_range_max(
    value: GObject.Value,
) -> float:
    """
    Gets the maximum of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_double_range_min(
    value: GObject.Value,
) -> float:
    """
    Gets the minimum of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_flagset_flags(
    value: GObject.Value,
) -> int:
    """
    Retrieve the flags field of a GstFlagSet `value`.
    """
    ...

@staticmethod
def value_get_flagset_mask(
    value: GObject.Value,
) -> int:
    """
    Retrieve the mask field of a GstFlagSet `value`.
    """
    ...

@staticmethod
def value_get_fraction_denominator(
    value: GObject.Value,
) -> int:
    """
    Gets the denominator of the fraction specified by `value`.
    """
    ...

@staticmethod
def value_get_fraction_numerator(
    value: GObject.Value,
) -> int:
    """
    Gets the numerator of the fraction specified by `value`.
    """
    ...

@staticmethod
def value_get_fraction_range_max(
    value: GObject.Value,
) -> GObject.Value | None:
    """
    Gets the maximum of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_fraction_range_min(
    value: GObject.Value,
) -> GObject.Value | None:
    """
    Gets the minimum of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_int64_range_max(
    value: GObject.Value,
) -> int:
    """
    Gets the maximum of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_int64_range_min(
    value: GObject.Value,
) -> int:
    """
    Gets the minimum of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_int64_range_step(
    value: GObject.Value,
) -> int:
    """
    Gets the step of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_int_range_max(
    value: GObject.Value,
) -> int:
    """
    Gets the maximum of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_int_range_min(
    value: GObject.Value,
) -> int:
    """
    Gets the minimum of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_int_range_step(
    value: GObject.Value,
) -> int:
    """
    Gets the step of the range specified by `value`.
    """
    ...

@staticmethod
def value_get_structure(
    value: GObject.Value,
) -> Structure:
    """
    Gets the contents of `value`.
    """
    ...

@staticmethod
def value_init_and_copy(
    src: GObject.Value,
) -> GObject.Value:
    """
    Initialises the target value to be of the same type as source and then copies
    the contents from source to target.
    """
    ...

@staticmethod
def value_intersect(
    value1: GObject.Value,
    value2: GObject.Value,
) -> tuple[bool, GObject.Value]:
    """
    Calculates the intersection of two values.  If the values have
    a non-empty intersection, the value representing the intersection
    is placed in `dest`, unless None.  If the intersection is non-empty,
    `dest` is not modified.
    """
    ...

@staticmethod
def value_is_fixed(
    value: GObject.Value,
) -> bool:
    """
    Tests if the given GValue, if available in a GstStructure (or any other
    container) contains a "fixed" (which means: one value) or an "unfixed"
    (which means: multiple possible values, such as data lists or data
    ranges) value.
    """
    ...

@staticmethod
def value_is_subset(
    value1: GObject.Value,
    value2: GObject.Value,
) -> bool:
    """
    Check that `value1` is a subset of `value2`.
    """
    ...

@staticmethod
def value_register(
    table: ValueTable,
) -> None:
    """
    Registers functions to perform calculations on GValue items of a given
    type. Each type can only be added once.
    """
    ...

@staticmethod
def value_serialize(
    value: GObject.Value,
) -> str | None:
    """
    tries to transform the given `value` into a string representation that allows
    getting back this string later on using `Gst.value_deserialize`.

    Free-function: g_free
    """
    ...

@staticmethod
def value_set_bitmask(
    value: GObject.Value,
    bitmask: int,
) -> None:
    """
    Sets `value` to the bitmask specified by `bitmask`.
    """
    ...

@staticmethod
def value_set_caps(
    value: GObject.Value,
    caps: Caps,
) -> None:
    """
    Sets the contents of `value` to `caps`. A reference to the
    provided `caps` will be taken by the `value`.
    """
    ...

@staticmethod
def value_set_caps_features(
    value: GObject.Value,
    features: CapsFeatures,
) -> None:
    """
    Sets the contents of `value` to `features`.
    """
    ...

@staticmethod
def value_set_double_range(
    value: GObject.Value,
    start: float,
    end: float,
) -> None:
    """
    Sets `value` to the range specified by `start` and `end`.
    """
    ...

@staticmethod
def value_set_flagset(
    value: GObject.Value,
    flags: int,
    mask: int,
) -> None:
    """
    Sets `value` to the flags and mask values provided in `flags` and `mask`.
    The `flags` value indicates the values of flags, the `mask` represents
    which bits in the flag value have been set, and which are "don't care"
    """
    ...

@staticmethod
def value_set_fraction(
    value: GObject.Value,
    numerator: int,
    denominator: int,
) -> None:
    """
    Sets `value` to the fraction specified by `numerator` over `denominator`.
    The fraction gets reduced to the smallest numerator and denominator,
    and if necessary the sign is moved to the numerator.
    """
    ...

@staticmethod
def value_set_fraction_range(
    value: GObject.Value,
    start: GObject.Value,
    end: GObject.Value,
) -> None:
    """
    Sets `value` to the range specified by `start` and `end`.
    """
    ...

@staticmethod
def value_set_fraction_range_full(
    value: GObject.Value,
    numerator_start: int,
    denominator_start: int,
    numerator_end: int,
    denominator_end: int,
) -> None:
    """
    Sets `value` to the range specified by `numerator_start`/`denominator_start`
    and `numerator_end`/`denominator_end`.
    """
    ...

@staticmethod
def value_set_int64_range(
    value: GObject.Value,
    start: int,
    end: int,
) -> None:
    """
    Sets `value` to the range specified by `start` and `end`.
    """
    ...

@staticmethod
def value_set_int64_range_step(
    value: GObject.Value,
    start: int,
    end: int,
    step: int,
) -> None:
    """
    Sets `value` to the range specified by `start`, `end` and `step`.
    """
    ...

@staticmethod
def value_set_int_range(
    value: GObject.Value,
    start: int,
    end: int,
) -> None:
    """
    Sets `value` to the range specified by `start` and `end`.
    """
    ...

@staticmethod
def value_set_int_range_step(
    value: GObject.Value,
    start: int,
    end: int,
    step: int,
) -> None:
    """
    Sets `value` to the range specified by `start`, `end` and `step`.
    """
    ...

@staticmethod
def value_set_structure(
    value: GObject.Value,
    structure: Structure,
) -> None:
    """
    Sets the contents of `value` to `structure`.
    """
    ...

@staticmethod
def value_subtract(
    minuend: GObject.Value,
    subtrahend: GObject.Value,
) -> tuple[bool, GObject.Value]:
    """
    Subtracts `subtrahend` from `minuend` and stores the result in `dest`.
    Note that this means subtraction as in sets, not as in mathematics.
    """
    ...

@staticmethod
def value_union(
    value1: GObject.Value,
    value2: GObject.Value,
) -> tuple[bool, GObject.Value]:
    """
    Creates a GValue corresponding to the union of `value1` and `value2`.
    """
    ...

@staticmethod
def version() -> tuple[int, int, int, int]:
    """
    Gets the version number of the GStreamer library.
    """
    ...

@staticmethod
def version_string() -> str:
    """
    This function returns a string that is useful for describing this version
    of GStreamer to the outside world: user agent strings, logging, ...
    """
    ...

###############################################################
# builtin_functions
###############################################################

@staticmethod
def TIME_ARGS(
    time: typing.Any,
) -> typing.Any: ...
@staticmethod
def deinit() -> typing.Any: ...
@staticmethod
def init(
    argv: typing.Any = None,
) -> typing.Any: ...
@staticmethod
def init_check(
    argv: typing.Any,
) -> typing.Any: ...
@staticmethod
def init_python() -> typing.Any: ...

###############################################################
# Enums/Flags
###############################################################

class AllocatorFlags(GObject.GFlags):
    """
    Flags for allocators."""

    CUSTOM_ALLOC = 16
    """
    The allocator has a custom alloc function.
       Only elements designed to work with this allocator should be using it,
       other elements should ignore it from allocation propositions.
       This implies Gst.ALLOCATOR_FLAG_NO_COPY.
    """
    NO_COPY = 32
    """
    When copying a Gst.Memory allocated with this allocator, the copy will
    instead be allocated using the default allocator. Use this when allocating a
    new memory is an heavy opperation that should only be done with a
    Gst.BufferPool for example.
    """
    LAST = 1048576
    """
    first flag that can be used for custom purposes
    """

class BinFlags(GObject.GFlags):
    """
    GstBinFlags are a set of flags specific to bins. Most are set/used
    internally. They can be checked using the `GST_OBJECT_FLAG_IS_SET` macro,
    and (un)set using `GST_OBJECT_FLAG_SET` and `GST_OBJECT_FLAG_UNSET`."""

    NO_RESYNC = 16384
    """
    Don't resync a state change when elements are added or linked in the bin
    """
    STREAMS_AWARE = 32768
    """
    Indicates whether the bin can handle elements that add/remove source pads
    at any point in time without first posting a no-more-pads signal.
    """
    LAST = 524288
    """
    The last enum in the series of flags for bins. Derived classes can use this
    as first value in a list of flags.
    """

class BufferCopyFlags(GObject.GFlags):
    """
    A set of flags that can be provided to the `Gst.Buffer.copy_into`
    function to specify which items should be copied."""

    NONE = 0
    """
    copy nothing
    """
    FLAGS = 1
    """
    flag indicating that buffer flags should be copied
    """
    TIMESTAMPS = 2
    """
    flag indicating that buffer pts, dts,
      duration, offset and offset_end should be copied
    """
    META = 4
    """
    flag indicating that buffer meta should be
      copied
    """
    MEMORY = 8
    """
    flag indicating that buffer memory should be reffed
      and appended to already existing memory. Unless the memory is marked as
      NO_SHARE, no actual copy of the memory is made but it is simply reffed.
      Add `GST_BUFFER_COPY_DEEP` to force a real copy.
    """
    MERGE = 16
    """
    flag indicating that buffer memory should be
      merged
    """
    DEEP = 32
    """
    flag indicating that memory should always be copied instead of reffed
    """

class BufferFlags(GObject.GFlags):
    """
    A set of buffer flags used to describe properties of a Gst.Buffer."""

    LIVE = 16
    """
    the buffer is live data and should be discarded in
                                    the PAUSED state.
    """
    DECODE_ONLY = 32
    """
    the buffer contains data that should be dropped
                                    because it will be clipped against the segment
                                    boundaries or because it does not contain data
                                    that should be shown to the user.
    """
    DISCONT = 64
    """
    the buffer marks a data discontinuity in the stream.
                                    This typically occurs after a seek or a dropped buffer
                                    from a live or network source.
    """
    RESYNC = 128
    """
    the buffer timestamps might have a discontinuity
                                    and this buffer is a good point to resynchronize.
    """
    CORRUPTED = 256
    """
    the buffer data is corrupted.
    """
    MARKER = 512
    """
    the buffer contains a media specific marker. for
                                    video this is the end of a frame boundary, for audio
                                    this is the start of a talkspurt. for RTP
                                    packets this matches the marker flag in the
                                    RTP packet header.
    """
    HEADER = 1024
    """
    the buffer contains header information that is
                                    needed to decode the following data.
    """
    GAP = 2048
    """
    the buffer has been created to fill a gap in the
                                    stream and contains media neutral data (elements can
                                    switch to optimized code path that ignores the buffer
                                    content).
    """
    DROPPABLE = 4096
    """
    the buffer can be dropped without breaking the
                                    stream, for example to reduce bandwidth.
    """
    DELTA_UNIT = 8192
    """
    this unit cannot be decoded independently.
    """
    TAG_MEMORY = 16384
    """
    this flag is set when memory of the buffer
                                    is added/removed
    """
    SYNC_AFTER = 32768
    """
    Elements which write to disk or permanent storage should ensure the data
    is synced after writing the contents of this buffer.
    """
    NON_DROPPABLE = 65536
    """
    This buffer is important and should not be dropped.
    
    This can be used to mark important buffers, e.g. to flag RTP packets
    carrying keyframes or codec setup data for RTP Forward Error Correction
    purposes, or to prevent still video frames from being dropped by elements
    due to QoS.
    """
    LAST = 1048576
    """
    additional media specific flags can be added starting from
                                    this flag.
    """

class BufferPoolAcquireFlags(GObject.GFlags):
    """
    Additional flags to control the allocation of a buffer"""

    NONE = 0
    """
    no flags
    """
    KEY_UNIT = 1
    """
    buffer is keyframe
    """
    DONTWAIT = 2
    """
    when the bufferpool is empty, acquire_buffer
    will by default block until a buffer is released into the pool again. Setting
    this flag makes acquire_buffer return GST_FLOW_EOS instead of blocking.
    """
    DISCONT = 4
    """
    buffer is discont
    """
    LAST = 65536
    """
    last flag, subclasses can use private flags
       starting from this value.
    """

class BufferingMode(GObject.GEnum):
    """
    The different types of buffering methods."""

    STREAM = 0
    """
    a small amount of data is buffered
    """
    DOWNLOAD = 1
    """
    the stream is being downloaded
    """
    TIMESHIFT = 2
    """
    the stream is being downloaded in a ringbuffer
    """
    LIVE = 3
    """
    the stream is a live stream
    """

class BusFlags(GObject.GFlags):
    """
    The standard flags that a bus may have."""

    FLUSHING = 16
    """
    The bus is currently dropping all messages
    """
    FLAG_LAST = 32
    """
    offset to define more flags
    """

class BusSyncReply(GObject.GEnum):
    """
    The result values for a GstBusSyncHandler."""

    DROP = 0
    """
    drop the message
    """
    PASS = 1
    ASYNC = 2

class CapsFlags(GObject.GFlags):
    """
    Extra flags for a caps."""

    ANY = 16
    """
    Caps has no specific content, but can contain
       anything.
    """

class CapsIntersectMode(GObject.GEnum):
    """
    Modes of caps intersection

    Gst.CAPS_INTERSECT_ZIG_ZAG tries to preserve overall order of both caps
    by iterating on the caps' structures as the following matrix shows:

    ```
             caps1
          +-------------
          | 1  2  4  7
    caps2 | 3  5  8 10
          | 6  9 11 12
    ```

    Used when there is no explicit precedence of one caps over the other. e.g.
    tee's sink pad getcaps function, it will probe its src pad peers' for their
    caps and intersect them with this mode.

    Gst.CAPS_INTERSECT_FIRST is useful when an element wants to preserve
    another element's caps priority order when intersecting with its own caps.
    Example: If caps1 is `[A, B, C]` and caps2 is `[E, B, D, A]`, the result
    would be `[A, B]`, maintaining the first caps priority on the intersection."""

    ZIG_ZAG = 0
    """
    Zig-zags over both caps.
    """
    FIRST = 1
    """
    Keeps the first caps order.
    """

class ClockEntryType(GObject.GEnum):
    """
    The type of the clock entry"""

    SINGLE = 0
    """
    a single shot timeout
    """
    PERIODIC = 1
    """
    a periodic timeout request
    """

class ClockFlags(GObject.GFlags):
    """
    The capabilities of this clock"""

    CAN_DO_SINGLE_SYNC = 16
    """
    clock can do a single sync timeout request
    """
    CAN_DO_SINGLE_ASYNC = 32
    """
    clock can do a single async timeout request
    """
    CAN_DO_PERIODIC_SYNC = 64
    """
    clock can do sync periodic timeout requests
    """
    CAN_DO_PERIODIC_ASYNC = 128
    """
    clock can do async periodic timeout callbacks
    """
    CAN_SET_RESOLUTION = 256
    """
    clock's resolution can be changed
    """
    CAN_SET_MASTER = 512
    """
    clock can be slaved to a master clock
    """
    NEEDS_STARTUP_SYNC = 1024
    """
    clock needs to be synced before it can be used
    """
    LAST = 4096
    """
    subclasses can add additional flags starting from this flag
    """

class ClockReturn(GObject.GEnum):
    """
    The return value of a clock operation."""

    OK = 0
    """
    The operation succeeded.
    """
    EARLY = 1
    """
    The operation was scheduled too late.
    """
    UNSCHEDULED = 2
    """
    The clockID was unscheduled
    """
    BUSY = 3
    """
    The ClockID is busy
    """
    BADTIME = 4
    """
    A bad time was provided to a function.
    """
    ERROR = 5
    """
    An error occurred
    """
    UNSUPPORTED = 6
    """
    Operation is not supported
    """
    DONE = 7
    """
    The ClockID is done waiting
    """

class ClockType(GObject.GEnum):
    """
    The different kind of clocks."""

    REALTIME = 0
    """
    time since Epoch
    """
    MONOTONIC = 1
    """
    monotonic time since some unspecified starting
                               point
    """
    OTHER = 2
    """
    some other time source is used (Since: 1.0.5)
    """
    TAI = 3
    """
    time since Epoch, but using International Atomic Time
                         as reference (Since: 1.18)
    """

class CoreError(GObject.GEnum):
    """
    Core errors are errors inside the core GStreamer library."""

    FAILED = 1
    """
    a general error which doesn't fit in any other
    category.  Make sure you add a custom message to the error call.
    """
    TOO_LAZY = 2
    """
    do not use this except as a placeholder for
    deciding where to go while developing code.
    """
    NOT_IMPLEMENTED = 3
    """
    use this when you do not want to implement
    this functionality yet.
    """
    STATE_CHANGE = 4
    """
    used for state change errors.
    """
    PAD = 5
    """
    used for pad-related errors.
    """
    THREAD = 6
    """
    used for thread-related errors.
    """
    NEGOTIATION = 7
    """
    used for negotiation-related errors.
    """
    EVENT = 8
    """
    used for event-related errors.
    """
    SEEK = 9
    """
    used for seek-related errors.
    """
    CAPS = 10
    """
    used for caps-related errors.
    """
    TAG = 11
    """
    used for negotiation-related errors.
    """
    MISSING_PLUGIN = 12
    """
    used if a plugin is missing.
    """
    CLOCK = 13
    """
    used for clock related errors.
    """
    DISABLED = 14
    """
    used if functionality has been disabled at
                              compile time.
    """
    NUM_ERRORS = 15
    """
    the number of core error types.
    """

class DebugColorFlags(GObject.GFlags):
    """
    These are some terminal style flags you can use when creating your
    debugging categories to make them stand out in debugging output."""

    FG_BLACK = 0
    """
    Use black as foreground color.
    """
    FG_RED = 1
    """
    Use red as foreground color.
    """
    FG_GREEN = 2
    """
    Use green as foreground color.
    """
    FG_YELLOW = 3
    """
    Use yellow as foreground color.
    """
    FG_BLUE = 4
    """
    Use blue as foreground color.
    """
    FG_MAGENTA = 5
    """
    Use magenta as foreground color.
    """
    FG_CYAN = 6
    """
    Use cyan as foreground color.
    """
    FG_WHITE = 7
    """
    Use white as foreground color.
    """
    BG_BLACK = 0
    """
    Use black as background color.
    """
    BG_RED = 16
    """
    Use red as background color.
    """
    BG_GREEN = 32
    """
    Use green as background color.
    """
    BG_YELLOW = 48
    """
    Use yellow as background color.
    """
    BG_BLUE = 64
    """
    Use blue as background color.
    """
    BG_MAGENTA = 80
    """
    Use magenta as background color.
    """
    BG_CYAN = 96
    """
    Use cyan as background color.
    """
    BG_WHITE = 112
    """
    Use white as background color.
    """
    BOLD = 256
    """
    Make the output bold.
    """
    UNDERLINE = 512
    """
    Underline the output.
    """

class DebugColorMode(GObject.GEnum):
    OFF = 0
    """
    Do not use colors in logs.
    """
    ON = 1
    """
    Paint logs in a platform-specific way.
    """
    UNIX = 2
    """
    Paint logs with UNIX terminal color codes
                                no matter what platform GStreamer is running on.
    """

class DebugGraphDetails(GObject.GFlags):
    """
    Available details for pipeline graphs produced by `GST_DEBUG_BIN_TO_DOT_FILE`
    and `GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS`."""

    MEDIA_TYPE = 1
    """
    show caps-name on edges
    """
    CAPS_DETAILS = 2
    """
    show caps-details on edges
    """
    NON_DEFAULT_PARAMS = 4
    """
    show modified parameters on
                                              elements
    """
    STATES = 8
    """
    show element states
    """
    FULL_PARAMS = 16
    """
    show full element parameter values even
                                       if they are very long
    """
    ALL = 15
    """
    show all the typical details that one might want
    """
    VERBOSE = 4294967295
    """
    show all details regardless of how large or
                                   verbose they make the resulting output
    """

class DebugLevel(GObject.GEnum):
    """
    The level defines the importance of a debugging message. The more important a
    message is, the greater the probability that the debugging system outputs it."""

    NONE = 0
    """
    No debugging level specified or desired. Used to deactivate
     debugging output.
    """
    ERROR = 1
    """
    Error messages are to be used only when an error occurred
     that stops the application from keeping working correctly.
     An examples is gst_element_error, which outputs a message with this priority.
     It does not mean that the application is terminating as with g_error.
    """
    WARNING = 2
    """
    Warning messages are to inform about abnormal behaviour
     that could lead to problems or weird behaviour later on. An example of this
     would be clocking issues ("your computer is pretty slow") or broken input
     data ("Can't synchronize to stream.")
    """
    FIXME = 3
    """
    Fixme messages are messages that indicate that something
     in the executed code path is not fully implemented or handled yet. Note
     that this does not replace proper error handling in any way, the purpose
     of this message is to make it easier to spot incomplete/unfinished pieces
     of code when reading the debug log.
    """
    INFO = 4
    """
    Informational messages should be used to keep the developer
     updated about what is happening.
     Examples where this should be used are when a typefind function has
     successfully determined the type of the stream or when an mp3 plugin detects
     the format to be used. ("This file has mono sound.")
    """
    DEBUG = 5
    """
    Debugging messages should be used when something common
     happens that is not the expected default behavior, or something that's
     useful to know but doesn't happen all the time (ie. per loop iteration or
     buffer processed or event handled).
     An example would be notifications about state changes or receiving/sending
     of events.
    """
    LOG = 6
    """
    Log messages are messages that are very common but might be
     useful to know. As a rule of thumb a pipeline that is running as expected
     should never output anything else but LOG messages whilst processing data.
     Use this log level to log recurring information in chain functions and
     loop functions, for example.
    """
    TRACE = 7
    """
    Tracing-related messages.
     Examples for this are referencing/dereferencing of objects.
    """
    MEMDUMP = 9
    """
    memory dump messages are used to log (small) chunks of
     data as memory dumps in the log. They will be displayed as hexdump with
     ASCII characters.
    """
    COUNT = 10
    """
    The number of defined debugging levels.
    """

class ElementFlags(GObject.GFlags):
    """
    The standard flags that an element may have."""

    LOCKED_STATE = 16
    """
    ignore state changes from parent
    """
    SINK = 32
    """
    the element is a sink
    """
    SOURCE = 64
    """
    the element is a source.
    """
    PROVIDE_CLOCK = 128
    """
    the element can provide a clock
    """
    REQUIRE_CLOCK = 256
    """
    the element requires a clock
    """
    INDEXABLE = 512
    """
    the element can use an index
    """
    LAST = 16384
    """
    offset to define more flags
    """

class EventType(GObject.GEnum):
    """
    Gst.EventType lists the standard event types that can be sent in a pipeline.

    The custom event types can be used for private messages between elements
    that can't be expressed using normal
    GStreamer buffer passing semantics. Custom events carry an arbitrary
    Gst.Structure.
    Specific custom events are distinguished by the name of the structure."""

    UNKNOWN = 0
    """
    unknown event.
    """
    FLUSH_START = 2563
    """
    Start a flush operation. This event clears all data
                    from the pipeline and unblock all streaming threads.
    """
    FLUSH_STOP = 5127
    """
    Stop a flush operation. This event resets the
                    running-time of the pipeline.
    """
    STREAM_START = 10254
    """
    Event to mark the start of a new stream. Sent before any
                    other serialized event and only sent at the start of a new stream,
                    not after flushing seeks.
    """
    CAPS = 12814
    """
    Gst.Caps event. Notify the pad of a new media type.
    """
    SEGMENT = 17934
    """
    A new media segment follows in the dataflow. The
                    segment events contains information for clipping buffers and
                    converting buffer timestamps to running-time and
                    stream-time.
    """
    STREAM_COLLECTION = 19230
    """
    A new Gst.StreamCollection is available (Since: 1.10)
    """
    TAG = 20510
    """
    A new set of metadata tags has been found in the stream.
    """
    BUFFERSIZE = 23054
    """
    Notification of buffering requirements. Currently not
                    used yet.
    """
    SINK_MESSAGE = 25630
    """
    An event that sinks turn into a message. Used to
                             send messages that should be emitted in sync with
                             rendering.
    """
    STREAM_GROUP_DONE = 26894
    """
    Indicates that there is no more data for
                    the stream group ID in the message. Sent before EOS
                    in some instances and should be handled mostly the same. (Since: 1.10)
    """
    EOS = 28174
    """
    End-Of-Stream. No more data is to be expected to follow
                    without either a STREAM_START event, or a FLUSH_STOP and a SEGMENT
                    event.
    """
    TOC = 30750
    """
    An event which indicates that a new table of contents (TOC)
                    was found or updated.
    """
    PROTECTION = 33310
    """
    An event which indicates that new or updated
                    encryption information has been found in the stream.
    """
    SEGMENT_DONE = 38406
    """
    Marks the end of a segment playback.
    """
    GAP = 40966
    """
    Marks a gap in the datastream.
    """
    INSTANT_RATE_CHANGE = 46090
    """
    Notify downstream that a playback rate override
                                    should be applied as soon as possible. (Since: 1.18)
    """
    QOS = 48641
    """
    A quality message. Used to indicate to upstream elements
                    that the downstream elements should adjust their processing
                    rate.
    """
    SEEK = 51201
    """
    A request for a new playback position and rate.
    """
    NAVIGATION = 53761
    """
    Navigation events are usually used for communicating
                           user requests, such as mouse or keyboard movements,
                           to upstream elements.
    """
    LATENCY = 56321
    """
    Notification of new latency adjustment. Sinks will use
                        the latency information to adjust their synchronisation.
    """
    STEP = 58881
    """
    A request for stepping through the media. Sinks will usually
                     execute the step operation.
    """
    RECONFIGURE = 61441
    """
    A request for upstream renegotiating caps and reconfiguring.
    """
    TOC_SELECT = 64001
    """
    A request for a new playback position based on TOC
                           entry's UID.
    """
    SELECT_STREAMS = 66561
    """
    A request to select one or more streams (Since: 1.10)
    """
    INSTANT_RATE_SYNC_TIME = 66817
    """
    Sent by the pipeline to notify elements that handle the
                                       instant-rate-change event about the running-time when
                                       the rate multiplier should be applied (or was applied). (Since: 1.18)
    """
    CUSTOM_UPSTREAM = 69121
    """
    Upstream custom event
    """
    CUSTOM_DOWNSTREAM = 71686
    """
    Downstream custom event that travels in the
                           data flow.
    """
    CUSTOM_DOWNSTREAM_OOB = 74242
    """
    Custom out-of-band downstream event.
    """
    CUSTOM_DOWNSTREAM_STICKY = 76830
    """
    Custom sticky downstream event.
    """
    CUSTOM_BOTH = 79367
    """
    Custom upstream or downstream event.
                            In-band when travelling downstream.
    """
    CUSTOM_BOTH_OOB = 81923
    """
    Custom upstream or downstream out-of-band event.
    """

class EventTypeFlags(GObject.GFlags):
    """
    Gst.EventTypeFlags indicate the aspects of the different Gst.EventType
    values. You can get the type flags of a Gst.EventType with the
    `Gst.Event.type_get_flags` function."""

    UPSTREAM = 1
    """
    Set if the event can travel upstream.
    """
    DOWNSTREAM = 2
    """
    Set if the event can travel downstream.
    """
    SERIALIZED = 4
    """
    Set if the event should be serialized with data
                                  flow.
    """
    STICKY = 8
    """
    Set if the event is sticky on the pads.
    """
    STICKY_MULTI = 16
    """
    Multiple sticky events can be on a pad, each
                                  identified by the event name.
    """

class FlowReturn(GObject.GEnum):
    """
    The result of passing data to a pad.

    Note that the custom return values should not be exposed outside of the
    element scope."""

    CUSTOM_SUCCESS_2 = 102
    """
    Pre-defined custom success code.
    """
    CUSTOM_SUCCESS_1 = 101
    """
    Pre-defined custom success code (define your
                                  custom success code to this to avoid compiler
                                  warnings).
    """
    CUSTOM_SUCCESS = 100
    """
    Elements can use values starting from
                                  this (and higher) to define custom success
                                  codes.
    """
    OK = 0
    """
    Data passing was ok.
    """
    NOT_LINKED = -1
    """
    Pad is not linked.
    """
    FLUSHING = -2
    """
    Pad is flushing.
    """
    EOS = -3
    """
    Pad is EOS.
    """
    NOT_NEGOTIATED = -4
    """
    Pad is not negotiated.
    """
    ERROR = -5
    """
    Some (fatal) error occurred. Element generating
                                  this error should post an error message using
                                  `GST_ELEMENT_ERROR` with more details.
    """
    NOT_SUPPORTED = -6
    """
    This operation is not supported.
    """
    CUSTOM_ERROR = -100
    """
    Elements can use values starting from
                                  this (and lower) to define custom error codes.
    """
    CUSTOM_ERROR_1 = -101
    """
    Pre-defined custom error code (define your
                                  custom error code to this to avoid compiler
                                  warnings).
    """
    CUSTOM_ERROR_2 = -102
    """
    Pre-defined custom error code.
    """

class Format(GObject.GEnum):
    """
    Standard predefined formats"""

    UNDEFINED = 0
    """
    undefined format
    """
    DEFAULT = 1
    """
    the default format of the pad/element. This can be
       samples for raw audio, frames/fields for raw video (some, but not all,
       elements support this; use `GST_FORMAT_TIME` if you don't have a good
       reason to query for samples/frames)
    """
    BYTES = 2
    """
    bytes
    """
    TIME = 3
    """
    time in nanoseconds
    """
    BUFFERS = 4
    """
    buffers (few, if any, elements implement this as of
        May 2009)
    """
    PERCENT = 5
    """
    percentage of stream (few, if any, elements implement
        this as of May 2009)
    """

class GapFlags(GObject.GFlags):
    """
    The different flags that can be set on GST_EVENT_GAP events. See
    `Gst.Event.set_gap_flags` for details."""

    DATA = 1
    """
    The GST_EVENT_GAP signals missing data,
       for example because of packet loss.
    """

class IteratorItem(GObject.GEnum):
    """
    The result of a Gst.IteratorItemFunction."""

    SKIP = 0
    """
    Skip this item
    """
    PASS = 1
    END = 2
    """
    Stop after this item.
    """

class IteratorResult(GObject.GEnum):
    """
    The result of `Gst.Iterator.next`."""

    DONE = 0
    """
    No more items in the iterator
    """
    OK = 1
    """
    An item was retrieved
    """
    RESYNC = 2
    """
    Datastructure changed while iterating
    """
    ERROR = 3
    """
    An error happened
    """

class LibraryError(GObject.GEnum):
    """
    Library errors are for errors from the library being used by elements
    (initializing, finalizing, settings, ...)"""

    FAILED = 1
    """
    a general error which doesn't fit in any other
    category.  Make sure you add a custom message to the error call.
    """
    TOO_LAZY = 2
    """
    do not use this except as a placeholder for
    deciding where to go while developing code.
    """
    INIT = 3
    """
    used when the library could not be opened.
    """
    SHUTDOWN = 4
    """
    used when the library could not be closed.
    """
    SETTINGS = 5
    """
    used when the library doesn't accept settings.
    """
    ENCODE = 6
    """
    used when the library generated an encoding error.
    """
    NUM_ERRORS = 7
    """
    the number of library error types.
    """

class LockFlags(GObject.GFlags):
    """
    Flags used when locking miniobjects"""

    READ = 1
    """
    lock for read access
    """
    WRITE = 2
    """
    lock for write access
    """
    EXCLUSIVE = 4
    """
    lock for exclusive access
    """
    LAST = 256
    """
    first flag that can be used for custom purposes
    """

class MapFlags(GObject.GFlags):
    """
    Flags used when mapping memory"""

    READ = 1
    """
    map for read access
    """
    WRITE = 2
    """
    map for write access
    """
    FLAG_LAST = 65536
    """
    first flag that can be used for custom purposes
    """

class MemoryFlags(GObject.GFlags):
    """
    Flags for wrapped memory."""

    READONLY = 2
    """
    memory is readonly. It is not allowed to map the
    memory with GST_MAP_WRITE.
    """
    NO_SHARE = 16
    """
    memory must not be shared. Copies will have to be
    made when this memory needs to be shared between buffers. (DEPRECATED:
    do not use in new code, instead you should create a custom GstAllocator for
    memory pooling instead of relying on the GstBuffer they were originally
    attached to.)
    """
    ZERO_PREFIXED = 32
    """
    the memory prefix is filled with 0 bytes
    """
    ZERO_PADDED = 64
    """
    the memory padding is filled with 0 bytes
    """
    PHYSICALLY_CONTIGUOUS = 128
    """
    the memory is physically
    contiguous. (Since: 1.2)
    """
    NOT_MAPPABLE = 256
    """
    the memory can't be mapped via
    `Gst.Memory.map` without any preconditions. (Since: 1.2)
    """
    LAST = 1048576
    """
    first flag that can be used for custom purposes
    """

class MessageType(GObject.GFlags):
    """
    The different message types that are available."""

    UNKNOWN = 0
    """
    an undefined message
    """
    EOS = 1
    """
    end-of-stream reached in a pipeline. The application will
    only receive this message in the PLAYING state and every time it sets a
    pipeline to PLAYING that is in the EOS state. The application can perform a
    flushing seek in the pipeline, which will undo the EOS state again.
    """
    ERROR = 2
    """
    an error occurred. When the application receives an error
    message it should stop playback of the pipeline and not assume that more
    data will be played. It is possible to specify a redirection url to the error
    messages by setting a `redirect-location` field into the error message, application
    or high level bins might use the information as required.
    """
    WARNING = 4
    """
    a warning occurred.
    """
    INFO = 8
    """
    an info message occurred
    """
    TAG = 16
    """
    a tag was found.
    """
    BUFFERING = 32
    """
    the pipeline is buffering. When the application
    receives a buffering message in the PLAYING state for a non-live pipeline it
    must PAUSE the pipeline until the buffering completes, when the percentage
    field in the message is 100%. For live pipelines, no action must be
    performed and the buffering percentage can be used to inform the user about
    the progress.
    """
    STATE_CHANGED = 64
    """
    a state change happened
    """
    STATE_DIRTY = 128
    """
    an element changed state in a streaming thread.
    This message is deprecated.
    """
    STEP_DONE = 256
    """
    a stepping operation finished.
    """
    CLOCK_PROVIDE = 512
    """
    an element notifies its capability of providing
                                a clock. This message is used internally and
                                never forwarded to the application.
    """
    CLOCK_LOST = 1024
    """
    The current clock as selected by the pipeline became
                             unusable. The pipeline will select a new clock on
                             the next PLAYING state change. The application
                             should set the pipeline to PAUSED and back to
                             PLAYING when this message is received.
    """
    NEW_CLOCK = 2048
    """
    a new clock was selected in the pipeline.
    """
    STRUCTURE_CHANGE = 4096
    """
    the structure of the pipeline changed. This
    message is used internally and never forwarded to the application.
    """
    STREAM_STATUS = 8192
    """
    status about a stream, emitted when it starts,
                                stops, errors, etc..
    """
    APPLICATION = 16384
    """
    message posted by the application, possibly
                              via an application-specific element.
    """
    ELEMENT = 32768
    """
    element-specific message, see the specific element's
                          documentation
    """
    SEGMENT_START = 65536
    """
    pipeline started playback of a segment. This
    message is used internally and never forwarded to the application.
    """
    SEGMENT_DONE = 131072
    """
    pipeline completed playback of a segment. This
    message is forwarded to the application after all elements that posted
    `GST_MESSAGE_SEGMENT_START` posted a GST_MESSAGE_SEGMENT_DONE message.
    """
    DURATION_CHANGED = 262144
    """
    The duration of a pipeline changed. The
    application can get the new duration with a duration query.
    """
    LATENCY = 524288
    """
    Posted by elements when their latency changes. The
    application should recalculate and distribute a new latency.
    """
    ASYNC_START = 1048576
    """
    Posted by elements when they start an ASYNC
    Gst.StateChange. This message is not forwarded to the application but is used
    internally.
    """
    ASYNC_DONE = 2097152
    """
    Posted by elements when they complete an ASYNC
    Gst.StateChange. The application will only receive this message from the toplevel
    pipeline.
    """
    REQUEST_STATE = 4194304
    """
    Posted by elements when they want the pipeline to
    change state. This message is a suggestion to the application which can
    decide to perform the state change on (part of) the pipeline.
    """
    STEP_START = 8388608
    """
    A stepping operation was started.
    """
    QOS = 16777216
    """
    A buffer was dropped or an element changed its processing
    strategy for Quality of Service reasons.
    """
    PROGRESS = 33554432
    """
    A progress message.
    """
    TOC = 67108864
    """
    A new table of contents (TOC) was found or previously found TOC
    was updated.
    """
    RESET_TIME = 134217728
    """
    Message to request resetting the pipeline's
        running time from the pipeline. This is an internal message which
        applications will likely never receive.
    """
    STREAM_START = 268435456
    """
    Message indicating start of a new stream. Useful
        e.g. when using playbin in gapless playback mode, to get notified when
        the next title actually starts playing (which will be some time after
        the URI for the next title has been set).
    """
    NEED_CONTEXT = 536870912
    """
    Message indicating that an element wants a specific context (Since: 1.2)
    """
    HAVE_CONTEXT = 1073741824
    """
    Message indicating that an element created a context (Since: 1.2)
    """
    EXTENDED = 2147483648
    """
    Message is an extended message type (see below).
        These extended message IDs can't be used directly with mask-based API
        like `Gst.Bus.poll` or `Gst.Bus.timed_pop_filtered`, but you can still
        filter for GST_MESSAGE_EXTENDED and then check the result for the
        specific type. (Since: 1.4)
    """
    DEVICE_ADDED = 2147483649
    """
    Message indicating a Gst.Device was added to
        a Gst.DeviceProvider (Since: 1.4)
    """
    DEVICE_REMOVED = 2147483650
    """
    Message indicating a Gst.Device was removed
        from a Gst.DeviceProvider (Since: 1.4)
    """
    PROPERTY_NOTIFY = 2147483651
    """
    Message indicating a GObject property has
        changed (Since: 1.10)
    """
    STREAM_COLLECTION = 2147483652
    """
    Message indicating a new Gst.StreamCollection
        is available (Since: 1.10)
    """
    STREAMS_SELECTED = 2147483653
    """
    Message indicating the active selection of
        Gst.Streams has changed (Since: 1.10)
    """
    REDIRECT = 2147483654
    """
    Message indicating to request the application to
        try to play the given URL(s). Useful if for example a HTTP 302/303
        response is received with a non-HTTP URL inside. (Since: 1.10)
    """
    DEVICE_CHANGED = 2147483655
    """
    Message indicating a Gst.Device was changed
        a Gst.DeviceProvider (Since: 1.16)
    """
    INSTANT_RATE_REQUEST = 2147483656
    """
    Message sent by elements to request the
        running time from the pipeline when an instant rate change should
        be applied (which may be in the past when the answer arrives). (Since: 1.18)
    """
    ANY = 4294967295
    """
    mask for all of the above messages.
    """

class MetaFlags(GObject.GFlags):
    """
    Extra metadata flags."""

    NONE = 0
    """
    no flags
    """
    READONLY = 1
    """
    metadata should not be modified
    """
    POOLED = 2
    """
    metadata is managed by a bufferpool
    """
    LOCKED = 4
    """
    metadata should not be removed
    """
    LAST = 65536
    """
    additional flags can be added starting from this flag.
    """

class MiniObjectFlags(GObject.GFlags):
    """
    Flags for the mini object"""

    LOCKABLE = 1
    """
    the object can be locked and unlocked with
    `Gst.MiniObject.lock` and `Gst.MiniObject.unlock`.
    """
    LOCK_READONLY = 2
    """
    the object is permanently locked in
    READONLY mode. Only read locks can be performed on the object.
    """
    MAY_BE_LEAKED = 4
    """
    the object is expected to stay alive
    even after `Gst.deinit` has been called and so should be ignored by leak
    detection tools. (Since: 1.10)
    """
    LAST = 16
    """
    first flag that can be used by subclasses.
    """

class ObjectFlags(GObject.GFlags):
    """
    The standard flags that an gstobject may have."""

    MAY_BE_LEAKED = 1
    """
    the object is expected to stay alive even
    after `Gst.deinit` has been called and so should be ignored by leak
    detection tools. (Since: 1.10)
    """
    CONSTRUCTED = 2
    """
    Flag that's set when the object has been constructed. This can be used by
    API such as base class setters to differentiate between the case where
    they're called from a subclass's instance init function (and where the
    object isn't fully constructed yet, and so one shouldn't do anything but
    set values in the instance structure), and the case where the object is
    constructed.
    """
    LAST = 16
    """
    subclasses can add additional flags starting from this flag
    """

class PadDirection(GObject.GEnum):
    """
    The direction of a pad."""

    UNKNOWN = 0
    """
    direction is unknown.
    """
    SRC = 1
    """
    the pad is a source pad.
    """
    SINK = 2
    """
    the pad is a sink pad.
    """

class PadFlags(GObject.GFlags):
    """
    Pad state flags"""

    BLOCKED = 16
    """
    is dataflow on a pad blocked
    """
    FLUSHING = 32
    """
    is pad flushing
    """
    EOS = 64
    """
    is pad in EOS state
    """
    BLOCKING = 128
    """
    is pad currently blocking on a buffer or event
    """
    NEED_PARENT = 256
    """
    ensure that there is a parent object before calling
                          into the pad callbacks.
    """
    NEED_RECONFIGURE = 512
    """
    the pad should be reconfigured/renegotiated.
                               The flag has to be unset manually after
                               reconfiguration happened.
    """
    PENDING_EVENTS = 1024
    """
    the pad has pending events
    """
    FIXED_CAPS = 2048
    """
    the pad is using fixed caps. This means that
        once the caps are set on the pad, the default caps query function
        will only return those caps.
    """
    PROXY_CAPS = 4096
    """
    the default event and query handler will forward
                         all events and queries to the internally linked pads
                         instead of discarding them.
    """
    PROXY_ALLOCATION = 8192
    """
    the default query handler will forward
                         allocation queries to the internally linked pads
                         instead of discarding them.
    """
    PROXY_SCHEDULING = 16384
    """
    the default query handler will forward
                         scheduling queries to the internally linked pads
                         instead of discarding them.
    """
    ACCEPT_INTERSECT = 32768
    """
    the default accept-caps handler will check
                         it the caps intersect the query-caps result instead
                         of checking for a subset. This is interesting for
                         parsers that can accept incompletely specified caps.
    """
    ACCEPT_TEMPLATE = 65536
    """
    the default accept-caps handler will use
                         the template pad caps instead of query caps to
                         compare with the accept caps. Use this in combination
                         with Gst.PAD_FLAG_ACCEPT_INTERSECT. (Since: 1.6)
    """
    LAST = 1048576
    """
    offset to define more flags
    """

class PadLinkCheck(GObject.GFlags):
    """
    The amount of checking to be done when linking pads. `GST_PAD_LINK_CHECK_CAPS`
    and `GST_PAD_LINK_CHECK_TEMPLATE_CAPS` are mutually exclusive. If both are
    specified, expensive but safe `GST_PAD_LINK_CHECK_CAPS` are performed.

    > Only disable some of the checks if you are 100% certain you know the link
    > will not fail because of hierarchy/caps compatibility failures. If uncertain,
    > use the default checks (Gst.PAD_LINK_CHECK_DEFAULT) or the regular methods
    > for linking the pads."""

    NOTHING = 0
    """
    Don't check hierarchy or caps compatibility.
    """
    HIERARCHY = 1
    """
    Check the pads have same parents/grandparents.
      Could be omitted if it is already known that the two elements that own the
      pads are in the same bin.
    """
    TEMPLATE_CAPS = 2
    """
    Check if the pads are compatible by using
      their template caps. This is much faster than `GST_PAD_LINK_CHECK_CAPS`, but
      would be unsafe e.g. if one pad has Gst.CAPS_ANY.
    """
    CAPS = 4
    """
    Check if the pads are compatible by comparing the
      caps returned by `Gst.Pad.query_caps`.
    """
    NO_RECONFIGURE = 8
    """
    Disables pushing a reconfigure event when pads are
      linked.
    """
    DEFAULT = 5
    """
    The default checks done when linking
      pads (i.e. the ones used by `Gst.Pad.link`).
    """

class PadLinkReturn(GObject.GEnum):
    """
    Result values from gst_pad_link and friends."""

    OK = 0
    """
    link succeeded
    """
    WRONG_HIERARCHY = -1
    """
    pads have no common grandparent
    """
    WAS_LINKED = -2
    """
    pad was already linked
    """
    WRONG_DIRECTION = -3
    """
    pads have wrong direction
    """
    NOFORMAT = -4
    """
    pads do not have common format
    """
    NOSCHED = -5
    """
    pads cannot cooperate in scheduling
    """
    REFUSED = -6
    """
    refused for some reason
    """

class PadMode(GObject.GEnum):
    """
    The status of a GstPad. After activating a pad, which usually happens when the
    parent element goes from READY to PAUSED, the GstPadMode defines if the
    pad operates in push or pull mode."""

    NONE = 0
    """
    Pad will not handle dataflow
    """
    PUSH = 1
    """
    Pad handles dataflow in downstream push mode
    """
    PULL = 2
    """
    Pad handles dataflow in upstream pull mode
    """

class PadPresence(GObject.GEnum):
    """
    Indicates when this pad will become available."""

    ALWAYS = 0
    """
    the pad is always available
    """
    SOMETIMES = 1
    """
    the pad will become available depending on the media stream
    """
    REQUEST = 2
    """
    the pad is only available on request with
     `Gst.Element.request_pad`.
    """

class PadProbeReturn(GObject.GEnum):
    """
    Different return values for the Gst.PadProbeCallback."""

    DROP = 0
    """
    drop data in data probes. For push mode this means that
           the data item is not sent downstream. For pull mode, it means that
           the data item is not passed upstream. In both cases, no other probes
           are called for this item and Gst.FLOW_OK or True is returned to the
           caller.
    """
    OK = 1
    """
    normal probe return value. This leaves the probe in
           place, and defers decisions about dropping or passing data to other
           probes, if any. If there are no other probes, the default behaviour
           for the probe type applies ('block' for blocking probes,
           and 'pass' for non-blocking probes).
    """
    REMOVE = 2
    """
    remove this probe, passing the data. For blocking probes
           this will cause data flow to unblock, unless there are also other
           blocking probes installed.
    """
    PASS = 3
    HANDLED = 4
    """
    Data has been handled in the probe and will not be
           forwarded further. For events and buffers this is the same behaviour as
           Gst.PAD_PROBE_DROP (except that in this case you need to unref the buffer
           or event yourself). For queries it will also return True to the caller.
           The probe can also modify the Gst.FlowReturn value by using the
           `GST_PAD_PROBE_INFO_FLOW_RETURN` accessor.
           Note that the resulting query must contain valid entries.
           Since: 1.6
    """

class PadProbeType(GObject.GFlags):
    """
    The different probing types that can occur. When either one of
    `GST_PAD_PROBE_TYPE_IDLE` or `GST_PAD_PROBE_TYPE_BLOCK` is used, the probe will be a
    blocking probe."""

    INVALID = 0
    """
    invalid probe type
    """
    IDLE = 1
    """
    probe idle pads and block while the callback is called
    """
    BLOCK = 2
    """
    probe and block pads
    """
    BUFFER = 16
    """
    probe buffers
    """
    BUFFER_LIST = 32
    """
    probe buffer lists
    """
    EVENT_DOWNSTREAM = 64
    """
    probe downstream events
    """
    EVENT_UPSTREAM = 128
    """
    probe upstream events
    """
    EVENT_FLUSH = 256
    """
    probe flush events. This probe has to be
        explicitly enabled and is not included in the
        @`GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM` or
        @`GST_PAD_PROBE_TYPE_EVENT_UPSTREAM` probe types.
    """
    QUERY_DOWNSTREAM = 512
    """
    probe downstream queries
    """
    QUERY_UPSTREAM = 1024
    """
    probe upstream queries
    """
    PUSH = 4096
    """
    probe push
    """
    PULL = 8192
    """
    probe pull
    """
    BLOCKING = 3
    """
    probe and block at the next opportunity, at data flow or when idle
    """
    DATA_DOWNSTREAM = 112
    """
    probe downstream data (buffers, buffer lists, and events)
    """
    DATA_UPSTREAM = 128
    """
    probe upstream data (events)
    """
    DATA_BOTH = 240
    """
    probe upstream and downstream data (buffers, buffer lists, and events)
    """
    BLOCK_DOWNSTREAM = 114
    """
    probe and block downstream data (buffers, buffer lists, and events)
    """
    BLOCK_UPSTREAM = 130
    """
    probe and block upstream data (events)
    """
    EVENT_BOTH = 192
    """
    probe upstream and downstream events
    """
    QUERY_BOTH = 1536
    """
    probe upstream and downstream queries
    """
    ALL_BOTH = 1776
    """
    probe upstream events and queries and downstream buffers, buffer lists, events and queries
    """
    SCHEDULING = 12288
    """
    probe push and pull
    """

class PadTemplateFlags(GObject.GFlags):
    """
    Flags for the padtemplate"""

    LAST = 256
    """
    first flag that can be used by subclasses.
    """

class ParseError(GObject.GEnum):
    """
    The different parsing errors that can occur."""

    SYNTAX = 0
    """
    A syntax error occurred.
    """
    NO_SUCH_ELEMENT = 1
    """
    The description contained an unknown element
    """
    NO_SUCH_PROPERTY = 2
    """
    An element did not have a specified property
    """
    LINK = 3
    """
    There was an error linking two pads.
    """
    COULD_NOT_SET_PROPERTY = 4
    """
    There was an error setting a property
    """
    EMPTY_BIN = 5
    """
    An empty bin was specified.
    """
    EMPTY = 6
    """
    An empty description was specified
    """
    DELAYED_LINK = 7
    """
    A delayed link did not get resolved.
    """

class ParseFlags(GObject.GFlags):
    """
    Parsing options."""

    NONE = 0
    """
    Do not use any special parsing options.
    """
    FATAL_ERRORS = 1
    """
    Always return None when an error occurs
        (default behaviour is to return partially constructed bins or elements
         in some cases)
    """
    NO_SINGLE_ELEMENT_BINS = 2
    """
    If a bin only has a single element,
        just return the element.
    """
    PLACE_IN_BIN = 4
    """
    If more than one toplevel element is described
        by the pipeline description string, put them in a Gst.Bin instead of a
        Gst.Pipeline. (Since: 1.10)
    """

class PipelineFlags(GObject.GFlags):
    """
    Pipeline flags"""

    FIXED_CLOCK = 524288
    """
    this pipeline works with a fixed clock
    """
    LAST = 8388608
    """
    offset to define more flags
    """

class PluginAPIFlags(GObject.GFlags):
    MEMBERS = 1
    """
    Ignore enum members when generating
      the plugins cache. This is useful if the members of the enum are generated
      dynamically, in order not to expose incorrect documentation to the end user.
    """

class PluginDependencyFlags(GObject.GFlags):
    """
    Flags used in connection with `Gst.Plugin.add_dependency`."""

    NONE = 0
    """
    no special flags
    """
    RECURSE = 1
    """
    recurse into subdirectories
    """
    PATHS_ARE_DEFAULT_ONLY = 2
    """
    use paths
            argument only if none of the environment variables is set
    """
    FILE_NAME_IS_SUFFIX = 4
    """
    interpret
            filename argument as filter suffix and check all matching files in
            the directory
    """
    FILE_NAME_IS_PREFIX = 8
    """
    interpret
            filename argument as filter prefix and check all matching files in
            the directory. Since: 1.8.
    """
    PATHS_ARE_RELATIVE_TO_EXE = 16
    """
    interpret
      non-absolute paths as relative to the main executable directory. Since
      1.14.
    """

class PluginError(GObject.GEnum):
    """
    The plugin loading errors"""

    MODULE = 0
    """
    The plugin could not be loaded
    """
    DEPENDENCIES = 1
    """
    The plugin has unresolved dependencies
    """
    NAME_MISMATCH = 2
    """
    The plugin has already be loaded from a different file
    """

class PluginFlags(GObject.GFlags):
    """
    The plugin loading state"""

    CACHED = 16
    """
    Temporarily loaded plugins
    """
    BLACKLISTED = 32
    """
    The plugin won't be scanned (again)
    """

class ProgressType(GObject.GEnum):
    """
    The type of a Gst.MESSAGE_PROGRESS. The progress messages inform the
    application of the status of asynchronous tasks."""

    START = 0
    """
    A new task started.
    """
    CONTINUE = 1
    COMPLETE = 2
    """
    A task completed.
    """
    CANCELED = 3
    """
    A task was canceled.
    """
    ERROR = 4
    """
    A task caused an error. An error message is also
             posted on the bus.
    """

class PromiseResult(GObject.GEnum):
    """
    The result of a Gst.Promise"""

    PENDING = 0
    """
    Initial state. Waiting for transition to any
    	other state.
    """
    INTERRUPTED = 1
    """
    Interrupted by the consumer as it doesn't
    	want the value anymore.
    """
    REPLIED = 2
    """
    A producer marked a reply
    """
    EXPIRED = 3
    """
    The promise expired (the carrying object
    	lost all refs) and the promise will never be fulfilled.
    """

class QOSType(GObject.GEnum):
    """
    The different types of QoS events that can be given to the
    `Gst.Event.new_qos` method."""

    OVERFLOW = 0
    """
    The QoS event type that is produced when upstream
       elements are producing data too quickly and the element can't keep up
       processing the data. Upstream should reduce their production rate. This
       type is also used when buffers arrive early or in time.
    """
    UNDERFLOW = 1
    """
    The QoS event type that is produced when upstream
       elements are producing data too slowly and need to speed up their
       production rate.
    """
    THROTTLE = 2
    """
    The QoS event type that is produced when the
       application enabled throttling to limit the data rate.
    """

class QueryType(GObject.GEnum):
    """
    Standard predefined Query types"""

    UNKNOWN = 0
    """
    unknown query type
    """
    POSITION = 2563
    """
    current position in stream
    """
    DURATION = 5123
    """
    total duration of the stream
    """
    LATENCY = 7683
    """
    latency of stream
    """
    JITTER = 10243
    """
    current jitter of stream
    """
    RATE = 12803
    """
    current rate of the stream
    """
    SEEKING = 15363
    """
    seeking capabilities
    """
    SEGMENT = 17923
    """
    segment start/stop positions
    """
    CONVERT = 20483
    """
    convert values between formats
    """
    FORMATS = 23043
    """
    query supported formats for convert
    """
    BUFFERING = 28163
    """
    query available media for efficient seeking.
    """
    CUSTOM = 30723
    """
    a custom application or element defined query.
    """
    URI = 33283
    """
    query the URI of the source or sink.
    """
    ALLOCATION = 35846
    """
    the buffer allocation properties
    """
    SCHEDULING = 38401
    """
    the scheduling properties
    """
    ACCEPT_CAPS = 40963
    """
    the accept caps query
    """
    CAPS = 43523
    """
    the caps query
    """
    DRAIN = 46086
    """
    wait till all serialized data is consumed downstream
    """
    CONTEXT = 48643
    """
    query the pipeline-local context from
        downstream or upstream (since 1.2)
    """
    BITRATE = 51202
    """
    the bitrate query (since 1.16)
    """
    SELECTABLE = 53763
    """
    Query stream selection capability.
    """

class QueryTypeFlags(GObject.GFlags):
    """
    Gst.QueryTypeFlags indicate the aspects of the different Gst.QueryType
    values. You can get the type flags of a Gst.QueryType with the
    `Gst.Query.type_get_flags` function."""

    UPSTREAM = 1
    """
    Set if the query can travel upstream.
    """
    DOWNSTREAM = 2
    """
    Set if the query can travel downstream.
    """
    SERIALIZED = 4
    """
    Set if the query should be serialized with data
                                  flow.
    """

class Rank(GObject.GEnum):
    """
    Element priority ranks. Defines the order in which the autoplugger (or
    similar rank-picking mechanisms, such as e.g. `Gst.Element.make_from_uri`)
    will choose this element over an alternative one with the same function.

    These constants serve as a rough guidance for defining the rank of a
    Gst.PluginFeature. Any value is valid, including values bigger than
    `GST_RANK_PRIMARY`."""

    NONE = 0
    """
    will be chosen last or not at all
    """
    MARGINAL = 64
    """
    unlikely to be chosen
    """
    SECONDARY = 128
    """
    likely to be chosen
    """
    PRIMARY = 256
    """
    will be chosen first
    """

class ResourceError(GObject.GEnum):
    """
    Resource errors are for any resource used by an element:
    memory, files, network connections, process space, ...
    They're typically used by source and sink elements."""

    FAILED = 1
    """
    a general error which doesn't fit in any other
    category.  Make sure you add a custom message to the error call.
    """
    TOO_LAZY = 2
    """
    do not use this except as a placeholder for
    deciding where to go while developing code.
    """
    NOT_FOUND = 3
    """
    used when the resource could not be found.
    """
    BUSY = 4
    """
    used when resource is busy.
    """
    OPEN_READ = 5
    """
    used when resource fails to open for reading.
    """
    OPEN_WRITE = 6
    """
    used when resource fails to open for writing.
    """
    OPEN_READ_WRITE = 7
    """
    used when resource cannot be opened for
    both reading and writing, or either (but unspecified which).
    """
    CLOSE = 8
    """
    used when the resource can't be closed.
    """
    READ = 9
    """
    used when the resource can't be read from.
    """
    WRITE = 10
    """
    used when the resource can't be written to.
    """
    SEEK = 11
    """
    used when a seek on the resource fails.
    """
    SYNC = 12
    """
    used when a synchronize on the resource fails.
    """
    SETTINGS = 13
    """
    used when settings can't be manipulated on.
    """
    NO_SPACE_LEFT = 14
    """
    used when the resource has no space left.
    """
    NOT_AUTHORIZED = 15
    """
    used when the resource can't be opened
                                        due to missing authorization.
                                        (Since: 1.2.4)
    """
    NUM_ERRORS = 16
    """
    the number of resource error types.
    """

class SchedulingFlags(GObject.GFlags):
    """
    The different scheduling flags."""

    SEEKABLE = 1
    """
    if seeking is possible
    """
    SEQUENTIAL = 2
    """
    if sequential access is recommended
    """
    BANDWIDTH_LIMITED = 4
    """
    if bandwidth is limited and buffering possible (since 1.2)
    """

class SearchMode(GObject.GEnum):
    """
    The different search modes."""

    EXACT = 0
    """
    Only search for exact matches.
    """
    BEFORE = 1
    """
    Search for an exact match or the element just before.
    """
    AFTER = 2
    """
    Search for an exact match or the element just after.
    """

class SeekFlags(GObject.GFlags):
    """
    Flags to be used with `Gst.Element.seek` or `Gst.Event.new_seek`. All flags
    can be used together.

    A non flushing seek might take some time to perform as the currently
    playing data in the pipeline will not be cleared.

    An accurate seek might be slower for formats that don't have any indexes
    or timestamp markers in the stream. Specifying this flag might require a
    complete scan of the file in those cases.

    When performing a segment seek: after the playback of the segment completes,
    no EOS will be emitted by the element that performed the seek, but a
    Gst.MESSAGE_SEGMENT_DONE message will be posted on the bus by the element.
    When this message is posted, it is possible to send a new seek event to
    continue playback. With this seek method it is possible to perform seamless
    looping or simple linear editing.

    When only changing the playback rate and not the direction, the
    Gst.SEEK_FLAG_INSTANT_RATE_CHANGE flag can be used for a non-flushing seek
    to signal that the rate change should be applied immediately. This requires
    special support in the seek handlers (e.g. demuxers) and any elements
    synchronizing to the clock, and in general can't work in all cases (for example
    UDP streaming where the delivery rate is controlled by a remote server). The
    instant-rate-change mode supports changing the trickmode-related GST_SEEK_ flags,
    but can't be used in conjunction with other seek flags that affect the new
    playback position - as the playback position will not be changing.

    When doing fast forward (rate > 1.0) or fast reverse (rate < -1.0) trickmode
    playback, the Gst.SEEK_FLAG_TRICKMODE flag can be used to instruct decoders
    and demuxers to adjust the playback rate by skipping frames. This can improve
    performance and decrease CPU usage because not all frames need to be decoded.

    Beyond that, the Gst.SEEK_FLAG_TRICKMODE_KEY_UNITS flag can be used to
    request that decoders skip all frames except key units, and
    Gst.SEEK_FLAG_TRICKMODE_NO_AUDIO flags can be used to request that audio
    decoders do no decoding at all, and simple output silence.

    The Gst.SEEK_FLAG_SNAP_BEFORE flag can be used to snap to the previous
    relevant location, and the Gst.SEEK_FLAG_SNAP_AFTER flag can be used to
    select the next relevant location. If Gst.SEEK_FLAG_KEY_UNIT is specified,
    the relevant location is a keyframe. If both flags are specified, the nearest
    of these locations will be selected. If none are specified, the implementation is
    free to select whichever it wants.

    The before and after here are in running time, so when playing backwards,
    the next location refers to the one that will played in next, and not the
    one that is located after in the actual source stream.

    Also see part-seeking.txt in the GStreamer design documentation for more
    details on the meaning of these flags and the behaviour expected of
    elements that handle them."""

    NONE = 0
    """
    no flag
    """
    FLUSH = 1
    """
    flush pipeline
    """
    ACCURATE = 2
    """
    accurate position is requested, this might
                        be considerably slower for some formats.
    """
    KEY_UNIT = 4
    """
    seek to the nearest keyframe. This might be
                        faster but less accurate.
    """
    SEGMENT = 8
    """
    perform a segment seek.
    """
    TRICKMODE = 16
    """
    when doing fast forward or fast reverse playback, allow
                        elements to skip frames instead of generating all
                        frames. (Since: 1.6)
    """
    SKIP = 16
    """
    Deprecated backward compatibility flag, replaced
                        by Gst.SEEK_FLAG_TRICKMODE
    """
    SNAP_BEFORE = 32
    """
    go to a location before the requested position,
                        if Gst.SEEK_FLAG_KEY_UNIT this means the keyframe at or before
                        the requested position the one at or before the seek target.
    """
    SNAP_AFTER = 64
    """
    go to a location after the requested position,
                        if Gst.SEEK_FLAG_KEY_UNIT this means the keyframe at of after the
                        requested position.
    """
    SNAP_NEAREST = 96
    """
    go to a position near the requested position,
                        if Gst.SEEK_FLAG_KEY_UNIT this means the keyframe closest
                        to the requested position, if both keyframes are at an equal
                        distance, behaves like Gst.SEEK_FLAG_SNAP_BEFORE.
    """
    TRICKMODE_KEY_UNITS = 128
    """
    when doing fast forward or fast reverse
                        playback, request that elements only decode keyframes
                        and skip all other content, for formats that have
                        keyframes. (Since: 1.6)
    """
    TRICKMODE_NO_AUDIO = 256
    """
    when doing fast forward or fast reverse
                        playback, request that audio decoder elements skip
                        decoding and output only gap events or silence. (Since: 1.6)
    """
    TRICKMODE_FORWARD_PREDICTED = 512
    """
    When doing fast forward or fast reverse
                        playback, request that elements only decode keyframes and
                        forward predicted frames and skip all other content (for example
                        B-Frames), for formats that have keyframes and forward predicted
                        frames. (Since: 1.18)
    """
    INSTANT_RATE_CHANGE = 1024
    """
    Signals that a rate change should be
                        applied immediately. Only valid if start/stop position
                        are GST_CLOCK_TIME_NONE, the playback direction does not change
                        and the seek is not flushing. (Since: 1.18)
    """

class SeekType(GObject.GEnum):
    """
    The different types of seek events. When constructing a seek event with
    `Gst.Event.new_seek` or when doing gst_segment_do_seek ()."""

    NONE = 0
    """
    no change in position is required
    """
    SET = 1
    """
    absolute position is requested
    """
    END = 2
    """
    relative position to duration is requested
    """

class SegmentFlags(GObject.GFlags):
    """
    Flags for the GstSegment structure. Currently mapped to the corresponding
    values of the seek flags."""

    NONE = 0
    """
    no flags
    """
    RESET = 1
    """
    reset the pipeline running_time to the segment
                             running_time
    """
    TRICKMODE = 16
    """
    perform skip playback (Since: 1.6)
    """
    SKIP = 16
    """
    Deprecated backward compatibility flag, replaced
                            by `GST_SEGMENT_FLAG_TRICKMODE`
    """
    SEGMENT = 8
    """
    send SEGMENT_DONE instead of EOS
    """
    TRICKMODE_KEY_UNITS = 128
    """
    Decode only keyframes, where
                                           possible (Since: 1.6)
    """
    TRICKMODE_FORWARD_PREDICTED = 512
    """
    Decode only keyframes or forward
                                           predicted frames, where possible (Since: 1.18)
    """
    TRICKMODE_NO_AUDIO = 256
    """
    Do not decode any audio, where
                                           possible (Since: 1.6)
    """

class SerializeFlags(GObject.GFlags):
    NONE = 0
    """
    No special flags specified.
    """
    BACKWARD_COMPAT = 1
    """
    Serialize using the old format for
                                         nested structures.
    """
    STRICT = 2
    """
    Serialization fails if a value cannot be serialized instead of using
    placeholder "None" value (e.g. pointers, objects).
    """

class StackTraceFlags(GObject.GFlags):
    NONE = 0
    """
    Try to retrieve the minimum information
                                available, which may be none on some platforms
                                (Since: 1.18)
    """
    FULL = 1
    """
    Try to retrieve as much information as possible,
                                including source information when getting the
                                stack trace
    """

class State(GObject.GEnum):
    """
    The possible states an element can be in. States can be changed using
    `Gst.Element.set_state` and checked using `Gst.Element.get_state`."""

    VOID_PENDING = 0
    """
    no pending state.
    """
    NULL = 1
    """
    the None state or initial state of an element.
    """
    READY = 2
    """
    the element is ready to go to PAUSED.
    """
    PAUSED = 3
    """
    the element is PAUSED, it is ready to accept and
                             process data. Sink elements however only accept one
                             buffer and then block.
    """
    PLAYING = 4
    """
    the element is PLAYING, the Gst.Clock is running and
                             the data is flowing.
    """

class StateChange(GObject.GEnum):
    """
    These are the different state changes an element goes through.
    Gst.STATE_NULL &rArr; Gst.STATE_PLAYING is called an upwards state change
    and Gst.STATE_PLAYING &rArr; Gst.STATE_NULL a downwards state change."""

    NULL_TO_READY = 10
    """
    state change from None to READY.
      * The element must check if the resources it needs are available. Device
        sinks and -sources typically try to probe the device to constrain their
        caps.
      * The element opens the device (in case feature need to be probed).
    """
    READY_TO_PAUSED = 19
    """
    state change from READY to PAUSED.
      * The element pads are activated in order to receive data in PAUSED.
        Streaming threads are started.
      * Some elements might need to return Gst.STATE_CHANGE_ASYNC and complete
        the state change when they have enough information. It is a requirement
        for sinks to return Gst.STATE_CHANGE_ASYNC and complete the state change
        when they receive the first buffer or Gst.EVENT_EOS (preroll).
        Sinks also block the dataflow when in PAUSED.
      * A pipeline resets the running_time to 0.
      * Live sources return Gst.STATE_CHANGE_NO_PREROLL and don't generate data.
    """
    PAUSED_TO_PLAYING = 28
    """
    state change from PAUSED to PLAYING.
      * Most elements ignore this state change.
      * The pipeline selects a Gst.Clock and distributes this to all the children
        before setting them to PLAYING. This means that it is only allowed to
        synchronize on the Gst.Clock in the PLAYING state.
      * The pipeline uses the Gst.Clock and the running_time to calculate the
        base_time. The base_time is distributed to all children when performing
        the state change.
      * Sink elements stop blocking on the preroll buffer or event and start
        rendering the data.
      * Sinks can post Gst.MESSAGE_EOS in the PLAYING state. It is not allowed
        to post Gst.MESSAGE_EOS when not in the PLAYING state.
      * While streaming in PAUSED or PLAYING elements can create and remove
        sometimes pads.
      * Live sources start generating data and return Gst.STATE_CHANGE_SUCCESS.
    """
    PLAYING_TO_PAUSED = 35
    """
    state change from PLAYING to PAUSED.
      * Most elements ignore this state change.
      * The pipeline calculates the running_time based on the last selected
        Gst.Clock and the base_time. It stores this information to continue
        playback when going back to the PLAYING state.
      * Sinks unblock any Gst.Clock wait calls.
      * When a sink does not have a pending buffer to play, it returns
        GST_STATE_CHANGE_ASYNC from this state change and completes the state
        change when it receives a new buffer or an Gst.EVENT_EOS.
      * Any queued Gst.MESSAGE_EOS items are removed since they will be reposted
        when going back to the PLAYING state. The EOS messages are queued in
        Gst.Bin containers.
      * Live sources stop generating data and return Gst.STATE_CHANGE_NO_PREROLL.
    """
    PAUSED_TO_READY = 26
    """
    state change from PAUSED to READY.
      * Sinks unblock any waits in the preroll.
      * Elements unblock any waits on devices
      * Chain or get_range functions return Gst.FLOW_FLUSHING.
      * The element pads are deactivated so that streaming becomes impossible and
        all streaming threads are stopped.
      * The sink forgets all negotiated formats
      * Elements remove all sometimes pads
    """
    READY_TO_NULL = 17
    """
    state change from READY to None.
      * Elements close devices
      * Elements reset any internal state.
    """
    NULL_TO_NULL = 9
    """
    state change from None to None. (Since: 1.14)
    """
    READY_TO_READY = 18
    """
    state change from READY to READY,
    This might happen when going to PAUSED asynchronously failed, in that case
    elements should make sure they are in a proper, coherent READY state. (Since: 1.14)
    """
    PAUSED_TO_PAUSED = 27
    """
    state change from PAUSED to PAUSED.
    This might happen when elements were in PLAYING state and 'lost state',
    they should make sure to go back to real 'PAUSED' state (prerolling for example). (Since: 1.14)
    """
    PLAYING_TO_PLAYING = 36
    """
    state change from PLAYING to PLAYING. (Since: 1.14)
    """

class StateChangeReturn(GObject.GEnum):
    """
    The possible return values from a state change function such as
    `Gst.Element.set_state`. Only `GST_STATE_CHANGE_FAILURE` is a real failure."""

    FAILURE = 0
    """
    the state change failed
    """
    SUCCESS = 1
    """
    the state change succeeded
    """
    ASYNC = 2
    NO_PREROLL = 3
    """
    the state change succeeded but the element
                                  cannot produce data in Gst.STATE_PAUSED.
                                  This typically happens with live sources.
    """

class StreamError(GObject.GEnum):
    """
    Stream errors are for anything related to the stream being processed:
    format errors, media type errors, ...
    They're typically used by decoders, demuxers, converters, ..."""

    FAILED = 1
    """
    a general error which doesn't fit in any other
    category.  Make sure you add a custom message to the error call.
    """
    TOO_LAZY = 2
    """
    do not use this except as a placeholder for
    deciding where to go while developing code.
    """
    NOT_IMPLEMENTED = 3
    """
    use this when you do not want to implement
    this functionality yet.
    """
    TYPE_NOT_FOUND = 4
    """
    used when the element doesn't know the
    stream's type.
    """
    WRONG_TYPE = 5
    """
    used when the element doesn't handle this type
    of stream.
    """
    CODEC_NOT_FOUND = 6
    """
    used when there's no codec to handle the
    stream's type.
    """
    DECODE = 7
    """
    used when decoding fails.
    """
    ENCODE = 8
    """
    used when encoding fails.
    """
    DEMUX = 9
    """
    used when demuxing fails.
    """
    MUX = 10
    """
    used when muxing fails.
    """
    FORMAT = 11
    """
    used when the stream is of the wrong format
    (for example, wrong caps).
    """
    DECRYPT = 12
    """
    used when the stream is encrypted and can't be
    decrypted because this is not supported by the element.
    """
    DECRYPT_NOKEY = 13
    """
    used when the stream is encrypted and
    can't be decrypted because no suitable key is available.
    """
    NUM_ERRORS = 14
    """
    the number of stream error types.
    """

class StreamFlags(GObject.GFlags):
    NONE = 0
    """
    This stream has no special attributes
    """
    SPARSE = 1
    """
    This stream is a sparse stream (e.g. a subtitle
       stream), data may flow only in irregular intervals with large gaps in
       between.
    """
    SELECT = 2
    """
    This stream should be selected by default. This
       flag may be used by demuxers to signal that a stream should be selected
       by default in a playback scenario.
    """
    UNSELECT = 4
    """
    This stream should not be selected by default.
       This flag may be used by demuxers to signal that a stream should not
       be selected by default in a playback scenario, but only if explicitly
       selected by the user (e.g. an audio track for the hard of hearing or
       a director's commentary track).
    """

class StreamStatusType(GObject.GEnum):
    """
    The type of a Gst.MESSAGE_STREAM_STATUS. The stream status messages inform the
    application of new streaming threads and their status."""

    CREATE = 0
    """
    A new thread need to be created.
    """
    ENTER = 1
    """
    a thread entered its loop function
    """
    LEAVE = 2
    """
    a thread left its loop function
    """
    DESTROY = 3
    """
    a thread is destroyed
    """
    START = 8
    """
    a thread is started
    """
    PAUSE = 9
    """
    a thread is paused
    """
    STOP = 10
    """
    a thread is stopped
    """

class StreamType(GObject.GFlags):
    """
    Gst.StreamType describes a high level classification set for
    flows of data in Gst.Stream objects.

    Note that this is a flag, and therefore users should not assume it
    will be a single value. Do not use the equality operator for checking
    whether a stream is of a certain type."""

    UNKNOWN = 1
    """
    The stream is of unknown (unclassified) type.
    """
    AUDIO = 2
    """
    The stream is of audio data
    """
    VIDEO = 4
    """
    The stream carries video data
    """
    CONTAINER = 8
    """
    The stream is a muxed container type
    """
    TEXT = 16
    """
    The stream contains subtitle / subpicture data.
    """

class StructureChangeType(GObject.GEnum):
    """
    The type of a Gst.MESSAGE_STRUCTURE_CHANGE."""

    LINK = 0
    """
    Pad linking is starting or done.
    """
    UNLINK = 1
    """
    Pad unlinking is starting or done.
    """

class TagFlag(GObject.GEnum):
    """
    Extra tag flags used when registering tags."""

    UNDEFINED = 0
    """
    undefined flag
    """
    META = 1
    """
    tag is meta data
    """
    ENCODED = 2
    """
    tag is encoded
    """
    DECODED = 3
    """
    tag is decoded
    """
    COUNT = 4
    """
    number of tag flags
    """

class TagMergeMode(GObject.GEnum):
    """
    The different tag merging modes are basically replace, overwrite and append,
    but they can be seen from two directions. Given two taglists: (A) the tags
    already in the element and (B) the ones that are supplied to the element (
    e.g. via `Gst.TagSetter.merge_tags` / `Gst.TagSetter.add_tags` or a
    Gst.EVENT_TAG), how are these tags merged?
    In the table below this is shown for the cases that a tag exists in the list
    (A) or does not exists (!A) and combinations thereof.

    | merge mode  | A + B | A + !B | !A + B | !A + !B |
    | ----------- | ----- | ------ | ------ | ------- |
    | REPLACE_ALL | B     |       | B      |        |
    | REPLACE     | B     | A      | B      |        |
    | APPEND      | A, B  | A      | B      |        |
    | PREPEND     | B, A  | A      | B      |        |
    | KEEP        | A     | A      | B      |        |
    | KEEP_ALL    | A     | A      |       |        |"""

    UNDEFINED = 0
    """
    undefined merge mode
    """
    REPLACE_ALL = 1
    """
    replace all tags (clear list and append)
    """
    REPLACE = 2
    """
    replace tags
    """
    APPEND = 3
    """
    append tags
    """
    PREPEND = 4
    """
    prepend tags
    """
    KEEP = 5
    """
    keep existing tags
    """
    KEEP_ALL = 6
    """
    keep all existing tags
    """
    COUNT = 7
    """
    the number of merge modes
    """

class TagScope(GObject.GEnum):
    """
    GstTagScope specifies if a taglist applies to the complete
    medium or only to one single stream."""

    STREAM = 0
    """
    tags specific to this single stream
    """
    GLOBAL = 1

class TaskState(GObject.GEnum):
    """
    The different states a task can be in"""

    STARTED = 0
    """
    the task is started and running
    """
    STOPPED = 1
    """
    the task is stopped
    """
    PAUSED = 2
    """
    the task is paused
    """

class TocEntryType(GObject.GEnum):
    """
    The different types of TOC entries (see Gst.TocEntry).

    There are two types of TOC entries: alternatives or parts in a sequence."""

    ANGLE = -3
    """
    entry is an angle (i.e. an alternative)
    """
    VERSION = -2
    """
    entry is a version (i.e. alternative)
    """
    EDITION = -1
    """
    entry is an edition (i.e. alternative)
    """
    INVALID = 0
    """
    invalid entry type value
    """
    TITLE = 1
    """
    entry is a title (i.e. a part of a sequence)
    """
    TRACK = 2
    """
    entry is a track (i.e. a part of a sequence)
    """
    CHAPTER = 3
    """
    entry is a chapter (i.e. a part of a sequence)
    """

class TocLoopType(GObject.GEnum):
    """
    How a Gst.TocEntry should be repeated. By default, entries are played a
    single time."""

    NONE = 0
    """
    single forward playback
    """
    FORWARD = 1
    """
    repeat forward
    """
    REVERSE = 2
    """
    repeat backward
    """
    PING_PONG = 3
    """
    repeat forward and backward
    """

class TocScope(GObject.GEnum):
    """
    The scope of a TOC."""

    GLOBAL = 1
    CURRENT = 2
    """
    TOC for the currently active/selected stream
        (this is a TOC representing the current stream from start to EOS,
        and is what a TOC writer / muxer is usually interested in; it will
        usually be a subset of the global TOC, e.g. just the chapters of
        the current title, or the chapters selected for playback from the
        current title)
    """

class TracerValueFlags(GObject.GFlags):
    """
    Flag that describe the value. These flags help applications processing the
    logs to understand the values."""

    NONE = 0
    """
    no flags
    """
    OPTIONAL = 1
    """
    the value is optional. When using this flag
      one need to have an additional boolean arg before this value in the
      var-args list passed to  `Gst.TracerRecord.log`.
    """
    AGGREGATED = 2
    """
    the value is a combined figure, since the
      start of tracing. Examples are averages or timestamps.
    """

class TracerValueScope(GObject.GEnum):
    """
    Tracing record will contain fields that contain a measured value or extra
    meta-data. One such meta data are values that tell where a measurement was
    taken. This enumerating declares to which scope such a meta data field
    relates to. If it is e.g. Gst.TRACER_VALUE_SCOPE_PAD, then each of the log
    events may contain values for different Gst.Pads."""

    PROCESS = 0
    """
    the value is related to the process
    """
    THREAD = 1
    """
    the value is related to a thread
    """
    ELEMENT = 2
    """
    the value is related to an Gst.Element
    """
    PAD = 3
    """
    the value is related to a Gst.Pad
    """

class TypeFindProbability(GObject.GEnum):
    """
    The probability of the typefind function. Higher values have more certainty
    in doing a reliable typefind."""

    NONE = 0
    """
    type undetected.
    """
    MINIMUM = 1
    """
    unlikely typefind.
    """
    POSSIBLE = 50
    """
    possible type detected.
    """
    LIKELY = 80
    """
    likely a type was detected.
    """
    NEARLY_CERTAIN = 99
    """
    nearly certain that a type was detected.
    """
    MAXIMUM = 100
    """
    very certain a type was detected.
    """

class URIError(GObject.GEnum):
    """
    Different URI-related errors that can occur."""

    UNSUPPORTED_PROTOCOL = 0
    """
    The protocol is not supported
    """
    BAD_URI = 1
    """
    There was a problem with the URI
    """
    BAD_STATE = 2
    """
    Could not set or change the URI because the
        URI handler was in a state where that is not possible or not permitted
    """
    BAD_REFERENCE = 3
    """
    There was a problem with the entity that
        the URI references
    """

class URIType(GObject.GEnum):
    """
    The different types of URI direction."""

    UNKNOWN = 0
    """
    The URI direction is unknown
    """
    SINK = 1
    """
    The URI is a consumer.
    """
    SRC = 2
    """
    The URI is a producer.
    """

###############################################################
# classes
###############################################################

class AddError(builtins.Exception): ...

class AllocationParams(GObject.GBoxed):
    """
    Parameters to control the allocation of memory
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    align: int = ...
    """
    the desired alignment of the memory
    """
    flags: MemoryFlags = ...
    """
    flags to control allocation
    """
    padding: int = ...
    """
    the desired padding
    """
    prefix: int = ...
    """
    the desired prefix
    """

    # gi Methods
    def copy(self) -> AllocationParams | None:
        """
        Create a copy of `params`.
        """
    def free(self) -> None:
        """
        Free `params`
        """
    def init(self) -> None:
        """
        Initialize `params` to its default values
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
    ) -> AllocationParams:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.AllocationParams
        """

class Allocator(Object):
    """
    Memory is usually created by allocators with a `Gst.Allocator.alloc`
    method call. When None is used as the allocator, the default allocator will
    be used.

    New allocators can be registered with `Gst.Allocator.register`.
    Allocators are identified by name and can be retrieved with
    `Gst.Allocator.find`. `Gst.Allocator.set_default` can be used to change the
    default allocator.

    New memory can be created with `Gst.Memory.new_wrapped` that wraps the memory
    allocated elsewhere.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def mem_copy(self) -> MemoryCopyFunctionAllocatorCB:
        """
        the implementation of the GstMemoryCopyFunction
        """
    @builtins.property
    def mem_is_span(self) -> MemoryIsSpanFunctionAllocatorCB:
        """
        the implementation of the GstMemoryIsSpanFunction
        """
    @builtins.property
    def mem_map(self) -> MemoryMapFunctionAllocatorCB | None:
        """
        the implementation of the GstMemoryMapFunction
        """
    @builtins.property
    def mem_map_full(self) -> MemoryMapFullFunctionAllocatorCB | None:
        """
        the implementation of the GstMemoryMapFullFunction.
         Will be used instead of `mem_map` if present. (Since: 1.6)
        """
    @builtins.property
    def mem_share(self) -> MemoryShareFunctionAllocatorCB:
        """
        the implementation of the GstMemoryShareFunction
        """
    @builtins.property
    def mem_type(self) -> str: ...
    @builtins.property
    def mem_unmap(self) -> MemoryUnmapFunctionAllocatorCB:
        """
        the implementation of the GstMemoryUnmapFunction
        """
    @builtins.property
    def mem_unmap_full(self) -> MemoryUnmapFullFunctionAllocatorCB:
        """
        the implementation of the GstMemoryUnmapFullFunction.
         Will be used instead of `mem_unmap` if present. (Since: 1.6)
        """
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def priv(self) -> AllocatorPrivate | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize Allocator object with properties.
        """
    def alloc(self, size: int, params: AllocationParams | None = None) -> Memory | None:
        """
            Use `allocator` to allocate a new memory block with memory that is at least
        `size` big.

        The optional `params` can specify the prefix and padding for the memory. If
        None is passed, no flags, no extra prefix/padding and a default alignment is
        used.

        The prefix/padding will be filled with 0 if flags contains
        GST_MEMORY_FLAG_ZERO_PREFIXED and GST_MEMORY_FLAG_ZERO_PADDED respectively.

        When `allocator` is None, the default allocator will be used.

        The alignment in `params` is given as a bitmask so that `align` + 1 equals
        the amount of bytes to align to. For example, to align to 8 bytes,
        use an alignment of 7.
        """
    @staticmethod
    def find(name: str | None = None) -> Allocator | None:
        """
            Find a previously registered allocator with `name`. When `name` is None, the
        default allocator will be returned.
        """
    def free(self, memory: Memory) -> None:
        """
        Free `memory` that was previously allocated with `Gst.Allocator.alloc`.
        """
    @staticmethod
    def register(name: str, allocator: Allocator) -> None:
        """
        Registers the memory `allocator` with `name`.
        """
    def set_default(self) -> None:
        """
        Set the default allocator.
        """

    # python methods (overrides?)
    def do_alloc(
        self,
        size: int,
        params: AllocationParams | None = None,
    ) -> Memory | None:
        """
        alloc(self, size:int, params:Gst.AllocationParams=None) -> Gst.Memory or None
        """
    def do_free(
        self,
        memory: Memory,
    ) -> None:
        """
        free(self, memory:Gst.Memory)
        """

class AllocatorClass(GObject.GPointer):
    """
    The Gst.Allocator is used to create new memory.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def alloc(self) -> allocAllocatorClassCB | None:
        """
        implementation that acquires memory
        """
    @builtins.property
    def free(self) -> freeAllocatorClassCB:
        """
        implementation that releases memory
        """
    @builtins.property
    def object_class(self) -> ObjectClass | None:
        """
        Object parent class
        """

class AllocatorPrivate(GObject.GPointer): ...

class AtomicQueue(GObject.GBoxed):
    """
    The Gst.AtomicQueue object implements a queue that can be used from multiple
    threads without performing any blocking operations.
    """

    # gi Methods
    def length(self) -> int:
        """
        Get the amount of items in the queue.
        """
    def peek(self) -> object | None:
        """
        Peek the head element of the queue without removing it from the queue.
        """
    def pop(self) -> object | None:
        """
        Get the head element of the queue.
        """
    def push(self, data: object | None = None) -> None:
        """
        Append `data` to the tail of the queue.
        """
    def ref(self) -> None:
        """
        Increase the refcount of `queue`.
        """
    def unref(self) -> None:
        """
        Unref `queue` and free the memory when the refcount reaches 0.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        initial_size: int,
    ) -> AtomicQueue:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(initial_size:int) -> Gst.AtomicQueue
        """

class Bin(Element):
    """
    Gst.Bin is an element that can contain other Gst.Element, allowing them to be
    managed as a group.
    Pads from the child elements can be ghosted to the bin, see Gst.GhostPad.
    This makes the bin look like any other elements and enables creation of
    higher-level abstraction elements.

    A new Gst.Bin is created with `Gst.Bin.new`. Use a Gst.Pipeline instead if you
    want to create a toplevel bin because a normal bin doesn't have a bus or
    handle clock distribution of its own.

    After the bin has been created you will typically add elements to it with
    `Gst.Bin.add`. You can remove elements with `Gst.Bin.remove`.

    An element can be retrieved from a bin with `Gst.Bin.get_by_name`, using the
    elements name. `Gst.Bin.get_by_name_recurse_up` is mainly used for internal
    purposes and will query the parent bins when the element is not found in the
    current bin.

    An iterator of elements in a bin can be retrieved with
    `Gst.Bin.iterate_elements`. Various other iterators exist to retrieve the
    elements in a bin.

    `Gst.Object.unref` is used to drop your reference to the bin.

    The Gst.Bin::element-added signal is fired whenever a new element is added to
    the bin. Likewise the Gst.Bin::element-removed signal is fired whenever an
    element is removed from the bin.

    A Gst.Bin internally intercepts every Gst.Message posted by its children and
    implements the following default behaviour for each of them:

    * Gst.MESSAGE_EOS: This message is only posted by sinks in the PLAYING
    state. If all sinks posted the EOS message, this bin will post and EOS
    message upwards.

    * Gst.MESSAGE_SEGMENT_START: Just collected and never forwarded upwards.
      The messages are used to decide when all elements have completed playback
      of their segment.

    * Gst.MESSAGE_SEGMENT_DONE: Is posted by Gst.Bin when all elements that posted
      a SEGMENT_START have posted a SEGMENT_DONE.

    * Gst.MESSAGE_DURATION_CHANGED: Is posted by an element that detected a change
      in the stream duration. The duration change is posted to the
      application so that it can refetch the new duration with a duration
      query.

      Note that these messages can be posted before the bin is prerolled, in which
      case the duration query might fail.

      Note also that there might be a discrepancy (due to internal buffering/queueing)
      between the stream being currently displayed and the returned duration query.

      Applications might want to also query for duration (and changes) by
      listening to the Gst.MESSAGE_STREAM_START message, signaling the active start
      of a (new) stream.

    * Gst.MESSAGE_CLOCK_LOST: This message is posted by an element when it
      can no longer provide a clock.

      The default bin behaviour is to check if the lost clock was the one provided
      by the bin. If so and the bin is currently in the PLAYING state, the message
      is forwarded to the bin parent.

      This message is also generated when a clock provider is removed from
      the bin. If this message is received by the application, it should
      PAUSE the pipeline and set it back to PLAYING to force a new clock
      distribution.

    * Gst.MESSAGE_CLOCK_PROVIDE: This message is generated when an element
      can provide a clock. This mostly happens when a new clock
      provider is added to the bin.

      The default behaviour of the bin is to mark the currently selected clock as
      dirty, which will perform a clock recalculation the next time the bin is
      asked to provide a clock.

      This message is never sent to the application but is forwarded to
      the parent of the bin.

    * OTHERS: posted upwards.

    A Gst.Bin implements the following default behaviour for answering to a
    Gst.Query:

    * Gst.QUERY_DURATION: The bin will forward the query to all sink
      elements contained within and will return the maximum value.
      If no sinks are available in the bin, the query fails.

    * Gst.QUERY_POSITION: The query is sent to all sink elements in the bin and the
      MAXIMUM of all values is returned. If no sinks are available in the bin,
      the query fails.

    * OTHERS: the query is forwarded to all sink elements, the result
      of the first sink that answers the query successfully is returned. If no
      sink is in the bin, the query fails.

    A Gst.Bin will by default forward any event sent to it to all sink
    ( Gst.EVENT_TYPE_UPSTREAM ) or source ( Gst.EVENT_TYPE_DOWNSTREAM ) elements
    depending on the event type.

    If all the elements return True, the bin will also return True, else False
    is returned. If no elements of the required type are in the bin, the event
    handler will return True.
    """

    class Props(Element.Props):
        async_handling: bool  # [async-handling]: changed because contained invalid characters
        """
        If set to True, the bin will handle asynchronous state changes.
        This should be used only if the bin subclass is modifying the state
        of its children on its own.
        """
        message_forward: bool  # [message-forward]: changed because contained invalid characters
        """
        Forward all children messages, even those that would normally be filtered by
        the bin. This can be interesting when one wants to be notified of the EOS
        state of individual elements, for example.

        The messages are converted to an ELEMENT message with the bin as the
        source. The structure of the message is named `GstBinForwarded` and contains
        a field named `message` that contains the original forwarded Gst.Message.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def child_bus(self) -> Bus | None:
        """
        internal bus for handling child messages
        """
    @builtins.property
    def children(self) -> list | None:
        """
        the list of children in this bin
        """
    @builtins.property
    def children_cookie(self) -> int:
        """
        updated whenever `children` changes
        """
    @builtins.property
    def clock_dirty(self) -> bool:
        """
        the bin needs to select a new clock
        """
    @builtins.property
    def clock_provider(self) -> Element | None:
        """
        the element that provided `provided_clock`
        """
    @builtins.property
    def element(self) -> Element | None: ...
    @builtins.property
    def messages(self) -> list | None:
        """
        queued and cached messages
        """
    @builtins.property
    def numchildren(self) -> int:
        """
        the number of children in this bin
        """
    @builtins.property
    def polling(self) -> bool:
        """
        the bin is currently calculating its state
        """
    @builtins.property
    def priv(self) -> BinPrivate | None: ...
    @builtins.property
    def provided_clock(self) -> Clock | None:
        """
        the last clock selected
        """
    @builtins.property
    def state_dirty(self) -> bool:
        """
        the bin needs to recalculate its state (deprecated)
        """

    # gi Methods
    def find_unlinked_pad(self, direction: PadDirection) -> Pad | None:
        """
            Recursively looks for elements with an unlinked pad of the given
        direction within the specified bin and returns an unlinked pad
        if one is found, or None otherwise. If a pad is found, the caller
        owns a reference to it and should use `Gst.Object.unref` on the
        pad when it is not needed any longer.
        """
    def get_by_interface(self, iface: GObject.GType) -> Element | None:
        """
            Looks for an element inside the bin that implements the given
        interface. If such an element is found, it returns the element.
        You can cast this element to the given interface afterwards.  If you want
        all elements that implement the interface, use
        `Gst.Bin.iterate_all_by_interface`. This function recurses into child bins.
        """
    def get_by_name(self, name: str) -> Element | None:
        """
            Gets the element with the given name from a bin. This
        function recurses into child bins.
        """
    def get_by_name_recurse_up(self, name: str) -> Element | None:
        """
            Gets the element with the given name from this bin. If the
        element is not found, a recursion is performed on the parent bin.
        """
    def get_suppressed_flags(self) -> ElementFlags: ...
    def iterate_all_by_element_factory_name(self, factory_name: str) -> Iterator | None:
        """
            Looks for all elements inside the bin with the given element factory name.
        The function recurses inside child bins. The iterator will yield a series of
        Gst.Element.
        """
    def iterate_all_by_interface(self, iface: GObject.GType) -> Iterator | None:
        """
            Looks for all elements inside the bin that implements the given
        interface. You can safely cast all returned elements to the given interface.
        The function recurses inside child bins. The iterator will yield a series
        of Gst.Element.
        """
    def iterate_elements(self) -> Iterator | None:
        """
        Gets an iterator for the elements in this bin.
        """
    def iterate_recurse(self) -> Iterator | None:
        """
            Gets an iterator for the elements in this bin.
        This iterator recurses into GstBin children.
        """
    def iterate_sinks(self) -> Iterator | None:
        """
            Gets an iterator for all elements in the bin that have the
        GST_ELEMENT_FLAG_SINK flag set.
        """
    def iterate_sorted(self) -> Iterator | None:
        """
            Gets an iterator for the elements in this bin in topologically
        sorted order. This means that the elements are returned from
        the most downstream elements (sinks) to the sources.

        This function is used internally to perform the state changes
        of the bin elements and for clock selection.
        """
    def iterate_sources(self) -> Iterator | None:
        """
            Gets an iterator for all elements in the bin that have the
        GST_ELEMENT_FLAG_SOURCE flag set.
        """
    @classmethod
    def new(cls, name: str | None = None) -> Bin:
        """
        Creates a new bin with the given name.
        """
    def recalculate_latency(self) -> bool:
        """
            Queries `bin` for the current latency and reconfigures this latency on all the
        elements using a LATENCY event.

        This method is typically called on the pipeline when a GST_MESSAGE_LATENCY
        is posted on the bus.

        This function simply emits the Gst.Bin::do-latency signal so any custom latency
        calculations will be performed.
        """
    def remove(self, element: Element) -> bool:
        """
            Removes the element from the bin, unparenting it as well.
        Unparenting the element means that the element will be dereferenced,
        so if the bin holds the only reference to the element, the element
        will be freed in the process of removing it from the bin.  If you
        want the element to still exist after removing, you need to call
        `Gst.Object.ref` before removing it from the bin.

        If the element's pads are linked to other pads, the pads will be unlinked
        before the element is removed from the bin.
        """
    def set_suppressed_flags(self, flags: ElementFlags) -> None:
        """
            Suppresses the given flags on the bin. Gst.ElementFlags of a
        child element are propagated when it is added to the bin.
        When suppressed flags are set, those specified flags will
        not be propagated to the bin.
        """
    def sync_children_states(self) -> bool:
        """
            Synchronizes the state of every child of `bin` with the state
        of `bin`. See also `Gst.Element.sync_state_with_parent`.
        """

    # python methods (overrides?)
    def __init__(
        self,
        name: typing.Any = None,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    def add(
        self,
        *args: typing.Any,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        add(self, element:Gst.Element) -> bool
        """
    def make_and_add(
        self,
        factoryname: typing.Any,
        name: typing.Any = None,
    ) -> typing.Any:
        """
        @raises: Gst.AddError
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["deep-element-added"],
        handler: typing.Callable[[typing_extensions.Self, Bin, Element], None],
        *args: typing.Any,
    ) -> int:
        """
        Will be emitted after the element was added to `sub_bin`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["deep-element-removed"],
        handler: typing.Callable[[typing_extensions.Self, Bin, Element], None],
        *args: typing.Any,
    ) -> int:
        """
        Will be emitted after the element was removed from `sub_bin`.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["do-latency"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int:
        """
            Will be emitted when the bin needs to perform latency calculations. This
        signal is only emitted for toplevel bins or when Gst.Bin:async-handling is
        enabled.

        Only one signal handler is invoked. If no signals are connected, the
        default handler is invoked, which will query and distribute the lowest
        possible latency to all sinks.

        Connect to this signal if the default latency calculations are not
        sufficient, like when you need different latencies for different sinks in
        the same pipeline.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["element-added"],
        handler: typing.Callable[[typing_extensions.Self, Element], None],
        *args: typing.Any,
    ) -> int:
        """
        Will be emitted after the element was added to the bin.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["element-removed"],
        handler: typing.Callable[[typing_extensions.Self, Element], None],
        *args: typing.Any,
    ) -> int:
        """
        Will be emitted after the element was removed from the bin.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::async_handling"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::message_forward"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BinClass(GObject.GPointer):
    """
    Subclasses can override Gst.BinClass::add_element and Gst.BinClass::remove_element
    to update the list of children in the bin.

    The Gst.BinClass::handle_message method can be overridden to implement custom
    message handling.

    Gst.BinClass::deep_element_added will be called when a new element has been
    added to any bin inside this bin, so it will also be called if a new child
    was added to a sub-bin of this bin. Gst.Bin implementations that override
    this message should chain up to the parent class implementation so the
    Gst.Bin::deep-element-added signal is emitted on all parents.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def add_element(self) -> add_elementBinClassCB: ...
    @builtins.property
    def deep_element_added(self) -> deep_element_addedBinClassCB: ...
    @builtins.property
    def deep_element_removed(self) -> deep_element_removedBinClassCB: ...
    @builtins.property
    def do_latency(self) -> do_latencyBinClassCB: ...
    @builtins.property
    def element_added(self) -> element_addedBinClassCB: ...
    @builtins.property
    def element_removed(self) -> element_removedBinClassCB: ...
    @builtins.property
    def handle_message(self) -> handle_messageBinClassCB: ...
    @builtins.property
    def parent_class(self) -> ElementClass | None:
        """
        bin parent class
        """
    @builtins.property
    def pool(self) -> GLib.ThreadPool | None: ...
    @builtins.property
    def remove_element(self) -> remove_elementBinClassCB: ...

class BinPrivate(GObject.GPointer): ...

class Bitmask(builtins.object):
    """
    A fundamental type that describes a 64-bit bitmask
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # python methods (overrides?)
    def __init__(
        self,
        v: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class Buffer(GObject.GBoxed):
    """
    Buffers are the basic unit of data transfer in GStreamer. They contain the
    timing and offset along with other arbitrary metadata that is associated
    with the Gst.Memory blocks that the buffer contains.

    Buffers are usually created with `Gst.Buffer.new`. After a buffer has been
    created one will typically allocate memory for it and add it to the buffer.
    The following example creates a buffer that can hold a given video frame
    with a given width, height and bits per plane.

    ``` C
      GstBuffer *buffer;
      GstMemory *memory;
      gint size, width, height, bpp;
      ...
      size = width * height * bpp;
      buffer = gst_buffer_new ();
      memory = gst_allocator_alloc (None, size, None);
      gst_buffer_insert_memory (buffer, -1, memory);
      ...
    ```

    Alternatively, use `Gst.Buffer.new_allocate` to create a buffer with
    preallocated data of a given size.

    Buffers can contain a list of Gst.Memory objects. You can retrieve how many
    memory objects with `Gst.Buffer.n_memory` and you can get a pointer
    to memory with `Gst.Buffer.peek_memory`

    A buffer will usually have timestamps, and a duration, but neither of these
    are guaranteed (they may be set to GST_CLOCK_TIME_NONE). Whenever a
    meaningful value can be given for these, they should be set. The timestamps
    and duration are measured in nanoseconds (they are Gst.ClockTime values).

    The buffer DTS refers to the timestamp when the buffer should be decoded and
    is usually monotonically increasing. The buffer PTS refers to the timestamp when
    the buffer content should be presented to the user and is not always
    monotonically increasing.

    A buffer can also have one or both of a start and an end offset. These are
    media-type specific. For video buffers, the start offset will generally be
    the frame number. For audio buffers, it will be the number of samples
    produced so far. For compressed data, it could be the byte offset in a
    source or destination file. Likewise, the end offset will be the offset of
    the end of the buffer. These can only be meaningfully interpreted if you
    know the media type of the buffer (the preceding CAPS event). Either or both
    can be set to GST_BUFFER_OFFSET_NONE.

    `Gst.Buffer.ref` is used to increase the refcount of a buffer. This must be
    done when you want to keep a handle to the buffer after pushing it to the
    next element. The buffer refcount determines the writability of the buffer, a
    buffer is only writable when the refcount is exactly 1, i.e. when the caller
    has the only reference to the buffer.

    To efficiently create a smaller buffer out of an existing one, you can
    use `Gst.Buffer.copy_region`. This method tries to share the memory objects
    between the two buffers.

    If a plug-in wants to modify the buffer data or metadata in-place, it should
    first obtain a buffer that is safe to modify by using
    `Gst.Buffer.make_writable`. This function is optimized so that a copy will
    only be made when it is necessary.

    Several flags of the buffer can be set and unset with the
    `GST_BUFFER_FLAG_SET` and `GST_BUFFER_FLAG_UNSET` macros. Use
    `GST_BUFFER_FLAG_IS_SET` to test if a certain Gst.BufferFlags flag is set.

    Buffers can be efficiently merged into a larger buffer with
    `Gst.Buffer.append`. Copying of memory will only be done when absolutely
    needed.

    Arbitrary extra metadata can be set on a buffer with `Gst.Buffer.add_meta`.
    Metadata can be retrieved with `Gst.Buffer.get_meta`. See also Gst.Meta.

    An element should either unref the buffer or push it out on a src pad
    using `Gst.Pad.push` (see Gst.Pad).

    Buffers are usually freed by unreffing them with `Gst.Buffer.unref`. When
    the refcount drops to 0, any memory and metadata pointed to by the buffer is
    unreffed as well. Buffers allocated from a Gst.BufferPool will be returned to
    the pool when the refcount drops to 0.

    The Gst.ParentBufferMeta is a meta which can be attached to a Gst.Buffer
    to hold a reference to another buffer that is only released when the child
    Gst.Buffer is released.

    Typically, Gst.ParentBufferMeta is used when the child buffer is directly
    using the Gst.Memory of the parent buffer, and wants to prevent the parent
    buffer from being returned to a buffer pool until the Gst.Memory is available
    for re-use. (Since: 1.6)
    """

    # gi Fields
    dts: int = ...
    """
    decoding timestamp of the buffer, can be GST_CLOCK_TIME_NONE when the
        dts is not known or relevant. The dts contains the timestamp when the
        media should be processed.
    """
    duration: int = ...
    """
    duration in time of the buffer data, can be GST_CLOCK_TIME_NONE
        when the duration is not known or relevant.
    """
    mini_object: MiniObject | None = ...
    """
    the parent structure
    """
    offset: int = ...
    """
    a media specific offset for the buffer data.
        For video frames, this is the frame number of this buffer.
        For audio samples, this is the offset of the first sample in this buffer.
        For file data or compressed data this is the byte offset of the first
          byte in this buffer.
    """
    offset_end: int = ...
    """
    the last offset contained in this buffer. It has the same
        format as `offset`.
    """
    pool: BufferPool | None = ...
    """
    pointer to the pool owner of the buffer
    """
    pts: int = ...
    """
    presentation timestamp of the buffer, can be GST_CLOCK_TIME_NONE when the
        pts is not known or relevant. The pts contains the timestamp when the
        media should be presented to the user.
    """

    # gi Methods
    def add_custom_meta(self, name: str) -> CustomMeta | None:
        """
            Creates and adds a Gst.CustomMeta for the desired `name`. `name` must have
        been successfully registered with `Gst.Meta.register_custom`.
        """
    def add_meta(self, info: MetaInfo, params: object | None = None) -> Meta | None:
        """
        Adds metadata for `info` to `buffer` using the parameters in `params`.
        """
    def add_parent_buffer_meta(self, ref: Buffer) -> ParentBufferMeta | None:
        """
            Adds a Gst.ParentBufferMeta to `buffer` that holds a reference on
        `ref` until the buffer is freed.
        """
    def add_protection_meta(self, info: Structure) -> ProtectionMeta:
        """
        Attaches protection metadata to a Gst.Buffer.
        """
    def add_reference_timestamp_meta(
        self, reference: Caps, timestamp: int, duration: int
    ) -> ReferenceTimestampMeta | None:
        """
            Adds a Gst.ReferenceTimestampMeta to `buffer` that holds a `timestamp` and
        optionally `duration` based on a specific timestamp `reference`. See the
        documentation of Gst.ReferenceTimestampMeta for details.
        """
    def append(self, buf2: Buffer) -> Buffer:
        """
            Appends all the memory from `buf2` to `buf1`. The result buffer will contain a
        concatenation of the memory of `buf1` and `buf2`.
        """
    def append_memory(self, mem: Memory) -> None:
        """
            Appends the memory block `mem` to `buffer`. This function takes
        ownership of `mem` and thus doesn't increase its refcount.

        This function is identical to `Gst.Buffer.insert_memory` with an index of -1.
        See `Gst.Buffer.insert_memory` for more details.
        """
    def append_region(self, buf2: Buffer, offset: int, size: int) -> Buffer:
        """
            Appends `size` bytes at `offset` from `buf2` to `buf1`. The result buffer will
        contain a concatenation of the memory of `buf1` and the requested region of
        `buf2`.
        """
    def copy_deep(self) -> Buffer | None:
        """
            Creates a copy of the given buffer. This will make a newly allocated
        copy of the data the source buffer contains.
        """
    def copy_into(self, src: Buffer, flags: BufferCopyFlags, offset: int, size: int) -> bool:
        """
            Copies the information from `src` into `dest`.

        If `dest` already contains memory and `flags` contains GST_BUFFER_COPY_MEMORY,
        the memory from `src` will be appended to `dest`.

        `flags` indicate which fields will be copied.
        """
    def copy_region(self, flags: BufferCopyFlags, offset: int, size: int) -> Buffer | None:
        """
            Creates a sub-buffer from `parent` at `offset` and `size`.
        This sub-buffer uses the actual memory space of the parent buffer.
        This function will copy the offset and timestamp fields when the
        offset is 0. If not, they will be set to GST_CLOCK_TIME_NONE and
        GST_BUFFER_OFFSET_NONE.
        If `offset` equals 0 and `size` equals the total size of `buffer`, the
        duration and offset end fields are also copied. If not they will be set
        to GST_CLOCK_TIME_NONE and GST_BUFFER_OFFSET_NONE.
        """
    def extract(self, offset: int, size: int) -> tuple[int, list]:
        """
        Copies `size` bytes starting from `offset` in `buffer` to `dest`.
        """
    def extract_dup(self, offset: int, size: int) -> tuple[list, int]:
        """
            Extracts a copy of at most `size` bytes the data at `offset` into
        newly-allocated memory. `dest` must be freed using `g_free` when done.
        """
    def fill(self, offset: int, src: list, size: int) -> int:
        """
        Copies `size` bytes from `src` to `buffer` at `offset`.
        """
    def find_memory(self, offset: int, size: int) -> tuple[bool, int, int, int]:
        """
            Finds the memory blocks that span `size` bytes starting from `offset`
        in `buffer`.

        When this function returns True, `idx` will contain the index of the first
        memory block where the byte for `offset` can be found and `length` contains the
        number of memory blocks containing the `size` remaining bytes. `skip` contains
        the number of bytes to skip in the memory block at `idx` to get to the byte
        for `offset`.

        `size` can be -1 to get all the memory blocks after `idx`.
        """
    def foreach_meta(self, func: BufferForeachMetaFunc, *user_data: object | None) -> bool:
        """
            Calls `func` with `user_data` for each meta in `buffer`.

        `func` can modify the passed meta pointer or its contents. The return value
        of `func` defines if this function returns or if the remaining metadata items
        in the buffer should be skipped.
        """
    def get_all_memory(self) -> Memory | None:
        """
            Gets all the memory blocks in `buffer`. The memory blocks will be merged
        into one large Gst.Memory.
        """
    def get_custom_meta(self, name: str) -> CustomMeta | None:
        """
        Finds the first Gst.CustomMeta on `buffer` for the desired `name`.
        """
    def get_flags(self) -> BufferFlags:
        """
        Gets the Gst.BufferFlags flags set on this buffer.
        """
    @staticmethod
    def get_max_memory() -> int:
        """
            Gets the maximum amount of memory blocks that a buffer can hold. This is a
        compile time constant that can be queried with the function.

        When more memory blocks are added, existing memory blocks will be merged
        together to make room for the new block.
        """
    def get_memory(self, idx: int) -> Memory | None:
        """
        Gets the memory block at index `idx` in `buffer`.
        """
    def get_memory_range(self, idx: int, length: int) -> Memory | None:
        """
            Gets `length` memory blocks in `buffer` starting at `idx`. The memory blocks will
        be merged into one large Gst.Memory.

        If `length` is -1, all memory starting from `idx` is merged.
        """
    def get_meta(self, api: GObject.GType) -> Meta | None:
        """
            Gets the metadata for `api` on buffer. When there is no such metadata, None is
        returned. If multiple metadata with the given `api` are attached to this
        buffer only the first one is returned.  To handle multiple metadata with a
        given API use `Gst.Buffer.iterate_meta` or `Gst.Buffer.foreach_meta` instead
        and check the `meta->info.api` member for the API type.
        """
    def get_n_meta(self, api_type: GObject.GType) -> int: ...
    def get_reference_timestamp_meta(self, reference: Caps | None = None) -> ReferenceTimestampMeta | None:
        """
            Finds the first Gst.ReferenceTimestampMeta on `buffer` that conforms to
        `reference`. Conformance is tested by checking if the meta's reference is a
        subset of `reference`.

        Buffers can contain multiple Gst.ReferenceTimestampMeta metadata items.
        """
    def get_size(self) -> int:
        """
        Gets the total size of the memory blocks in `buffer`.
        """
    def get_sizes(self) -> tuple[int, int, int]:
        """
            Gets the total size of the memory blocks in `buffer`.

        When not None, `offset` will contain the offset of the data in the
        first memory block in `buffer` and `maxsize` will contain the sum of
        the size and `offset` and the amount of extra padding on the last
        memory block.  `offset` and `maxsize` can be used to resize the
        buffer memory blocks with `Gst.Buffer.resize`.
        """
    def get_sizes_range(self, idx: int, length: int) -> tuple[int, int, int]:
        """
            Gets the total size of `length` memory blocks stating from `idx` in `buffer`.

        When not None, `offset` will contain the offset of the data in the
        memory block in `buffer` at `idx` and `maxsize` will contain the sum of the size
        and `offset` and the amount of extra padding on the memory block at `idx` +
        `length` -1.
        `offset` and `maxsize` can be used to resize the buffer memory blocks with
        `Gst.Buffer.resize_range`.
        """
    def has_flags(self, flags: BufferFlags) -> bool:
        """
        Gives the status of a specific flag on a buffer.
        """
    def insert_memory(self, idx: int, mem: Memory) -> None:
        """
            Inserts the memory block `mem` into `buffer` at `idx`. This function takes ownership
        of `mem` and thus doesn't increase its refcount.

        Only `Gst.Buffer.get_max_memory` can be added to a buffer. If more memory is
        added, existing memory blocks will automatically be merged to make room for
        the new memory.
        """
    def is_all_memory_writable(self) -> bool:
        """
            Checks if all memory blocks in `buffer` are writable.

        Note that this function does not check if `buffer` is writable, use
        `Gst.Buffer.is_writable` to check that if needed.
        """
    def is_memory_range_writable(self, idx: int, length: int) -> bool:
        """
            Checks if `length` memory blocks in `buffer` starting from `idx` are writable.

        `length` can be -1 to check all the memory blocks after `idx`.

        Note that this function does not check if `buffer` is writable, use
        `Gst.Buffer.is_writable` to check that if needed.
        """
    def memcmp(self, offset: int, mem: list, size: int) -> int:
        """
        Compares `size` bytes starting from `offset` in `buffer` with the memory in `mem`.
        """
    def memset(self, offset: int, val: int, size: int) -> int:
        """
        Fills `buf` with `size` bytes with `val` starting from `offset`.
        """
    def n_memory(self) -> int:
        """
            Gets the amount of memory blocks that this buffer has. This amount is never
        larger than what `Gst.Buffer.get_max_memory` returns.
        """
    @classmethod
    def new(cls) -> Buffer:
        """
        Creates a newly allocated buffer without any data.
        """
    @classmethod
    def new_allocate(
        cls, allocator: Allocator | None, size: int, params: AllocationParams | None = None
    ) -> Buffer | None:
        """
            Tries to create a newly allocated buffer with data of the given size and
        extra parameters from `allocator`. If the requested amount of memory can't be
        allocated, None will be returned. The allocated buffer memory is not cleared.

        When `allocator` is None, the default memory allocator will be used.

        Note that when `size` == 0, the buffer will not have memory associated with it.
        """
    @classmethod
    def new_memdup(cls, data: list, size: int) -> Buffer:
        """
        Creates a new buffer of size `size` and fills it with a copy of `data`.
        """
    @classmethod
    def new_wrapped(cls, data: list, size: int) -> Buffer:
        """
            Creates a new buffer that wraps the given `data`. The memory will be freed
        with `g_free` and will be marked writable.
        """
    @classmethod
    def new_wrapped_bytes(cls, bytes: GLib.Bytes) -> Buffer:
        """
            Creates a new Gst.Buffer that wraps the given `bytes`. The data inside
        `bytes` cannot be None and the resulting buffer will be marked as read only.
        """
    @classmethod
    def new_wrapped_full(
        cls,
        flags: MemoryFlags,
        data: list,
        maxsize: int,
        offset: int,
        size: int,
        *user_data: object | None,
        notify: GLib.DestroyNotify | None = None,
    ) -> Buffer:
        """
            Allocates a new buffer that wraps the given memory. `data` must point to
        `maxsize` of memory, the wrapped buffer will have the region from `offset` and
        `size` visible.

        When the buffer is destroyed, `notify` will be called with `user_data`.

        The prefix/padding must be filled with 0 if `flags` contains
        GST_MEMORY_FLAG_ZERO_PREFIXED and GST_MEMORY_FLAG_ZERO_PADDED respectively.
        """
    def peek_memory(self, idx: int) -> Memory | None:
        """
            Gets the memory block at `idx` in `buffer`. The memory block stays valid until
        the memory block in `buffer` is removed, replaced or merged, typically with
        any call that modifies the memory in `buffer`.
        """
    def prepend_memory(self, mem: Memory) -> None:
        """
            Prepends the memory block `mem` to `buffer`. This function takes
        ownership of `mem` and thus doesn't increase its refcount.

        This function is identical to `Gst.Buffer.insert_memory` with an index of 0.
        See `Gst.Buffer.insert_memory` for more details.
        """
    def remove_all_memory(self) -> None:
        """
        Removes all the memory blocks in `buffer`.
        """
    def remove_memory(self, idx: int) -> None:
        """
        Removes the memory block in `b` at index `i`.
        """
    def remove_memory_range(self, idx: int, length: int) -> None:
        """
            Removes `length` memory blocks in `buffer` starting from `idx`.

        `length` can be -1, in which case all memory starting from `idx` is removed.
        """
    def remove_meta(self, meta: Meta) -> bool:
        """
        Removes the metadata for `meta` on `buffer`.
        """
    def replace_all_memory(self, mem: Memory) -> None:
        """
        Replaces all memory in `buffer` with `mem`.
        """
    def replace_memory(self, idx: int, mem: Memory) -> None:
        """
        Replaces the memory block at index `idx` in `buffer` with `mem`.
        """
    def replace_memory_range(self, idx: int, length: int, mem: Memory) -> None:
        """
            Replaces `length` memory blocks in `buffer` starting at `idx` with `mem`.

        If `length` is -1, all memory starting from `idx` will be removed and
        replaced with `mem`.

        `buffer` should be writable.
        """
    def resize(self, offset: int, size: int) -> None:
        """
        Sets the offset and total size of the memory blocks in `buffer`.
        """
    def resize_range(self, idx: int, length: int, offset: int, size: int) -> bool:
        """
            Sets the total size of the `length` memory blocks starting at `idx` in
        `buffer`
        """
    def set_flags(self, flags: BufferFlags) -> bool:
        """
        Sets one or more buffer flags on a buffer.
        """
    def set_size(self, size: int) -> None:
        """
        Sets the total size of the memory blocks in `buffer`.
        """
    def unset_flags(self, flags: BufferFlags) -> bool:
        """
        Clears one or more buffer flags.
        """

    # python methods (overrides?)
    def map(
        self,
        flags: typing.Any,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        map(self, flags:Gst.MapFlags) -> bool, info:Gst.MapInfo
        """
    def map_range(
        self,
        idx: typing.Any,
        length: typing.Any,
        flags: typing.Any,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        map_range(self, idx:int, length:int, flags:Gst.MapFlags) -> bool, info:Gst.MapInfo
        """
    def unmap(
        self,
        mapinfo: typing.Any,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        unmap(self, info:Gst.MapInfo)
        """

class BufferList(GObject.GBoxed):
    """
    Buffer lists are an object containing a list of buffers.

    Buffer lists are created with `Gst.BufferList.new` and filled with data
    using `Gst.BufferList.insert`.

    Buffer lists can be pushed on a srcpad with `Gst.Pad.push_list`. This is
    interesting when multiple buffers need to be pushed in one go because it
    can reduce the amount of overhead for pushing each buffer individually.
    """

    # gi Methods
    def calculate_size(self) -> int:
        """
            Calculates the size of the data contained in `list` by adding the
        size of all buffers.
        """
    def copy_deep(self) -> BufferList:
        """
            Creates a copy of the given buffer list. This will make a newly allocated
        copy of the buffers that the source buffer list contains.
        """
    def foreach(self, func: BufferListFunc, *user_data: object | None) -> bool:
        """
            Calls `func` with `data` for each buffer in `list`.

        `func` can modify the passed buffer pointer or its contents. The return value
        of `func` defines if this function returns or if the remaining buffers in
        the list should be skipped.
        """
    def get(self, idx: int) -> Buffer:
        """
            Gets the buffer at `idx`.

        You must make sure that `idx` does not exceed the number of
        buffers available.
        """
    def get_writable(self, idx: int) -> Buffer:
        """
            Gets the buffer at `idx`, ensuring it is a writable buffer.

        You must make sure that `idx` does not exceed the number of
        buffers available.
        """
    def insert(self, idx: int, buffer: Buffer) -> None:
        """
            Inserts `buffer` at `idx` in `list`. Other buffers are moved to make room for
        this new buffer.

        A -1 value for `idx` will append the buffer at the end.
        """
    def length(self) -> int:
        """
        Returns the number of buffers in `list`.
        """
    def remove(self, idx: int, length: int) -> None:
        """
            Removes `length` buffers starting from `idx` in `list`. The following buffers
        are moved to close the gap.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
    ) -> BufferList:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.BufferList
        """
    @classmethod
    def new_sized(
        cls,
        size: int,
    ) -> BufferList:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_sized(size:int) -> Gst.BufferList
        """

class BufferPool(Object):
    """
    A Gst.BufferPool is an object that can be used to pre-allocate and recycle
    buffers of the same size and with the same properties.

    A Gst.BufferPool is created with `Gst.BufferPool.new`.

    Once a pool is created, it needs to be configured. A call to
    `Gst.BufferPool.get_config` returns the current configuration structure from
    the pool. With `Gst.BufferPool.config_set_params` and
    `Gst.BufferPool.config_set_allocator` the bufferpool parameters and
    allocator can be configured. Other properties can be configured in the pool
    depending on the pool implementation.

    A bufferpool can have extra options that can be enabled with
    `Gst.BufferPool.config_add_option`. The available options can be retrieved
    with `Gst.BufferPool.get_options`. Some options allow for additional
    configuration properties to be set.

    After the configuration structure has been configured,
    `Gst.BufferPool.set_config` updates the configuration in the pool. This can
    fail when the configuration structure is not accepted.

    After the pool has been configured, it can be activated with
    `Gst.BufferPool.set_active`. This will preallocate the configured resources
    in the pool.

    When the pool is active, `Gst.BufferPool.acquire_buffer` can be used to
    retrieve a buffer from the pool.

    Buffers allocated from a bufferpool will automatically be returned to the
    pool with `Gst.BufferPool.release_buffer` when their refcount drops to 0.

    The bufferpool can be deactivated again with `Gst.BufferPool.set_active`.
    All further `Gst.BufferPool.acquire_buffer` calls will return an error. When
    all buffers are returned to the pool they will be freed.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def flushing(self) -> int:
        """
        whether the pool is currently gathering back outstanding buffers
        """
    @builtins.property
    def object(self) -> Object | None:
        """
        the parent structure
        """
    @builtins.property
    def priv(self) -> BufferPoolPrivate | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize BufferPool object with properties.
        """
    def acquire_buffer(self, params: BufferPoolAcquireParams | None = None) -> tuple[FlowReturn, Buffer | None]:
        """
            Acquires a buffer from `pool`. `buffer` should point to a memory location that
        can hold a pointer to the new buffer. When the pool is empty, this function
        will by default block until a buffer is released into the pool again or when
        the pool is set to flushing or deactivated.

        `params` can contain optional parameters to influence the allocation.
        """
    @staticmethod
    def config_add_option(config: Structure, option: str) -> None:
        """
            Enables the option in `config`. This will instruct the `bufferpool` to enable
        the specified option on the buffers that it allocates.

        The options supported by `pool` can be retrieved with `Gst.BufferPool.get_options`.
        """
    @staticmethod
    def config_get_allocator(config: Structure) -> tuple[bool, Allocator | None, AllocationParams]:
        """
        Gets the `allocator` and `params` from `config`.
        """
    @staticmethod
    def config_get_option(config: Structure, index: int) -> str | None:
        """
            Parses an available `config` and gets the option at `index` of the options API
        array.
        """
    @staticmethod
    def config_get_params(config: Structure) -> tuple[bool, Caps | None, int, int, int]:
        """
        Gets the configuration values from `config`.
        """
    @staticmethod
    def config_has_option(config: Structure, option: str) -> bool:
        """
        Checks if `config` contains `option`.
        """
    @staticmethod
    def config_n_options(config: Structure) -> int:
        """
            Retrieves the number of values currently stored in the options array of the
        `config` structure.
        """
    @staticmethod
    def config_set_allocator(
        config: Structure, allocator: Allocator | None = None, params: AllocationParams | None = None
    ) -> None:
        """
            Sets the `allocator` and `params` on `config`.

        One of `allocator` and `params` can be None, but not both. When `allocator`
        is None, the default allocator of the pool will use the values in `param`
        to perform its allocation. When `param` is None, the pool will use the
        provided `allocator` with its default Gst.AllocationParams.

        A call to `Gst.BufferPool.set_config` can update the allocator and params
        with the values that it is able to do. Some pools are, for example, not able
        to operate with different allocators or cannot allocate with the values
        specified in `params`. Use `Gst.BufferPool.get_config` to get the currently
        used values.
        """
    @staticmethod
    def config_set_params(config: Structure, caps: Caps | None, size: int, min_buffers: int, max_buffers: int) -> None:
        """
        Configures `config` with the given parameters.
        """
    @staticmethod
    def config_validate_params(
        config: Structure, caps: Caps | None, size: int, min_buffers: int, max_buffers: int
    ) -> bool:
        """
            Validates that changes made to `config` are still valid in the context of the
        expected parameters. This function is a helper that can be used to validate
        changes made by a pool to a config when `Gst.BufferPool.set_config`
        returns False. This expects that `caps` haven't changed and that
        `min_buffers` aren't lower then what we initially expected.
        This does not check if options or allocator parameters are still valid,
        won't check if size have changed, since changing the size is valid to adapt
        padding.
        """
    def get_config(self) -> Structure:
        """
            Gets a copy of the current configuration of the pool. This configuration
        can be modified and used for the `Gst.BufferPool.set_config` call.
        """
    def get_options(self) -> list:
        """
            Gets a None terminated array of string with supported bufferpool options for
        `pool`. An option would typically be enabled with
        `Gst.BufferPool.config_add_option`.
        """
    def has_option(self, option: str) -> bool:
        """
        Checks if the bufferpool supports `option`.
        """
    def is_active(self) -> bool:
        """
            Checks if `pool` is active. A pool can be activated with the
        `Gst.BufferPool.set_active` call.
        """
    def release_buffer(self, buffer: Buffer) -> None:
        """
            Releases `buffer` to `pool`. `buffer` should have previously been allocated from
        `pool` with `Gst.BufferPool.acquire_buffer`.

        This function is usually called automatically when the last ref on `buffer`
        disappears.
        """
    def set_active(self, active: bool) -> bool:
        """
            Controls the active state of `pool`. When the pool is inactive, new calls to
        `Gst.BufferPool.acquire_buffer` will return with Gst.FLOW_FLUSHING.

        Activating the bufferpool will preallocate all resources in the pool based on
        the configuration of the pool.

        Deactivating will free the resources again when there are no outstanding
        buffers. When there are outstanding buffers, they will be freed as soon as
        they are all returned to the pool.
        """
    def set_config(self, config: Structure) -> bool:
        """
            Sets the configuration of the pool. If the pool is already configured, and
        the configuration hasn't changed, this function will return True. If the
        pool is active, this method will return False and active configuration
        will remain. Buffers allocated from this pool must be returned or else this
        function will do nothing and return False.

        `config` is a Gst.Structure that contains the configuration parameters for
        the pool. A default and mandatory set of parameters can be configured with
        `Gst.BufferPool.config_set_params`, `Gst.BufferPool.config_set_allocator`
        and `Gst.BufferPool.config_add_option`.

        If the parameters in `config` can not be set exactly, this function returns
        False and will try to update as much state as possible. The new state can
        then be retrieved and refined with `Gst.BufferPool.get_config`.

        This function takes ownership of `config`.
        """
    def set_flushing(self, flushing: bool) -> None:
        """
            Enables or disables the flushing state of a `pool` without freeing or
        allocating buffers.
        """

    # python methods (overrides?)
    def do_acquire_buffer(
        self,
        params: BufferPoolAcquireParams | None = None,
    ) -> tuple:
        """
        acquire_buffer(self, params:Gst.BufferPoolAcquireParams=None) -> Gst.FlowReturn, buffer:Gst.Buffer
        """
    def do_alloc_buffer(
        self,
        params: BufferPoolAcquireParams | None = None,
    ) -> tuple:
        """
        alloc_buffer(self, params:Gst.BufferPoolAcquireParams=None) -> Gst.FlowReturn, buffer:Gst.Buffer
        """
    def do_flush_start(
        self,
    ) -> None:
        """
        flush_start(self)
        """
    def do_flush_stop(
        self,
    ) -> None:
        """
        flush_stop(self)
        """
    def do_free_buffer(
        self,
        buffer: Buffer,
    ) -> None:
        """
        free_buffer(self, buffer:Gst.Buffer)
        """
    def do_get_options(
        self,
    ) -> list:
        """
        get_options(self) -> list
        """
    def do_release_buffer(
        self,
        buffer: Buffer,
    ) -> None:
        """
        release_buffer(self, buffer:Gst.Buffer)
        """
    def do_reset_buffer(
        self,
        buffer: Buffer,
    ) -> None:
        """
        reset_buffer(self, buffer:Gst.Buffer)
        """
    def do_set_config(
        self,
        config: Structure,
    ) -> bool:
        """
        set_config(self, config:Gst.Structure) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """
    @classmethod
    def new(
        cls,
    ) -> BufferPool:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.BufferPool
        """

class BufferPoolAcquireParams(GObject.GPointer):
    """
    Parameters passed to the `Gst.BufferPool.acquire_buffer` function to control the
    allocation of the buffer.

    The default implementation ignores the `start` and `stop` members but other
    implementations can use this extra information to decide what buffer to
    return.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    flags: BufferPoolAcquireFlags = ...
    """
    additional flags
    """
    format: Format = ...
    """
    the format of `start` and `stop`
    """
    start: int = ...
    """
    the start position
    """
    stop: int = ...
    """
    the stop position
    """

class BufferPoolClass(GObject.GPointer):
    """
    The Gst.BufferPool class.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def acquire_buffer(self) -> acquire_bufferBufferPoolClassCB: ...
    @builtins.property
    def alloc_buffer(self) -> alloc_bufferBufferPoolClassCB: ...
    @builtins.property
    def flush_start(self) -> flush_startBufferPoolClassCB: ...
    @builtins.property
    def flush_stop(self) -> flush_stopBufferPoolClassCB: ...
    @builtins.property
    def free_buffer(self) -> free_bufferBufferPoolClassCB: ...
    @builtins.property
    def get_options(self) -> get_optionsBufferPoolClassCB: ...
    @builtins.property
    def object_class(self) -> ObjectClass | None:
        """
        Object parent class
        """
    @builtins.property
    def release_buffer(self) -> release_bufferBufferPoolClassCB: ...
    @builtins.property
    def reset_buffer(self) -> reset_bufferBufferPoolClassCB: ...
    @builtins.property
    def set_config(self) -> set_configBufferPoolClassCB: ...
    @builtins.property
    def start(self) -> startBufferPoolClassCB: ...
    @builtins.property
    def stop(self) -> stopBufferPoolClassCB: ...

class BufferPoolPrivate(GObject.GPointer): ...

class Bus(Object):
    """
    The Gst.Bus is an object responsible for delivering Gst.Message packets in
    a first-in first-out way from the streaming threads (see Gst.Task) to the
    application.

    Since the application typically only wants to deal with delivery of these
    messages from one thread, the GstBus will marshall the messages between
    different threads. This is important since the actual streaming of media
    is done in another thread than the application.

    The GstBus provides support for GSource based notifications. This makes it
    possible to handle the delivery in the glib GMainLoop.

    The GSource callback function `Gst.Bus.async_signal_func` can be used to
    convert all bus messages into signal emissions.

    A message is posted on the bus with the `Gst.Bus.post` method. With the
    `Gst.Bus.peek` and `Gst.Bus.pop` methods one can look at or retrieve a
    previously posted message.

    The bus can be polled with the `Gst.Bus.poll` method. This methods blocks
    up to the specified timeout value until one of the specified messages types
    is posted on the bus. The application can then `Gst.Bus.pop` the messages
    from the bus to handle them.
    Alternatively the application can register an asynchronous bus function
    using `Gst.Bus.add_watch_full` or `Gst.Bus.add_watch`. This function will
    install a GSource in the default glib main loop and will deliver messages
    a short while after they have been posted. Note that the main loop should
    be running for the asynchronous callbacks.

    It is also possible to get messages from the bus without any thread
    marshalling with the `Gst.Bus.set_sync_handler` method. This makes it
    possible to react to a message in the same thread that posted the
    message on the bus. This should only be used if the application is able
    to deal with messages from different threads.

    Every Gst.Pipeline has one bus.

    Note that a Gst.Pipeline will set its bus into flushing state when changing
    from READY to None state.
    """

    class Props(Object.Props):
        enable_async: bool  # [enable-async]: changed because contained invalid characters
        """
        Enables async message delivery support for bus watches,
        `Gst.Bus.pop` and similar API. Without this only the
        synchronous message handlers are called.

        This property is used to create the child element buses
        in Gst.Bin.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def object(self) -> Object | None:
        """
        the parent structure
        """
    @builtins.property
    def priv(self) -> BusPrivate | None: ...

    # gi Methods
    def __init__(self, enable_async: bool | None = None, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize Bus object with properties.
        """
    def add_signal_watch(self) -> None:
        """
            Adds a bus signal watch to the default main context with the default priority
        ( G_PRIORITY_DEFAULT ). It is also possible to use a non-default
        main context set up using `g_main_context_push_thread_default` (before
        one had to create a bus watch source and attach it to the desired main
        context 'manually').

        After calling this statement, the bus will emit the "message" signal for each
        message posted on the bus.

        This function may be called multiple times. To clean up, the caller is
        responsible for calling `Gst.Bus.remove_signal_watch` as many times as this
        function is called.
        """
    def add_signal_watch_full(self, priority: int) -> None:
        """
            Adds a bus signal watch to the default main context with the given `priority`
        (e.g. G_PRIORITY_DEFAULT). It is also possible to use a non-default main
        context set up using `g_main_context_push_thread_default`
        (before one had to create a bus watch source and attach it to the desired
        main context 'manually').

        After calling this statement, the bus will emit the "message" signal for each
        message posted on the bus when the GMainLoop is running.

        This function may be called multiple times. To clean up, the caller is
        responsible for calling `Gst.Bus.remove_signal_watch` as many times as this
        function is called.

        There can only be a single bus watch per bus, you must remove any signal
        watch before you can set another type of watch.
        """
    def add_watch(self, priority: int, func: BusFunc, *user_data: object | None) -> int:
        """
            Adds a bus watch to the default main context with the default priority
        ( G_PRIORITY_DEFAULT ). It is also possible to use a non-default main
        context set up using `g_main_context_push_thread_default` (before
        one had to create a bus watch source and attach it to the desired main
        context 'manually').

        This function is used to receive asynchronous messages in the main loop.
        There can only be a single bus watch per bus, you must remove it before you
        can set a new one.

        The bus watch will only work if a GMainLoop is being run.

        The watch can be removed using `Gst.Bus.remove_watch` or by returning False
        from `func`. If the watch was added to the default main context it is also
        possible to remove the watch using `g_source_remove`.

        The bus watch will take its own reference to the `bus`, so it is safe to unref
        `bus` using `Gst.Object.unref` after setting the bus watch.
        """
    def async_signal_func(self, message: Message, data: object | None = None) -> bool:
        """
            A helper Gst.BusFunc that can be used to convert all asynchronous messages
        into signals.
        """
    def create_watch(self) -> GLib.Source | None:
        """
            Create watch for this bus. The GSource will be dispatched whenever
        a message is on the bus. After the GSource is dispatched, the
        message is popped off the bus and unreffed.

        As with other watches, there can only be one watch on the bus, including
        any signal watch added with #gst_bus_add_signal_watch.
        """
    def disable_sync_message_emission(self) -> None:
        """
            Instructs GStreamer to stop emitting the "sync-message" signal for this bus.
        See `Gst.Bus.enable_sync_message_emission` for more information.

        In the event that multiple pieces of code have called
        `Gst.Bus.enable_sync_message_emission`, the sync-message emissions will only
        be stopped after all calls to `Gst.Bus.enable_sync_message_emission` were
        "cancelled" by calling this function. In this way the semantics are exactly
        the same as `Gst.Object.ref` that which calls enable should also call
        disable.
        """
    def enable_sync_message_emission(self) -> None:
        """
            Instructs GStreamer to emit the "sync-message" signal after running the bus's
        sync handler. This function is here so that code can ensure that they can
        synchronously receive messages without having to affect what the bin's sync
        handler is.

        This function may be called multiple times. To clean up, the caller is
        responsible for calling `Gst.Bus.disable_sync_message_emission` as many times
        as this function is called.

        While this function looks similar to `Gst.Bus.add_signal_watch`, it is not
        exactly the same -- this function enables *synchronous* emission of
        signals when messages arrive; `Gst.Bus.add_signal_watch` adds an idle callback
        to pop messages off the bus *asynchronously*. The sync-message signal
        comes from the thread of whatever object posted the message; the "message"
        signal is marshalled to the main thread via the GMainLoop.
        """
    def get_pollfd(self) -> GLib.PollFD:
        """
            Gets the file descriptor from the bus which can be used to get notified about
        messages being available with functions like `g_poll`, and allows integration
        into other event loops based on file descriptors.
        Whenever a message is available, the POLLIN / G_IO_IN event is set.

        Warning: NEVER read or write anything to the returned fd but only use it
        for getting notifications via `g_poll` or similar and then use the normal
        GstBus API, e.g. `Gst.Bus.pop`.
        """
    def have_pending(self) -> bool:
        """
            Checks if there are pending messages on the bus that
        should be handled.
        """
    def peek(self) -> Message | None:
        """
            Peeks the message on the top of the bus' queue. The message will remain
        on the bus' message queue.
        """
    def poll(self, events: MessageType, timeout: int) -> Message | None:
        """
            Polls the bus for messages. Will block while waiting for messages to come.
        You can specify a maximum time to poll with the `timeout` parameter. If
        `timeout` is negative, this function will block indefinitely.

        All messages not in `events` will be popped off the bus and will be ignored.
        It is not possible to use message enums beyond GST_MESSAGE_EXTENDED in the
        `events` mask

        Because poll is implemented using the "message" signal enabled by
        `Gst.Bus.add_signal_watch`, calling `Gst.Bus.poll` will cause the "message"
        signal to be emitted for every message that poll sees. Thus a "message"
        signal handler will see the same messages that this function sees -- neither
        will steal messages from the other.

        This function will run a GMainLoop from the default main context when
        polling.

        You should never use this function, since it is pure evil. This is
        especially true for GUI applications based on Gtk+ or Qt, but also for any
        other non-trivial application that uses the GLib main loop. As this function
        runs a GLib main loop, any callback attached to the default GLib main
        context may be invoked. This could be timeouts, GUI events, I/O events etc.;
        even if `Gst.Bus.poll` is called with a 0 timeout. Any of these callbacks
        may do things you do not expect, e.g. destroy the main application window or
        some other resource; change other application state; display a dialog and
        run another main loop until the user clicks it away. In short, using this
        function may add a lot of complexity to your code through unexpected
        re-entrancy and unexpected changes to your application's state.

        For 0 timeouts use `Gst.Bus.pop_filtered` instead of this function; for
        other short timeouts use `Gst.Bus.timed_pop_filtered`; everything else is
        better handled by setting up an asynchronous bus watch and doing things
        from there.
        """
    def pop(self) -> Message | None:
        """
        Gets a message from the bus.
        """
    def pop_filtered(self, types: MessageType) -> Message | None:
        """
            Gets a message matching `type` from the bus.  Will discard all messages on
        the bus that do not match `type` and that have been posted before the first
        message that does match `type`.  If there is no message matching `type` on
        the bus, all messages will be discarded. It is not possible to use message
        enums beyond GST_MESSAGE_EXTENDED in the `events` mask.
        """
    def post(self, message: Message) -> bool:
        """
            Posts a message on the given bus. Ownership of the message
        is taken by the bus.
        """
    def remove_signal_watch(self) -> None:
        """
        Removes a signal watch previously added with `Gst.Bus.add_signal_watch`.
        """
    def remove_watch(self) -> bool:
        """
        Removes an installed bus watch from `bus`.
        """
    def set_flushing(self, flushing: bool) -> None:
        """
            If `flushing`, flushes out and unrefs any messages queued in the bus. Releases
        references to the message origin objects. Will flush future messages until
        `Gst.Bus.set_flushing` sets `flushing` to False.
        """
    def set_sync_handler(
        self, func: BusSyncHandler | None | typing.Callable[..., BusSyncReply] = None, *user_data: object | None
    ) -> None:
        """
            Sets the synchronous handler on the bus. The function will be called
        every time a new message is posted on the bus. Note that the function
        will be called in the same thread context as the posting object. This
        function is usually only called by the creator of the bus. Applications
        should handle messages asynchronously using the gst_bus watch and poll
        functions.

        Before 1.16.3 it was not possible to replace an existing handler and
        clearing an existing handler with None was not thread-safe.
        """
    def sync_signal_handler(self, message: Message, data: object | None = None) -> BusSyncReply:
        """
            A helper Gst.BusSyncHandler that can be used to convert all synchronous
        messages into signals.
        """
    def timed_pop(self, timeout: int) -> Message | None:
        """
            Gets a message from the bus, waiting up to the specified timeout.

        If `timeout` is 0, this function behaves like `Gst.Bus.pop`. If `timeout` is
        GST_CLOCK_TIME_NONE, this function will block forever until a message was
        posted on the bus.
        """
    def timed_pop_filtered(self, timeout: int, types: MessageType) -> Message | None:
        """
            Gets a message from the bus whose type matches the message type mask `types`,
        waiting up to the specified timeout (and discarding any messages that do not
        match the mask provided).

        If `timeout` is 0, this function behaves like `Gst.Bus.pop_filtered`. If
        `timeout` is GST_CLOCK_TIME_NONE, this function will block forever until a
        matching message was posted on the bus.
        """

    # python methods (overrides?)
    def do_message(
        self,
        message: Message,
    ) -> None:
        """
        message(self, message:Gst.Message)
        """
    def do_sync_message(
        self,
        message: Message,
    ) -> None:
        """
        sync_message(self, message:Gst.Message)
        """
    @classmethod
    def new(
        cls,
    ) -> Bus:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.Bus
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["message"],
        handler: typing.Callable[[typing_extensions.Self, Message], None],
        *args: typing.Any,
    ) -> int:
        """
            A message has been posted on the bus. This signal is emitted from a
        GSource added to the mainloop. this signal will only be emitted when
        there is a GMainLoop running.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["sync-message"],
        handler: typing.Callable[[typing_extensions.Self, Message], None],
        *args: typing.Any,
    ) -> int:
        """
            A message has been posted on the bus. This signal is emitted from the
        thread that posted the message so one has to be careful with locking.

        This signal will not be emitted by default, you have to call
        `Gst.Bus.enable_sync_message_emission` before.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_async"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BusClass(GObject.GPointer):
    """
    GStreamer bus class.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def message(self) -> messageBusClassCB: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        the parent class structure
        """
    @builtins.property
    def sync_message(self) -> sync_messageBusClassCB: ...

class BusPrivate(GObject.GPointer): ...

class ByteArrayInterface(GObject.GPointer):
    """
    Interface for an array of bytes. It is expected to be subclassed to implement
    `resize` virtual method using language native array implementation, such as
    GLib's GByteArray, C++'s `std::vector<uint8_t>` or Rust's `Vec<u8>`.

    `resize` implementation could allocate more than requested to avoid repeated
    reallocations. It can return False, or be set to None, in the case the
    array cannot grow.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    data: int = ...
    """
    A pointer to an array of bytes.
    """
    len: int = ...
    """
    Number of bytes in `data`.
    """
    @builtins.property
    def resize(self) -> resizeByteArrayInterfaceCB:
        """
        Reallocate `data`.
        """

class Caps(GObject.GBoxed):
    """
    Caps (capabilities) are lightweight refcounted objects describing media types.
    They are composed of an array of Gst.Structure.

    Caps are exposed on Gst.PadTemplate to describe all possible types a
    given pad can handle. They are also stored in the Gst.Registry along with
    a description of the Gst.Element.

    Caps are exposed on the element pads using the `Gst.Pad.query_caps` pad
    function. This function describes the possible types that the pad can
    handle or produce at runtime.

    A Gst.Caps can be constructed with the following code fragment:

    ``` C
      GstCaps *caps = gst_caps_new_simple ("video/x-raw",
         "format", G_TYPE_STRING, "I420",
         "framerate", GST_TYPE_FRACTION, 25, 1,
         "pixel-aspect-ratio", GST_TYPE_FRACTION, 1, 1,
         "width", G_TYPE_INT, 320,
         "height", G_TYPE_INT, 240,
         None);
    ```

    A Gst.Caps is fixed when it has no fields with ranges or lists. Use
    `Gst.Caps.is_fixed` to test for fixed caps. Fixed caps can be used in a
    caps event to notify downstream elements of the current media type.

    Various methods exist to work with the media types such as subtracting
    or intersecting.

    Be aware that until 1.20 the Gst.Caps / Gst.Structure serialization into string
    had limited support for nested Gst.Caps / Gst.Structure fields. It could only
    support one level of nesting. Using more levels would lead to unexpected
    behavior when using serialization features, such as `Gst.Caps.to_string` or
    `Gst.value_serialize` and their counterparts.
    """

    # gi Fields
    mini_object: MiniObject | None = ...
    """
    the parent type
    """

    # gi Methods
    def append(self, caps2: Caps) -> None:
        """
            Appends the structures contained in `caps2` to `caps1`. The structures in
        `caps2` are not copied -- they are transferred to `caps1`, and then `caps2` is
        freed. If either caps is ANY, the resulting caps will be ANY.
        """
    def append_structure(self, structure: Structure) -> None:
        """
            Appends `structure` to `caps`.  The structure is not copied; `caps`
        becomes the owner of `structure`.
        """
    def append_structure_full(self, structure: Structure, features: CapsFeatures | None = None) -> None:
        """
            Appends `structure` with `features` to `caps`.  The structure is not copied; `caps`
        becomes the owner of `structure`.
        """
    def can_intersect(self, caps2: Caps) -> bool:
        """
            Tries intersecting `caps1` and `caps2` and reports whether the result would not
        be empty
        """
    def copy(self) -> Caps:
        """
            Creates a new Gst.Caps as a copy of the old `caps`. The new caps will have a
        refcount of 1, owned by the caller. The structures are copied as well.

        Note that this function is the semantic equivalent of a `Gst.Caps.ref`
        followed by a `Gst.Caps.make_writable`. If you only want to hold on to a
        reference to the data, you should use `Gst.Caps.ref`.
        """
    def copy_nth(self, nth: int) -> Caps:
        """
            Creates a new Gst.Caps and appends a copy of the nth structure
        contained in `caps`.
        """
    def filter_and_map_in_place(self, func: CapsFilterMapFunc, *user_data: object | None) -> None:
        """
            Calls the provided function once for each structure and caps feature in the
        Gst.Caps. In contrast to `Gst.Caps.foreach`, the function may modify the
        structure and features. In contrast to `Gst.Caps.map_in_place`, the structure
        and features are removed from the caps if False is returned from the
        function. The caps must be mutable.
        """
    def fixate(self) -> Caps:
        """
            Modifies the given `caps` into a representation with only fixed
        values. First the caps will be truncated and then the first structure will be
        fixated with `Gst.Structure.fixate`.

        This function takes ownership of `caps` and will call `Gst.Caps.make_writable`
        on it so you must not use `caps` afterwards unless you keep an additional
        reference to it with `Gst.Caps.ref`.

        Note that it is not guaranteed that the returned caps have exactly one
        structure. If `caps` are empty caps then the returned caps will be
        the empty too and contain no structure at all.

        Calling this function with ANY caps is not allowed.
        """
    def foreach(self, func: CapsForeachFunc, *user_data: object | None) -> bool:
        """
            Calls the provided function once for each structure and caps feature in the
        Gst.Caps. The function must not modify the fields.
        Also see `Gst.Caps.map_in_place` and `Gst.Caps.filter_and_map_in_place`.
        """
    @staticmethod
    def from_string(string: str) -> Caps | None:
        """
            Converts `caps` from a string representation.

        The implementation of serialization up to 1.20 would lead to unexpected results
        when there were nested Gst.Caps / Gst.Structure deeper than one level.
        """
    def get_features(self, index: int) -> CapsFeatures | None:
        """
            Finds the features in `caps` at `index`, and returns it.

        WARNING: This function takes a `const GstCaps *`, but returns a
        non-const `GstCapsFeatures *`.  This is for programming convenience --
        the caller should be aware that features inside a constant
        Gst.Caps should not be modified. However, if you know the caps
        are writable, either because you have just copied them or made
        them writable with `Gst.Caps.make_writable`, you may modify the
        features returned in the usual way, e.g. with functions like
        `Gst.CapsFeatures.add`.
        """
    def get_size(self) -> int:
        """
        Gets the number of structures contained in `caps`.
        """
    def get_structure(self, index: int) -> Structure:
        """
            Finds the structure in `caps` at `index`, and returns it.

        WARNING: This function takes a `const GstCaps *`, but returns a
        non-const `GstStructure *`.  This is for programming convenience --
        the caller should be aware that structures inside a constant
        Gst.Caps should not be modified. However, if you know the caps
        are writable, either because you have just copied them or made
        them writable with `Gst.Caps.make_writable`, you may modify the
        structure returned in the usual way, e.g. with functions like
        `Gst.Structure.set`.
        """
    def id_str_set_value(self, field: IdStr, value: GObject.Value) -> None:
        """
            Sets the given `field` on all structures of `caps` to the given `value`.
        This is a convenience function for calling `Gst.Structure.set_value` on
        all structures of `caps`.
        """
    def intersect(self, caps2: Caps) -> Caps:
        """
            Creates a new Gst.Caps that contains all the formats that are common
        to both `caps1` and `caps2`. Defaults to Gst.CAPS_INTERSECT_ZIG_ZAG mode.
        """
    def intersect_full(self, caps2: Caps, mode: CapsIntersectMode) -> Caps:
        """
            Creates a new Gst.Caps that contains all the formats that are common
        to both `caps1` and `caps2`, the order is defined by the Gst.CapsIntersectMode
        used.
        """
    def is_always_compatible(self, caps2: Caps) -> bool:
        """
            A given Gst.Caps structure is always compatible with another if
        every media format that is in the first is also contained in the
        second.  That is, `caps1` is a subset of `caps2`.
        """
    def is_any(self) -> bool:
        """
        Determines if `caps` represents any media format.
        """
    def is_empty(self) -> bool:
        """
        Determines if `caps` represents no media formats.
        """
    def is_equal(self, caps2: Caps) -> bool:
        """
        Checks if the given caps represent the same set of caps.
        """
    def is_equal_fixed(self, caps2: Caps) -> bool:
        """
            Tests if two Gst.Caps are equal.  This function only works on fixed
        Gst.Caps.
        """
    def is_fixed(self) -> bool:
        """
            Fixed Gst.Caps describe exactly one format, that is, they have exactly
        one structure, and each field in the structure describes a fixed type.
        Examples of non-fixed types are GST_TYPE_INT_RANGE and GST_TYPE_LIST.
        """
    def is_strictly_equal(self, caps2: Caps) -> bool:
        """
        Checks if the given caps are exactly the same set of caps.
        """
    def is_subset(self, superset: Caps) -> bool:
        """
        Checks if all caps represented by `subset` are also represented by `superset`.
        """
    def is_subset_structure(self, structure: Structure) -> bool:
        """
            Checks if `structure` is a subset of `caps`. See `Gst.Caps.is_subset`
        for more information.
        """
    def is_subset_structure_full(self, structure: Structure, features: CapsFeatures | None = None) -> bool:
        """
            Checks if `structure` is a subset of `caps`. See `Gst.Caps.is_subset`
        for more information.
        """
    def map_in_place(self, func: CapsMapFunc, *user_data: object | None) -> bool:
        """
            Calls the provided function once for each structure and caps feature in the
        Gst.Caps. In contrast to `Gst.Caps.foreach`, the function may modify but not
        delete the structures and features. The caps must be mutable.
        """
    def merge(self, caps2: Caps) -> Caps:
        """
            Appends the structures contained in `caps2` to `caps1` if they are not yet
        expressed by `caps1`. The structures in `caps2` are not copied -- they are
        transferred to a writable copy of `caps1`, and then `caps2` is freed.
        If either caps is ANY, the resulting caps will be ANY.
        """
    def merge_structure(self, structure: Structure) -> Caps:
        """
        Appends `structure` to `caps` if it is not already expressed by `caps`.
        """
    def merge_structure_full(self, structure: Structure, features: CapsFeatures | None = None) -> Caps:
        """
        Appends `structure` with `features` to `caps` if its not already expressed by `caps`.
        """
    @classmethod
    def new_any(cls) -> Caps:
        """
            Creates a new Gst.Caps that indicates that it is compatible with
        any media format.
        """
    @classmethod
    def new_empty(cls) -> Caps:
        """
            Creates a new Gst.Caps that is empty.  That is, the returned
        Gst.Caps contains no media formats.
        The Gst.Caps is guaranteed to be writable.
        """
    @classmethod
    def new_empty_simple(cls, media_type: str) -> Caps:
        """
            Creates a new Gst.Caps that contains one Gst.Structure with name
        `media_type`.
        """
    @classmethod
    def new_id_str_empty_simple(cls, media_type: IdStr) -> Caps:
        """
            Creates a new Gst.Caps that contains one Gst.Structure with name
        `media_type`.
        """
    @classmethod
    def new_static_str_empty_simple(cls, media_type: str) -> Caps:
        """
            Creates a new Gst.Caps that contains one Gst.Structure with name
        `media_type`.

        `media_type` needs to be valid for the remaining lifetime of the process, e.g.
        has to be a static string.
        """
    def normalize(self) -> Caps:
        """
            Returns a Gst.Caps that represents the same set of formats as
        `caps`, but contains no lists.  Each list is expanded into separate
        Gst.Structure.

        This function takes ownership of `caps` and will call `Gst.Caps.make_writable`
        on it so you must not use `caps` afterwards unless you keep an additional
        reference to it with `Gst.Caps.ref`.
        """
    def remove_structure(self, idx: int) -> None:
        """
            Removes the structure with the given index from the list of structures
        contained in `caps`.
        """
    def serialize(self, flags: SerializeFlags) -> str:
        """
            Converts `caps` to a string representation.  This string representation can be
        converted back to a Gst.Caps by `Gst.Caps.from_string`.

        This prints the caps in human readable form.

        This version of the caps serialization function introduces support for nested
        structures and caps but the resulting strings won't be parsable with
        GStreamer prior to 1.20 unless GST_SERIALIZE_FLAG_BACKWARD_COMPAT is passed
        as `flag`.
        """
    def set_features(self, index: int, features: CapsFeatures | None = None) -> None:
        """
        Sets the `features` for the structure at `index`.
        """
    def set_features_simple(self, features: CapsFeatures | None = None) -> None:
        """
        Sets the `features` for all the structures of `caps`.
        """
    def set_value(self, field: str, value: GObject.Value) -> None:
        """
            Sets the given `field` on all structures of `caps` to the given `value`.
        This is a convenience function for calling `Gst.Structure.set_value` on
        all structures of `caps`.
        """
    def set_value_static_str(self, field: str, value: GObject.Value) -> None:
        """
            Sets the given `field` on all structures of `caps` to the given `value`.
        This is a convenience function for calling `Gst.Structure.set_value` on
        all structures of `caps`.

        `field` needs to be valid for the remaining lifetime of the process, e.g.
        has to be a static string.
        """
    def simplify(self) -> Caps:
        """
            Converts the given `caps` into a representation that represents the
        same set of formats, but in a simpler form.  Component structures that are
        identical are merged.  Component structures that have values that can be
        merged are also merged.

        This function takes ownership of `caps` and will call `Gst.Caps.make_writable`
        on it if necessary, so you must not use `caps` afterwards unless you keep an
        additional reference to it with `Gst.Caps.ref`.

        This method does not preserve the original order of `caps`.
        """
    def steal_structure(self, index: int) -> Structure | None:
        """
            Retrieves the structure with the given index from the list of structures
        contained in `caps`. The caller becomes the owner of the returned structure.
        """
    def subtract(self, subtrahend: Caps) -> Caps:
        """
            Subtracts the `subtrahend` from the `minuend`.
        > This function does not work reliably if optional properties for caps
        > are included on one caps and omitted on the other.
        """
    def to_string(self) -> str:
        """
            Converts `caps` to a string representation.  This string representation
        can be converted back to a Gst.Caps by `Gst.Caps.from_string`.

        For debugging purposes its easier to do something like this:

        ``` C
        GST_LOG ("caps are %" GST_PTR_FORMAT, caps);
        ```

        This prints the caps in human readable form.

        The implementation of serialization up to 1.20 would lead to unexpected results
        when there were nested Gst.Caps / Gst.Structure deeper than one level.
        """
    def truncate(self) -> Caps:
        """
            Discards all but the first structure from `caps`. Useful when
        fixating.

        This function takes ownership of `caps` and will call `Gst.Caps.make_writable`
        on it if necessary, so you must not use `caps` afterwards unless you keep an
        additional reference to it with `Gst.Caps.ref`.

        Note that it is not guaranteed that the returned caps have exactly one
        structure. If `caps` is any or empty caps then the returned caps will be
        the same and contain no structure at all.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class CapsFeatures(GObject.GBoxed):
    """
    Gst.CapsFeatures can optionally be set on a Gst.Caps to add requirements
    for additional features for a specific Gst.Structure. Caps structures with
    the same name but with a non-equal set of caps features are not compatible.
    If a pad supports multiple sets of features it has to add multiple equal
    structures with different feature sets to the caps.

    Empty Gst.CapsFeatures are equivalent with the Gst.CapsFeatures that only
    contain GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY. ANY Gst.CapsFeatures as
    created by `Gst.CapsFeatures.new_any` are equal to any other Gst.CapsFeatures
    and can be used to specify that any Gst.CapsFeatures would be supported, e.g.
    for elements that don't touch buffer memory. Gst.Caps with ANY Gst.CapsFeatures
    are considered non-fixed and during negotiation some Gst.CapsFeatures have
    to be selected.

    Examples for caps features would be the requirement of a specific Gst.Memory
    types or the requirement of having a specific Gst.Meta on the buffer. Features
    are given as a string of the format `memory:GstMemoryTypeName` or
    `meta:GstMetaAPIName`.
    """

    # gi Methods
    def add(self, feature: str) -> None:
        """
        Adds `feature` to `features`.
        """
    @deprecated("deprecated")
    def add_id(self, feature: int) -> None:
        """
        Adds `feature` to `features`.
        """
    def add_id_str(self, feature: IdStr) -> None:
        """
        Adds `feature` to `features`.
        """
    def add_static_str(self, feature: str) -> None:
        """
            Adds `feature` to `features`.

        `feature` needs to be valid for the remaining lifetime of the process, e.g. has
        to be a static string.
        """
    def contains(self, feature: str) -> bool:
        """
        Checks if `features` contains `feature`.
        """
    @deprecated("deprecated")
    def contains_id(self, feature: int) -> bool:
        """
        Checks if `features` contains `feature`.
        """
    def contains_id_str(self, feature: IdStr) -> bool:
        """
        Checks if `features` contains `feature`.
        """
    def copy(self) -> CapsFeatures:
        """
        Duplicates a Gst.CapsFeatures and all its values.
        """
    def free(self) -> None:
        """
            Frees a Gst.CapsFeatures and all its values. The caps features must not
        have a parent when this function is called.
        """
    @staticmethod
    def from_string(features: str) -> CapsFeatures | None:
        """
        Creates a Gst.CapsFeatures from a string representation.
        """
    def get_nth(self, i: int) -> str | None:
        """
        Returns the `i`-th feature of `features`.
        """
    @deprecated("deprecated")
    def get_nth_id(self, i: int) -> int:
        """
        Returns the `i`-th feature of `features`.
        """
    def get_nth_id_str(self, i: int) -> IdStr:
        """
        Returns the `i`-th feature of `features`.
        """
    def get_size(self) -> int:
        """
        Returns the number of features in `features`.
        """
    def is_any(self) -> bool:
        """
        Checks if `features` is Gst.CAPS_FEATURES_ANY.
        """
    def is_equal(self, features2: CapsFeatures) -> bool:
        """
        Checks if `features1` and `features2` are equal.
        """
    def remove(self, feature: str) -> None:
        """
        Removes `feature` from `features`.
        """
    @deprecated("deprecated")
    def remove_id(self, feature: int) -> None:
        """
        Removes `feature` from `features`.
        """
    def remove_id_str(self, feature: IdStr) -> None:
        """
        Removes `feature` from `features`.
        """
    def set_parent_refcount(self, refcount: int) -> bool:
        """
            Sets the parent_refcount field of Gst.CapsFeatures. This field is used to
        determine whether a caps features is mutable or not. This function should only be
        called by code implementing parent objects of Gst.CapsFeatures, as described in
        [the MT refcounting design document](additional/design/MT-refcounting.md).
        """
    def to_string(self) -> str:
        """
            Converts `features` to a human-readable string representation.

        For debugging purposes its easier to do something like this:

        ``` C
        GST_LOG ("features is %" GST_PTR_FORMAT, features);
        ```

        This prints the features in human readable form.
        """

    # python methods (overrides?)
    @classmethod
    def new_any(
        cls,
    ) -> CapsFeatures:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_any() -> Gst.CapsFeatures
        """
    @classmethod
    def new_empty(
        cls,
    ) -> CapsFeatures:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_empty() -> Gst.CapsFeatures
        """
    @classmethod
    def new_single(
        cls,
        feature: str,
    ) -> CapsFeatures:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_single(feature:str) -> Gst.CapsFeatures
        """
    @classmethod
    def new_single_static_str(
        cls,
        feature: str,
    ) -> CapsFeatures:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_single_static_str(feature:str) -> Gst.CapsFeatures
        """

class ChildProxy(builtins.object):
    """
    This interface abstracts handling of property sets for elements with
    children. Imagine elements such as mixers or polyphonic generators. They all
    have multiple Gst.Pad or some kind of voice objects. Another use case are
    container elements like Gst.Bin.
    The element implementing the interface acts as a parent for those child
    objects.

    By implementing this interface the child properties can be accessed from the
    parent element by using `Gst.ChildProxy.get` and `Gst.ChildProxy.set`.

    Property names are written as `child-name::property-name`. The whole naming
    scheme is recursive. Thus `child1::child2::property` is valid too, if
    `child1` and `child2` implement the Gst.ChildProxy interface.
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize ChildProxy object with properties.
        """
    def child_added(self, child: GObject.Object, name: str) -> None:
        """
        Emits the Gst.ChildProxy::child-added signal.
        """
    def child_removed(self, child: GObject.Object, name: str) -> None:
        """
        Emits the Gst.ChildProxy::child-removed signal.
        """
    def get_child_by_index(self, index: int) -> GObject.Object | None:
        """
        Fetches a child by its number.
        """
    def get_child_by_name(self, name: str) -> GObject.Object | None:
        """
            Looks up a child element by the given name.

        This virtual method has a default implementation that uses Gst.Object
        together with `Gst.Object.get_name`. If the interface is to be used with
        GObjects, this methods needs to be overridden.
        """
    def get_child_by_name_recurse(self, name: str) -> GObject.Object | None:
        """
            Looks up a child element by the given full-path name.

        Similar to `Gst.ChildProxy.get_child_by_name`, this method
        searches and returns a child given a name. The difference is that
        this method allows a hierarchical path in the form of
        child1::child2::child3. In the later example this method would
        return a reference to child3, if found. The name should be made of
        element names only and should not contain any property names.
        """
    def get_children_count(self) -> int:
        """
        Gets the number of child objects this parent contains.
        """
    def get_property(self, name: str) -> GObject.Value:
        """
            Gets a single property using the GstChildProxy mechanism.
        You are responsible for freeing it by calling `g_value_unset`
        """
    def lookup(self, name: str) -> tuple[bool, GObject.Object, GObject.ParamSpec]:
        """
        Looks up which object and GParamSpec would be effected by the given `name`.
        """
    def set_property(self, name: str, value: GObject.Value) -> None:
        """
        Sets a single property using the GstChildProxy mechanism.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["child-added"],
        handler: typing.Callable[[typing_extensions.Self, GObject.Object, str], None],
        *args: typing.Any,
    ) -> int:
        """
        Will be emitted after the `object` was added to the `child_proxy`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["child-removed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.Object, str], None],
        *args: typing.Any,
    ) -> int:
        """
        Will be emitted after the `object` was removed from the `child_proxy`.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ChildProxyInterface(GObject.GPointer):
    """
    Gst.ChildProxy interface.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def child_added(self) -> child_addedChildProxyInterfaceCB:
        """
        Called when `child` is added to `parent`
        """
    @builtins.property
    def child_removed(self) -> child_removedChildProxyInterfaceCB:
        """
        Called when `child` is removed from `parent`
        """
    @builtins.property
    def get_child_by_index(self) -> get_child_by_indexChildProxyInterfaceCB | None:
        """
        Fetch a child object by index
        """
    @builtins.property
    def get_child_by_name(self) -> get_child_by_nameChildProxyInterfaceCB | None:
        """
        Fetch a child object by name
        """
    @builtins.property
    def get_children_count(self) -> get_children_countChildProxyInterfaceCB:
        """
        Get the number of children in `parent`
        """
    @builtins.property
    def parent(self) -> GObject.TypeInterface | None:
        """
        parent interface type.
        """

class Clock(Object):
    """
    GStreamer uses a global clock to synchronize the plugins in a pipeline.
    Different clock implementations are possible by implementing this abstract
    base class or, more conveniently, by subclassing Gst.SystemClock.

    The Gst.Clock returns a monotonically increasing time with the method
    `Gst.Clock.get_time`. Its accuracy and base time depend on the specific
    clock implementation but time is always expressed in nanoseconds. Since the
    baseline of the clock is undefined, the clock time returned is not
    meaningful in itself, what matters are the deltas between two clock times.
    The time returned by a clock is called the absolute time.

    The pipeline uses the clock to calculate the running time. Usually all
    renderers synchronize to the global clock using the buffer timestamps, the
    GST_EVENT_SEGMENT events and the element's base time, see Gst.Pipeline.

    A clock implementation can support periodic and single shot clock
    notifications both synchronous and asynchronous.

    One first needs to create a Gst.ClockID for the periodic or single shot
    notification using `Gst.Clock.new_single_shot_id` or
    `Gst.Clock.new_periodic_id`.

    To perform a blocking wait for the specific time of the Gst.ClockID use
    `Gst.Clock.id_wait`. To receive a callback when the specific time is reached
    in the clock use `Gst.Clock.id_wait_async`. Both these calls can be
    interrupted with the `Gst.Clock.id_unschedule` call. If the blocking wait is
    unscheduled a return value of GST_CLOCK_UNSCHEDULED is returned.

    Periodic callbacks scheduled async will be repeatedly called automatically
    until they are unscheduled. To schedule a sync periodic callback,
    `Gst.Clock.id_wait` should be called repeatedly.

    The async callbacks can happen from any thread, either provided by the core
    or from a streaming thread. The application should be prepared for this.

    A Gst.ClockID that has been unscheduled cannot be used again for any wait
    operation, a new Gst.ClockID should be created and the old unscheduled one
    should be destroyed with `Gst.Clock.id_unref`.

    It is possible to perform a blocking wait on the same Gst.ClockID from
    multiple threads. However, registering the same Gst.ClockID for multiple
    async notifications is not possible, the callback will only be called for
    the thread registering the entry last.

    None of the wait operations unref the Gst.ClockID, the owner is responsible
    for unreffing the ids itself. This holds for both periodic and single shot
    notifications. The reason being that the owner of the Gst.ClockID has to
    keep a handle to the Gst.ClockID to unblock the wait on FLUSHING events or
    state changes and if the entry would be unreffed automatically, the handle
    might become invalid without any notification.

    These clock operations do not operate on the running time, so the callbacks
    will also occur when not in PLAYING state as if the clock just keeps on
    running. Some clocks however do not progress when the element that provided
    the clock is not PLAYING.

    When a clock has the GST_CLOCK_FLAG_CAN_SET_MASTER flag set, it can be
    slaved to another Gst.Clock with `Gst.Clock.set_master`. The clock will
    then automatically be synchronized to this master clock by repeatedly
    sampling the master clock and the slave clock and recalibrating the slave
    clock with `Gst.Clock.set_calibration`. This feature is mostly useful for
    plugins that have an internal clock but must operate with another clock
    selected by the Gst.Pipeline.  They can track the offset and rate difference
    of their internal clock relative to the master clock by using the
    `Gst.Clock.get_calibration` function.

    The master/slave synchronisation can be tuned with the Gst.Clock:timeout,
    Gst.Clock:window-size and Gst.Clock:window-threshold properties.
    The Gst.Clock:timeout property defines the interval to sample the master
    clock and run the calibration functions. Gst.Clock:window-size defines the
    number of samples to use when calibrating and Gst.Clock:window-threshold
    defines the minimum number of samples before the calibration is performed.
    """

    class Props(Object.Props):
        timeout: int
        window_size: int  # [window-size]: changed because contained invalid characters
        window_threshold: int  # [window-threshold]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def object(self) -> Object | None:
        """
        the parent structure
        """
    @builtins.property
    def priv(self) -> ClockPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        name: str | None = None,
        parent: Object | None = None,
        timeout: int | None = None,
        window_size: int | None = None,
        window_threshold: int | None = None,
    ) -> None:
        """
        Initialize Clock object with properties.
        """
    def add_observation(self, observation_internal: int, observation_external: int) -> tuple[bool, float]:
        """
            The time `observation_external` of the external or master clock and the time
        `observation_internal` of the internal or slave clock are added to the list of
        observations. If enough observations are available, a linear regression
        algorithm is run on the observations and `clock` is recalibrated.

        If this functions returns True, `r_squared` will contain the
        correlation coefficient of the interpolation. A value of 1.0
        means a perfect regression was performed. This value can
        be used to control the sampling frequency of the master and slave
        clocks.
        """
    def add_observation_unapplied(
        self, observation_internal: int, observation_external: int
    ) -> tuple[bool, float, int, int, int, int]:
        """
            Add a clock observation to the internal slaving algorithm the same as
        `Gst.Clock.add_observation`, and return the result of the external or master
        clock estimation, without updating the internal calibration.

        The caller can then take the results and call `Gst.Clock.set_calibration`
        with the values, or some modified version of them.
        """
    def adjust_unlocked(self, internal: int) -> int:
        """
            Converts the given `internal` clock time to the external time, adjusting for the
        rate and reference time set with `Gst.Clock.set_calibration` and making sure
        that the returned time is increasing. This function should be called with the
        clock's OBJECT_LOCK held and is mainly used by clock subclasses.

        This function is the reverse of `Gst.Clock.unadjust_unlocked`.
        """
    def adjust_with_calibration(
        self, internal_target: int, cinternal: int, cexternal: int, cnum: int, cdenom: int
    ) -> int:
        """
            Converts the given `internal_target` clock time to the external time,
        using the passed calibration parameters. This function performs the
        same calculation as `Gst.Clock.adjust_unlocked` when called using the
        current calibration parameters, but doesn't ensure a monotonically
        increasing result as `Gst.Clock.adjust_unlocked` does.

        Note: The `clock` parameter is unused and can be None
        """
    def get_calibration(self) -> tuple[int, int, int, int]:
        """
            Gets the internal rate and reference time of `clock`. See
        `Gst.Clock.set_calibration` for more information.

        `internal`, `external`, `rate_num`, and `rate_denom` can be left None if the
        caller is not interested in the values.
        """
    def get_internal_time(self) -> int:
        """
            Gets the current internal time of the given clock. The time is returned
        unadjusted for the offset and the rate.
        """
    def get_master(self) -> Clock | None:
        """
            Gets the master clock that `clock` is slaved to or None when the clock is
        not slaved to any master clock.
        """
    def get_resolution(self) -> int:
        """
            Gets the accuracy of the clock. The accuracy of the clock is the granularity
        of the values returned by `Gst.Clock.get_time`.
        """
    def get_time(self) -> int:
        """
            Gets the current time of the given clock. The time is always
        monotonically increasing and adjusted according to the current
        offset and rate.
        """
    @builtins.property
    def get_timeout(self) -> int:
        """
        Gets the amount of time that master and slave clocks are sampled.
        """
    @staticmethod
    def id_compare_func(id1: object | None = None, id2: object | None = None) -> int:
        """
            Compares the two Gst.ClockID instances. This function can be used
        as a GCompareFunc when sorting ids.
        """
    @staticmethod
    def id_get_clock(id: object) -> Clock | None:
        """
        This function returns the underlying clock.
        """
    @staticmethod
    def id_get_time(id: object) -> int:
        """
        Gets the time of the clock ID
        """
    @staticmethod
    def id_ref(id: object) -> object:
        """
        Increases the refcount of given `id`.
        """
    @staticmethod
    def id_unref(id: object) -> None:
        """
            Unrefs given `id`. When the refcount reaches 0 the
        Gst.ClockID will be freed.
        """
    @staticmethod
    def id_unschedule(id: object) -> None:
        """
            Cancels an outstanding request with `id`. This can either
        be an outstanding async notification or a pending sync notification.
        After this call, `id` cannot be used anymore to receive sync or
        async notifications, you need to create a new Gst.ClockID.
        """
    @staticmethod
    def id_uses_clock(id: object, clock: Clock) -> bool:
        """
            This function returns whether `id` uses `clock` as the underlying clock.
        `clock` can be None, in which case the return value indicates whether
        the underlying clock has been freed.  If this is the case, the `id` is
        no longer usable and should be freed.
        """
    @staticmethod
    def id_wait(id: object) -> tuple[ClockReturn, int]:
        """
            Performs a blocking wait on `id`.
        `id` should have been created with `Gst.Clock.new_single_shot_id`
        or `Gst.Clock.new_periodic_id` and should not have been unscheduled
        with a call to `Gst.Clock.id_unschedule`.

        If the `jitter` argument is not None and this function returns GST_CLOCK_OK
        or GST_CLOCK_EARLY, it will contain the difference
        against the clock and the time of `id` when this method was
        called.
        Positive values indicate how late `id` was relative to the clock
        (in which case this function will return GST_CLOCK_EARLY).
        Negative values indicate how much time was spent waiting on the clock
        before this function returned.
        """
    @staticmethod
    def id_wait_async(id: object, func: ClockCallback, *user_data: object | None) -> ClockReturn:
        """
            Registers a callback on the given Gst.ClockID `id` with the given
        function and user_data. When passing a Gst.ClockID with an invalid
        time to this function, the callback will be called immediately
        with  a time set to Gst.CLOCK_TIME_NONE. The callback will
        be called when the time of `id` has been reached.

        The callback `func` can be invoked from any thread, either provided by the
        core or from a streaming thread. The application should be prepared for this.
        """
    def is_synced(self) -> bool:
        """
            Checks if the clock is currently synced, by looking at whether
        Gst.CLOCK_FLAG_NEEDS_STARTUP_SYNC is set.
        """
    def new_periodic_id(self, start_time: int, interval: int) -> object:
        """
            Gets an ID from `clock` to trigger a periodic notification.
        The periodic notifications will start at time `start_time` and
        will then be fired with the given `interval`.
        """
    def new_single_shot_id(self, time: int) -> object:
        """
            Gets a Gst.ClockID from `clock` to trigger a single shot
        notification at the requested time.
        """
    def periodic_id_reinit(self, id: object, start_time: int, interval: int) -> bool:
        """
            Reinitializes the provided periodic `id` to the provided start time and
        interval. Does not modify the reference count.
        """
    def set_calibration(self, internal: int, external: int, rate_num: int, rate_denom: int) -> None:
        """
            Adjusts the rate and time of `clock`. A rate of 1/1 is the normal speed of
        the clock. Values bigger than 1/1 make the clock go faster.

        `internal` and `external` are calibration parameters that arrange that
        `Gst.Clock.get_time` should have been `external` at internal time `internal`.
        This internal time should not be in the future; that is, it should be less
        than the value of `Gst.Clock.get_internal_time` when this function is called.

        Subsequent calls to `Gst.Clock.get_time` will return clock times computed as
        follows:

        ``` C
          time = (internal_time - internal) * rate_num / rate_denom + external
        ```

        This formula is implemented in `Gst.Clock.adjust_unlocked`. Of course, it
        tries to do the integer arithmetic as precisely as possible.

        Note that `Gst.Clock.get_time` always returns increasing values so when you
        move the clock backwards, `Gst.Clock.get_time` will report the previous value
        until the clock catches up.
        """
    def set_master(self, master: Clock | None = None) -> bool:
        """
            Sets `master` as the master clock for `clock`. `clock` will be automatically
        calibrated so that `Gst.Clock.get_time` reports the same time as the
        master clock.

        A clock provider that slaves its clock to a master can get the current
        calibration values with `Gst.Clock.get_calibration`.

        `master` can be None in which case `clock` will not be slaved anymore. It will
        however keep reporting its time adjusted with the last configured rate
        and time offsets.
        """
    def set_resolution(self, resolution: int) -> int:
        """
            Sets the accuracy of the clock. Some clocks have the possibility to operate
        with different accuracy at the expense of more resource usage. There is
        normally no need to change the default resolution of a clock. The resolution
        of a clock can only be changed if the clock has the
        GST_CLOCK_FLAG_CAN_SET_RESOLUTION flag set.
        """
    def set_synced(self, synced: bool) -> None:
        """
            Sets `clock` to synced and emits the Gst.Clock::synced signal, and wakes up any
        thread waiting in `Gst.Clock.wait_for_sync`.

        This function must only be called if Gst.CLOCK_FLAG_NEEDS_STARTUP_SYNC
        is set on the clock, and is intended to be called by subclasses only.
        """
    def set_timeout(self, timeout: int) -> None:
        """
            Sets the amount of time, in nanoseconds, to sample master and slave
        clocks
        """
    def single_shot_id_reinit(self, id: object, time: int) -> bool:
        """
            Reinitializes the provided single shot `id` to the provided time. Does not
        modify the reference count.
        """
    def unadjust_unlocked(self, external: int) -> int:
        """
            Converts the given `external` clock time to the internal time of `clock`,
        using the rate and reference time set with `Gst.Clock.set_calibration`.
        This function should be called with the clock's OBJECT_LOCK held and
        is mainly used by clock subclasses.

        This function is the reverse of `Gst.Clock.adjust_unlocked`.
        """
    def unadjust_with_calibration(
        self, external_target: int, cinternal: int, cexternal: int, cnum: int, cdenom: int
    ) -> int:
        """
            Converts the given `external_target` clock time to the internal time,
        using the passed calibration parameters. This function performs the
        same calculation as `Gst.Clock.unadjust_unlocked` when called using the
        current calibration parameters.

        Note: The `clock` parameter is unused and can be None
        """
    def wait_for_sync(self, timeout: int) -> bool:
        """
            Waits until `clock` is synced for reporting the current time. If `timeout`
        is Gst.CLOCK_TIME_NONE it will wait forever, otherwise it will time out
        after `timeout` nanoseconds.

        For asynchronous waiting, the Gst.Clock::synced signal can be used.

        This returns immediately with True if Gst.CLOCK_FLAG_NEEDS_STARTUP_SYNC
        is not set on the clock, or if the clock is already synced.
        """

    # python methods (overrides?)
    def do_change_resolution(
        self,
        old_resolution: int,
        new_resolution: int,
    ) -> int:
        """
        change_resolution(self, old_resolution:int, new_resolution:int) -> int
        """
    def do_get_internal_time(
        self,
    ) -> int:
        """
        get_internal_time(self) -> int
        """
    def do_get_resolution(
        self,
    ) -> int:
        """
        get_resolution(self) -> int
        """
    def do_unschedule(
        self,
        entry: ClockEntry,
    ) -> None:
        """
        unschedule(self, entry:Gst.ClockEntry)
        """
    def do_wait(
        self,
        entry: ClockEntry,
    ) -> tuple:
        """
        wait(self, entry:Gst.ClockEntry) -> Gst.ClockReturn, jitter:int
        """
    def do_wait_async(
        self,
        entry: ClockEntry,
    ) -> ClockReturn:
        """
        wait_async(self, entry:Gst.ClockEntry) -> Gst.ClockReturn
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["synced"],
        handler: typing.Callable[[typing_extensions.Self, bool], None],
        *args: typing.Any,
    ) -> int:
        """
            Signaled on clocks with Gst.CLOCK_FLAG_NEEDS_STARTUP_SYNC set once
        the clock is synchronized, or when it completely lost synchronization.
        This signal will not be emitted on clocks without the flag.

        This signal will be emitted from an arbitrary thread, most likely not
        the application's main thread.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::window_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::window_threshold"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ClockClass(GObject.GPointer):
    """
    GStreamer clock class. Override the vmethods to implement the clock
    functionality.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def change_resolution(self) -> change_resolutionClockClassCB: ...
    @builtins.property
    def get_internal_time(self) -> get_internal_timeClockClassCB: ...
    @builtins.property
    def get_resolution(self) -> get_resolutionClockClassCB: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        the parent class structure
        """
    @builtins.property
    def unschedule(self) -> unscheduleClockClassCB: ...
    @builtins.property
    def wait(self) -> waitClockClassCB: ...
    @builtins.property
    def wait_async(self) -> wait_asyncClockClassCB: ...

class ClockEntry(GObject.GPointer):
    """
    All pending timeouts or periodic notifies are converted into
    an entry.
    Note that GstClockEntry should be treated as an opaque structure. It must
    not be extended or allocated using a custom allocator.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def clock(self) -> Clock | None: ...
    @builtins.property
    def destroy_data(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def func(self) -> ClockCallbackClockEntryCB: ...
    @builtins.property
    def interval(self) -> int: ...
    refcount: int = ...
    """
    reference counter (read-only)
    """
    @builtins.property
    def status(self) -> ClockReturn: ...
    @builtins.property
    def time(self) -> int: ...
    @builtins.property
    def type(self) -> ClockEntryType: ...
    @builtins.property
    def unscheduled(self) -> bool: ...
    @builtins.property
    def user_data(self) -> object | None: ...
    @builtins.property
    def woken_up(self) -> bool: ...

class ClockPrivate(GObject.GPointer): ...

class Context(GObject.GBoxed):
    """
    Gst.Context is a container object used to store contexts like a device
    context, a display server connection and similar concepts that should
    be shared between multiple elements.

    Applications can set a context on a complete pipeline by using
    `Gst.Element.set_context`, which will then be propagated to all
    child elements. Elements can handle these in Gst.ElementClass::set_context
    and merge them with the context information they already have.

    When an element needs a context it will do the following actions in this
    order until one step succeeds:

    1. Check if the element already has a context
    2. Query downstream with Gst.QUERY_CONTEXT for the context
    3. Query upstream with Gst.QUERY_CONTEXT for the context
    4. Post a Gst.MESSAGE_NEED_CONTEXT message on the bus with the required
       context types and afterwards check if a usable context was set now
    5. Create a context by itself and post a Gst.MESSAGE_HAVE_CONTEXT message
       on the bus.

    Bins will catch Gst.MESSAGE_NEED_CONTEXT messages and will set any previously
    known context on the element that asks for it if possible. Otherwise the
    application should provide one if it can.

    Gst.Context can be persistent.
    A persistent Gst.Context is kept in elements when they reach
    Gst.STATE_NULL, non-persistent ones will be removed.
    Also, a non-persistent context won't override a previous persistent
    context set to an element.
    """

    # gi Methods
    def get_context_type(self) -> str:
        """
        Gets the type of `context`.
        """
    def get_structure(self) -> Structure:
        """
        Accesses the structure of the context.
        """
    def has_context_type(self, context_type: str) -> bool:
        """
        Checks if `context` has `context_type`.
        """
    def is_persistent(self) -> bool:
        """
        Checks if `context` is persistent.
        """
    def writable_structure(self) -> Structure:
        """
        Gets a writable version of the structure.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        context_type: str,
        persistent: bool,
    ) -> Context:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(context_type:str, persistent:bool) -> Gst.Context
        """

class ControlBinding(Object):
    """
    A base class for value mapping objects that attaches control sources to GObject
    properties. Such an object is taking one or more Gst.ControlSource instances,
    combines them and maps the resulting value to the type and value range of the
    bound property.
    """

    class Props(Object.Props):
        name: str
        object: Object | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def disabled(self) -> bool: ...
    @builtins.property
    def name(self) -> str:
        """
        name of the property of this binding
        """
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def parent(self) -> Object | None:
        """
        the parent structure
        """
    @builtins.property
    def pspec(self) -> GObject.ParamSpec | None:
        """
        GParamSpec for this property
        """

    # gi Methods
    def __init__(self, name: str | None = None, object: Object | None = None, parent: Object | None = None) -> None:
        """
        Initialize ControlBinding object with properties.
        """
    def get_g_value_array(self, timestamp: int, interval: int, n_values: int, values: list) -> bool:
        """
            Gets a number of GValues for the given controlled property starting at the
        requested time. The array `values` need to hold enough space for `n_values` of
        GValue.

        This function is useful if one wants to e.g. draw a graph of the control
        curve or apply a control curve sample by sample.
        """
    def get_value(self, timestamp: int) -> GObject.Value | None:
        """
        Gets the value for the given controlled property at the requested time.
        """
    def is_disabled(self) -> bool:
        """
        Checks if the control binding is disabled.
        """
    def set_disabled(self, disabled: bool) -> None:
        """
            This function is used to disable a control binding for some time, i.e.
        `Gst.Object.sync_values` will do nothing.
        """
    def sync_values(self, object: Object, timestamp: int, last_sync: int) -> bool:
        """
            Sets the property of the `object`, according to the Gst.ControlSources that
        handles it and for the given timestamp.

        If this function fails, it is most likely the application developers fault.
        Most probably the control sources are not setup correctly.
        """

    # python methods (overrides?)
    def do_get_g_value_array(
        self,
        timestamp: int,
        interval: int,
        values: list,
    ) -> bool:
        """
        get_g_value_array(self, timestamp:int, interval:int, values:list) -> bool
        """
    def do_get_value(
        self,
        timestamp: int,
    ) -> GObject.Value | None:
        """
        get_value(self, timestamp:int) -> GObject.Value or None
        """
    def do_sync_values(
        self,
        object: Object,
        timestamp: int,
        last_sync: int,
    ) -> bool:
        """
        sync_values(self, object:Gst.Object, timestamp:int, last_sync:int) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::object"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ControlBindingClass(GObject.GPointer):
    """
    The class structure of Gst.ControlBinding.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def get_g_value_array(self) -> get_g_value_arrayControlBindingClassCB: ...
    @builtins.property
    def get_value(self) -> get_valueControlBindingClassCB | None: ...
    @builtins.property
    def get_value_array(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        Parent class
        """
    @builtins.property
    def sync_values(self) -> sync_valuesControlBindingClassCB: ...

class ControlBindingPrivate(GObject.GPointer): ...

class ControlSource(Object):
    """
    The Gst.ControlSource is a base class for control value sources that could
    be used to get timestamp-value pairs. A control source essentially is a
    function over time.

    A Gst.ControlSource is used by first getting an instance of a specific
    control-source, creating a binding for the control-source to the target property
    of the element and then adding the binding to the element. The binding will
    convert the data types and value range to fit to the bound property.

    For implementing a new Gst.ControlSource one has to implement
    Gst.ControlSourceGetValue and Gst.ControlSourceGetValueArray functions.
    These are then used by `Gst.ControlSource.get_value` and
    `Gst.ControlSource.get_value_array` to get values for specific timestamps.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def get_value(self) -> ControlSourceGetValueControlSourceCB:
        """
        Function for returning a value for a given timestamp
        """
    @builtins.property
    def get_value_array(self) -> ControlSourceGetValueArrayControlSourceCB:
        """
        Function for returning a values array for a given timestamp
        """
    @builtins.property
    def parent(self) -> Object | None:
        """
        the parent structure
        """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize ControlSource object with properties.
        """
    def control_source_get_value(self, timestamp: int) -> tuple[bool, float]:
        """
        Gets the value for this Gst.ControlSource at a given timestamp.
        """
    def control_source_get_value_array(self, timestamp: int, interval: int, n_values: int, values: list) -> bool:
        """
            Gets an array of values for for this Gst.ControlSource. Values that are
        undefined contain NANs.
        """

class ControlSourceClass(GObject.GPointer):
    """
    The class structure of Gst.ControlSource.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        Parent class
        """

class CustomMeta(GObject.GPointer):
    """
    Extra custom metadata. The `structure` field is the same as returned by
    `Gst.CustomMeta.get_structure`.

    Since 1.24 it can be serialized using `Gst.Meta.serialize` and
    `Gst.Meta.deserialize`, but only if the Gst.Structure does not contain any
    fields that cannot be serialized, see Gst.SERIALIZE_FLAG_STRICT.
    """

    # gi Fields
    meta: Meta | None = ...
    """
    parent Gst.Meta
    """
    structure: Structure | None = ...
    """
    Gst.Structure containing custom metadata.
    """

    # gi Methods
    def get_structure(self) -> Structure:
        """
            Retrieve the Gst.Structure backing a custom meta, the structure's mutability
        is conditioned to the writability of the Gst.Buffer `meta` is attached to.
        """
    def has_name(self, name: str) -> bool:
        """
        Checks whether the name of the custom meta is `name`
        """

class DateTime(GObject.GBoxed):
    """
    Struct to store date, time and timezone information altogether.
    Gst.DateTime is refcounted and immutable.

    Date information is handled using the [proleptic Gregorian calendar].

    Provides basic creation functions and accessor functions to its fields.

    [proleptic Gregorian calendar]: https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar
    """

    # gi Methods
    def get_day(self) -> int:
        """
        Returns the day of the month of this Gst.DateTime.
        """
    def get_hour(self) -> int:
        """
            Retrieves the hour of the day represented by `datetime` in the gregorian
        calendar. The return is in the range of 0 to 23.
        """
    def get_microsecond(self) -> int:
        """
            Retrieves the fractional part of the seconds in microseconds represented by
        `datetime` in the gregorian calendar.
        """
    def get_minute(self) -> int:
        """
            Retrieves the minute of the hour represented by `datetime` in the gregorian
        calendar.
        """
    def get_month(self) -> int:
        """
        Returns the month of this Gst.DateTime. January is 1, February is 2, etc..
        """
    def get_second(self) -> int:
        """
            Retrieves the second of the minute represented by `datetime` in the gregorian
        calendar.
        """
    def get_time_zone_offset(self) -> float:
        """
            Retrieves the offset from UTC in hours that the timezone specified
        by `datetime` represents. Timezones ahead (to the east) of UTC have positive
        values, timezones before (to the west) of UTC have negative values.
        If `datetime` represents UTC time, then the offset is zero.
        """
    def get_year(self) -> int:
        """
            Returns the year of this Gst.DateTime.
        Call `Gst.DateTime.has_year` before, to avoid warnings.
        """
    def has_day(self) -> bool: ...
    def has_month(self) -> bool: ...
    def has_second(self) -> bool: ...
    def has_time(self) -> bool: ...
    def has_year(self) -> bool: ...
    def ref(self) -> DateTime:
        """
        Atomically increments the reference count of `datetime` by one.
        """
    def to_g_date_time(self) -> GLib.DateTime | None:
        """
        Creates a new GDateTime from a fully defined Gst.DateTime object.
        """
    def to_iso8601_string(self) -> str | None:
        """
            Create a minimal string compatible with ISO-8601. Possible output formats
        are (for example): `2012`, `2012-06`, `2012-06-23`, `2012-06-23T23:30Z`,
        `2012-06-23T23:30+0100`, `2012-06-23T23:30:59Z`, `2012-06-23T23:30:59+0100`
        """
    def unref(self) -> None:
        """
            Atomically decrements the reference count of `datetime` by one.  When the
        reference count reaches zero, the structure is freed.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        tzoffset: float,
        year: int,
        month: int,
        day: int,
        hour: int,
        minute: int,
        seconds: float,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(tzoffset:float, year:int, month:int, day:int, hour:int, minute:int, seconds:float) -> Gst.DateTime or None
        """
    @classmethod
    def new_from_g_date_time(
        cls,
        dt: GLib.DateTime | None = None,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_g_date_time(dt:GLib.DateTime=None) -> Gst.DateTime or None
        """
    @classmethod
    def new_from_iso8601_string(
        cls,
        string: str,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_iso8601_string(string:str) -> Gst.DateTime or None
        """
    @classmethod
    def new_from_unix_epoch_local_time(
        cls,
        secs: int,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_unix_epoch_local_time(secs:int) -> Gst.DateTime or None
        """
    @classmethod
    def new_from_unix_epoch_local_time_usecs(
        cls,
        usecs: int,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_unix_epoch_local_time_usecs(usecs:int) -> Gst.DateTime or None
        """
    @classmethod
    def new_from_unix_epoch_utc(
        cls,
        secs: int,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_unix_epoch_utc(secs:int) -> Gst.DateTime or None
        """
    @classmethod
    def new_from_unix_epoch_utc_usecs(
        cls,
        usecs: int,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_unix_epoch_utc_usecs(usecs:int) -> Gst.DateTime or None
        """
    @classmethod
    def new_local_time(
        cls,
        year: int,
        month: int,
        day: int,
        hour: int,
        minute: int,
        seconds: float,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_local_time(year:int, month:int, day:int, hour:int, minute:int, seconds:float) -> Gst.DateTime or None
        """
    @classmethod
    def new_now_local_time(
        cls,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_now_local_time() -> Gst.DateTime or None
        """
    @classmethod
    def new_now_utc(
        cls,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_now_utc() -> Gst.DateTime or None
        """
    @classmethod
    def new_y(
        cls,
        year: int,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_y(year:int) -> Gst.DateTime or None
        """
    @classmethod
    def new_ym(
        cls,
        year: int,
        month: int,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_ym(year:int, month:int) -> Gst.DateTime or None
        """
    @classmethod
    def new_ymd(
        cls,
        year: int,
        month: int,
        day: int,
    ) -> DateTime | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_ymd(year:int, month:int, day:int) -> Gst.DateTime or None
        """

class DebugCategory(GObject.GPointer):
    """
    This is the struct that describes the categories. Once initialized with
    GST_DEBUG_CATEGORY_INIT, its values can't be changed anymore.
    """

    # gi Fields
    @builtins.property
    def color(self) -> int: ...
    @builtins.property
    def description(self) -> str: ...
    @builtins.property
    def name(self) -> str: ...
    @builtins.property
    def threshold(self) -> int: ...

    # gi Methods
    @deprecated("deprecated")
    def free(self) -> None:
        """
        Removes and frees the category and all associated resources.
        """
    def get_color(self) -> int:
        """
            Returns the color of a debug category used when printing output in this
        category.
        """
    def get_description(self) -> str:
        """
        Returns the description of a debug category.
        """
    def get_name(self) -> str:
        """
        Returns the name of a debug category.
        """
    def get_threshold(self) -> DebugLevel:
        """
        Returns the threshold of a Gst.DebugCategory.
        """
    def reset_threshold(self) -> None:
        """
            Resets the threshold of the category to the default level. Debug information
        will only be output if the threshold is lower or equal to the level of the
        debugging message.
        Use this function to set the threshold back to where it was after using
        `Gst.DebugCategory.set_threshold`.
        """
    def set_threshold(self, level: DebugLevel) -> None:
        """
            Sets the threshold of the category to the given level. Debug information will
        only be output if the threshold is lower or equal to the level of the
        debugging message.
        > Do not use this function in production code, because other functions may
        > change the threshold of categories as side effect. It is however a nice
        > function to use when debugging (even from gdb).
        """

class DebugMessage(GObject.GPointer):
    # gi Methods
    def get(self) -> str | None:
        """
            Gets the string representation of a Gst.DebugMessage. This function is used
        in debug handlers to extract the message.
        """
    def get_id(self) -> str | None:
        """
            Get the id of the object that emitted this message. This function is used in
        debug handlers. Can be empty.
        """

class Device(Object):
    """
    Gst.Device are objects representing a device, they contain
    relevant metadata about the device, such as its class and the Gst.Caps
    representing the media types it can produce or handle.

    Gst.Device are created by Gst.DeviceProvider objects which can be
    aggregated by Gst.DeviceMonitor objects.
    """

    class Props(Object.Props):
        caps: Caps | None
        device_class: str  # [device-class]: changed because contained invalid characters
        display_name: str  # [display-name]: changed because contained invalid characters
        properties: Structure | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent(self) -> Object | None:
        """
        The parent Gst.Object structure.
        """
    @builtins.property
    def priv(self) -> DevicePrivate | None: ...

    # gi Methods
    def __init__(
        self,
        caps: Caps | None = None,
        device_class: str | None = None,
        display_name: str | None = None,
        name: str | None = None,
        parent: Object | None = None,
        properties: Structure | None = None,
    ) -> None:
        """
        Initialize Device object with properties.
        """
    def create_element(self, name: str | None = None) -> Element | None:
        """
            Creates the element with all of the required parameters set to use
        this device.
        """
    @builtins.property
    def get_caps(self) -> Caps | None:
        """
        Getter for the Gst.Caps that this device supports.
        """
    @builtins.property
    def get_device_class(self) -> str:
        """
            Gets the "class" of a device. This is a "/" separated list of
        classes that represent this device. They are a subset of the
        classes of the Gst.DeviceProvider that produced this device.
        """
    @builtins.property
    def get_display_name(self) -> str:
        """
        Gets the user-friendly name of the device.
        """
    @builtins.property
    def get_properties(self) -> Structure | None:
        """
        Gets the extra properties of a device.
        """
    def has_classes(self, classes: str) -> bool:
        """
        Check if `device` matches all of the given classes
        """
    def has_classesv(self, classes: list) -> bool:
        """
        Check if `factory` matches all of the given classes
        """
    def reconfigure_element(self, element: Element) -> bool:
        """
            Tries to reconfigure an existing element to use the device. If this
        function fails, then one must destroy the element and create a new one
        using `Gst.Device.create_element`.

        Note: This should only be implemented for elements can change their
        device in the PLAYING state.
        """

    # python methods (overrides?)
    def do_create_element(
        self,
        name: str | None = None,
    ) -> Element | None:
        """
        create_element(self, name:str=None) -> Gst.Element or None
        """
    def do_reconfigure_element(
        self,
        element: Element,
    ) -> bool:
        """
        reconfigure_element(self, element:Gst.Element) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["removed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::device_class"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::display_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::properties"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DeviceClass(GObject.GPointer):
    """
    The class structure for a Gst.Device object.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def create_element(self) -> create_elementDeviceClassCB | None:
        """
           Creates the fully configured element to access this device.
        Subclasses need to override this and return a new element.
        """
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        The parent Gst.ObjectClass structure.
        """
    @builtins.property
    def reconfigure_element(self) -> reconfigure_elementDeviceClassCB:
        """
           This only needs to be implemented by subclasses if the
        element can be reconfigured to use a different device. See the documentation
        for `Gst.Device.reconfigure_element`.
        """

class DeviceMonitor(Object):
    """
    Applications should create a Gst.DeviceMonitor when they want
    to probe, list and monitor devices of a specific type. The
    Gst.DeviceMonitor will create the appropriate
    Gst.DeviceProvider objects and manage them. It will then post
    messages on its Gst.Bus for devices that have been added and
    removed.

    The device monitor will monitor all devices matching the filters that
    the application has set.

    The basic use pattern of a device monitor is as follows:
    |[
      static gboolean
      my_bus_func (GstBus * bus, GstMessage * message, gpointer user_data)
      {
         GstDevice *device;
         gchar *name;

         switch (GST_MESSAGE_TYPE (message)) {
           case GST_MESSAGE_DEVICE_ADDED:
             gst_message_parse_device_added (message, &device);
             name = gst_device_get_display_name (device);
             g_print("Device added: %s\\n", name);
             g_free (name);
             gst_object_unref (device);
             break;
           case GST_MESSAGE_DEVICE_REMOVED:
             gst_message_parse_device_removed (message, &device);
             name = gst_device_get_display_name (device);
             g_print("Device removed: %s\\n", name);
             g_free (name);
             gst_object_unref (device);
             break;
           default:
             break;
         }

         return G_SOURCE_CONTINUE;
      }

      GstDeviceMonitor *
      setup_raw_video_source_device_monitor (void) {
         GstDeviceMonitor *monitor;
         GstBus *bus;
         GstCaps *caps;

         monitor = gst_device_monitor_new ();

         bus = gst_device_monitor_get_bus (monitor);
         gst_bus_add_watch (bus, my_bus_func, None);
         gst_object_unref (bus);

         caps = gst_caps_new_empty_simple ("video/x-raw");
         gst_device_monitor_add_filter (monitor, "Video/Source", caps);
         gst_caps_unref (caps);

         gst_device_monitor_start (monitor);

         return monitor;
      }
    ]|
    """

    class Props(Object.Props):
        show_all: bool  # [show-all]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent(self) -> Object | None:
        """
        the parent Gst.Object structure
        """
    @builtins.property
    def priv(self) -> DeviceMonitorPrivate | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None, show_all: bool | None = None) -> None:
        """
        Initialize DeviceMonitor object with properties.
        """
    def add_filter(self, classes: str | None = None, caps: Caps | None = None) -> int:
        """
            Adds a filter for which Gst.Device will be monitored, any device that matches
        all these classes and the Gst.Caps will be returned.

        If this function is called multiple times to add more filters, each will be
        matched independently. That is, adding more filters will not further restrict
        what devices are matched.

        The Gst.Caps supported by the device as returned by `Gst.Device.get_caps` are
        not intersected with caps filters added using this function.

        Filters must be added before the Gst.DeviceMonitor is started.
        """
    def get_bus(self) -> Bus:
        """
        Gets the Gst.Bus of this Gst.DeviceMonitor
        """
    def get_devices(self) -> list | None:
        """
            Gets a list of devices from all of the relevant monitors. This may actually
        probe the hardware if the monitor is not currently started.
        """
    def get_providers(self) -> list:
        """
            Get a list of the currently selected device provider factories.

        This
        """
    def get_show_all_devices(self) -> bool:
        """
            Get if `monitor` is currently showing all devices, even those from hidden
        providers.
        """
    def remove_filter(self, filter_id: int) -> bool:
        """
            Removes a filter from the Gst.DeviceMonitor using the id that was returned
        by `Gst.DeviceMonitor.add_filter`.
        """
    def set_show_all_devices(self, show_all: bool) -> None:
        """
            Set if all devices should be visible, even those devices from hidden
        providers. Setting `show_all` to true might show some devices multiple times.
        """
    def start(self) -> bool:
        """
            Starts monitoring the devices, one this has succeeded, the
        Gst.MESSAGE_DEVICE_ADDED and Gst.MESSAGE_DEVICE_REMOVED messages
        will be emitted on the bus when the list of devices changes.
        """
    def stop(self) -> None:
        """
        Stops monitoring the devices.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
    ) -> DeviceMonitor:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.DeviceMonitor
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_all"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DeviceMonitorClass(GObject.GPointer):
    """
    Opaque device monitor class structure.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        the parent Gst.ObjectClass structure
        """

class DeviceMonitorPrivate(GObject.GPointer): ...
class DevicePrivate(GObject.GPointer): ...

class DeviceProvider(Object):
    """
    A Gst.DeviceProvider subclass is provided by a plugin that handles devices
    if there is a way to programmatically list connected devices. It can also
    optionally provide updates to the list of connected devices.

    Each Gst.DeviceProvider subclass is a singleton, a plugin should
    normally provide a single subclass for all devices.

    Applications would normally use a Gst.DeviceMonitor to monitor devices
    from all relevant providers.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def devices(self) -> list | None:
        """
        a GList of the Gst.Device objects
        """
    @builtins.property
    def parent(self) -> Object | None:
        """
        The parent Gst.Object
        """
    @builtins.property
    def priv(self) -> DeviceProviderPrivate | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize DeviceProvider object with properties.
        """
    def can_monitor(self) -> bool: ...
    def device_add(self, device: Device) -> None:
        """
            Posts a message on the provider's Gst.Bus to inform applications that
        a new device has been added.

        This is for use by subclasses.

        `device`'s reference count will be incremented, and any floating reference
        will be removed (see `Gst.Object.ref_sink`).
        """
    def device_changed(self, device: Device, changed_device: Device) -> None:
        """
            This function is used when `changed_device` was modified into its new form
        `device`. This will post a `DEVICE_CHANGED` message on the bus to let
        the application know that the device was modified. Gst.Device is immutable
        for MT. safety purposes so this is an "atomic" way of letting the application
        know when a device was modified.
        """
    def device_remove(self, device: Device) -> None:
        """
            Posts a message on the provider's Gst.Bus to inform applications that
        a device has been removed.

        This is for use by subclasses.
        """
    def get_bus(self) -> Bus:
        """
        Gets the Gst.Bus of this Gst.DeviceProvider
        """
    def get_devices(self) -> list:
        """
            Gets a list of devices that this provider understands. This may actually
        probe the hardware if the provider is not currently started.

        If the provider has been started, this will returned the same Gst.Device
        objedcts that have been returned by the GST_MESSAGE_DEVICE_ADDED messages.
        """
    def get_factory(self) -> DeviceProviderFactory | None:
        """
        Retrieves the factory that was used to create this device provider.
        """
    def get_hidden_providers(self) -> list:
        """
            Get the provider factory names of the Gst.DeviceProvider instances that
        are hidden by `provider`.
        """
    def get_metadata(self, key: str) -> str:
        """
        Get metadata with `key` in `provider`.
        """
    def hide_provider(self, name: str) -> None:
        """
            Make `provider` hide the devices from the factory with `name`.

        This function is used when `provider` will also provide the devices reported
        by provider factory `name`. A monitor should stop monitoring the
        device provider with `name` to avoid duplicate devices.
        """
    def is_started(self) -> bool:
        """
        This function can be used to know if the `provider` was successfully started.
        """
    @staticmethod
    def register(plugin: Plugin | None, name: str, rank: int, type: GObject.GType) -> bool:
        """
            Create a new device providerfactory capable of instantiating objects of the
        `type` and add the factory to `plugin`.
        """
    def start(self) -> bool:
        """
            Starts providering the devices. This will cause GST_MESSAGE_DEVICE_ADDED
        and GST_MESSAGE_DEVICE_REMOVED messages to be posted on the provider's bus
        when devices are added or removed from the system.

        Since the Gst.DeviceProvider is a singleton,
        `Gst.DeviceProvider.start` may already have been called by another
        user of the object, `Gst.DeviceProvider.stop` needs to be called the same
        number of times.

        After this function has been called, `Gst.DeviceProvider.get_devices` will
        return the same objects that have been received from the
        GST_MESSAGE_DEVICE_ADDED messages and will no longer probe.
        """
    def stop(self) -> None:
        """
            Decreases the use-count by one. If the use count reaches zero, this
        Gst.DeviceProvider will stop providering the devices. This needs to be
        called the same number of times that `Gst.DeviceProvider.start` was called.
        """
    def unhide_provider(self, name: str) -> None:
        """
            Make `provider` unhide the devices from factory `name`.

        This function is used when `provider` will no longer provide the devices
        reported by provider factory `name`. A monitor should start
        monitoring the devices from provider factory `name` in order to see
        all devices again.
        """

    # python methods (overrides?)
    @classmethod
    def add_metadata(
        cls,
        key: str,
        value: str,
    ) -> None:
        """
        add_metadata(self, key:str, value:str)
        """
    @classmethod
    def add_static_metadata(
        cls,
        key: str,
        value: str,
    ) -> None:
        """
        add_static_metadata(self, key:str, value:str)
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> None:
        """
        stop(self)
        """
    @classmethod
    def set_metadata(
        cls,
        longname: str,
        classification: str,
        description: str,
        author: str,
    ) -> None:
        """
        set_metadata(self, longname:str, classification:str, description:str, author:str)
        """
    @classmethod
    def set_static_metadata(
        cls,
        longname: str,
        classification: str,
        description: str,
        author: str,
    ) -> None:
        """
        set_static_metadata(self, longname:str, classification:str, description:str, author:str)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["provider-hidden"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["provider-unhidden"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DeviceProviderClass(GObject.GPointer):
    """
    The structure of the base Gst.DeviceProviderClass
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def factory(self) -> DeviceProviderFactory | None:
        """
           a pointer to the Gst.DeviceProviderFactory that creates this
        provider
        """
    @builtins.property
    def metadata(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        the parent Gst.ObjectClass structure
        """
    @builtins.property
    def probe(self) -> object | None:
        """
           Returns a list of devices that are currently available.
        This should never block. The devices should not have a parent and should
        be floating.
        """
    @builtins.property
    def start(self) -> startDeviceProviderClassCB:
        """
           Starts monitoring for new devices. Only subclasses that can know
        that devices have been added or remove need to implement this method.
        """
    @builtins.property
    def stop(self) -> stopDeviceProviderClassCB:
        """
           Stops monitoring for new devices. Only subclasses that implement
        the `start` method need to implement this method.
        """

    # gi Methods
    def add_metadata(self, key: str, value: str) -> None:
        """
        Set `key` with `value` as metadata in `klass`.
        """
    def add_static_metadata(self, key: str, value: str) -> None:
        """
            Set `key` with `value` as metadata in `klass`.

        Same as `Gst.DeviceProviderClass.add_metadata`, but `value` must be a static string
        or an inlined string, as it will not be copied. (GStreamer plugins will
        be made resident once loaded, so this function can be used even from
        dynamically loaded plugins.)
        """
    def get_metadata(self, key: str) -> str | None:
        """
        Get metadata with `key` in `klass`.
        """
    def set_metadata(self, longname: str, classification: str, description: str, author: str) -> None:
        """
            Sets the detailed information for a Gst.DeviceProviderClass.

        > This function is for use in _class_init functions only.
        """
    def set_static_metadata(self, longname: str, classification: str, description: str, author: str) -> None:
        """
            Sets the detailed information for a Gst.DeviceProviderClass.

        > This function is for use in _class_init functions only.

        Same as `Gst.DeviceProviderClass.set_metadata`, but `longname`, `classification`,
        `description`, and `author` must be static strings or inlined strings, as
        they will not be copied. (GStreamer plugins will be made resident once
        loaded, so this function can be used even from dynamically loaded plugins.)
        """

class DeviceProviderFactory(PluginFeature):
    """
    Gst.DeviceProviderFactory is used to create instances of device providers. A
    GstDeviceProviderfactory can be added to a Gst.Plugin as it is also a
    Gst.PluginFeature.

    Use the `Gst.DeviceProviderFactory.find` and
    `Gst.DeviceProviderFactory.get` functions to create device
    provider instances or use `Gst.DeviceProviderFactory.get_by_name` as a
    convenient shortcut.
    """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize DeviceProviderFactory object with properties.
        """
    @staticmethod
    def find(name: str) -> DeviceProviderFactory | None:
        """
            Search for an device provider factory of the given name. Refs the returned
        device provider factory; caller is responsible for unreffing.
        """
    def get(self) -> DeviceProvider | None:
        """
            Returns the device provider of the type defined by the given device
        providerfactory.
        """
    @staticmethod
    def get_by_name(factoryname: str) -> DeviceProvider | None:
        """
            Returns the device provider of the type defined by the given device
        provider factory.
        """
    def get_device_provider_type(self) -> GObject.GType:
        """
            Get the GType for device providers managed by this factory. The type can
        only be retrieved if the device provider factory is loaded, which can be
        assured with `Gst.PluginFeature.load`.
        """
    def get_metadata(self, key: str) -> str | None:
        """
        Get the metadata on `factory` with `key`.
        """
    def get_metadata_keys(self) -> list | None:
        """
        Get the available keys for the metadata on `factory`.
        """
    def has_classes(self, classes: str | None = None) -> bool:
        """
        Check if `factory` matches all of the given `classes`
        """
    def has_classesv(self, classes: list | None = None) -> bool:
        """
        Check if `factory` matches all of the given classes
        """
    @staticmethod
    def list_get_device_providers(minrank: Rank) -> list:
        """
            Get a list of factories with a rank greater or equal to `minrank`.
        The list of factories is returned by decreasing rank.
        """

class DeviceProviderFactoryClass(GObject.GPointer):
    """
    The opaque Gst.DeviceProviderFactoryClass data structure.
    """

    ...

class DeviceProviderPrivate(GObject.GPointer): ...

class DoubleRange(builtins.object):
    """
    A fundamental type that describes a #gdouble range
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # python methods (overrides?)
    def __init__(
        self,
        start: typing.Any,
        stop: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class DynamicTypeFactory(PluginFeature):
    """
    Gst.DynamicTypeFactory is used to represent a type that can be
    automatically loaded the first time it is used. For example,
    a non-standard type for use in caps fields.

    In general, applications and plugins don't need to use the factory
    beyond registering the type in a plugin init function. Once that is
    done, the type is stored in the registry, and ready as soon as the
    registry is loaded.

    ## Registering a type for dynamic loading

    |[<!-- language="C" -->

    static gboolean
    plugin_init (GstPlugin * plugin)
    {
      return gst_dynamic_type_register (plugin, GST_TYPE_CUSTOM_CAPS_FIELD);
    }
    ]|
    """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize DynamicTypeFactory object with properties.
        """
    @staticmethod
    def load(factoryname: str) -> GObject.GType: ...

class DynamicTypeFactoryClass(GObject.GPointer): ...

class Element(Object):
    """
    GstElement is the abstract base class needed to construct an element that
    can be used in a GStreamer pipeline. Please refer to the plugin writers
    guide for more information on creating Gst.Element subclasses.

    The name of a Gst.Element can be get with `Gst.Element.get_name` and set with
    `Gst.Element.set_name`.  For speed, `GST_ELEMENT_NAME` can be used in the
    core when using the appropriate locking. Do not use this in plug-ins or
    applications in order to retain ABI compatibility.

    Elements can have pads (of the type Gst.Pad).  These pads link to pads on
    other elements.  Gst.Buffer flow between these linked pads.
    A Gst.Element has a GList of Gst.Pad structures for all their input (or sink)
    and output (or source) pads.
    Core and plug-in writers can add and remove pads with `Gst.Element.add_pad`
    and `Gst.Element.remove_pad`.

    An existing pad of an element can be retrieved by name with
    `Gst.Element.get_static_pad`. A new dynamic pad can be created using
    `Gst.Element.request_pad` with a Gst.PadTemplate.
    An iterator of all pads can be retrieved with `Gst.Element.iterate_pads`.

    Elements can be linked through their pads.
    If the link is straightforward, use the `Gst.Element.link`
    convenience function to link two elements, or `Gst.Element.link_many`
    for more elements in a row.
    Use `Gst.Element.link_filtered` to link two elements constrained by
    a specified set of Gst.Caps.
    For finer control, use `Gst.Element.link_pads` and
    `Gst.Element.link_pads_filtered` to specify the pads to link on
    each element by name.

    Each element has a state (see Gst.State).  You can get and set the state
    of an element with `Gst.Element.get_state` and `Gst.Element.set_state`.
    Setting a state triggers a Gst.StateChange. To get a string representation
    of a Gst.State, use `Gst.Element.state_get_name`.

    You can get and set a Gst.Clock on an element using `Gst.Element.get_clock`
    and `Gst.Element.set_clock`.
    Some elements can provide a clock for the pipeline if
    the GST_ELEMENT_FLAG_PROVIDE_CLOCK flag is set. With the
    `Gst.Element.provide_clock` method one can retrieve the clock provided by
    such an element.
    Not all elements require a clock to operate correctly. If the
    `GST_ELEMENT_FLAG_REQUIRE_CLOCK` flag is set, a clock should be set on the
    element with `Gst.Element.set_clock`.

    Note that clock selection and distribution is normally handled by the
    toplevel Gst.Pipeline so the clock functions are only to be used in very
    specific situations.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def base_time(self) -> int:
        """
            the time of the clock right before the element is set to
        PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
        state will yield the running_time against the clock.
        """
    @builtins.property
    def bus(self) -> Bus | None:
        """
            the bus of the element. This bus is provided to the element by the
        parent element or the application. A Gst.Pipeline has a bus of its own.
        """
    @builtins.property
    def clock(self) -> Clock | None:
        """
            the clock of the element. This clock is usually provided to the
        element by the toplevel Gst.Pipeline.
        """
    @builtins.property
    def contexts(self) -> list | None:
        """
        list of contexts
        """
    @builtins.property
    def current_state(self) -> State:
        """
        the current state of an element
        """
    @builtins.property
    def last_return(self) -> StateChangeReturn:
        """
        the last return value of an element state change
        """
    @builtins.property
    def next_state(self) -> State:
        """
            the next state of an element, can be GST_STATE_VOID_PENDING if
        the element is in the correct state.
        """
    @builtins.property
    def numpads(self) -> int:
        """
        number of pads of the element, includes both source and sink pads.
        """
    @builtins.property
    def numsinkpads(self) -> int:
        """
        number of sink pads of the element.
        """
    @builtins.property
    def numsrcpads(self) -> int:
        """
        number of source pads of the element.
        """
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def pads(self) -> list | None:
        """
        list of pads
        """
    @builtins.property
    def pads_cookie(self) -> int:
        """
        updated whenever the a pad is added or removed
        """
    @builtins.property
    def pending_state(self) -> State:
        """
            the final state the element should go to, can be
        GST_STATE_VOID_PENDING if the element is in the correct state
        """
    @builtins.property
    def sinkpads(self) -> list | None:
        """
        list of sink pads
        """
    @builtins.property
    def srcpads(self) -> list | None:
        """
        list of source pads
        """
    @builtins.property
    def start_time(self) -> int:
        """
        the running_time of the last PAUSED state
        """
    @builtins.property
    def state_cond(self) -> GLib.Cond | None:
        """
        Used to signal completion of a state change
        """
    @builtins.property
    def state_cookie(self) -> int:
        """
            Used to detect concurrent execution of
        `Gst.Element.set_state` and `Gst.Element.get_state`
        """
    @builtins.property
    def state_lock(self) -> GLib.RecMutex | None:
        """
        Used to serialize execution of `Gst.Element.set_state`
        """
    @builtins.property
    def target_state(self) -> State:
        """
        the target state of an element as set by the application
        """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize Element object with properties.
        """
    def abort_state(self) -> None:
        """
            Abort the state change of the element. This function is used
        by elements that do asynchronous state changes and find out
        something is wrong.

        This function should be called with the STATE_LOCK held.

        MT safe.
        """
    def add_pad(self, pad: Pad) -> bool:
        """
            Adds a pad (link point) to `element`. `pad`'s parent will be set to `element`;
        see `Gst.Object.set_parent` for refcounting information.

        Pads are automatically activated when added in the PAUSED or PLAYING
        state.

        The pad and the element should be unlocked when calling this function.

        This function will emit the Gst.Element::pad-added signal on the element.
        """
    def add_property_deep_notify_watch(self, property_name: str | None, include_value: bool) -> int: ...
    def add_property_notify_watch(self, property_name: str | None, include_value: bool) -> int: ...
    def call_async(self, func: ElementCallAsyncFunc, *user_data: object | None) -> None:
        """
            Calls `func` from another thread and passes `user_data` to it. This is to be
        used for cases when a state change has to be performed from a streaming
        thread, directly via `Gst.Element.set_state` or indirectly e.g. via SEEK
        events.

        Calling those functions directly from the streaming thread will cause
        deadlocks in many situations, as they might involve waiting for the
        streaming thread to shut down from this very streaming thread.

        MT safe.
        """
    def change_state(self, transition: StateChange) -> StateChangeReturn:
        """
            Perform `transition` on `element`.

        This function must be called with STATE_LOCK held and is mainly used
        internally.
        """
    def continue_state(self, ret: StateChangeReturn) -> StateChangeReturn:
        """
            Commit the state change of the element and proceed to the next
        pending state if any. This function is used
        by elements that do asynchronous state changes.
        The core will normally call this method automatically when an
        element returned Gst.STATE_CHANGE_SUCCESS from the state change function.

        If after calling this method the element still has not reached
        the pending state, the next state change is performed.

        This method is used internally and should normally not be called by plugins
        or applications.

        This function must be called with STATE_LOCK held.
        """
    def create_all_pads(self) -> None:
        """
            Creates a pad for each pad template that is always available.
        This function is only useful during object initialization of
        subclasses of Gst.Element.
        """
    def decorate_stream_id(self, stream_id: str) -> str:
        """
            Creates a stream-id for `element` by combining the upstream information with
        the `stream_id`.

        This function generates an unique stream-id by getting the upstream
        stream-start event stream ID and appending `stream_id` to it. If the element
        has no sinkpad it will generate an upstream stream-id by doing an URI query
        on the element and in the worst case just uses a random number. Source
        elements that don't implement the URI handler interface should ideally
        generate a unique, deterministic stream-id manually instead.

        Since stream IDs are sorted alphabetically, any numbers in the stream ID
        should be printed with a fixed number of characters, preceded by 0's, such as
        by using the format \\03u instead of %u.
        """
    def foreach_pad(self, func: ElementForeachPadFunc, *user_data: object | None) -> bool:
        """
            Call `func` with `user_data` for each of `element`'s pads. `func` will be called
        exactly once for each pad that exists at the time of this call, unless
        one of the calls to `func` returns False in which case we will stop
        iterating pads and return early. If new pads are added or pads are removed
        while pads are being iterated, this will not be taken into account until
        next time this function is used.
        """
    def foreach_sink_pad(self, func: ElementForeachPadFunc, *user_data: object | None) -> bool:
        """
            Call `func` with `user_data` for each of `element`'s sink pads. `func` will be
        called exactly once for each sink pad that exists at the time of this call,
        unless one of the calls to `func` returns False in which case we will stop
        iterating pads and return early. If new sink pads are added or sink pads
        are removed while the sink pads are being iterated, this will not be taken
        into account until next time this function is used.
        """
    def foreach_src_pad(self, func: ElementForeachPadFunc, *user_data: object | None) -> bool:
        """
            Call `func` with `user_data` for each of `element`'s source pads. `func` will be
        called exactly once for each source pad that exists at the time of this call,
        unless one of the calls to `func` returns False in which case we will stop
        iterating pads and return early. If new source pads are added or source pads
        are removed while the source pads are being iterated, this will not be taken
        into account until next time this function is used.
        """
    def get_base_time(self) -> int:
        """
            Returns the base time of the element. The base time is the
        absolute time of the clock when this element was last put to
        PLAYING. Subtracting the base time from the clock time gives
        the running time of the element.
        """
    def get_bus(self) -> Bus | None:
        """
            Returns the bus of the element. Note that only a Gst.Pipeline will provide a
        bus for the application.
        """
    def get_clock(self) -> Clock | None:
        """
            Gets the currently configured clock of the element. This is the clock as was
        last set with `Gst.Element.set_clock`.

        Elements in a pipeline will only have their clock set when the
        pipeline is in the PLAYING state.
        """
    def get_compatible_pad(self, pad: Pad, caps: Caps | None = None) -> Pad | None:
        """
            Looks for an unlinked pad to which the given pad can link. It is not
        guaranteed that linking the pads will work, though it should work in most
        cases.

        This function will first attempt to find a compatible unlinked ALWAYS pad,
        and if none can be found, it will request a compatible REQUEST pad by looking
        at the templates of `element`.
        """
    def get_compatible_pad_template(self, compattempl: PadTemplate) -> PadTemplate | None:
        """
            Retrieves a pad template from `element` that is compatible with `compattempl`.
        Pads from compatible templates can be linked together.
        """
    def get_context(self, context_type: str) -> Context | None:
        """
            Gets the context with `context_type` set on the element or None.

        MT safe.
        """
    def get_context_unlocked(self, context_type: str) -> Context | None:
        """
        Gets the context with `context_type` set on the element or None.
        """
    def get_contexts(self) -> list:
        """
            Gets the contexts set on the element.

        MT safe.
        """
    def get_current_clock_time(self) -> int:
        """
            Returns the current clock time of the element, as in, the time of the
        element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
        """
    def get_current_running_time(self) -> int:
        """
            Returns the running time of the element. The running time is the
        element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
        if the element has no clock, or if its base time has not been set.
        """
    def get_factory(self) -> ElementFactory | None:
        """
        Retrieves the factory that was used to create this element.
        """
    def get_metadata(self, key: str) -> str:
        """
        Get metadata with `key` in `klass`.
        """
    def get_pad_template(self, name: str) -> PadTemplate | None:
        """
        Retrieves a padtemplate from `element` with the given name.
        """
    def get_pad_template_list(self) -> list:
        """
            Retrieves a list of the pad templates associated with `element`. The
        list must not be modified by the calling code.
        """
    @deprecated("deprecated")
    def get_request_pad(self, name: str) -> Pad | None:
        """
            The name of this function is confusing to people learning GStreamer.
        `Gst.Element.request_pad_simple` aims at making it more explicit it is
        a simplified `Gst.Element.request_pad`.
        """
    def get_start_time(self) -> int:
        """
            Returns the start time of the element. The start time is the
        running time of the clock when this element was last put to PAUSED.

        Usually the start_time is managed by a toplevel element such as
        Gst.Pipeline.

        MT safe.
        """
    def get_state(self, timeout: int) -> tuple[StateChangeReturn, State, State]:
        """
            Gets the state of the element.

        For elements that performed an ASYNC state change, as reported by
        `Gst.Element.set_state`, this function will block up to the
        specified timeout value for the state change to complete.
        If the element completes the state change or goes into
        an error, this function returns immediately with a return value of
        Gst.STATE_CHANGE_SUCCESS or Gst.STATE_CHANGE_FAILURE respectively.

        For elements that did not return Gst.STATE_CHANGE_ASYNC, this function
        returns the current and pending state immediately.

        This function returns Gst.STATE_CHANGE_NO_PREROLL if the element
        successfully changed its state but is not able to provide data yet.
        This mostly happens for live sources that only produce data in
        Gst.STATE_PLAYING. While the state change return is equivalent to
        Gst.STATE_CHANGE_SUCCESS, it is returned to the application to signal that
        some sink elements might not be able to complete their state change because
        an element is not producing data to complete the preroll. When setting the
        element to playing, the preroll will complete and playback will start.
        """
    def get_static_pad(self, name: str) -> Pad | None:
        """
            Retrieves a pad from `element` by name. This version only retrieves
        already-existing (i.e. 'static') pads.
        """
    def is_locked_state(self) -> bool:
        """
            Checks if the state of an element is locked.
        If the state of an element is locked, state changes of the parent don't
        affect the element.
        This way you can leave currently unused elements inside bins. Just lock their
        state before changing the state from GST_STATE_NULL.

        MT safe.
        """
    def iterate_pads(self) -> Iterator:
        """
            Retrieves an iterator of `element`'s pads. The iterator should
        be freed after usage. Also more specialized iterators exists such as
        `Gst.Element.iterate_src_pads` or `Gst.Element.iterate_sink_pads`.

        The order of pads returned by the iterator will be the order in which
        the pads were added to the element.
        """
    def iterate_sink_pads(self) -> Iterator:
        """
            Retrieves an iterator of `element`'s sink pads.

        The order of pads returned by the iterator will be the order in which
        the pads were added to the element.
        """
    def iterate_src_pads(self) -> Iterator:
        """
            Retrieves an iterator of `element`'s source pads.

        The order of pads returned by the iterator will be the order in which
        the pads were added to the element.
        """
    def link(self, dest: Element) -> bool:
        """
            Links `src` to `dest`. The link must be from source to
        destination; the other direction will not be tried. The function looks for
        existing pads that aren't linked yet. It will request new pads if necessary.
        Such pads need to be released manually when unlinking.
        If multiple links are possible, only one is established.

        Make sure you have added your elements to a bin or pipeline with
        `Gst.Bin.add` before trying to link them.
        """
    def link_filtered(self, dest: Element, filter: Caps | None = None) -> bool:
        """
            Links `src` to `dest` using the given caps as filtercaps.
        The link must be from source to
        destination; the other direction will not be tried. The function looks for
        existing pads that aren't linked yet. It will request new pads if necessary.
        If multiple links are possible, only one is established.

        Make sure you have added your elements to a bin or pipeline with
        `Gst.Bin.add` before trying to link them.
        """
    def link_pads(self, srcpadname: str | None, dest: Element, destpadname: str | None = None) -> bool:
        """
            Links the two named pads of the source and destination elements.
        Side effect is that if one of the pads has no parent, it becomes a
        child of the parent of the other element.  If they have different
        parents, the link fails.
        """
    def link_pads_filtered(
        self, srcpadname: str | None, dest: Element, destpadname: str | None = None, filter: Caps | None = None
    ) -> bool:
        """
            Links the two named pads of the source and destination elements. Side effect
        is that if one of the pads has no parent, it becomes a child of the parent of
        the other element. If they have different parents, the link fails. If `caps`
        is not None, makes sure that the caps of the link is a subset of `caps`.
        """
    def link_pads_full(
        self, srcpadname: str | None, dest: Element, destpadname: str | None, flags: PadLinkCheck
    ) -> bool:
        """
            Links the two named pads of the source and destination elements.
        Side effect is that if one of the pads has no parent, it becomes a
        child of the parent of the other element.  If they have different
        parents, the link fails.

        Calling `Gst.Element.link_pads_full` with `flags` == Gst.PAD_LINK_CHECK_DEFAULT
        is the same as calling `Gst.Element.link_pads` and the recommended way of
        linking pads with safety checks applied.

        This is a convenience function for `Gst.Pad.link_full`.
        """
    def lost_state(self) -> None:
        """
            Brings the element to the lost state. The current state of the
        element is copied to the pending state so that any call to
        `Gst.Element.get_state` will return Gst.STATE_CHANGE_ASYNC.

        An ASYNC_START message is posted. If the element was PLAYING, it will
        go to PAUSED. The element will be restored to its PLAYING state by
        the parent pipeline when it prerolls again.

        This is mostly used for elements that lost their preroll buffer
        in the Gst.STATE_PAUSED or Gst.STATE_PLAYING state after a flush,
        they will go to their pending state again when a new preroll buffer is
        queued. This function can only be called when the element is currently
        not in error or an async state change.

        This function is used internally and should normally not be called from
        plugins or applications.
        """
    @staticmethod
    def make_from_uri(type: URIType, uri: str, elementname: str | None = None) -> Element:
        """
        Creates an element for handling the given URI.
        """
    def message_full(
        self,
        type: MessageType,
        domain: int,
        code: int,
        text: str | None,
        debug: str | None,
        file: str,
        function: str,
        line: int,
    ) -> None:
        """
            Post an error, warning or info message on the bus from inside an element.

        `type` must be of GST_MESSAGE_ERROR, GST_MESSAGE_WARNING or
        GST_MESSAGE_INFO.

        MT safe.
        """
    def message_full_with_details(
        self,
        type: MessageType,
        domain: int,
        code: int,
        text: str | None,
        debug: str | None,
        file: str,
        function: str,
        line: int,
        structure: Structure,
    ) -> None:
        """
            Post an error, warning or info message on the bus from inside an element.

        `type` must be of GST_MESSAGE_ERROR, GST_MESSAGE_WARNING or
        GST_MESSAGE_INFO.
        """
    def no_more_pads(self) -> None:
        """
            Use this function to signal that the element does not expect any more pads
        to show up in the current pipeline. This function should be called whenever
        pads have been added by the element itself. Elements with GST_PAD_SOMETIMES
        pad templates use this in combination with autopluggers to figure out that
        the element is done initializing its pads.

        This function emits the Gst.Element::no-more-pads signal.

        MT safe.
        """
    def post_message(self, message: Message) -> bool:
        """
            Post a message on the element's Gst.Bus. This function takes ownership of the
        message; if you want to access the message after this call, you should add an
        additional reference before calling.
        """
    def provide_clock(self) -> Clock | None:
        """
            Get the clock provided by the given element.
        > An element is only required to provide a clock in the PAUSED
        > state. Some elements can provide a clock in other states.
        """
    def query(self, query: Query) -> bool:
        """
            Performs a query on the given element.

        For elements that don't implement a query handler, this function
        forwards the query to a random srcpad or to the peer of a
        random linked sinkpad of this element.

        Please note that some queries might need a running pipeline to work.
        """
    def query_convert(self, src_format: Format, src_val: int, dest_format: Format) -> tuple[bool, int]:
        """
        Queries an element to convert `src_val` in `src_format` to `dest_format`.
        """
    def query_duration(self, format: Format) -> tuple[bool, int]:
        """
            Queries an element (usually top-level pipeline or playbin element) for the
        total stream duration in nanoseconds. This query will only work once the
        pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
        will receive an ASYNC_DONE message on the pipeline bus when that is the case.

        If the duration changes for some reason, you will get a DURATION_CHANGED
        message on the pipeline bus, in which case you should re-query the duration
        using this function.
        """
    def query_position(self, format: Format) -> tuple[bool, int]:
        """
            Queries an element (usually top-level pipeline or playbin element) for the
        stream position in nanoseconds. This will be a value between 0 and the
        stream duration (if the stream duration is known). This query will usually
        only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
        state). The application will receive an ASYNC_DONE message on the pipeline
        bus when that is the case.

        If one repeatedly calls this function one can also create a query and reuse
        it in `Gst.Element.query`.
        """
    @staticmethod
    def register(plugin: Plugin | None, name: str, rank: int, type: GObject.GType) -> bool:
        """
            Create a new elementfactory capable of instantiating objects of the
        `type` and add the factory to `plugin`.
        """
    def release_request_pad(self, pad: Pad) -> None:
        """
            Makes the element free the previously requested pad as obtained
        with `Gst.Element.request_pad`.

        This does not unref the pad. If the pad was created by using
        `Gst.Element.request_pad`, `Gst.Element.release_request_pad` needs to be
        followed by `Gst.Object.unref` to free the `pad`.

        MT safe.
        """
    def remove_pad(self, pad: Pad) -> bool:
        """
            Removes `pad` from `element`. `pad` will be destroyed if it has not been
        referenced elsewhere using `Gst.Object.unparent`.

        This function is used by plugin developers and should not be used
        by applications. Pads that were dynamically requested from elements
        with `Gst.Element.request_pad` should be released with the
        `Gst.Element.release_request_pad` function instead.

        Pads are not automatically deactivated so elements should perform the needed
        steps to deactivate the pad in case this pad is removed in the PAUSED or
        PLAYING state. See `Gst.Pad.set_active` for more information about
        deactivating pads.

        The pad and the element should be unlocked when calling this function.

        This function will emit the Gst.Element::pad-removed signal on the element.
        """
    def remove_property_notify_watch(self, watch_id: int) -> None: ...
    def request_pad(self, templ: PadTemplate, name: str | None = None, caps: Caps | None = None) -> Pad | None:
        """
            Retrieves a request pad from the element according to the provided template.
        Pad templates can be looked up using
        `Gst.ElementFactory.get_static_pad_templates`.

        The pad should be released with `Gst.Element.release_request_pad`.
        """
    def request_pad_simple(self, name: str) -> Pad | None:
        """
            Retrieves a pad from the element by name (e.g. "src_%d"). This version only
        retrieves request pads. The pad should be released with
        `Gst.Element.release_request_pad`.

        This method is slower than manually getting the pad template and calling
        `Gst.Element.request_pad` if the pads should have a specific name (e.g.
        `name` is "src_1" instead of "src_%u").

        Note that this function was introduced in GStreamer 1.20 in order to provide
        a better name to `Gst.Element.get_request_pad`. Prior to 1.20, users
        should use `Gst.Element.get_request_pad` which provides the same
        functionality.
        """
    def seek(
        self,
        rate: float,
        format: Format,
        flags: SeekFlags,
        start_type: SeekType,
        start: int,
        stop_type: SeekType,
        stop: int,
    ) -> bool:
        """
            Sends a seek event to an element. See `Gst.Event.new_seek` for the details of
        the parameters. The seek event is sent to the element using
        `Gst.Element.send_event`.

        MT safe.
        """
    def seek_simple(self, format: Format, seek_flags: SeekFlags, seek_pos: int) -> bool:
        """
            Simple API to perform a seek on the given element, meaning it just seeks
        to the given position relative to the start of the stream. For more complex
        operations like segment seeks (e.g. for looping) or changing the playback
        rate or seeking relative to the last configured playback segment you should
        use `Gst.Element.seek`.

        In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
        guaranteed to return True on a seekable media type or False when the media
        type is certainly not seekable (such as a live stream).

        Some elements allow for seeking in the READY state, in this
        case they will store the seek event and execute it when they are put to
        PAUSED. If the element supports seek in READY, it will always return True when
        it receives the event in the READY state.
        """
    def send_event(self, event: Event) -> bool:
        """
            Sends an event to an element. If the element doesn't implement an
        event handler, the event will be pushed on a random linked sink pad for
        downstream events or a random linked source pad for upstream events.

        This function takes ownership of the provided event so you should
        `Gst.Event.ref` it if you want to reuse the event after this call.

        MT safe.
        """
    def set_base_time(self, time: int) -> None:
        """
            Set the base time of an element. See `Gst.Element.get_base_time`.

        MT safe.
        """
    def set_bus(self, bus: Bus | None = None) -> None:
        """
            Sets the bus of the element. Increases the refcount on the bus.
        For internal use only, unless you're testing elements.

        MT safe.
        """
    def set_clock(self, clock: Clock | None = None) -> bool:
        """
            Sets the clock for the element. This function increases the
        refcount on the clock. Any previously set clock on the object
        is unreffed.
        """
    def set_context(self, context: Context) -> None:
        """
            Sets the context of the element. Increases the refcount of the context.

        MT safe.
        """
    def set_locked_state(self, locked_state: bool) -> bool:
        """
            Locks the state of an element, so state changes of the parent don't affect
        this element anymore.

        Note that this is racy if the state lock of the parent bin is not taken.
        The parent bin might've just checked the flag in another thread and as the
        next step proceed to change the child element's state.

        MT safe.
        """
    def set_start_time(self, time: int) -> None:
        """
            Set the start time of an element. The start time of the element is the
        running time of the element when it last went to the PAUSED state. In READY
        or after a flushing seek, it is set to 0.

        Toplevel elements like Gst.Pipeline will manage the start_time and
        base_time on its children. Setting the start_time to GST_CLOCK_TIME_NONE
        on such a toplevel element will disable the distribution of the base_time to
        the children and can be useful if the application manages the base_time
        itself, for example if you want to synchronize capture from multiple
        pipelines, and you can also ensure that the pipelines have the same clock.

        MT safe.
        """
    def set_state(self, state: State) -> StateChangeReturn:
        """
            Sets the state of the element. This function will try to set the
        requested state by going through all the intermediary states and calling
        the class's state change function for each.

        This function can return GST_STATE_CHANGE_ASYNC, in which case the
        element will perform the remainder of the state change asynchronously in
        another thread.
        An application can use `Gst.Element.get_state` to wait for the completion
        of the state change or it can wait for a Gst.MESSAGE_ASYNC_DONE or
        Gst.MESSAGE_STATE_CHANGED on the bus.

        State changes to Gst.STATE_READY or Gst.STATE_NULL never return
        GST_STATE_CHANGE_ASYNC.
        """
    @staticmethod
    def state_change_return_get_name(state_ret: StateChangeReturn) -> str:
        """
        Gets a string representing the given state change result.
        """
    @staticmethod
    def state_get_name(state: State) -> str:
        """
        Gets a string representing the given state.
        """
    def sync_state_with_parent(self) -> bool:
        """
            Tries to change the state of the element to the same as its parent.
        If this function returns False, the state of element is undefined.
        """
    @staticmethod
    def type_set_skip_documentation(type: GObject.GType) -> None:
        """
            Marks `type` as "documentation should be skipped".
        Can be useful for dynamically registered element to be excluded from
        plugin documentation system.

        Example:
        ```c
        GType my_type;
        GTypeInfo my_type_info;

        // Fill "my_type_info"
        ...

        my_type = g_type_register_static (GST_TYPE_MY_ELEMENT, "my-type-name",
           &my_type_info, 0);
        gst_element_type_set_skip_documentation (my_type);
        gst_element_register (plugin, "my-plugin-feature-name", rank, my_type);
        ```
        """
    def unlink(self, dest: Element) -> None:
        """
            Unlinks all source pads of the source element with all sink pads
        of the sink element to which they are linked.

        If the link has been made using `Gst.Element.link`, it could have created an
        requestpad, which has to be released using `Gst.Element.release_request_pad`.
        """
    def unlink_pads(self, srcpadname: str, dest: Element, destpadname: str) -> None:
        """
            Unlinks the two named pads of the source and destination elements.

        This is a convenience function for `Gst.Pad.unlink`.
        """

    # python methods (overrides?)
    @staticmethod
    def link_many(
        *args: typing.Any,
    ) -> typing.Any:
        """
        @raises: Gst.LinkError
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["no-more-pads"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            This signals that the element will not generate more dynamic pads.
        Note that this signal will usually be emitted from the context of
        the streaming thread.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pad-added"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int:
        """
            a new Gst.Pad has been added to the element. Note that this signal will
        usually be emitted from the context of the streaming thread. Also keep in
        mind that if you add new elements to the pipeline in the signal handler
        you will need to set them to the desired target state with
        `Gst.Element.set_state` or `Gst.Element.sync_state_with_parent`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pad-removed"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int:
        """
        a Gst.Pad has been removed from the element
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ElementClass(GObject.GPointer):
    """
    GStreamer element class. Override the vmethods to implement the element
    functionality.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def change_state(self) -> change_stateElementClassCB:
        """
        called by `set_state` to perform an incremental state change
        """
    @builtins.property
    def elementfactory(self) -> ElementFactory | None:
        """
        the Gst.ElementFactory that creates these elements
        """
    @builtins.property
    def get_state(self) -> get_stateElementClassCB:
        """
        get the state of the element
        """
    @builtins.property
    def metadata(self) -> object | None:
        """
        metadata for elements of this class
        """
    @builtins.property
    def no_more_pads(self) -> no_more_padsElementClassCB: ...
    @builtins.property
    def numpadtemplates(self) -> int:
        """
        the number of padtemplates
        """
    @builtins.property
    def pad_added(self) -> pad_addedElementClassCB: ...
    @builtins.property
    def pad_removed(self) -> pad_removedElementClassCB: ...
    @builtins.property
    def pad_templ_cookie(self) -> int:
        """
        changed whenever the padtemplates change
        """
    @builtins.property
    def padtemplates(self) -> list | None:
        """
        a GList of Gst.PadTemplate
        """
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        the parent class structure
        """
    @builtins.property
    def post_message(self) -> post_messageElementClassCB:
        """
        called when a message is posted on the element. Chain up to
                   the parent class' handler to have it posted on the bus.
        """
    @builtins.property
    def provide_clock(self) -> provide_clockElementClassCB | None:
        """
        gets the Gst.Clock provided by the element
        """
    @builtins.property
    def query(self) -> queryElementClassCB:
        """
        perform a Gst.Query on the element
        """
    @builtins.property
    def release_pad(self) -> release_padElementClassCB:
        """
        called when a request pad is to be released
        """
    @builtins.property
    def request_new_pad(self) -> request_new_padElementClassCB | None:
        """
        called when a new pad is requested
        """
    @builtins.property
    def send_event(self) -> send_eventElementClassCB:
        """
        send a Gst.Event to the element
        """
    @builtins.property
    def set_bus(self) -> set_busElementClassCB:
        """
        set a Gst.Bus on the element
        """
    @builtins.property
    def set_clock(self) -> set_clockElementClassCB:
        """
        set the Gst.Clock on the element
        """
    @builtins.property
    def set_context(self) -> set_contextElementClassCB:
        """
        set a Gst.Context on the element
        """
    @builtins.property
    def set_state(self) -> set_stateElementClassCB:
        """
        set a new state on the element
        """
    @builtins.property
    def state_changed(self) -> state_changedElementClassCB:
        """
        called immediately after a new state was set.
        """

    # gi Methods
    def add_metadata(self, key: str, value: str) -> None:
        """
        Set `key` with `value` as metadata in `klass`.
        """
    def add_pad_template(self, templ: PadTemplate) -> None:
        """
            Adds a padtemplate to an element class. This is mainly used in the _class_init
        functions of classes. If a pad template with the same name as an already
        existing one is added the old one is replaced by the new one.

        `templ`'s reference count will be incremented, and any floating
        reference will be removed (see `Gst.Object.ref_sink`)
        """
    def add_static_metadata(self, key: str, value: str) -> None:
        """
            Set `key` with `value` as metadata in `klass`.

        Same as `Gst.ElementClass.add_metadata`, but `value` must be a static string
        or an inlined string, as it will not be copied. (GStreamer plugins will
        be made resident once loaded, so this function can be used even from
        dynamically loaded plugins.)
        """
    def add_static_pad_template(self, static_templ: StaticPadTemplate) -> None:
        """
            Adds a pad template to an element class based on the static pad template
        `templ`. This is mainly used in the _class_init functions of element
        implementations. If a pad template with the same name already exists,
        the old one is replaced by the new one.
        """
    def add_static_pad_template_with_gtype(self, static_templ: StaticPadTemplate, pad_type: GObject.GType) -> None:
        """
            Adds a pad template to an element class based on the static pad template
        `templ`. This is mainly used in the _class_init functions of element
        implementations. If a pad template with the same name already exists,
        the old one is replaced by the new one.
        """
    def get_metadata(self, key: str) -> str:
        """
        Get metadata with `key` in `klass`.
        """
    def get_pad_template(self, name: str) -> PadTemplate | None:
        """
            Retrieves a padtemplate from `element_class` with the given name.
        > If you use this function in the GInstanceInitFunc of an object class
        > that has subclasses, make sure to pass the g_class parameter of the
        > GInstanceInitFunc here.
        """
    def get_pad_template_list(self) -> list:
        """
            Retrieves a list of the pad templates associated with `element_class`. The
        list must not be modified by the calling code.
        > If you use this function in the GInstanceInitFunc of an object class
        > that has subclasses, make sure to pass the g_class parameter of the
        > GInstanceInitFunc here.
        """
    def set_metadata(self, longname: str, classification: str, description: str, author: str) -> None:
        """
            Sets the detailed information for a Gst.ElementClass.
        > This function is for use in _class_init functions only.
        """
    def set_static_metadata(self, longname: str, classification: str, description: str, author: str) -> None:
        """
            Sets the detailed information for a Gst.ElementClass.

        > This function is for use in _class_init functions only.

        Same as `Gst.ElementClass.set_metadata`, but `longname`, `classification`,
        `description`, and `author` must be static strings or inlined strings, as
        they will not be copied. (GStreamer plugins will be made resident once
        loaded, so this function can be used even from dynamically loaded plugins.)
        """

class ElementFactory(PluginFeature):
    """
    Gst.ElementFactory is used to create instances of elements. A
    GstElementFactory can be added to a Gst.Plugin as it is also a
    Gst.PluginFeature.

    Use the `Gst.ElementFactory.find` and `Gst.ElementFactory.create`
    functions to create element instances or use `Gst.ElementFactory.make` as a
    convenient shortcut.

    The following code example shows you how to create a GstFileSrc element.

    ## Using an element factory
    |[<!-- language="C" -->
      #include <gst/gst.h>

      GstElement *src;
      GstElementFactory *srcfactory;

      gst_init (&argc, &argv);

      srcfactory = gst_element_factory_find ("filesrc");
      g_return_if_fail (srcfactory != None);
      src = gst_element_factory_create (srcfactory, "src");
      g_return_if_fail (src != None);
      ...
    ]|
    """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize ElementFactory object with properties.
        """
    def can_sink_all_caps(self, caps: Caps) -> bool:
        """
        Checks if the factory can sink all possible capabilities.
        """
    def can_sink_any_caps(self, caps: Caps) -> bool:
        """
        Checks if the factory can sink any possible capability.
        """
    def can_src_all_caps(self, caps: Caps) -> bool:
        """
        Checks if the factory can src all possible capabilities.
        """
    def can_src_any_caps(self, caps: Caps) -> bool:
        """
        Checks if the factory can src any possible capability.
        """
    def create(self, name: str | None = None) -> Element | None:
        """
            Create a new element of the type defined by the given elementfactory.
        It will be given the name supplied, since all elements require a name as
        their first argument.
        """
    def create_with_properties(self, n: int, names: list | None = None, values: list | None = None) -> Element | None:
        """
            Create a new element of the type defined by the given elementfactory.
        The supplied list of properties, will be passed at object construction.
        """
    @staticmethod
    def find(name: str) -> ElementFactory | None:
        """
            Search for an element factory of the given name. Refs the returned
        element factory; caller is responsible for unreffing.
        """
    def get_element_type(self) -> GObject.GType:
        """
            Get the GType for elements managed by this factory. The type can
        only be retrieved if the element factory is loaded, which can be
        assured with `Gst.PluginFeature.load`.
        """
    def get_metadata(self, key: str) -> str | None:
        """
        Get the metadata on `factory` with `key`.
        """
    def get_metadata_keys(self) -> list | None:
        """
        Get the available keys for the metadata on `factory`.
        """
    def get_num_pad_templates(self) -> int:
        """
        Gets the number of pad_templates in this factory.
        """
    def get_skip_documentation(self) -> bool:
        """
            Queries whether registered element managed by `factory` needs to
        be excluded from documentation system or not.
        """
    def get_static_pad_templates(self) -> list:
        """
        Gets the GList of Gst.StaticPadTemplate for this factory.
        """
    def get_uri_protocols(self) -> list:
        """
            Gets a None-terminated array of protocols this element supports or None if
        no protocols are supported. You may not change the contents of the returned
        array, as it is still owned by the element factory. Use `g_strdupv` to
        make a copy of the protocol string array if you need to.
        """
    def get_uri_type(self) -> URIType:
        """
        Gets the type of URIs the element supports or GST_URI_UNKNOWN if none.
        """
    def has_interface(self, interfacename: str) -> bool:
        """
        Check if `factory` implements the interface with name `interfacename`.
        """
    @staticmethod
    def list_filter(list: list, caps: Caps, direction: PadDirection, subsetonly: bool) -> list:
        """
            Filter out all the elementfactories in `list` that can handle `caps` in
        the given direction.

        If `subsetonly` is True, then only the elements whose pads templates
        are a complete superset of `caps` will be returned. Else any element
        whose pad templates caps can intersect with `caps` will be returned.
        """
    @staticmethod
    def list_get_elements(type: int, minrank: Rank) -> list:
        """
            Get a list of factories that match the given `type`. Only elements
        with a rank greater or equal to `minrank` will be returned.
        The list of factories is returned by decreasing rank.
        """
    def list_is_type(self, type: int) -> bool:
        """
        Check if `factory` is of the given types.
        """
    @staticmethod
    def make_with_properties(
        factoryname: str, n: int, names: list | None = None, values: list | None = None
    ) -> Element | None:
        """
            Create a new element of the type defined by the given elementfactory.
        The supplied list of properties, will be passed at object construction.
        """

    # python methods (overrides?)
    def get_description(
        self,
    ) -> typing.Any: ...
    def get_klass(
        self,
    ) -> typing.Any: ...
    def get_longname(
        self,
    ) -> typing.Any: ...
    @classmethod
    def make(
        cls,
        factoryname: typing.Any,
        name: typing.Any = None,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        make(factoryname:str, name:str=None) -> Gst.Element or None
        """

class ElementFactoryClass(GObject.GPointer): ...

class Event(GObject.GBoxed):
    """
    The event class provides factory methods to construct events for sending
    and functions to query (parse) received events.

    Events are usually created with gst_event_new_*() which takes event-type
    specific parameters as arguments.
    To send an event application will usually use `Gst.Element.send_event` and
    elements will use `Gst.Pad.send_event` or `Gst.Pad.push_event`.
    The event should be unreffed with `Gst.Event.unref` if it has not been sent.

    Events that have been received can be parsed with their respective
    gst_event_parse_*() functions. It is valid to pass None for unwanted details.

    Events are passed between elements in parallel to the data stream. Some events
    are serialized with buffers, others are not. Some events only travel downstream,
    others only upstream. Some events can travel both upstream and downstream.

    The events are used to signal special conditions in the datastream such as
    EOS (end of stream) or the start of a new stream-segment.
    Events are also used to flush the pipeline of any pending data.

    Most of the event API is used inside plugins. Applications usually only
    construct and use seek events.
    To do that `Gst.Event.new_seek` is used to create a seek event. It takes
    the needed parameters to specify seeking time and mode.
    |[<!-- language="C" -->
      GstEvent *event;
      gboolean result;
      ...
      // construct a seek event to play the media from second 2 to 5, flush
      // the pipeline to decrease latency.
      event = gst_event_new_seek (1.0,
         GST_FORMAT_TIME,
         GST_SEEK_FLAG_FLUSH,
         GST_SEEK_TYPE_SET, 2 * GST_SECOND,
         GST_SEEK_TYPE_SET, 5 * GST_SECOND);
      ...
      result = gst_element_send_event (pipeline, event);
      if (!result)
        g_warning ("seek failed");
      ...
    ]|
    """

    # gi Fields
    mini_object: MiniObject | None = ...
    """
    the parent structure
    """
    seqnum: int = ...
    """
    the sequence number of the event
    """
    timestamp: int = ...
    """
    the timestamp of the event
    """
    type: EventType = ...
    """
    the Gst.EventType of the event
    """

    # gi Methods
    def copy_segment(self, segment: Segment) -> None:
        """
            Parses a segment `event` and copies the Gst.Segment into the location
        given by `segment`.
        """
    def get_running_time_offset(self) -> int:
        """
            Retrieve the accumulated running time offset of the event.

        Events passing through Gst.Pads that have a running time
        offset set via `Gst.Pad.set_offset` will get their offset
        adjusted according to the pad's offset.

        If the event contains any information that related to the
        running time, this information will need to be updated
        before usage with this offset.
        """
    def get_seqnum(self) -> int:
        """
            Retrieve the sequence number of a event.

        Events have ever-incrementing sequence numbers, which may also be set
        explicitly via `Gst.Event.set_seqnum`. Sequence numbers are typically used to
        indicate that a event corresponds to some other set of events or messages,
        for example an EOS event corresponding to a SEEK event. It is considered good
        practice to make this correspondence when possible, though it is not
        required.

        Note that events and messages share the same sequence number incrementor;
        two events or messages will never have the same sequence number unless
        that correspondence was made explicitly.
        """
    def get_structure(self) -> Structure | None:
        """
        Access the structure of the event.
        """
    def has_name(self, name: str) -> bool:
        """
            Checks if `event` has the given `name`. This function is usually used to
        check the name of a custom event.
        """
    @deprecated("deprecated")
    def has_name_id(self, name: int) -> bool:
        """
            Checks if `event` has the given `name`. This function is usually used to
        check the name of a custom event.
        """
    def parse_buffer_size(self) -> tuple[Format, int, int, bool]:
        """
        Get the format, minsize, maxsize and async-flag in the buffersize event.
        """
    def parse_caps(self) -> Caps:
        """
            Get the caps from `event`. The caps remains valid as long as `event` remains
        valid.
        """
    def parse_flush_stop(self) -> bool:
        """
        Parse the FLUSH_STOP event and retrieve the `reset_time` member.
        """
    def parse_gap(self) -> tuple[int, int]:
        """
        Extract timestamp and duration from a new GAP event.
        """
    def parse_gap_flags(self) -> GapFlags:
        """
            Retrieve the gap flags that may have been set on a gap event with
        `Gst.Event.set_gap_flags`.
        """
    def parse_group_id(self) -> tuple[bool, int]: ...
    def parse_instant_rate_change(self) -> tuple[float, SegmentFlags]:
        """
        Extract rate and flags from an instant-rate-change event.
        """
    def parse_instant_rate_sync_time(self) -> tuple[float, int, int]:
        """
        Extract the rate multiplier and running times from an instant-rate-sync-time event.
        """
    def parse_latency(self) -> int:
        """
        Get the latency in the latency event.
        """
    def parse_protection(self) -> tuple[str, Buffer, str]:
        """
            Parses an event containing protection system specific information and stores
        the results in `system_id`, `data` and `origin`. The data stored in `system_id`,
        `origin` and `data` are valid until `event` is released.
        """
    def parse_qos(self) -> tuple[QOSType, float, int, int]:
        """
            Get the type, proportion, diff and timestamp in the qos event. See
        `Gst.Event.new_qos` for more information about the different QoS values.

        `timestamp` will be adjusted for any pad offsets of pads it was passing through.
        """
    def parse_seek(self) -> tuple[float, Format, SeekFlags, SeekType, int, SeekType, int]:
        """
        Parses a seek `event` and stores the results in the given result locations.
        """
    def parse_seek_trickmode_interval(self) -> int:
        """
            Retrieve the trickmode interval that may have been set on a
        seek event with `Gst.Event.set_seek_trickmode_interval`.
        """
    def parse_segment(self) -> Segment:
        """
            Parses a segment `event` and stores the result in the given `segment` location.
        `segment` remains valid only until the `event` is freed. Don't modify the segment
        and make a copy if you want to modify it or store it for later use.
        """
    def parse_segment_done(self) -> tuple[Format, int]:
        """
        Extracts the position and format from the segment done message.
        """
    def parse_select_streams(self) -> list:
        """
        Parse the SELECT_STREAMS event and retrieve the contained streams.
        """
    def parse_sink_message(self) -> Message:
        """
        Parse the sink-message event. Unref `msg` after usage.
        """
    def parse_step(self) -> tuple[Format, int, float, bool, bool]:
        """
        Parse the step event.
        """
    def parse_stream(self) -> Stream:
        """
        Parse a stream-start `event` and extract the Gst.Stream from it.
        """
    def parse_stream_collection(self) -> StreamCollection:
        """
        Retrieve new Gst.StreamCollection from STREAM_COLLECTION event `event`.
        """
    def parse_stream_flags(self) -> StreamFlags: ...
    def parse_stream_group_done(self) -> int:
        """
            Parse a stream-group-done `event` and store the result in the given
        `group_id` location.
        """
    def parse_stream_start(self) -> str:
        """
            Parse a stream-id `event` and store the result in the given `stream_id`
        location. The string stored in `stream_id` must not be modified and will
        remain valid only until `event` gets freed. Make a copy if you want to
        modify it or store it for later use.
        """
    def parse_tag(self) -> TagList:
        """
            Parses a tag `event` and stores the results in the given `taglist` location.
        No reference to the taglist will be returned, it remains valid only until
        the `event` is freed. Don't modify or free the taglist, make a copy if you
        want to modify it or store it for later use.
        """
    def parse_toc(self) -> tuple[Toc, bool]:
        """
        Parse a TOC `event` and store the results in the given `toc` and `updated` locations.
        """
    def parse_toc_select(self) -> str:
        """
        Parse a TOC select `event` and store the results in the given `uid` location.
        """
    def set_gap_flags(self, flags: GapFlags) -> None:
        """
            Sets `flags` on `event` to give additional information about the reason for
        the GST_EVENT_GAP.
        """
    def set_group_id(self, group_id: int) -> None:
        """
            All streams that have the same group id are supposed to be played
        together, i.e. all streams inside a container file should have the
        same group id but different stream ids. The group id should change
        each time the stream is started, resulting in different group ids
        each time a file is played for example.

        Use `Gst.util_group_id_next` to get a new group id.
        """
    def set_running_time_offset(self, offset: int) -> None:
        """
            Set the running time offset of a event. See
        `Gst.Event.get_running_time_offset` for more information.

        MT safe.
        """
    def set_seek_trickmode_interval(self, interval: int) -> None:
        """
            Sets a trickmode interval on a (writable) seek event. Elements
        that support TRICKMODE_KEY_UNITS seeks SHOULD use this as the minimal
        interval between each frame they may output.
        """
    def set_seqnum(self, seqnum: int) -> None:
        """
            Set the sequence number of a event.

        This function might be called by the creator of a event to indicate that the
        event relates to other events or messages. See `Gst.Event.get_seqnum` for
        more information.

        MT safe.
        """
    def set_stream(self, stream: Stream) -> None:
        """
        Set the `stream` on the stream-start `event`
        """
    def set_stream_flags(self, flags: StreamFlags) -> None: ...
    def writable_structure(self) -> Structure:
        """
        Get a writable version of the structure.
        """

    # python methods (overrides?)
    @classmethod
    def new_buffer_size(
        cls,
        format: Format,
        minsize: int,
        maxsize: int,
        async_: bool,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_buffer_size(format:Gst.Format, minsize:int, maxsize:int, async_:bool) -> Gst.Event
        """
    @classmethod
    def new_caps(
        cls,
        caps: Caps,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_caps(caps:Gst.Caps) -> Gst.Event
        """
    @classmethod
    def new_custom(
        cls,
        type: EventType,
        structure: Structure,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_custom(type:Gst.EventType, structure:Gst.Structure) -> Gst.Event
        """
    @classmethod
    def new_eos(
        cls,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_eos() -> Gst.Event
        """
    @classmethod
    def new_flush_start(
        cls,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_flush_start() -> Gst.Event
        """
    @classmethod
    def new_flush_stop(
        cls,
        reset_time: bool,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_flush_stop(reset_time:bool) -> Gst.Event
        """
    @classmethod
    def new_gap(
        cls,
        timestamp: int,
        duration: int,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_gap(timestamp:int, duration:int) -> Gst.Event
        """
    @classmethod
    def new_instant_rate_change(
        cls,
        rate_multiplier: float,
        new_flags: SegmentFlags,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_instant_rate_change(rate_multiplier:float, new_flags:Gst.SegmentFlags) -> Gst.Event
        """
    @classmethod
    def new_instant_rate_sync_time(
        cls,
        rate_multiplier: float,
        running_time: int,
        upstream_running_time: int,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_instant_rate_sync_time(rate_multiplier:float, running_time:int, upstream_running_time:int) -> Gst.Event
        """
    @classmethod
    def new_latency(
        cls,
        latency: int,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_latency(latency:int) -> Gst.Event
        """
    @classmethod
    def new_navigation(
        cls,
        structure: Structure,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_navigation(structure:Gst.Structure) -> Gst.Event
        """
    @classmethod
    def new_protection(
        cls,
        system_id: str,
        data: Buffer,
        origin: str,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_protection(system_id:str, data:Gst.Buffer, origin:str) -> Gst.Event
        """
    @classmethod
    def new_qos(
        cls,
        type: QOSType,
        proportion: float,
        diff: int,
        timestamp: int,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_qos(type:Gst.QOSType, proportion:float, diff:int, timestamp:int) -> Gst.Event
        """
    @classmethod
    def new_reconfigure(
        cls,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_reconfigure() -> Gst.Event
        """
    @classmethod
    def new_seek(
        cls,
        rate: float,
        format: Format,
        flags: SeekFlags,
        start_type: SeekType,
        start: int,
        stop_type: SeekType,
        stop: int,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_seek(rate:float, format:Gst.Format, flags:Gst.SeekFlags, start_type:Gst.SeekType, start:int, stop_type:Gst.SeekType, stop:int) -> Gst.Event
        """
    @classmethod
    def new_segment(
        cls,
        segment: Segment,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_segment(segment:Gst.Segment) -> Gst.Event
        """
    @classmethod
    def new_segment_done(
        cls,
        format: Format,
        position: int,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_segment_done(format:Gst.Format, position:int) -> Gst.Event
        """
    @classmethod
    def new_select_streams(
        cls,
        streams: list,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_select_streams(streams:list) -> Gst.Event
        """
    @classmethod
    def new_sink_message(
        cls,
        name: str,
        msg: Message,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_sink_message(name:str, msg:Gst.Message) -> Gst.Event
        """
    @classmethod
    def new_step(
        cls,
        format: Format,
        amount: int,
        rate: float,
        flush: bool,
        intermediate: bool,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_step(format:Gst.Format, amount:int, rate:float, flush:bool, intermediate:bool) -> Gst.Event
        """
    @classmethod
    def new_stream_collection(
        cls,
        collection: StreamCollection,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_stream_collection(collection:Gst.StreamCollection) -> Gst.Event
        """
    @classmethod
    def new_stream_group_done(
        cls,
        group_id: int,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_stream_group_done(group_id:int) -> Gst.Event
        """
    @classmethod
    def new_stream_start(
        cls,
        stream_id: str,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_stream_start(stream_id:str) -> Gst.Event
        """
    @classmethod
    def new_tag(
        cls,
        taglist: TagList,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_tag(taglist:Gst.TagList) -> Gst.Event
        """
    @classmethod
    def new_toc(
        cls,
        toc: Toc,
        updated: bool,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_toc(toc:Gst.Toc, updated:bool) -> Gst.Event
        """
    @classmethod
    def new_toc_select(
        cls,
        uid: str,
    ) -> Event:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_toc_select(uid:str) -> Gst.Event
        """

class FlagSet(builtins.object):
    """
    A fundamental type that describes a 32-bit flag bitfield, with 32-bit
    mask indicating which of the bits in the field are explicitly set.
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    @staticmethod
    def register(flags_type: GObject.GType) -> GObject.GType:
        """
            Create a new sub-class of GST_TYPE_FLAG_SET
        which will pretty-print the human-readable flags
        when serializing, for easier debugging.
        """

class FormatDefinition(GObject.GPointer):
    """
    A format definition
    """

    # gi Fields
    description: str = ...
    """
    A longer description of the format
    """
    nick: str = ...
    """
    A short nick of the format
    """
    quark: int = ...
    """
    A quark for the nick
    """
    value: Format = ...
    """
    The unique id of this format
    """

class Fraction(builtins.object):
    """
    A fundamental type that describes a fraction of an integer numerator
    over an integer denominator
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    denom: int = ...
    """
    Denominator of the fraction.
    """
    num: int = ...
    """
    Numerator of the fraction.
    """

    # python methods (overrides?)
    def __init__(
        self,
        num: typing.Any,
        denom: typing.Any = 1,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class FractionRange(builtins.object):
    """
    A fundamental type that describes a Gst.FractionRange range
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # python methods (overrides?)
    def __init__(
        self,
        start: typing.Any,
        stop: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class GhostPad(ProxyPad):
    """
    GhostPads are useful when organizing pipelines with Gst.Bin like elements.
    The idea here is to create hierarchical element graphs. The bin element
    contains a sub-graph. Now one would like to treat the bin-element like any
    other Gst.Element. This is where GhostPads come into play. A GhostPad acts as
    a proxy for another pad. Thus the bin can have sink and source ghost-pads
    that are associated with sink and source pads of the child elements.

    If the target pad is known at creation time, `Gst.GhostPad.new` is the
    function to use to get a ghost-pad. Otherwise one can use `Gst.GhostPad.new_no_target`
    to create the ghost-pad and use `Gst.GhostPad.set_target` to establish the
    association later on.

    Note that GhostPads add overhead to the data processing of a pipeline.
    """

    # gi Fields
    @builtins.property
    def pad(self) -> ProxyPad | None: ...
    @builtins.property
    def priv(self) -> GhostPadPrivate | None: ...

    # gi Methods
    @staticmethod
    def activate_mode_default(pad: Pad, parent: Object | None, mode: PadMode, active: bool) -> bool:
        """
        Invoke the default activate mode function of a ghost pad.
        """
    @deprecated("deprecated")
    def construct(self) -> bool:
        """
            Finish initialization of a newly allocated ghost pad.

        This function is most useful in language bindings and when subclassing
        Gst.GhostPad; plugin and application developers normally will not call this
        function. Call this function directly after a call to g_object_new
        (GST_TYPE_GHOST_PAD, "direction", `dir`, ..., None).
        """
    def get_target(self) -> Pad | None:
        """
        Get the target pad of `gpad`. Unref target pad after usage.
        """
    @staticmethod
    def internal_activate_mode_default(pad: Pad, parent: Object | None, mode: PadMode, active: bool) -> bool:
        """
            Invoke the default activate mode function of a proxy pad that is
        owned by a ghost pad.
        """
    @classmethod
    def new(cls, name: str | None, target: Pad) -> GhostPad | None:
        """
            Create a new ghostpad with `target` as the target. The direction will be taken
        from the target pad. `target` must be unlinked.

        Will ref the target.
        """
    @classmethod
    def new_from_template(cls, name: str | None, target: Pad, templ: PadTemplate) -> GhostPad | None:
        """
            Create a new ghostpad with `target` as the target. The direction will be taken
        from the target pad. The template used on the ghostpad will be `template`.

        Will ref the target.
        """
    @classmethod
    def new_no_target(cls, name: str | None, dir: PadDirection) -> GhostPad | None:
        """
            Create a new ghostpad without a target with the given direction.
        A target can be set on the ghostpad later with the
        `Gst.GhostPad.set_target` function.

        The created ghostpad will not have a padtemplate.
        """
    @classmethod
    def new_no_target_from_template(cls, name: str | None, templ: PadTemplate) -> GhostPad | None:
        """
            Create a new ghostpad based on `templ`, without setting a target. The
        direction will be taken from the `templ`.
        """
    def set_target(self, newtarget: Pad | None = None) -> bool:
        """
            Set the new target of the ghostpad `gpad`. Any existing target
        is unlinked and links to the new target are established. if `newtarget` is
        None the target will be cleared.
        """

    # python methods (overrides?)
    def __init__(
        self,
        name: typing.Any,
        target: typing.Any = None,
        direction: typing.Any = None,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    def query_caps(
        self,
        filter: typing.Any = None,
    ) -> typing.Any:
        """
        query_caps(self, filter:Gst.Caps=None) -> Gst.Caps
        """

class GhostPadClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ProxyPadClass | None: ...

class GhostPadPrivate(GObject.GPointer): ...

class IdStr(GObject.GBoxed):
    """
    A Gst.IdStr is string type optimized for short strings and used for structure
    names, structure field names and in other places.

    Strings up to 16 bytes (including NUL terminator) are stored inline, other
    strings are stored on the heap.

    ```cpp
    GstIdStr s = GST_ID_STR_INIT;

    gst_id_str_set (&s, "Hello, World!");
    g_print ("%s\\n", gst_id_str_as_str (&s));

    gst_id_str_clear (&s);
    ```
    """

    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def pointer(self) -> object | None: ...

    # gi Methods
    def as_str(self) -> str: ...
    def clear(self) -> None:
        """
        Clears `s` and sets it to the empty string.
        """
    def copy(self) -> IdStr:
        """
        Copies `s` into newly allocated heap memory.
        """
    def copy_into(self, s: IdStr) -> None:
        """
        Copies `s` into `d`.
        """
    def free(self) -> None:
        """
        Frees `s`. This should only be called for heap-allocated Gst.IdStr.
        """
    def get_len(self) -> int:
        """
            Returns the length of `s`, exluding the NUL-terminator. This is equivalent to
        calling ``strcmp`` but potentially faster.
        """
    def init(self) -> None:
        """
            Initializes a (usually stack-allocated) id string `s`. The newly-initialized
        id string will contain an empty string by default as value.
        """
    def is_equal(self, s2: IdStr) -> bool:
        """
        Compares `s1` and `s2` for equality.
        """
    def is_equal_to_str(self, s2: str) -> bool:
        """
        Compares `s1` and `s2` for equality.
        """
    def is_equal_to_str_with_len(self, s2: str, len: int) -> bool:
        """
            Compares `s1` and `s2` with length `len` for equality. `s2` does not have to be
        NUL-terminated and `len` should not include the NUL-terminator.

        This is generally faster than `Gst.IdStr.is_equal_to_str` if the length is
        already known.
        """
    def move(self, s: IdStr) -> None:
        """
        Moves `s` into `d` and resets `s`.
        """
    def set(self, value: str) -> None:
        """
        Sets `s` to the string `value`.
        """
    def set_static_str(self, value: str) -> None:
        """
            Sets `s` to the string `value`. `value` needs to be valid for the remaining
        lifetime of the process, e.g. has to be a static string.
        """
    def set_static_str_with_len(self, value: str, len: int) -> None:
        """
            Sets `s` to the string `value` of length `len`. `value` needs to be valid for the
        remaining lifetime of the process, e.g. has to be a static string.

        `value` must be NUL-terminated and `len` should not include the
        NUL-terminator.
        """
    def set_with_len(self, value: str, len: int) -> None:
        """
            Sets `s` to the string `value` of length `len`. `value` does not have to be
        NUL-terminated and `len` should not include the NUL-terminator.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
    ) -> IdStr:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.IdStr
        """

class Int64Range(builtins.object):
    """
    A fundamental type that describes a #gint64 range
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # python methods (overrides?)
    def __init__(
        self,
        r: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class IntRange(builtins.object):
    """
    A fundamental type that describes a #gint range
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # python methods (overrides?)
    def __init__(
        self,
        r: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class Iterator(GObject.GBoxed):
    """
    A GstIterator is used to retrieve multiple objects from another object in
    a threadsafe way.

    Various GStreamer objects provide access to their internal structures using
    an iterator.

    Note that if calling a GstIterator function results in your code receiving
    a refcounted object (with, say, `g_value_get_object`), the refcount for that
    object will not be increased. Your code is responsible for taking a reference
    if it wants to continue using it later.

    The basic use pattern of an iterator is as follows:
    |[<!-- language="C" -->
      GstIterator *it = _get_iterator(object);
      GValue item = G_VALUE_INIT;
      done = False;
      while (!done) {
        switch (gst_iterator_next (it, &item)) {
          case GST_ITERATOR_OK:
            ...get/use/change item here...
            g_value_reset (&item);
            break;
          case GST_ITERATOR_RESYNC:
            ...rollback changes to items...
            gst_iterator_resync (it);
            break;
          case GST_ITERATOR_ERROR:
            ...wrong parameters were given...
            done = True;
            break;
          case GST_ITERATOR_DONE:
            done = True;
            break;
        }
      }
      g_value_unset (&item);
      gst_iterator_free (it);
    ]|
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    cookie: int = ...
    """
    The cookie; the value of the master_cookie when this iterator was
             created.
    """
    item: IteratorItemFunctionIteratorCB = ...
    """
    The function to be called for each item retrieved
    """
    lock: GLib.Mutex | None = ...  # type: ignore
    """
    The lock protecting the data structure and the cookie.
    """
    master_cookie: int = ...
    """
    A pointer to the master cookie.
    """
    pushed: Iterator | None = ...
    """
    The iterator that is currently pushed with `Gst.Iterator.push`
    """
    size: int = ...
    """
    the size of the iterator
    """
    type: GObject.GType = ...  # type: ignore
    """
    The type of the object that this iterator will return
    """

    # gi Methods
    def copy(self) -> Iterator:
        """
        Copy the iterator and its state.
        """
    def filter(self, func: GLib.CompareFunc, user_data: GObject.Value) -> Iterator:
        """
            Create a new iterator from an existing iterator. The new iterator
        will only return those elements that match the given compare function `func`.
        The first parameter that is passed to `func` is the GValue of the current
        iterator element and the second parameter is `user_data`. `func` should
        return 0 for elements that should be included in the filtered iterator.

        When this iterator is freed, `it` will also be freed.
        """
    def find_custom(self, func: GLib.CompareFunc, *user_data: object | None) -> tuple[bool, GObject.Value]:
        """
            Find the first element in `it` that matches the compare function `func`.
        `func` should return 0 when the element is found. The first parameter
        to `func` will be the current element of the iterator and the
        second parameter will be `user_data`.
        The result will be stored in `elem` if a result is found.

        The iterator will not be freed.

        This function will return False if an error happened to the iterator
        or if the element wasn't found.
        """
    def fold(self, func: IteratorFoldFunction, ret: GObject.Value, *user_data: object | None) -> IteratorResult:
        """
            Folds `func` over the elements of `iter`. That is to say, `func` will be called
        as `func` (object, `ret`, `user_data`) for each object in `it`. The normal use
        of this procedure is to accumulate the results of operating on the objects in
        `ret`.

        This procedure can be used (and is used internally) to implement the
        `Gst.Iterator.foreach` and `Gst.Iterator.find_custom` operations.

        The fold will proceed as long as `func` returns True. When the iterator has no
        more arguments, Gst.ITERATOR_DONE will be returned. If `func` returns False,
        the fold will stop, and Gst.ITERATOR_OK will be returned. Errors or resyncs
        will cause fold to return Gst.ITERATOR_ERROR or Gst.ITERATOR_RESYNC as
        appropriate.

        The iterator will not be freed.
        """
    def foreach(self, func: IteratorForeachFunction, *user_data: object | None) -> IteratorResult:
        """
            Iterate over all element of `it` and call the given function `func` for
        each element.
        """
    def free(self) -> None:
        """
            Free the iterator.

        MT safe.
        """
    @classmethod
    def new_single(cls, type: GObject.GType, object: GObject.Value) -> Iterator:
        """
            This Gst.Iterator is a convenient iterator for the common
        case where a Gst.Iterator needs to be returned but only
        a single object has to be considered. This happens often
        for the Gst.PadIterIntLinkFunction.
        """
    def next(self) -> tuple[IteratorResult, GObject.Value]:
        """
            Get the next item from the iterator in `elem`.

        Only when this function returns Gst.ITERATOR_OK, `elem` will contain a valid
        value. `elem` must have been initialized to the type of the iterator or
        initialized to zeroes with `g_value_unset`. The caller is responsible for
        unsetting or resetting `elem` with `g_value_unset` or `g_value_reset`
        after usage.

        When this function returns Gst.ITERATOR_DONE, no more elements can be
        retrieved from `it`.

        A return value of Gst.ITERATOR_RESYNC indicates that the element list was
        concurrently updated. The user of `it` should call `Gst.Iterator.resync` to
        get the newly updated list.

        A return value of Gst.ITERATOR_ERROR indicates an unrecoverable fatal error.
        """
    def push(self, other: Iterator) -> None:
        """
            Pushes `other` iterator onto `it`. All calls performed on `it` are
        forwarded to `other`. If `other` returns Gst.ITERATOR_DONE, it is
        popped again and calls are handled by `it` again.

        This function is mainly used by objects implementing the iterator
        next function to recurse into substructures.

        When `Gst.Iterator.resync` is called on `it`, `other` will automatically be
        popped.

        MT safe.
        """
    def resync(self) -> None:
        """
            Resync the iterator. this function is mostly called
        after `Gst.Iterator.next` returned Gst.ITERATOR_RESYNC.

        When an iterator was pushed on `it`, it will automatically be popped again
        with this function.

        MT safe.
        """

class IteratorError(builtins.Exception): ...
class LinkError(builtins.Exception): ...
class MapError(builtins.Exception): ...

class MapInfo(builtins.object):
    """
    A structure containing the result of a map operation such as
    `Gst.Memory.map`. It contains the data and size.

    Gst.MapInfo cannot be used with `g_auto` because it is ambiguous whether it
    needs to be unmapped using `Gst.Buffer.unmap` or `Gst.Memory.unmap`. Instead,
    Gst.BufferMapInfo and Gst.MemoryMapInfo can be used in that case.
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    data: list | None = ...
    """
    a pointer to the mapped data
    """
    flags: MapFlags | None = ...
    """
    flags used when mapping the memory
    """
    maxsize: int = ...
    """
    the maximum bytes in `data`
    """
    memory: Memory | None = ...
    """
    a pointer to the mapped memory
    """
    size: int = ...
    """
    the valid size in `data`
    """
    user_data: list | None = ...
    """
    extra private user_data that the implementation of the memory
                can use to store extra info.
    """

    # python methods (overrides?)
    def __init__(
        self,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class Memory(GObject.GBoxed):
    """
    GstMemory is a lightweight refcounted object that wraps a region of memory.
    They are typically used to manage the data of a Gst.Buffer.

    A GstMemory object has an allocated region of memory of maxsize. The maximum
    size does not change during the lifetime of the memory object. The memory
    also has an offset and size property that specifies the valid range of memory
    in the allocated region.

    Memory is usually created by allocators with a `Gst.Allocator.alloc`
    method call. When None is used as the allocator, the default allocator will
    be used.

    New allocators can be registered with `Gst.Allocator.register`.
    Allocators are identified by name and can be retrieved with
    `Gst.Allocator.find`. `Gst.Allocator.set_default` can be used to change the
    default allocator.

    New memory can be created with `Gst.Memory.new_wrapped` that wraps the memory
    allocated elsewhere.

    Refcounting of the memory block is performed with `Gst.Memory.ref` and
    `Gst.Memory.unref`.

    The size of the memory can be retrieved and changed with
    `Gst.Memory.get_sizes` and `Gst.Memory.resize` respectively.

    Getting access to the data of the memory is performed with `Gst.Memory.map`.
    The call will return a pointer to offset bytes into the region of memory.
    After the memory access is completed, `Gst.Memory.unmap` should be called.

    Memory can be copied with `Gst.Memory.copy`, which will return a writable
    copy. `Gst.Memory.share` will create a new memory block that shares the
    memory with an existing memory block at a custom offset and with a custom
    size.

    Memory can be efficiently merged when `Gst.Memory.is_span` returns True.
    """

    # gi Fields
    align: int = ...
    """
    the alignment of the memory
    """
    allocator: Allocator | None = ...
    """
    pointer to the Gst.Allocator
    """
    maxsize: int = ...
    """
    the maximum size allocated
    """
    mini_object: MiniObject | None = ...
    """
    parent structure
    """
    offset: int = ...
    """
    the offset where valid data starts
    """
    parent: Memory | None = ...
    """
    parent memory block
    """
    size: int = ...
    """
    the size of valid data
    """

    # gi Methods
    def copy(self, offset: int, size: int) -> Memory | None:
        """
            Return a copy of `size` bytes from `mem` starting from `offset`. This copy is
        guaranteed to be writable. `size` can be set to -1 to return a copy
        from `offset` to the end of the memory region.
        """
    def get_sizes(self) -> tuple[int, int, int]:
        """
        Get the current `size`, `offset` and `maxsize` of `mem`.
        """
    def is_span(self, mem2: Memory) -> tuple[bool, int]:
        """
            Check if `mem1` and mem2 share the memory with a common parent memory object
        and that the memory is contiguous.

        If this is the case, the memory of `mem1` and `mem2` can be merged
        efficiently by performing `Gst.Memory.share` on the parent object from
        the returned `offset`.
        """
    def is_type(self, mem_type: str) -> bool:
        """
        Check if `mem` if allocated with an allocator for `mem_type`.
        """
    def make_mapped(self, flags: MapFlags) -> tuple[Memory | None, MapInfo]:
        """
            Create a Gst.Memory object that is mapped with `flags`. If `mem` is mappable
        with `flags`, this function returns the mapped `mem` directly. Otherwise a
        mapped copy of `mem` is returned.

        This function takes ownership of old `mem` and returns a reference to a new
        Gst.Memory.
        """
    @classmethod
    def new_wrapped(
        cls,
        flags: MemoryFlags,
        data: list,
        maxsize: int,
        offset: int,
        size: int,
        *user_data: object | None,
        notify: GLib.DestroyNotify | None = None,
    ) -> Memory | None:
        """
            Allocate a new memory block that wraps the given `data`.

        The prefix/padding must be filled with 0 if `flags` contains
        GST_MEMORY_FLAG_ZERO_PREFIXED and GST_MEMORY_FLAG_ZERO_PADDED respectively.
        """
    def resize(self, offset: int, size: int) -> None:
        """
            Resize the memory region. `mem` should be writable and offset + size should be
        less than the maxsize of `mem`.

        GST_MEMORY_FLAG_ZERO_PREFIXED and GST_MEMORY_FLAG_ZERO_PADDED will be
        cleared when offset or padding is increased respectively.
        """
    def share(self, offset: int, size: int) -> Memory:
        """
            Return a shared copy of `size` bytes from `mem` starting from `offset`. No
        memory copy is performed and the memory region is simply shared. The result
        is guaranteed to be non-writable. `size` can be set to -1 to return a shared
        copy from `offset` to the end of the memory region.
        """

    # python methods (overrides?)
    def map(
        self,
        flags: typing.Any,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        map(self, flags:Gst.MapFlags) -> bool, info:Gst.MapInfo
        """
    def unmap(
        self,
        mapinfo: typing.Any,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        unmap(self, info:Gst.MapInfo)
        """

class Message(GObject.GBoxed):
    """
    Messages are implemented as a subclass of Gst.MiniObject with a generic
    Gst.Structure as the content. This allows for writing custom messages without
    requiring an API change while allowing a wide range of different types
    of messages.

    Messages are posted by objects in the pipeline and are passed to the
    application using the Gst.Bus.

    The basic use pattern of posting a message on a Gst.Bus is as follows:
    |[<!-- language="C" -->
      gst_bus_post (bus, `Gst.Message.new_eos`);
    ]|

    A Gst.Element usually posts messages on the bus provided by the parent
    container using `Gst.Element.post_message`.
    """

    # gi Fields
    @builtins.property
    def cond(self) -> GLib.Cond | None: ...
    @builtins.property
    def lock(self) -> GLib.Mutex | None: ...
    mini_object: MiniObject | None = ...
    """
    the parent structure
    """
    seqnum: int = ...
    """
    the sequence number of the message
    """
    src: Object | None = ...
    """
    the src of the message
    """
    timestamp: int = ...
    """
    the timestamp of the message
    """
    type: MessageType = ...
    """
    the Gst.MessageType of the message
    """

    # gi Methods
    def add_redirect_entry(
        self, location: str, tag_list: TagList | None = None, entry_struct: Structure | None = None
    ) -> None:
        """
            Creates and appends a new entry.

        The specified location string is copied. However, ownership over the tag
        list and structure are transferred to the message.
        """
    def get_details(self) -> Structure | None:
        """
            Returns the optional details structure of the message. May be None if none.

        The returned structure must not be freed.
        """
    def get_num_redirect_entries(self) -> int: ...
    def get_seqnum(self) -> int:
        """
            Retrieve the sequence number of a message.

        Messages have ever-incrementing sequence numbers, which may also be set
        explicitly via `Gst.Message.set_seqnum`. Sequence numbers are typically used
        to indicate that a message corresponds to some other set of messages or
        events, for example a SEGMENT_DONE message corresponding to a SEEK event. It
        is considered good practice to make this correspondence when possible, though
        it is not required.

        Note that events and messages share the same sequence number incrementor;
        two events or messages will never have the same sequence number unless
        that correspondence was made explicitly.
        """
    def get_stream_status_object(self) -> GObject.Value | None:
        """
        Extracts the object managing the streaming thread from `message`.
        """
    def get_structure(self) -> Structure | None:
        """
        Access the structure of the message.
        """
    def has_name(self, name: str) -> bool:
        """
            Checks if `message` has the given `name`. This function is usually used to
        check the name of a custom message.
        """
    def parse_async_done(self) -> int:
        """
            Extract the running_time from the async_done message.

        MT safe.
        """
    def parse_buffering(self) -> int:
        """
            Extracts the buffering percent from the GstMessage. see also
        `Gst.Message.new_buffering`.

        MT safe.
        """
    def parse_buffering_stats(self) -> tuple[BufferingMode, int, int, int]:
        """
        Extracts the buffering stats values from `message`.
        """
    def parse_clock_lost(self) -> Clock:
        """
            Extracts the lost clock from the GstMessage.
        The clock object returned remains valid until the message is freed.

        MT safe.
        """
    def parse_clock_provide(self) -> tuple[Clock, bool]:
        """
            Extracts the clock and ready flag from the GstMessage.
        The clock object returned remains valid until the message is freed.

        MT safe.
        """
    def parse_context_type(self) -> tuple[bool, str]:
        """
        Parse a context type from an existing GST_MESSAGE_NEED_CONTEXT message.
        """
    def parse_device_added(self) -> Device:
        """
            Parses a device-added message. The device-added message is produced by
        Gst.DeviceProvider or a Gst.DeviceMonitor. It announces the appearance
        of monitored devices.
        """
    def parse_device_changed(self) -> tuple[Device, Device]:
        """
            Parses a device-changed message. The device-changed message is produced by
        Gst.DeviceProvider or a Gst.DeviceMonitor. It announces the
        disappearance of monitored devices. * It announce that a device properties has
        changed and `device` represents the new modified version of `changed_device`.
        """
    def parse_device_removed(self) -> Device:
        """
            Parses a device-removed message. The device-removed message is produced by
        Gst.DeviceProvider or a Gst.DeviceMonitor. It announces the
        disappearance of monitored devices.
        """
    def parse_error(self) -> tuple[GLib.Error, str | None]:
        """
            Extracts the GError and debug string from the GstMessage. The values returned
        in the output arguments are copies; the caller must free them when done.

        Typical usage of this function might be:
        |[<!-- language="C" -->
          ...
          switch (GST_MESSAGE_TYPE (msg)) {
            case GST_MESSAGE_ERROR: {
              GError *err = None;
              gchar *dbg_info = None;

              gst_message_parse_error (msg, &err, &dbg_info);
              g_printerr ("ERROR from element %s: %s\\n",
                  GST_OBJECT_NAME (msg->src), err->message);
              g_printerr ("Debugging info: %s\\n", (dbg_info) ? dbg_info : "none");
              g_error_free (err);
              g_free (dbg_info);
              break;
            }
            ...
          }
          ...
        ]|

        MT safe.
        """
    def parse_error_details(self) -> Structure | None:
        """
            Returns the optional details structure, may be None if none.
        The returned structure must not be freed.
        """
    def parse_error_writable_details(self) -> Structure | None:
        """
            Returns the details structure if present or will create one if not present.
        The returned structure must not be freed.
        """
    def parse_group_id(self) -> tuple[bool, int]:
        """
        Extract the group from the STREAM_START message.
        """
    def parse_have_context(self) -> Context:
        """
            Extract the context from the HAVE_CONTEXT message.

        MT safe.
        """
    def parse_info(self) -> tuple[GLib.Error, str | None]:
        """
            Extracts the GError and debug string from the GstMessage. The values returned
        in the output arguments are copies; the caller must free them when done.

        MT safe.
        """
    def parse_info_details(self) -> Structure | None:
        """
            Returns the optional details structure, may be None if none
        The returned structure must not be freed.
        """
    def parse_info_writable_details(self) -> Structure | None:
        """
            Returns the details structure if present or will create one if not present.
        The returned structure must not be freed.
        """
    def parse_instant_rate_request(self) -> float:
        """
        Parses the rate_multiplier from the instant-rate-request message.
        """
    def parse_new_clock(self) -> Clock:
        """
            Extracts the new clock from the GstMessage.
        The clock object returned remains valid until the message is freed.

        MT safe.
        """
    def parse_progress(self) -> tuple[ProgressType, str, str]:
        """
        Parses the progress `type`, `code` and `text`.
        """
    def parse_property_notify(self) -> tuple[Object, str, GObject.Value | None]:
        """
            Parses a property-notify message. These will be posted on the bus only
        when set up with `Gst.Element.add_property_notify_watch` or
        `Gst.Element.add_property_deep_notify_watch`.
        """
    def parse_qos(self) -> tuple[bool, int, int, int, int]:
        """
            Extract the timestamps and live status from the QoS message.

        The returned values give the running_time, stream_time, timestamp and
        duration of the dropped buffer. Values of GST_CLOCK_TIME_NONE mean unknown
        values.

        MT safe.
        """
    def parse_qos_stats(self) -> tuple[Format, int, int]:
        """
            Extract the QoS stats representing the history of the current continuous
        pipeline playback period.

        When `format` is `GST_FORMAT_UNDEFINED` both `dropped` and `processed` are
        invalid. Values of -1 for either `processed` or `dropped` mean unknown values.

        MT safe.
        """
    def parse_qos_values(self) -> tuple[int, float, int]:
        """
            Extract the QoS values that have been calculated/analysed from the QoS data

        MT safe.
        """
    def parse_redirect_entry(self, entry_index: int) -> tuple[str, TagList | None, Structure | None]:
        """
            Parses the location and/or structure from the entry with the given index.
        The index must be between 0 and `Gst.Message.get_num_redirect_entries` - 1.
        Returned pointers are valid for as long as this message exists.
        """
    def parse_request_state(self) -> State:
        """
            Extract the requested state from the request_state message.

        MT safe.
        """
    def parse_reset_time(self) -> int:
        """
            Extract the running-time from the RESET_TIME message.

        MT safe.
        """
    def parse_segment_done(self) -> tuple[Format, int]:
        """
            Extracts the position and format from the segment done message.

        MT safe.
        """
    def parse_segment_start(self) -> tuple[Format, int]:
        """
            Extracts the position and format from the segment start message.

        MT safe.
        """
    def parse_state_changed(self) -> tuple[State, State, State]:
        """
            Extracts the old and new states from the GstMessage.

        Typical usage of this function might be:
        |[<!-- language="C" -->
          ...
          switch (GST_MESSAGE_TYPE (msg)) {
            case GST_MESSAGE_STATE_CHANGED: {
              GstState old_state, new_state;

              gst_message_parse_state_changed (msg, &old_state, &new_state, None);
              g_print ("Element %s changed state from %s to %s.\\n",
                  GST_OBJECT_NAME (msg->src),
                  gst_element_state_get_name (old_state),
                  gst_element_state_get_name (new_state));
              break;
            }
            ...
          }
          ...
        ]|

        MT safe.
        """
    def parse_step_done(self) -> tuple[Format, int, float, bool, bool, int, bool]:
        """
            Extract the values the step_done message.

        MT safe.
        """
    def parse_step_start(self) -> tuple[bool, Format, int, float, bool, bool]:
        """
            Extract the values from step_start message.

        MT safe.
        """
    def parse_stream_collection(self) -> StreamCollection:
        """
        Parses a stream-collection message.
        """
    def parse_stream_status(self) -> tuple[StreamStatusType, Element]:
        """
            Extracts the stream status type and owner the GstMessage. The returned
        owner remains valid for as long as the reference to `message` is valid and
        should thus not be unreffed.

        MT safe.
        """
    def parse_streams_selected(self) -> StreamCollection:
        """
        Parses a streams-selected message.
        """
    def parse_structure_change(self) -> tuple[StructureChangeType, Element, bool]:
        """
            Extracts the change type and completion status from the GstMessage.

        MT safe.
        """
    def parse_tag(self) -> TagList:
        """
            Extracts the tag list from the GstMessage. The tag list returned in the
        output argument is a copy; the caller must free it when done.

        Typical usage of this function might be:
        |[<!-- language="C" -->
          ...
          switch (GST_MESSAGE_TYPE (msg)) {
            case GST_MESSAGE_TAG: {
              GstTagList *tags = None;

              gst_message_parse_tag (msg, &tags);
              g_print ("Got tags from element %s\\n", GST_OBJECT_NAME (msg->src));
              handle_tags (tags);
              gst_tag_list_unref (tags);
              break;
            }
            ...
          }
          ...
        ]|

        MT safe.
        """
    def parse_toc(self) -> tuple[Toc, bool]:
        """
            Extract the TOC from the Gst.Message. The TOC returned in the
        output argument is a copy; the caller must free it with
        `Gst.Toc.unref` when done.

        MT safe.
        """
    def parse_warning(self) -> tuple[GLib.Error, str | None]:
        """
            Extracts the GError and debug string from the GstMessage. The values returned
        in the output arguments are copies; the caller must free them when done.

        MT safe.
        """
    def parse_warning_details(self) -> Structure | None:
        """
            Returns the optional details structure, may be None if none
        The returned structure must not be freed.
        """
    def parse_warning_writable_details(self) -> Structure | None:
        """
            Returns the details structure if present or will create one if not present.
        The returned structure must not be freed.
        """
    def set_buffering_stats(self, mode: BufferingMode, avg_in: int, avg_out: int, buffering_left: int) -> None:
        """
        Configures the buffering stats values in `message`.
        """
    def set_details(self, details: Structure | None = None) -> None:
        """
            Add `details` to `message`. Will fail if the message already has details set on
        it or if it is not writable.
        """
    def set_group_id(self, group_id: int) -> None:
        """
            Sets the group id on the stream-start message.

        All streams that have the same group id are supposed to be played
        together, i.e. all streams inside a container file should have the
        same group id but different stream ids. The group id should change
        each time the stream is started, resulting in different group ids
        each time a file is played for example.

        MT safe.
        """
    def set_qos_stats(self, format: Format, processed: int, dropped: int) -> None:
        """
            Set the QoS stats representing the history of the current continuous pipeline
        playback period.

        When `format` is `GST_FORMAT_UNDEFINED` both `dropped` and `processed` are
        invalid. Values of -1 for either `processed` or `dropped` mean unknown values.

        MT safe.
        """
    def set_qos_values(self, jitter: int, proportion: float, quality: int) -> None:
        """
            Set the QoS values that have been calculated/analysed from the QoS data

        MT safe.
        """
    def set_seqnum(self, seqnum: int) -> None:
        """
            Set the sequence number of a message.

        This function might be called by the creator of a message to indicate that
        the message relates to other messages or events. See `Gst.Message.get_seqnum`
        for more information.

        MT safe.
        """
    def set_stream_status_object(self, object: GObject.Value) -> None:
        """
            Configures the object handling the streaming thread. This is usually a
        GstTask object but other objects might be added in the future.
        """
    def streams_selected_add(self, stream: Stream) -> None:
        """
        Adds the `stream` to the `message`.
        """
    def streams_selected_get_size(self) -> int:
        """
        Returns the number of streams contained in the `message`.
        """
    def streams_selected_get_stream(self, idx: int) -> Stream | None:
        """
        Retrieves the Gst.Stream with index `index` from the `message`.
        """
    def writable_details(self) -> Structure:
        """
            Returns the details structure of the `message`. If not present it will be
        created. Use this function (instead of `Gst.Message.get_details`) if you
        want to write to the `details` structure.

        The returned structure must not be freed.
        """
    def writable_structure(self) -> Structure:
        """
        Get a writable version of the structure.
        """

    # python methods (overrides?)
    @classmethod
    def new_application(
        cls,
        src: Object | None,
        structure: Structure,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_application(src:Gst.Object=None, structure:Gst.Structure) -> Gst.Message
        """
    @classmethod
    def new_async_done(
        cls,
        src: Object | None,
        running_time: int,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_async_done(src:Gst.Object=None, running_time:int) -> Gst.Message
        """
    @classmethod
    def new_async_start(
        cls,
        src: Object | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_async_start(src:Gst.Object=None) -> Gst.Message
        """
    @classmethod
    def new_buffering(
        cls,
        src: Object | None,
        percent: int,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_buffering(src:Gst.Object=None, percent:int) -> Gst.Message
        """
    @classmethod
    def new_clock_lost(
        cls,
        src: Object | None,
        clock: Clock,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_clock_lost(src:Gst.Object=None, clock:Gst.Clock) -> Gst.Message
        """
    @classmethod
    def new_clock_provide(
        cls,
        src: Object | None,
        clock: Clock,
        ready: bool,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_clock_provide(src:Gst.Object=None, clock:Gst.Clock, ready:bool) -> Gst.Message
        """
    @classmethod
    def new_custom(
        cls,
        type: MessageType,
        src: Object | None = None,
        structure: Structure | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_custom(type:Gst.MessageType, src:Gst.Object=None, structure:Gst.Structure=None) -> Gst.Message
        """
    @classmethod
    def new_device_added(
        cls,
        src: Object | None,
        device: Device,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_device_added(src:Gst.Object=None, device:Gst.Device) -> Gst.Message
        """
    @classmethod
    def new_device_changed(
        cls,
        src: Object | None,
        device: Device,
        changed_device: Device,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_device_changed(src:Gst.Object=None, device:Gst.Device, changed_device:Gst.Device) -> Gst.Message
        """
    @classmethod
    def new_device_removed(
        cls,
        src: Object | None,
        device: Device,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_device_removed(src:Gst.Object=None, device:Gst.Device) -> Gst.Message
        """
    @classmethod
    def new_duration_changed(
        cls,
        src: Object | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_duration_changed(src:Gst.Object=None) -> Gst.Message
        """
    @classmethod
    def new_element(
        cls,
        src: Object | None,
        structure: Structure,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_element(src:Gst.Object=None, structure:Gst.Structure) -> Gst.Message
        """
    @classmethod
    def new_eos(
        cls,
        src: Object | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_eos(src:Gst.Object=None) -> Gst.Message
        """
    @classmethod
    def new_error(
        cls,
        src: Object | None,
        error: GLib.Error,
        debug: str,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_error(src:Gst.Object=None, error:error, debug:str) -> Gst.Message
        """
    @classmethod
    def new_error_with_details(
        cls,
        src: Object | None,
        error: GLib.Error,
        debug: str,
        details: Structure | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_error_with_details(src:Gst.Object=None, error:error, debug:str, details:Gst.Structure=None) -> Gst.Message
        """
    @classmethod
    def new_have_context(
        cls,
        src: Object | None,
        context: Context,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_have_context(src:Gst.Object=None, context:Gst.Context) -> Gst.Message
        """
    @classmethod
    def new_info(
        cls,
        src: Object | None,
        error: GLib.Error,
        debug: str,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_info(src:Gst.Object=None, error:error, debug:str) -> Gst.Message
        """
    @classmethod
    def new_info_with_details(
        cls,
        src: Object | None,
        error: GLib.Error,
        debug: str,
        details: Structure | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_info_with_details(src:Gst.Object=None, error:error, debug:str, details:Gst.Structure=None) -> Gst.Message
        """
    @classmethod
    def new_instant_rate_request(
        cls,
        src: Object | None,
        rate_multiplier: float,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_instant_rate_request(src:Gst.Object=None, rate_multiplier:float) -> Gst.Message
        """
    @classmethod
    def new_latency(
        cls,
        src: Object | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_latency(src:Gst.Object=None) -> Gst.Message
        """
    @classmethod
    def new_need_context(
        cls,
        src: Object | None,
        context_type: str,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_need_context(src:Gst.Object=None, context_type:str) -> Gst.Message
        """
    @classmethod
    def new_new_clock(
        cls,
        src: Object | None,
        clock: Clock,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_new_clock(src:Gst.Object=None, clock:Gst.Clock) -> Gst.Message
        """
    @classmethod
    def new_progress(
        cls,
        src: Object | None,
        type: ProgressType,
        code: str,
        text: str,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_progress(src:Gst.Object=None, type:Gst.ProgressType, code:str, text:str) -> Gst.Message
        """
    @classmethod
    def new_property_notify(
        cls,
        src: Object,
        property_name: str,
        val: GObject.Value | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_property_notify(src:Gst.Object, property_name:str, val:GObject.Value=None) -> Gst.Message
        """
    @classmethod
    def new_qos(
        cls,
        src: Object | None,
        live: bool,
        running_time: int,
        stream_time: int,
        timestamp: int,
        duration: int,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_qos(src:Gst.Object=None, live:bool, running_time:int, stream_time:int, timestamp:int, duration:int) -> Gst.Message
        """
    @classmethod
    def new_redirect(
        cls,
        src: Object | None,
        location: str,
        tag_list: TagList | None = None,
        entry_struct: Structure | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_redirect(src:Gst.Object=None, location:str, tag_list:Gst.TagList=None, entry_struct:Gst.Structure=None) -> Gst.Message
        """
    @classmethod
    def new_request_state(
        cls,
        src: Object | None,
        state: State,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_request_state(src:Gst.Object=None, state:Gst.State) -> Gst.Message
        """
    @classmethod
    def new_reset_time(
        cls,
        src: Object | None,
        running_time: int,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_reset_time(src:Gst.Object=None, running_time:int) -> Gst.Message
        """
    @classmethod
    def new_segment_done(
        cls,
        src: Object | None,
        format: Format,
        position: int,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_segment_done(src:Gst.Object=None, format:Gst.Format, position:int) -> Gst.Message
        """
    @classmethod
    def new_segment_start(
        cls,
        src: Object | None,
        format: Format,
        position: int,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_segment_start(src:Gst.Object=None, format:Gst.Format, position:int) -> Gst.Message
        """
    @classmethod
    def new_state_changed(
        cls,
        src: Object | None,
        oldstate: State,
        newstate: State,
        pending: State,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_state_changed(src:Gst.Object=None, oldstate:Gst.State, newstate:Gst.State, pending:Gst.State) -> Gst.Message
        """
    @classmethod
    def new_state_dirty(
        cls,
        src: Object | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_state_dirty(src:Gst.Object=None) -> Gst.Message
        """
    @classmethod
    def new_step_done(
        cls,
        src: Object | None,
        format: Format,
        amount: int,
        rate: float,
        flush: bool,
        intermediate: bool,
        duration: int,
        eos: bool,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_step_done(src:Gst.Object=None, format:Gst.Format, amount:int, rate:float, flush:bool, intermediate:bool, duration:int, eos:bool) -> Gst.Message
        """
    @classmethod
    def new_step_start(
        cls,
        src: Object | None,
        active: bool,
        format: Format,
        amount: int,
        rate: float,
        flush: bool,
        intermediate: bool,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_step_start(src:Gst.Object=None, active:bool, format:Gst.Format, amount:int, rate:float, flush:bool, intermediate:bool) -> Gst.Message
        """
    @classmethod
    def new_stream_collection(
        cls,
        src: Object | None,
        collection: StreamCollection,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_stream_collection(src:Gst.Object=None, collection:Gst.StreamCollection) -> Gst.Message
        """
    @classmethod
    def new_stream_start(
        cls,
        src: Object | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_stream_start(src:Gst.Object=None) -> Gst.Message
        """
    @classmethod
    def new_stream_status(
        cls,
        src: Object | None,
        type: StreamStatusType,
        owner: Element,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_stream_status(src:Gst.Object=None, type:Gst.StreamStatusType, owner:Gst.Element) -> Gst.Message
        """
    @classmethod
    def new_streams_selected(
        cls,
        src: Object | None,
        collection: StreamCollection,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_streams_selected(src:Gst.Object=None, collection:Gst.StreamCollection) -> Gst.Message
        """
    @classmethod
    def new_structure_change(
        cls,
        src: Object | None,
        type: StructureChangeType,
        owner: Element,
        busy: bool,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_structure_change(src:Gst.Object=None, type:Gst.StructureChangeType, owner:Gst.Element, busy:bool) -> Gst.Message
        """
    @classmethod
    def new_tag(
        cls,
        src: Object | None,
        tag_list: TagList,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_tag(src:Gst.Object=None, tag_list:Gst.TagList) -> Gst.Message
        """
    @classmethod
    def new_toc(
        cls,
        src: Object | None,
        toc: Toc,
        updated: bool,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_toc(src:Gst.Object=None, toc:Gst.Toc, updated:bool) -> Gst.Message
        """
    @classmethod
    def new_warning(
        cls,
        src: Object | None,
        error: GLib.Error,
        debug: str,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_warning(src:Gst.Object=None, error:error, debug:str) -> Gst.Message
        """
    @classmethod
    def new_warning_with_details(
        cls,
        src: Object | None,
        error: GLib.Error,
        debug: str,
        details: Structure | None = None,
    ) -> Message:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_warning_with_details(src:Gst.Object=None, error:error, debug:str, details:Gst.Structure=None) -> Gst.Message
        """

class Meta(GObject.GPointer):
    """
    The Gst.Meta structure should be included as the first member of a Gst.Buffer
    metadata structure. The structure defines the API of the metadata and should
    be accessible to all elements using the metadata.

    A metadata API is registered with `Gst.Meta.api_type_register` which takes a
    name for the metadata API and some tags associated with the metadata.
    With `Gst.Meta.api_type_has_tag` one can check if a certain metadata API
    contains a given tag.

    Multiple implementations of a metadata API can be registered.
    To implement a metadata API, `Gst.Meta.register` should be used. This
    function takes all parameters needed to create, free and transform metadata
    along with the size of the metadata. The function returns a Gst.MetaInfo
    structure that contains the information for the implementation of the API.

    A specific implementation can be retrieved by name with `Gst.Meta.get_info`.

    See Gst.Buffer for how the metadata can be added, retrieved and removed from
    buffers.
    """

    # gi Fields
    flags: MetaFlags = ...
    """
    extra flags for the metadata
    """
    info: MetaInfo | None = ...
    """
    pointer to the Gst.MetaInfo
    """

    # gi Methods
    @staticmethod
    def api_type_aggregate_params(
        api: GObject.GType, aggregated_params: Structure, params0: Structure, params1: Structure
    ) -> bool:
        """
            When a element like `tee` decides the allocation, each downstream element may
        fill different parameters and pass them to `Gst.Query.add_allocation_meta`.
        In order to keep these parameters, a merge operation is needed. This
        aggregate function can combine the parameters from `params0` and `param1`, and
        write the result back into `aggregated_params`.
        """
    @staticmethod
    def api_type_get_tags(api: GObject.GType) -> list: ...
    @staticmethod
    def api_type_has_tag(api: GObject.GType, tag: int) -> bool:
        """
        Check if `api` was registered with `tag`.
        """
    @staticmethod
    def api_type_register(api: str, tags: list) -> GObject.GType:
        """
            Register and return a GType for the `api` and associate it with
        `tags`.
        """
    @staticmethod
    def api_type_set_params_aggregator(api: GObject.GType, aggregator: AllocationMetaParamsAggregator) -> None:
        """
        This function sets the aggregator function for a specific API type.
        """
    def compare_seqnum(self, meta2: Meta) -> int:
        """
            Meta sequence number compare function. Can be used as GCompareFunc
        or a GCompareDataFunc.
        """
    @staticmethod
    def deserialize(buffer: Buffer, data: int, size: int) -> tuple[Meta | None, int]:
        """
            Recreate a Gst.Meta from serialized data returned by
        `Gst.Meta.serialize` and add it to `buffer`.

        Note that the meta must have been previously registered by calling one of
        `gst_*_meta_get_info ()` functions.

        `consumed` is set to the number of bytes that can be skipped from `data` to
        find the next meta serialization, if any. In case of parsing error that does
        not allow to determine that size, `consumed` is set to 0.
        """
    @staticmethod
    def get_info(impl: str) -> MetaInfo | None:
        """
            Lookup a previously registered meta info structure by its implementation name
        `impl`.
        """
    def get_seqnum(self) -> int:
        """
        Gets seqnum for this meta.
        """
    @staticmethod
    def register_custom(
        name: str, tags: list, transform_func: CustomMetaTransformFunction | None = None, *user_data: object | None
    ) -> MetaInfo:
        """
            Register a new custom Gst.Meta implementation, backed by an opaque
        structure holding a Gst.Structure.

        The registered info can be retrieved later with `Gst.Meta.get_info` by using
        `name` as the key.

        The backing Gst.Structure can be retrieved with
        `Gst.CustomMeta.get_structure`, its mutability is conditioned by the
        writability of the buffer the meta is attached to.

        When `transform_func` is None, the meta and its backing Gst.Structure
        will always be copied when the transform operation is copy, other operations
        are discarded, copy regions are ignored.
        """
    @staticmethod
    def register_custom_simple(name: str) -> MetaInfo:
        """
            Simplified version of `Gst.Meta.register_custom`, with no tags and no
        transform function.
        """
    def serialize(self, data: ByteArrayInterface) -> bool:
        """
            Serialize `meta` into a format that can be stored or transmitted and later
        deserialized by `Gst.Meta.deserialize`.

        This is only supported for meta that implements Gst.MetaInfo.serialize_func,
        False is returned otherwise.

        Upon failure, `data`->data pointer could have been reallocated, but `data`->len
        won't be modified. This is intended to be able to append multiple metas
        into the same GByteArray.

        Since serialization size is often the same for every buffer, caller may want
        to remember the size of previous data to preallocate the next.
        """
    def serialize_simple(self, data: list) -> bool:
        """
            Same as `Gst.Meta.serialize` but with a GByteArray instead of
        Gst.ByteArrayInterface.
        """

class MetaInfo(GObject.GPointer):
    """
    The Gst.MetaInfo provides information about a specific metadata
    structure.
    """

    # gi Fields
    api: GObject.GType = ...  # type: ignore
    """
    tag identifying the metadata structure and api
    """
    clear_func: MetaClearFunctionMetaInfoCB = ...
    """
    Function for clearing the metadata, or None if not supported by this
    meta. This is called by the buffer pool when a buffer is returned for
    pooled metas.
    """
    deserialize_func: MetaDeserializeFunctionMetaInfoCB | None = ...
    """
    Function for deserializing the metadata, or None if not supported by this
    meta.
    """
    free_func: MetaFreeFunctionMetaInfoCB = ...
    """
    function for freeing the metadata
    """
    init_func: MetaInitFunctionMetaInfoCB = ...
    """
    function for initializing the metadata
    """
    serialize_func: MetaSerializeFunctionMetaInfoCB = ...
    """
    Function for serializing the metadata, or None if not supported by this
    meta.
    """
    size: int = ...
    """
    size of the metadata
    """
    transform_func: MetaTransformFunctionMetaInfoCB = ...
    """
    function for transforming the metadata
    """
    type: GObject.GType = ...  # type: ignore
    """
    type identifying the implementor of the api
    """

    # gi Methods
    def is_custom(self) -> bool: ...
    def register(self) -> MetaInfo:
        """
            Registers a new meta.

        Use the structure returned by `Gst.MetaInfo.new`, it consumes it and the
        structure shouldnt be used after. The one returned by the function can be
        kept.
        """

class MetaTransformCopy(GObject.GPointer):
    """
    Extra data passed to a "gst-copy" transform Gst.MetaTransformFunction.
    """

    # gi Fields
    offset: int = ...
    """
    the offset to copy, 0 if `region` is False, otherwise > 0
    """
    region: bool = ...
    """
    True if only region is copied
    """
    size: int = ...
    """
    the size to copy, -1 or the buffer size when `region` is False
    """

class MiniObject(GObject.GBoxed):
    """
    Gst.MiniObject is a simple structure that can be used to implement refcounted
    types.

    Subclasses will include Gst.MiniObject as the first member in their structure
    and then call `Gst.MiniObject.init` to initialize the Gst.MiniObject fields.

    `Gst.MiniObject.ref` and `Gst.MiniObject.unref` increment and decrement the
    refcount respectively. When the refcount of a mini-object reaches 0, the
    dispose function is called first and when this returns True, the free
    function of the miniobject is called.

    A copy can be made with `Gst.MiniObject.copy`.

    `Gst.MiniObject.is_writable` will return True when the refcount of the
    object is exactly 1 and there is no parent or a single parent exists and is
    writable itself, meaning the current caller has the only reference to the
    object. `Gst.MiniObject.make_writable` will return a writable version of
    the object, which might be a new copy when the refcount was not 1.

    Opaque data can be associated with a Gst.MiniObject with
    `Gst.MiniObject.set_qdata` and `Gst.MiniObject.get_qdata`. The data is
    meant to be specific to the particular object and is not automatically copied
    with `Gst.MiniObject.copy` or similar methods.

    A weak reference can be added and remove with `Gst.MiniObject.weak_ref`
    and `Gst.MiniObject.weak_unref` respectively.
    """

    # gi Fields
    copy: MiniObjectCopyFunctionMiniObjectCB = ...
    """
    a copy function
    """
    dispose: MiniObjectDisposeFunctionMiniObjectCB = ...
    """
    a dispose function
    """
    flags: int = ...
    """
    extra flags.
    """
    free: MiniObjectFreeFunctionMiniObjectCB = ...
    """
    the free function
    """
    lockstate: int = ...
    """
    atomic state of the locks
    """
    @builtins.property
    def priv_pointer(self) -> object | None: ...
    @builtins.property
    def priv_uint(self) -> int: ...
    refcount: int = ...
    """
    atomic refcount
    """
    type: GObject.GType = ...  # type: ignore
    """
    the GType of the object
    """

    # gi Methods
    def add_parent(self, parent: MiniObject) -> None:
        """
            This adds `parent` as a parent for `object`. Having one ore more parents affects the
        writability of `object`: if a `parent` is not writable, `object` is also not
        writable, regardless of its refcount. `object` is only writable if all
        the parents are writable and its own refcount is exactly 1.

        Note: This function does not take ownership of `parent` and also does not
        take an additional reference. It is the responsibility of the caller to
        remove the parent again at a later time.
        """
    def get_qdata(self, quark: int) -> object | None:
        """
            This function gets back user data pointers stored via
        `Gst.MiniObject.set_qdata`.
        """
    def is_writable(self) -> bool:
        """
            If `mini_object` has the LOCKABLE flag set, check if the current EXCLUSIVE
        lock on `object` is the only one, this means that changes to the object will
        not be visible to any other object.

        If the LOCKABLE flag is not set, check if the refcount of `mini_object` is
        exactly 1, meaning that no other reference exists to the object and that the
        object is therefore writable.

        Modification of a mini-object should only be done after verifying that it
        is writable.
        """
    def lock(self, flags: LockFlags) -> bool:
        """
        Lock the mini-object with the specified access mode in `flags`.
        """
    def remove_parent(self, parent: MiniObject) -> None:
        """
            This removes `parent` as a parent for `object`. See
        `Gst.MiniObject.add_parent`.
        """
    @staticmethod
    def replace(olddata: MiniObject | None = None, newdata: MiniObject | None = None) -> tuple[bool, MiniObject | None]:
        """
            Atomically modifies a pointer to point to a new mini-object.
        The reference count of `olddata` is decreased and the reference count of
        `newdata` is increased.

        Either `newdata` and the value pointed to by `olddata` may be None.
        """
    def set_qdata(self, quark: int, data: object | None, destroy: GLib.DestroyNotify) -> None:
        """
            This sets an opaque, named pointer on a miniobject.
        The name is specified through a GQuark (retrieved e.g. via
        `g_quark_from_static_string`), and the pointer
        can be gotten back from the `object` with `Gst.MiniObject.get_qdata`
        until the `object` is disposed.
        Setting a previously set user data pointer, overrides (frees)
        the old pointer set, using None as pointer essentially
        removes the data stored.

        `destroy` may be specified which is called with `data` as argument
        when the `object` is disposed, or the data is being overwritten by
        a call to `Gst.MiniObject.set_qdata` with the same `quark`.
        """
    def steal_qdata(self, quark: int) -> object | None:
        """
            This function gets back user data pointers stored via `Gst.MiniObject.set_qdata`
        and removes the data from `object` without invoking its ``destroy`` function (if
        any was set).
        """
    @staticmethod
    def take(olddata: MiniObject, newdata: MiniObject) -> tuple[bool, MiniObject]:
        """
            Modifies a pointer to point to a new mini-object. The modification
        is done atomically. This version is similar to `Gst.MiniObject.replace`
        except that it does not increase the refcount of `newdata` and thus
        takes ownership of `newdata`.

        Either `newdata` and the value pointed to by `olddata` may be None.
        """
    def unlock(self, flags: LockFlags) -> None:
        """
        Unlock the mini-object with the specified access mode in `flags`.
        """

class NotInitialized(builtins.Exception): ...

class Object(GObject.InitiallyUnowned):
    """
    Gst.Object provides a root for the object hierarchy tree filed in by the
    GStreamer library.  It is currently a thin wrapper on top of
    GInitiallyUnowned. It is an abstract class that is not very usable on its own.

    Gst.Object gives us basic refcounting, parenting functionality and locking.
    Most of the functions are just extended for special GStreamer needs and can be
    found under the same name in the base class of Gst.Object which is GObject
    (e.g. `g_object_ref` becomes `Gst.Object.ref`).

    Since Gst.Object derives from GInitiallyUnowned, it also inherits the
    floating reference. Be aware that functions such as `Gst.Bin.add` and
    `Gst.Element.add_pad` take ownership of the floating reference.

    In contrast to GObject instances, Gst.Object adds a name property. The functions
    `Gst.Object.set_name` and `Gst.Object.get_name` are used to set/get the name
    of the object.

    ## controlled properties

    Controlled properties offers a lightweight way to adjust gobject properties
    over stream-time. It works by using time-stamped value pairs that are queued
    for element-properties. At run-time the elements continuously pull value
    changes for the current stream-time.

    What needs to be changed in a Gst.Element?
    Very little - it is just two steps to make a plugin controllable!

      * mark gobject-properties paramspecs that make sense to be controlled,
        by GST_PARAM_CONTROLLABLE.

      * when processing data (get, chain, loop function) at the beginning call
        gst_object_sync_values(element,timestamp).
        This will make the controller update all GObject properties that are
        under its control with the current values based on the timestamp.

    What needs to be done in applications? Again it's not a lot to change.

      * create a Gst.ControlSource.
        csource = gst_interpolation_control_source_new ();
        g_object_set (csource, "mode", GST_INTERPOLATION_MODE_LINEAR, None);

      * Attach the Gst.ControlSource on the controller to a property.
        gst_object_add_control_binding (object, gst_direct_control_binding_new (object, "prop1", csource));

      * Set the control values
        gst_timed_value_control_source_set ((GstTimedValueControlSource *)csource,0 * GST_SECOND, value1);
        gst_timed_value_control_source_set ((GstTimedValueControlSource *)csource,1 * GST_SECOND, value2);

      * start your pipeline
    """

    class Props(GObject.InitiallyUnowned.Props):
        name: str
        parent: Object | None
        """
        The parent of the object. Please note, that when changing the 'parent'
        property, we don't emit GObject::notify and Gst.Object::deep-notify
        signals due to locking issues. In some cases one can use
        Gst.Bin::element-added or Gst.Bin::element-removed signals on the parent to
        achieve a similar effect.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> object | None: ...
    @builtins.property
    def control_bindings(self) -> list | None: ...
    @builtins.property
    def control_rate(self) -> int: ...
    @builtins.property
    def flags(self) -> int:
        """
        flags for this object
        """
    @builtins.property
    def last_sync(self) -> int: ...
    @builtins.property
    def lock(self) -> GLib.Mutex | None:
        """
        object LOCK
        """
    @builtins.property
    def name(self) -> str:
        """
        The name of the object
        """
    @builtins.property
    def object(self) -> GObject.InitiallyUnowned | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize Object object with properties.
        """
    def add_control_binding(self, binding: ControlBinding) -> bool:
        """
            Attach the Gst.ControlBinding to the object. If there already was a
        Gst.ControlBinding for this property it will be replaced.

        The object's reference count will be incremented, and any floating
        reference will be removed (see `Gst.Object.ref_sink`)
        """
    @staticmethod
    def check_uniqueness(list: list, name: str) -> bool:
        """
            Checks to see if there is any object named `name` in `list`. This function
        does not do any locking of any kind. You might want to protect the
        provided list with the lock of the owner of the list. This function
        will lock each Gst.Object in the list to compare the name, so be
        careful when passing a list with a locked object.
        """
    @staticmethod
    def default_deep_notify(
        object: GObject.Object, orig: Object, pspec: GObject.ParamSpec, excluded_props: list | None = None
    ) -> None:
        """
            A default deep_notify signal callback for an object. The user data
        should contain a pointer to an array of strings that should be excluded
        from the notify. The default handler will print the new value of the property
        using g_print.

        MT safe. This function grabs and releases `object`'s LOCK for getting its
                 path string.
        """
    def default_error(self, error: GLib.Error, debug: str | None = None) -> None:
        """
            A default error function that uses `g_printerr` to display the error message
        and the optional debug string..

        The default handler will simply print the error string using g_print.
        """
    def get_control_binding(self, property_name: str) -> ControlBinding | None:
        """
            Gets the corresponding Gst.ControlBinding for the property. This should be
        unreferenced again after use.
        """
    def get_control_rate(self) -> int:
        """
            Obtain the control-rate for this `object`. Audio processing Gst.Element
        objects will use this rate to sub-divide their processing loop and call
        `Gst.Object.sync_values` in between. The length of the processing segment
        should be up to `control`-rate nanoseconds.

        If the `object` is not under property control, this will return
        Gst.CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.

        The control-rate is not expected to change if the element is in
        Gst.STATE_PAUSED or Gst.STATE_PLAYING.
        """
    def get_g_value_array(self, property_name: str, timestamp: int, interval: int, n_values: int, values: list) -> bool:
        """
            Gets a number of GValues for the given controlled property starting at the
        requested time. The array `values` need to hold enough space for `n_values` of
        GValue.

        This function is useful if one wants to e.g. draw a graph of the control
        curve or apply a control curve sample by sample.
        """
    @builtins.property
    def get_name(self) -> str | None:
        """
            Returns a copy of the name of `object`.
        Caller should `g_free` the return value after usage.
        For a nameless object, this returns None, which you can safely `g_free`
        as well.

        Free-function: g_free
        """
    @builtins.property
    def get_parent(self) -> Object | None:
        """
            Returns the parent of `object`. This function increases the refcount
        of the parent object so you should `Gst.Object.unref` it after usage.
        """
    def get_path_string(self) -> str:
        """
            Generates a string describing the path of `object` in
        the object hierarchy. Only useful (or used) for debugging.

        Free-function: g_free
        """
    def get_value(self, property_name: str, timestamp: int) -> GObject.Value | None:
        """
        Gets the value for the given controlled property at the requested time.
        """
    def has_active_control_bindings(self) -> bool:
        """
        Check if the `object` has active controlled properties.
        """
    @deprecated("deprecated")
    def has_ancestor(self, ancestor: Object) -> bool:
        """
            Check if `object` has an ancestor `ancestor` somewhere up in
        the hierarchy. One can e.g. check if a Gst.Element is inside a Gst.Pipeline.
        """
    def has_as_ancestor(self, ancestor: Object) -> bool:
        """
            Check if `object` has an ancestor `ancestor` somewhere up in
        the hierarchy. One can e.g. check if a Gst.Element is inside a Gst.Pipeline.
        """
    def has_as_parent(self, parent: Object) -> bool:
        """
            Check if `parent` is the parent of `object`.
        E.g. a Gst.Element can check if it owns a given Gst.Pad.
        """
    def ref(self) -> Object:
        """
            Increments the reference count on `object`. This function
        does not take the lock on `object` because it relies on
        atomic refcounting.

        This object returns the input parameter to ease writing
        constructs like :
         result = gst_object_ref (object->parent);
        """
    def remove_control_binding(self, binding: ControlBinding) -> bool:
        """
            Removes the corresponding Gst.ControlBinding. If it was the
        last ref of the binding, it will be disposed.
        """
    @staticmethod
    def replace(oldobj: Object | None = None, newobj: Object | None = None) -> tuple[bool, Object | None]:
        """
            Atomically modifies a pointer to point to a new object.
        The reference count of `oldobj` is decreased and the reference count of
        `newobj` is increased.

        Either `newobj` and the value pointed to by `oldobj` may be None.
        """
    def set_control_binding_disabled(self, property_name: str, disabled: bool) -> None:
        """
            This function is used to disable the control bindings on a property for
        some time, i.e. `Gst.Object.sync_values` will do nothing for the
        property.
        """
    def set_control_bindings_disabled(self, disabled: bool) -> None:
        """
            This function is used to disable all controlled properties of the `object` for
        some time, i.e. `Gst.Object.sync_values` will do nothing.
        """
    def set_control_rate(self, control_rate: int) -> None:
        """
            Change the control-rate for this `object`. Audio processing Gst.Element
        objects will use this rate to sub-divide their processing loop and call
        `Gst.Object.sync_values` in between. The length of the processing segment
        should be up to `control`-rate nanoseconds.

        The control-rate should not change if the element is in Gst.STATE_PAUSED or
        Gst.STATE_PLAYING.
        """
    def set_name(self, name: str | None = None) -> bool:
        """
            Sets the name of `object`, or gives `object` a guaranteed unique
        name (if `name` is None).
        This function makes a copy of the provided name, so the caller
        retains ownership of the name it sent.
        """
    def set_parent(self, parent: Object) -> bool:
        """
            Sets the parent of `object` to `parent`. The object's reference count will
        be incremented, and any floating reference will be removed (see `Gst.Object.ref_sink`).
        """
    def suggest_next_sync(self) -> int:
        """
            Returns a suggestion for timestamps where buffers should be split
        to get best controller results.
        """
    def sync_values(self, timestamp: int) -> bool:
        """
            Sets the properties of the object, according to the Gst.ControlSources that
        (maybe) handle them and for the given timestamp.

        If this function fails, it is most likely the application developers fault.
        Most probably the control sources are not setup correctly.
        """
    def unparent(self) -> None:
        """
            Clear the parent of `object`, removing the associated reference.
        This function decreases the refcount of `object`.

        MT safe. Grabs and releases `object`'s lock.
        """
    def unref(self) -> None:
        """
            Decrements the reference count on `object`.  If reference count hits
        zero, destroy `object`. This function does not take the lock
        on `object` as it relies on atomic refcounting.

        The unref method should never be called with the LOCK held since
        this might deadlock the dispose function.
        """

    # python methods (overrides?)
    def do_deep_notify(
        self,
        orig: Object,
        pspec: GObject.ParamSpec,
    ) -> None:
        """
        deep_notify(self, orig:Gst.Object, pspec:GObject.ParamSpec)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["deep-notify"],
        handler: typing.Callable[[typing_extensions.Self, Object, GObject.ParamSpec], None],
        *args: typing.Any,
    ) -> int:
        """
            The deep notify signal is used to be notified of property changes. It is
        typically attached to the toplevel bin to receive notifications from all
        the elements contained in that bin.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ObjectClass(GObject.GPointer):
    """
    GStreamer base object class.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def deep_notify(self) -> deep_notifyObjectClassCB:
        """
        default signal handler
        """
    @builtins.property
    def parent_class(self) -> GObject.InitiallyUnownedClass | None:
        """
        parent
        """
    @builtins.property
    def path_string_separator(self) -> str:
        """
        separator used by `Gst.Object.get_path_string`
        """

class Pad(Object):
    """
    A Gst.Element is linked to other elements via "pads", which are extremely
    light-weight generic link points.

    Pads have a Gst.PadDirection, source pads produce data, sink pads consume
    data.

    Pads are typically created from a Gst.PadTemplate with
    `Gst.Pad.new_from_template` and are then added to a Gst.Element. This usually
    happens when the element is created but it can also happen dynamically based
    on the data that the element is processing or based on the pads that the
    application requests.

    Pads without pad templates can be created with `Gst.Pad.new`,
    which takes a direction and a name as an argument.  If the name is None,
    then a guaranteed unique name will be assigned to it.

    A Gst.Element creating a pad will typically use the various
    gst_pad_set_*_function() calls to register callbacks for events, queries or
    dataflow on the pads.

    `Gst.Pad.get_parent` will retrieve the Gst.Element that owns the pad.

    After two pads are retrieved from an element by `Gst.Element.get_static_pad`,
    the pads can be linked with `Gst.Pad.link`. (For quick links,
    you can also use `Gst.Element.link`, which will make the obvious
    link for you if it's straightforward.). Pads can be unlinked again with
    `Gst.Pad.unlink`. `Gst.Pad.get_peer` can be used to check what the pad is
    linked to.

    Before dataflow is possible on the pads, they need to be activated with
    `Gst.Pad.set_active`.

    `Gst.Pad.query` and `Gst.Pad.peer_query` can be used to query various
    properties of the pad and the stream.

    To send a Gst.Event on a pad, use `Gst.Pad.send_event` and
    `Gst.Pad.push_event`. Some events will be sticky on the pad, meaning that
    after they pass on the pad they can be queried later with
    `Gst.Pad.get_sticky_event` and `Gst.Pad.sticky_events_foreach`.
    `Gst.Pad.get_current_caps` and `Gst.Pad.has_current_caps` are convenience
    functions to query the current sticky CAPS event on a pad.

    GstElements will use `Gst.Pad.push` and `Gst.Pad.pull_range` to push out
    or pull in a buffer.

    The dataflow, events and queries that happen on a pad can be monitored with
    probes that can be installed with `Gst.Pad.add_probe`. `Gst.Pad.is_blocked`
    can be used to check if a block probe is installed on the pad.
    `Gst.Pad.is_blocking` checks if the blocking probe is currently blocking the
    pad. `Gst.Pad.remove_probe` is used to remove a previously installed probe
    and unblock blocking probes if any.

    Pad have an offset that can be retrieved with `Gst.Pad.get_offset`. This
    offset will be applied to the running_time of all data passing over the pad.
    `Gst.Pad.set_offset` can be used to change the offset.

    Convenience functions exist to start, pause and stop the task on a pad with
    `Gst.Pad.start_task`, `Gst.Pad.pause_task` and `Gst.Pad.stop_task`
    respectively.
    """

    class Props(Object.Props):
        caps: Caps | None
        direction: PadDirection
        offset: int
        """
        The offset that will be applied to the running time of the pad.
        """
        template: PadTemplate | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def activatedata(self) -> object | None: ...
    @builtins.property
    def activatefunc(self) -> PadActivateFunctionPadCB: ...
    @builtins.property
    def activatemodedata(self) -> object | None: ...
    @builtins.property
    def activatemodefunc(self) -> PadActivateModeFunctionPadCB: ...
    @builtins.property
    def activatemodenotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def activatenotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def block_cond(self) -> GLib.Cond | None: ...
    @builtins.property
    def chaindata(self) -> object | None: ...
    @builtins.property
    def chainfunc(self) -> PadChainFunctionPadCB: ...
    @builtins.property
    def chainlistdata(self) -> object | None: ...
    @builtins.property
    def chainlistfunc(self) -> PadChainListFunctionPadCB: ...
    @builtins.property
    def chainlistnotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def chainnotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def element_private(self) -> object | None:
        """
        private data owned by the parent element
        """
    @builtins.property
    def eventdata(self) -> object | None: ...
    @builtins.property
    def eventfunc(self) -> PadEventFunctionPadCB: ...
    @builtins.property
    def eventnotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def getrangedata(self) -> object | None: ...
    @builtins.property
    def getrangefunc(self) -> PadGetRangeFunctionPadCB: ...
    @builtins.property
    def getrangenotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def iterintlinkdata(self) -> object | None: ...
    @builtins.property
    def iterintlinkfunc(self) -> PadIterIntLinkFunctionPadCB: ...
    @builtins.property
    def iterintlinknotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def linkdata(self) -> object | None: ...
    @builtins.property
    def linkfunc(self) -> PadLinkFunctionPadCB: ...
    @builtins.property
    def linknotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def mode(self) -> PadMode: ...
    @builtins.property
    def num_blocked(self) -> int: ...
    @builtins.property
    def num_probes(self) -> int: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def padtemplate(self) -> PadTemplate | None:
        """
        padtemplate for this pad
        """
    @builtins.property
    def peer(self) -> Pad | None: ...
    @builtins.property
    def priv(self) -> PadPrivate | None: ...
    @builtins.property
    def probes(self) -> GLib.HookList | None: ...
    @builtins.property
    def querydata(self) -> object | None: ...
    @builtins.property
    def queryfunc(self) -> PadQueryFunctionPadCB: ...
    @builtins.property
    def querynotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def stream_rec_lock(self) -> GLib.RecMutex | None: ...
    @builtins.property
    def task(self) -> Task | None: ...
    @builtins.property
    def unlinkdata(self) -> object | None: ...
    @builtins.property
    def unlinkfunc(self) -> PadUnlinkFunctionPadCB: ...
    @builtins.property
    def unlinknotify(self) -> GLib.DestroyNotify: ...

    # gi Methods
    def activate_mode(self, mode: PadMode, active: bool) -> bool:
        """
            Activates or deactivates the given pad in `mode` via dispatching to the
        pad's activatemodefunc. For use from within pad activation functions only.

        If you don't know what this is, you probably don't want to call it.
        """
    def add_probe(
        self,
        mask: PadProbeType,
        callback: PadProbeCallback | typing.Callable[..., PadProbeReturn],
        *user_data: object | None,
    ) -> int:
        """
            Be notified of different states of pads. The provided callback is called for
        every state that matches `mask`.

        Probes are called in groups: First GST_PAD_PROBE_TYPE_BLOCK probes are
        called, then others, then finally GST_PAD_PROBE_TYPE_IDLE. The only
        exception here are GST_PAD_PROBE_TYPE_IDLE probes that are called
        immediately if the pad is already idle while calling `Gst.Pad.add_probe`.
        In each of the groups, probes are called in the order in which they were
        added.
        """
    def can_link(self, sinkpad: Pad) -> bool:
        """
            Checks if the source pad and the sink pad are compatible so they can be
        linked.
        """
    def chain(self, buffer: Buffer) -> FlowReturn:
        """
            Chain a buffer to `pad`.

        The function returns GST_FLOW_FLUSHING if the pad was flushing.

        If the buffer type is not acceptable for `pad` (as negotiated with a
        preceding GST_EVENT_CAPS event), this function returns
        GST_FLOW_NOT_NEGOTIATED.

        The function proceeds calling the chain function installed on `pad` (see
        `Gst.Pad.set_chain_function`) and the return value of that function is
        returned to the caller. GST_FLOW_NOT_SUPPORTED is returned if `pad` has no
        chain function.

        In all cases, success or failure, the caller loses its reference to `buffer`
        after calling this function.
        """
    def chain_list(self, list: BufferList) -> FlowReturn:
        """
            Chain a bufferlist to `pad`.

        The function returns GST_FLOW_FLUSHING if the pad was flushing.

        If `pad` was not negotiated properly with a CAPS event, this function
        returns GST_FLOW_NOT_NEGOTIATED.

        The function proceeds calling the chainlist function installed on `pad` (see
        `Gst.Pad.set_chain_list_function`) and the return value of that function is
        returned to the caller. GST_FLOW_NOT_SUPPORTED is returned if `pad` has no
        chainlist function.

        In all cases, success or failure, the caller loses its reference to `list`
        after calling this function.

        MT safe.
        """
    def check_reconfigure(self) -> bool:
        """
            Check and clear the GST_PAD_FLAG_NEED_RECONFIGURE flag on `pad` and return True
        if the flag was set.
        """
    def create_stream_id(self, parent: Element, stream_id: str | None = None) -> str:
        """
            Creates a stream-id for the source Gst.Pad `pad` by combining the
        upstream information with the optional `stream_id` of the stream
        of `pad`. `pad` must have a parent Gst.Element and which must have zero
        or one sinkpad. `stream_id` can only be None if the parent element
        of `pad` has only a single source pad.

        This function generates an unique stream-id by getting the upstream
        stream-start event stream ID and appending `stream_id` to it. If the
        element has no sinkpad it will generate an upstream stream-id by
        doing an URI query on the element and in the worst case just uses
        a random number. Source elements that don't implement the URI
        handler interface should ideally generate a unique, deterministic
        stream-id manually instead.

        Since stream IDs are sorted alphabetically, any numbers in the
        stream ID should be printed with a fixed number of characters,
        preceded by 0's, such as by using the format \\03u instead of %u.
        """
    def event_default(self, parent: Object | None, event: Event) -> bool:
        """
            Invokes the default event handler for the given pad.

        The EOS event will pause the task associated with `pad` before it is forwarded
        to all internally linked pads,

        The event is sent to all pads internally linked to `pad`. This function
        takes ownership of `event`.
        """
    def forward(self, forward: PadForwardFunction, *user_data: object | None) -> bool:
        """
            Calls `forward` for all internally linked pads of `pad`. This function deals with
        dynamically changing internal pads and will make sure that the `forward`
        function is only called once for each pad.

        When `forward` returns True, no further pads will be processed.
        """
    def get_allowed_caps(self) -> Caps | None:
        """
            Gets the capabilities of the allowed media types that can flow through
        `pad` and its peer.

        The allowed capabilities is calculated as the intersection of the results of
        calling `Gst.Pad.query_caps` on `pad` and its peer. The caller owns a reference
        on the resulting caps.
        """
    def get_current_caps(self) -> Caps | None:
        """
            Gets the capabilities currently configured on `pad` with the last
        GST_EVENT_CAPS event.
        """
    @builtins.property
    def get_direction(self) -> PadDirection:
        """
            Gets the direction of the pad. The direction of the pad is
        decided at construction time so this function does not take
        the LOCK.
        """
    def get_element_private(self) -> object | None:
        """
            Gets the private data of a pad.
        No locking is performed in this function.
        """
    def get_last_flow_return(self) -> FlowReturn:
        """
        Gets the Gst.FlowReturn return from the last data passed by this pad.
        """
    @builtins.property
    def get_offset(self) -> int:
        """
            Get the offset applied to the running time of `pad`. `pad` has to be a source
        pad.
        """
    def get_pad_template(self) -> PadTemplate | None:
        """
        Gets the template for `pad`.
        """
    def get_pad_template_caps(self) -> Caps:
        """
        Gets the capabilities for `pad`'s template.
        """
    def get_parent_element(self) -> Element | None:
        """
            Gets the parent of `pad`, cast to a Gst.Element. If a `pad` has no parent or
        its parent is not an element, return None.
        """
    def get_peer(self) -> Pad | None:
        """
            Gets the peer of `pad`. This function refs the peer pad so
        you need to unref it after use.
        """
    def get_range(self, offset: int, size: int) -> tuple[FlowReturn, Buffer]:
        """
            When `pad` is flushing this function returns GST_FLOW_FLUSHING
        immediately and `buffer` is None.

        Calls the getrange function of `pad`, see Gst.PadGetRangeFunction for a
        description of a getrange function. If `pad` has no getrange function
        installed (see `Gst.Pad.set_getrange_function`) this function returns
        GST_FLOW_NOT_SUPPORTED.

        If `buffer` points to a variable holding None, a valid new Gst.Buffer will be
        placed in `buffer` when this function returns GST_FLOW_OK. The new buffer
        must be freed with `Gst.Buffer.unref` after usage.

        When `buffer` points to a variable that points to a valid Gst.Buffer, the
        buffer will be filled with the result data when this function returns
        GST_FLOW_OK. If the provided buffer is larger than `size`, only
        `size` bytes will be filled in the result buffer and its size will be updated
        accordingly.

        Note that less than `size` bytes can be returned in `buffer` when, for example,
        an EOS condition is near or when `buffer` is not large enough to hold `size`
        bytes. The caller should check the result buffer size to get the result size.

        When this function returns any other result value than GST_FLOW_OK, `buffer`
        will be unchanged.

        This is a lowlevel function. Usually `Gst.Pad.pull_range` is used.
        """
    def get_single_internal_link(self) -> Pad | None:
        """
            If there is a single internal link of the given pad, this function will
        return it. Otherwise, it will return None.
        """
    def get_sticky_event(self, event_type: EventType, idx: int) -> Event | None:
        """
            Returns a new reference of the sticky event of type `event_type`
        from the event.
        """
    def get_stream(self) -> Stream | None:
        """
            Returns the current Gst.Stream for the `pad`, or None if none has been
        set yet, i.e. the pad has not received a stream-start event yet.

        This is a convenience wrapper around `Gst.Pad.get_sticky_event` and
        `Gst.Event.parse_stream`.
        """
    def get_stream_id(self) -> str | None:
        """
            Returns the current stream-id for the `pad`, or None if none has been
        set yet, i.e. the pad has not received a stream-start event yet.

        This is a convenience wrapper around `Gst.Pad.get_sticky_event` and
        `Gst.Event.parse_stream_start`.

        The returned stream-id string should be treated as an opaque string, its
        contents should not be interpreted.
        """
    def get_task_state(self) -> TaskState:
        """
            Get `pad` task state. If no task is currently
        set, GST_TASK_STOPPED is returned.
        """
    def has_current_caps(self) -> bool:
        """
        Check if `pad` has caps set on it with a GST_EVENT_CAPS event.
        """
    def is_active(self) -> bool:
        """
        Query if a pad is active
        """
    def is_blocked(self) -> bool:
        """
            Checks if the pad is blocked or not. This function returns the
        last requested state of the pad. It is not certain that the pad
        is actually blocking at this point (see `Gst.Pad.is_blocking`).
        """
    def is_blocking(self) -> bool:
        """
            Checks if the pad is blocking or not. This is a guaranteed state
        of whether the pad is actually blocking on a Gst.Buffer or a Gst.Event.
        """
    def is_linked(self) -> bool:
        """
        Checks if a `pad` is linked to another pad or not.
        """
    def iterate_internal_links(self) -> Iterator | None:
        """
            Gets an iterator for the pads to which the given pad is linked to inside
        of the parent element.

        Each Gst.Pad element yielded by the iterator will have its refcount increased,
        so unref after use.

        Free-function: gst_iterator_free
        """
    def iterate_internal_links_default(self, parent: Object | None = None) -> Iterator | None:
        """
            Iterate the list of pads to which the given pad is linked to inside of
        the parent element.
        This is the default handler, and thus returns an iterator of all of the
        pads inside the parent element with opposite direction.

        The caller must free this iterator after use with `Gst.Iterator.free`.
        """
    def link_full(self, sinkpad: Pad, flags: PadLinkCheck) -> PadLinkReturn:
        """
            Links the source pad and the sink pad.

        This variant of #gst_pad_link provides a more granular control on the
        checks being done when linking. While providing some considerable speedups
        the caller of this method must be aware that wrong usage of those flags
        can cause severe issues. Refer to the documentation of Gst.PadLinkCheck
        for more information.

        MT Safe.
        """
    @staticmethod
    def link_get_name(ret: PadLinkReturn) -> str:
        """
        Gets a string representing the given pad-link return.
        """
    def link_maybe_ghosting(self, sink: Pad) -> bool:
        """
            Links `src` to `sink`, creating any Gst.GhostPad's in between as necessary.

        This is a convenience function to save having to create and add intermediate
        Gst.GhostPad's as required for linking across Gst.Bin boundaries.

        If `src` or `sink` pads don't have parent elements or do not share a common
        ancestor, the link will fail.
        """
    def link_maybe_ghosting_full(self, sink: Pad, flags: PadLinkCheck) -> bool:
        """
            Links `src` to `sink`, creating any Gst.GhostPad's in between as necessary.

        This is a convenience function to save having to create and add intermediate
        Gst.GhostPad's as required for linking across Gst.Bin boundaries.

        If `src` or `sink` pads don't have parent elements or do not share a common
        ancestor, the link will fail.

        Calling `Gst.Pad.link_maybe_ghosting_full` with
        `flags` == Gst.PAD_LINK_CHECK_DEFAULT is the recommended way of linking
        pads with safety checks applied.
        """
    def mark_reconfigure(self) -> None:
        """
            Mark a pad for needing reconfiguration. The next call to
        `Gst.Pad.check_reconfigure` will return True after this call.
        """
    def needs_reconfigure(self) -> bool:
        """
            Check the GST_PAD_FLAG_NEED_RECONFIGURE flag on `pad` and return True
        if the flag was set.
        """
    @classmethod
    def new(cls, name: str | None, direction: PadDirection) -> Pad:
        """
            Creates a new pad with the given name in the given direction.
        If name is None, a guaranteed unique name (across all pads)
        will be assigned.
        This function makes a copy of the name so you can safely free the name.
        """
    @classmethod
    def new_from_static_template(cls, templ: StaticPadTemplate, name: str) -> Pad:
        """
            Creates a new pad with the given name from the given static template.
        If name is None, a guaranteed unique name (across all pads)
        will be assigned.
        This function makes a copy of the name so you can safely free the name.
        """
    @classmethod
    def new_from_template(cls, templ: PadTemplate, name: str | None = None) -> Pad:
        """
            Creates a new pad with the given name from the given template.
        If name is None, a guaranteed unique name (across all pads)
        will be assigned.
        This function makes a copy of the name so you can safely free the name.
        """
    def pause_task(self) -> bool:
        """
            Pause the task of `pad`. This function will also wait until the
        function executed by the task is finished if this function is not
        called from the task function.
        """
    def peer_query(self, query: Query) -> bool:
        """
            Performs `Gst.Pad.query` on the peer of `pad`.

        The caller is responsible for both the allocation and deallocation of
        the query structure.
        """
    def peer_query_accept_caps(self, caps: Caps) -> bool:
        """
            Check if the peer of `pad` accepts `caps`. If `pad` has no peer, this function
        returns True.
        """
    def peer_query_caps(self, filter: Caps | None = None) -> Caps:
        """
            Gets the capabilities of the peer connected to this pad. Similar to
        `Gst.Pad.query_caps`.

        When called on srcpads `filter` contains the caps that
        upstream could produce in the order preferred by upstream. When
        called on sinkpads `filter` contains the caps accepted by
        downstream in the preferred order. `filter` might be None but
        if it is not None the returned caps will be a subset of `filter`.
        """
    def peer_query_convert(self, src_format: Format, src_val: int, dest_format: Format) -> tuple[bool, int]:
        """
            Queries the peer pad of a given sink pad to convert `src_val` in `src_format`
        to `dest_format`.
        """
    def peer_query_duration(self, format: Format) -> tuple[bool, int]:
        """
        Queries the peer pad of a given sink pad for the total stream duration.
        """
    def peer_query_position(self, format: Format) -> tuple[bool, int]:
        """
        Queries the peer of a given sink pad for the stream position.
        """
    def proxy_query_accept_caps(self, query: Query) -> bool:
        """
            Checks if all internally linked pads of `pad` accepts the caps in `query` and
        returns the intersection of the results.

        This function is useful as a default accept caps query function for an element
        that can handle any stream format, but requires caps that are acceptable for
        all opposite pads.
        """
    def proxy_query_caps(self, query: Query) -> bool:
        """
            Calls `Gst.Pad.query_caps` for all internally linked pads of `pad` and returns
        the intersection of the results.

        This function is useful as a default caps query function for an element
        that can handle any stream format, but requires all its pads to have
        the same caps.  Two such elements are tee and adder.
        """
    def pull_range(self, offset: int, size: int) -> tuple[FlowReturn, Buffer]:
        """
            Pulls a `buffer` from the peer pad or fills up a provided buffer.

        This function will first trigger the pad block signal if it was
        installed.

        When `pad` is not linked GST_FLOW_NOT_LINKED is returned else this
        function returns the result of `Gst.Pad.get_range` on the peer pad.
        See `Gst.Pad.get_range` for a list of return values and for the
        semantics of the arguments of this function.

        If `buffer` points to a variable holding None, a valid new Gst.Buffer will be
        placed in `buffer` when this function returns GST_FLOW_OK. The new buffer
        must be freed with `Gst.Buffer.unref` after usage. When this function
        returns any other result value, `buffer` will still point to None.

        When `buffer` points to a variable that points to a valid Gst.Buffer, the
        buffer will be filled with the result data when this function returns
        GST_FLOW_OK. When this function returns any other result value,
        `buffer` will be unchanged. If the provided buffer is larger than `size`, only
        `size` bytes will be filled in the result buffer and its size will be updated
        accordingly.

        Note that less than `size` bytes can be returned in `buffer` when, for example,
        an EOS condition is near or when `buffer` is not large enough to hold `size`
        bytes. The caller should check the result buffer size to get the result size.
        """
    def push(self, buffer: Buffer) -> FlowReturn:
        """
            Pushes a buffer to the peer of `pad`.

        This function will call installed block probes before triggering any
        installed data probes.

        The function proceeds calling `Gst.Pad.chain` on the peer pad and returns
        the value from that function. If `pad` has no peer, GST_FLOW_NOT_LINKED will
        be returned.

        In all cases, success or failure, the caller loses its reference to `buffer`
        after calling this function.
        """
    def push_event(self, event: Event) -> bool:
        """
            Sends the event to the peer of the given pad. This function is
        mainly used by elements to send events to their peer
        elements.

        This function takes ownership of the provided event so you should
        `Gst.Event.ref` it if you want to reuse the event after this call.
        """
    def push_list(self, list: BufferList) -> FlowReturn:
        """
            Pushes a buffer list to the peer of `pad`.

        This function will call installed block probes before triggering any
        installed data probes.

        The function proceeds calling the chain function on the peer pad and returns
        the value from that function. If `pad` has no peer, GST_FLOW_NOT_LINKED will
        be returned. If the peer pad does not have any installed chainlist function
        every group buffer of the list will be merged into a normal Gst.Buffer and
        chained via `Gst.Pad.chain`.

        In all cases, success or failure, the caller loses its reference to `list`
        after calling this function.
        """
    def query(self, query: Query) -> bool:
        """
            Dispatches a query to a pad. The query should have been allocated by the
        caller via one of the type-specific allocation functions. The element that
        the pad belongs to is responsible for filling the query with an appropriate
        response, which should then be parsed with a type-specific query parsing
        function.

        Again, the caller is responsible for both the allocation and deallocation of
        the query structure.

        Please also note that some queries might need a running pipeline to work.
        """
    def query_accept_caps(self, caps: Caps) -> bool:
        """
        Check if the given pad accepts the caps.
        """
    def query_convert(self, src_format: Format, src_val: int, dest_format: Format) -> tuple[bool, int]:
        """
        Queries a pad to convert `src_val` in `src_format` to `dest_format`.
        """
    def query_default(self, parent: Object | None, query: Query) -> bool:
        """
            Invokes the default query handler for the given pad.
        The query is sent to all pads internally linked to `pad`. Note that
        if there are many possible sink pads that are internally linked to
        `pad`, only one will be sent the query.
        Multi-sinkpad elements should implement custom query handlers.
        """
    def query_duration(self, format: Format) -> tuple[bool, int]:
        """
        Queries a pad for the total stream duration.
        """
    def query_position(self, format: Format) -> tuple[bool, int]:
        """
        Queries a pad for the stream position.
        """
    def remove_probe(self, id: int) -> None:
        """
            Remove the probe with `id` from `pad`.

        MT safe.
        """
    def send_event(self, event: Event) -> bool:
        """
            Sends the event to the pad. This function can be used
        by applications to send events in the pipeline.

        If `pad` is a source pad, `event` should be an upstream event. If `pad` is a
        sink pad, `event` should be a downstream event. For example, you would not
        send a GST_EVENT_EOS on a src pad; EOS events only propagate downstream.
        Furthermore, some downstream events have to be serialized with data flow,
        like EOS, while some can travel out-of-band, like GST_EVENT_FLUSH_START. If
        the event needs to be serialized with data flow, this function will take the
        pad's stream lock while calling its event function.

        To find out whether an event type is upstream, downstream, or downstream and
        serialized, see Gst.EventTypeFlags, `Gst.Event.type_get_flags`,
        GST_EVENT_IS_UPSTREAM, GST_EVENT_IS_DOWNSTREAM, and
        GST_EVENT_IS_SERIALIZED. Note that in practice that an application or
        plugin doesn't need to bother itself with this information; the core handles
        all necessary locks and checks.

        This function takes ownership of the provided event so you should
        `Gst.Event.ref` it if you want to reuse the event after this call.
        """
    def set_activate_function_full(self, activate: PadActivateFunction, *user_data: object | None) -> None:
        """
            Sets the given activate function for `pad`. The activate function will
        dispatch to `Gst.Pad.activate_mode` to perform the actual activation.
        Only makes sense to set on sink pads.

        Call this function if your sink pad can start a pull-based task.
        """
    def set_activatemode_function_full(self, activatemode: PadActivateModeFunction, *user_data: object | None) -> None:
        """
            Sets the given activate_mode function for the pad. An activate_mode function
        prepares the element for data passing.
        """
    def set_active(self, active: bool) -> bool:
        """
            Activates or deactivates the given pad.
        Normally called from within core state change functions.

        If `active`, makes sure the pad is active. If it is already active, either in
        push or pull mode, just return. Otherwise dispatches to the pad's activate
        function to perform the actual activation.

        If not `active`, calls `Gst.Pad.activate_mode` with the pad's current mode
        and a False argument.
        """
    def set_chain_function_full(
        self, chain: PadChainFunction | typing.Callable[..., FlowReturn], *user_data: object | None
    ) -> None:
        """
            Sets the given chain function for the pad. The chain function is called to
        process a Gst.Buffer input buffer. see Gst.PadChainFunction for more details.
        """
    def set_chain_list_function_full(
        self, chainlist: PadChainListFunction | typing.Callable[..., FlowReturn], *user_data: object | None
    ) -> None:
        """
            Sets the given chain list function for the pad. The chainlist function is
        called to process a Gst.BufferList input buffer list. See
        Gst.PadChainListFunction for more details.
        """
    def set_element_private(self, priv: object | None = None) -> None:
        """
            Set the given private data gpointer on the pad.
        This function can only be used by the element that owns the pad.
        No locking is performed in this function.
        """
    def set_event_full_function_full(
        self, event: PadEventFullFunction | typing.Callable[..., FlowReturn], *user_data: object | None
    ) -> None:
        """
        Sets the given event handler for the pad.
        """
    def set_event_function_full(self, event: PadEventFunction, *user_data: object | None) -> None:
        """
        Sets the given event handler for the pad.
        """
    def set_getrange_function_full(
        self, get: PadGetRangeFunction | typing.Callable[..., FlowReturn], *user_data: object | None
    ) -> None:
        """
            Sets the given getrange function for the pad. The getrange function is
        called to produce a new Gst.Buffer to start the processing pipeline. see
        Gst.PadGetRangeFunction for a description of the getrange function.
        """
    def set_iterate_internal_links_function_full(
        self, iterintlink: PadIterIntLinkFunction | typing.Callable[..., Iterator], *user_data: object | None
    ) -> None:
        """
        Sets the given internal link iterator function for the pad.
        """
    def set_link_function_full(
        self, link: PadLinkFunction | typing.Callable[..., PadLinkReturn], *user_data: object | None
    ) -> None:
        """
            Sets the given link function for the pad. It will be called when
        the pad is linked with another pad.

        The return value GST_PAD_LINK_OK should be used when the connection can be
        made.

        The return value GST_PAD_LINK_REFUSED should be used when the connection
        cannot be made for some reason.

        If `link` is installed on a source pad, it should call the Gst.PadLinkFunction
        of the peer sink pad, if present.
        """
    def set_offset(self, offset: int) -> None:
        """
            Set the offset that will be applied to the running time of `pad`. Upon next
        buffer, every sticky events (notably segment) will be pushed again with
        their running time adjusted. For that reason this is only reliable on
        source pads.
        """
    def set_query_function_full(self, query: PadQueryFunction, *user_data: object | None) -> None:
        """
        Set the given query function for the pad.
        """
    def set_unlink_function_full(self, unlink: PadUnlinkFunction, *user_data: object | None) -> None:
        """
            Sets the given unlink function for the pad. It will be called
        when the pad is unlinked.

        Note that the pad's lock is already held when the unlink
        function is called, so most pad functions cannot be called
        from within the callback.
        """
    def start_task(self, func: TaskFunction, *user_data: object | None) -> bool:
        """
            Starts a task that repeatedly calls `func` with `user_data`. This function
        is mostly used in pad activation functions to start the dataflow.
        The GST_PAD_STREAM_LOCK of `pad` will automatically be acquired
        before `func` is called.
        """
    def sticky_events_foreach(self, foreach_func: PadStickyEventsForeachFunction, *user_data: object | None) -> None:
        """
            Iterates all sticky events on `pad` and calls `foreach_func` for every
        event. If `foreach_func` returns False the iteration is immediately stopped.
        """
    def stop_task(self) -> bool:
        """
            Stop the task of `pad`. This function will also make sure that the
        function executed by the task will effectively stop if not called
        from the GstTaskFunction.

        This function will deadlock if called from the GstTaskFunction of
        the task. Use `Gst.Task.pause` instead.

        Regardless of whether the pad has a task, the stream lock is acquired and
        released so as to ensure that streaming through this pad has finished.
        """
    def store_sticky_event(self, event: Event) -> FlowReturn:
        """
        Store the sticky `event` on `pad`
        """
    def unlink(self, sinkpad: Pad) -> bool:
        """
            Unlinks the source pad from the sink pad. Will emit the Gst.Pad::unlinked
        signal on both pads.
        """
    def use_fixed_caps(self) -> None:
        """
            A helper function you can use that sets the FIXED_CAPS flag
        This way the default CAPS query will always return the negotiated caps
        or in case the pad is not negotiated, the padtemplate caps.

        The negotiated caps are the caps of the last CAPS event that passed on the
        pad. Use this function on a pad that, once it negotiated to a CAPS, cannot
        be renegotiated to something else.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    def link(
        self,
        pad: typing.Any,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        link(self, sinkpad:Gst.Pad) -> Gst.PadLinkReturn
        """
    def query_caps(
        self,
        filter: typing.Any = None,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        query_caps(self, filter:Gst.Caps=None) -> Gst.Caps
        """
    def set_caps(
        self,
        caps: typing.Any,
    ) -> typing.Any: ...
    def set_chain_function(
        self,
        func: typing.Any,
    ) -> typing.Any: ...
    def set_event_function(
        self,
        func: typing.Any,
    ) -> typing.Any: ...
    def set_query_function(
        self,
        func: typing.Any,
    ) -> typing.Any: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["linked"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int:
        """
        Signals that a pad has been linked to the peer pad.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["unlinked"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int:
        """
        Signals that a pad has been unlinked from the peer pad.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::direction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::offset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::template"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PadClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def linked(self) -> linkedPadClassCB: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def unlinked(self) -> unlinkedPadClassCB: ...

class PadPrivate(GObject.GPointer): ...

class PadProbeInfo(GObject.GPointer):
    """
    Info passed in the Gst.PadProbeCallback.
    """

    # gi Fields
    data: object | None = ...
    """
    type specific data, check the `type` field to know the
       datatype.  This field can be None.
    """
    id: int = ...
    """
    the id of the probe
    """
    offset: int = ...
    """
    offset of pull probe, this field is valid when `type` contains
       GST_PAD_PROBE_TYPE_PULL
    """
    size: int = ...
    """
    size of pull probe, this field is valid when `type` contains
       GST_PAD_PROBE_TYPE_PULL
    """
    type: PadProbeType = ...
    """
    the current probe type
    """

    # gi Methods
    def get_buffer(self) -> Buffer | None: ...
    def get_buffer_list(self) -> BufferList | None: ...
    def get_event(self) -> Event | None: ...
    def get_query(self) -> Query | None: ...

class PadTemplate(Object):
    """
    Padtemplates describe the possible media types a pad or an elementfactory can
    handle. This allows for both inspection of handled types before loading the
    element plugin as well as identifying pads on elements that are not yet
    created (request or sometimes pads).

    Pad and PadTemplates have Gst.Caps attached to it to describe the media type
    they are capable of dealing with. `Gst.PadTemplate.get_caps` or
    `GST_PAD_TEMPLATE_CAPS` are used to get the caps of a padtemplate. It's not
    possible to modify the caps of a padtemplate after creation.

    PadTemplates have a Gst.PadPresence property which identifies the lifetime
    of the pad and that can be retrieved with `GST_PAD_TEMPLATE_PRESENCE`. Also
    the direction of the pad can be retrieved from the Gst.PadTemplate with
    `GST_PAD_TEMPLATE_DIRECTION`.

    The GST_PAD_TEMPLATE_NAME_TEMPLATE () is important for GST_PAD_REQUEST pads
    because it has to be used as the name in the `Gst.Element.request_pad_simple`
    call to instantiate a pad from this template.

    Padtemplates can be created with `Gst.PadTemplate.new` or with
    gst_static_pad_template_get (), which creates a Gst.PadTemplate from a
    Gst.StaticPadTemplate that can be filled with the
    convenient `GST_STATIC_PAD_TEMPLATE` macro.

    A padtemplate can be used to create a pad (see `Gst.Pad.new_from_template`
    or gst_pad_new_from_static_template ()) or to add to an element class
    (see gst_element_class_add_static_pad_template ()).

    The following code example shows the code to create a pad from a padtemplate.
    |[<!-- language="C" -->
      GstStaticPadTemplate my_template =
      GST_STATIC_PAD_TEMPLATE (
        "sink",          // the name of the pad
        GST_PAD_SINK,    // the direction of the pad
        GST_PAD_ALWAYS,  // when this pad will be present
        GST_STATIC_CAPS (        // the capabilities of the padtemplate
          "audio/x-raw, "
            "channels = (int) [ 1, 6 ]"
        )
      );
      void
      my_method (void)
      {
        GstPad *pad;
        pad = gst_pad_new_from_static_template (&my_template, "sink");
        ...
      }
    ]|

    The following example shows you how to add the padtemplate to an
    element class, this is usually done in the class_init of the class:
    |[<!-- language="C" -->
      static void
      my_element_class_init (GstMyElementClass *klass)
      {
        GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);

        gst_element_class_add_static_pad_template (gstelement_class, &my_template);
      }
    ]|
    """

    class Props(Object.Props):
        caps: Caps | None
        """
        The capabilities of the pad described by the pad template.
        """
        direction: PadDirection
        """
        The direction of the pad described by the pad template.
        """
        gtype: GObject.GType
        """
        The type of the pad described by the pad template.
        """
        name_template: str  # [name-template]: changed because contained invalid characters
        """
        The name template of the pad template.
        """
        presence: PadPresence
        """
        When the pad described by the pad template will become available.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def caps(self) -> Caps | None: ...
    @builtins.property
    def direction(self) -> PadDirection: ...
    @builtins.property
    def name_template(self) -> str: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def presence(self) -> PadPresence: ...

    # gi Methods
    def __init__(
        self,
        caps: Caps | None = None,
        direction: PadDirection | None = PadDirection.UNKNOWN,
        gtype: GObject.GType | None = None,
        name: str | None = None,
        name_template: str | None = None,
        parent: Object | None = None,
        presence: PadPresence | None = PadPresence.ALWAYS,
    ) -> None:
        """
        Initialize PadTemplate object with properties.
        """
    @builtins.property
    def get_caps(self) -> Caps:
        """
        Gets the capabilities of the pad template.
        """
    def get_documentation_caps(self) -> Caps:
        """
        See `Gst.PadTemplate.set_documentation_caps`.
        """
    def pad_created(self, pad: Pad) -> None:
        """
        Emit the pad-created signal for this template when created by this pad.
        """
    def set_documentation_caps(self, caps: Caps) -> None:
        """
            Certain elements will dynamically construct the caps of their
        pad templates. In order not to let environment-specific information
        into the documentation, element authors should use this method to
        expose "stable" caps to the reader.
        """

    # python methods (overrides?)
    def do_pad_created(
        self,
        pad: Pad,
    ) -> None:
        """
        pad_created(self, pad:Gst.Pad)
        """
    @classmethod
    def new(
        cls,
        name_template: str,
        direction: PadDirection,
        presence: PadPresence,
        caps: Caps,
    ) -> PadTemplate | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(name_template:str, direction:Gst.PadDirection, presence:Gst.PadPresence, caps:Gst.Caps) -> Gst.PadTemplate or None
        """
    @classmethod
    def new_from_static_pad_template_with_gtype(
        cls,
        pad_template: StaticPadTemplate,
        pad_type: GObject.GType,
    ) -> PadTemplate | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_static_pad_template_with_gtype(pad_template:Gst.StaticPadTemplate, pad_type:GType) -> Gst.PadTemplate or None
        """
    @classmethod
    def new_with_gtype(
        cls,
        name_template: str,
        direction: PadDirection,
        presence: PadPresence,
        caps: Caps,
        pad_type: GObject.GType,
    ) -> PadTemplate | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_with_gtype(name_template:str, direction:Gst.PadDirection, presence:Gst.PadPresence, caps:Gst.Caps, pad_type:GType) -> Gst.PadTemplate or None
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pad-created"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int:
        """
        This signal is fired when an element creates a pad from this template.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::direction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtype"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name_template"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::presence"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PadTemplateClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def pad_created(self) -> pad_createdPadTemplateClassCB: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...

class ParamArray(GObject.ParamSpec):
    """
    A fundamental type that describes a GParamSpec for arrays of
    values
    """

    ...

class ParamFraction(GObject.ParamSpec):
    """
    A fundamental type that describes a GParamSpec for fractional
    properties
    """

    ...

class ParamSpecArray(GObject.GPointer):
    """
    A GParamSpec derived structure for arrays of values.
    """

    # gi Fields
    element_spec: GObject.ParamSpec | None = ...  # type: ignore
    """
    the GParamSpec of the type of values in the array
    """
    parent_instance: GObject.ParamSpec | None = ...  # type: ignore
    """
    super class
    """

class ParamSpecFraction(GObject.GPointer):
    """
    A GParamSpec derived structure that contains the meta data for fractional
    properties.
    """

    # gi Fields
    def_den: int = ...
    """
    default denominator
    """
    def_num: int = ...
    """
    default numerator
    """
    max_den: int = ...
    """
    maximal denominator
    """
    max_num: int = ...
    """
    maximal numerator
    """
    min_den: int = ...
    """
    minimal denominator
    """
    min_num: int = ...
    """
    minimal numerator
    """
    parent_instance: GObject.ParamSpec | None = ...  # type: ignore
    """
    super class
    """

class ParentBufferMeta(GObject.GPointer):
    """
    The Gst.ParentBufferMeta is a Gst.Meta which can be attached to a Gst.Buffer
    to hold a reference to another buffer that is only released when the child
    Gst.Buffer is released.

    Typically, Gst.ParentBufferMeta is used when the child buffer is directly
    using the Gst.Memory of the parent buffer, and wants to prevent the parent
    buffer from being returned to a buffer pool until the Gst.Memory is available
    for re-use.
    """

    # gi Fields
    buffer: Buffer | None = ...
    """
    the Gst.Buffer on which a reference is being held.
    """
    parent: Meta | None = ...
    """
    the parent Gst.Meta structure
    """

    # gi Methods
    @staticmethod
    def get_info() -> MetaInfo:
        """
        Gets the global Gst.MetaInfo describing  the Gst.ParentBufferMeta meta.
        """

class ParseContext(GObject.GBoxed):
    """
    Opaque structure.
    """

    # gi Methods
    def copy(self) -> ParseContext | None:
        """
        Copies the `context`.
        """
    def free(self) -> None:
        """
        Frees a parse context previously allocated with `Gst.ParseContext.new`.
        """
    def get_missing_elements(self) -> list | None:
        """
            Retrieve missing elements from a previous run of `Gst.parse_launch_full`
        or `Gst.parse_launchv_full`. Will only return results if an error code
        of Gst.PARSE_ERROR_NO_SUCH_ELEMENT was returned.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
    ) -> ParseContext | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.ParseContext or None
        """

class Pipeline(Bin):
    """
    A Gst.Pipeline is a special Gst.Bin used as the toplevel container for
    the filter graph. The Gst.Pipeline will manage the selection and
    distribution of a global Gst.Clock as well as provide a Gst.Bus to the
    application.

    `Gst.Pipeline.new` is used to create a pipeline. when you are done with
    the pipeline, use `Gst.Object.unref` to free its resources including all
    added Gst.Element objects (if not otherwise referenced).

    Elements are added and removed from the pipeline using the Gst.Bin
    methods like `Gst.Bin.add` and `Gst.Bin.remove` (see Gst.Bin).

    Before changing the state of the Gst.Pipeline (see Gst.Element) a Gst.Bus
    should be retrieved with `Gst.Pipeline.get_bus`. This Gst.Bus should then
    be used to receive Gst.Message from the elements in the pipeline. Listening
    to the Gst.Bus is necessary for retrieving error messages from the
    Gst.Pipeline and otherwise the Gst.Pipeline might stop without any
    indication, why. Furthermore, the Gst.Pipeline posts messages even if
    nobody listens on the Gst.Bus, which will pile up and use up memory.

    By default, a Gst.Pipeline will automatically flush the pending Gst.Bus
    messages when going to the None state to ensure that no circular
    references exist when no messages are read from the Gst.Bus. This
    behaviour can be changed with `Gst.Pipeline.set_auto_flush_bus`.

    When the Gst.Pipeline performs the PAUSED to PLAYING state change it will
    select a clock for the elements. The clock selection algorithm will by
    default select a clock provided by an element that is most upstream
    (closest to the source). For live pipelines (ones that return
    GST_STATE_CHANGE_NO_PREROLL from the `Gst.Element.set_state` call) this
    will select the clock provided by the live source. For normal pipelines
    this will select a clock provided by the sinks (most likely the audio
    sink). If no element provides a clock, a default Gst.SystemClock is used.

    The clock selection can be controlled with the `Gst.Pipeline.use_clock`
    method, which will enforce a given clock on the pipeline. With
    `Gst.Pipeline.auto_clock` the default clock selection algorithm can be
    restored.

    A Gst.Pipeline maintains a running time for the elements. The running
    time is defined as the difference between the current clock time and
    the base time. When the pipeline goes to READY or a flushing seek is
    performed on it, the running time is reset to 0. When the pipeline is
    set from PLAYING to PAUSED, the current clock time is sampled and used to
    configure the base time for the elements when the pipeline is set
    to PLAYING again. The effect is that the running time (as the difference
    between the clock time and the base time) will count how much time was spent
    in the PLAYING state. This default behaviour can be changed with the
    `Gst.Element.set_start_time` method.
    """

    class Props(Bin.Props):
        auto_flush_bus: bool  # [auto-flush-bus]: changed because contained invalid characters
        """
        Whether or not to automatically flush all messages on the
        pipeline's bus when going from READY to None state. Please see
        `Gst.Pipeline.set_auto_flush_bus` for more information on this option.
        """
        delay: int
        """
        The expected delay needed for elements to spin up to the
        PLAYING state expressed in nanoseconds.
        see `Gst.Pipeline.set_delay` for more information on this option.
        """
        latency: int
        """
        Latency to configure on the pipeline. See `Gst.Pipeline.set_latency`.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def bin(self) -> Bin | None: ...
    @builtins.property
    def fixed_clock(self) -> Clock | None:
        """
        The fixed clock of the pipeline, used when
                  GST_PIPELINE_FLAG_FIXED_CLOCK is set.
        """
    @builtins.property
    def priv(self) -> PipelinePrivate | None: ...
    @builtins.property
    def stream_time(self) -> int:
        """
        The stream time of the pipeline. A better name for this
            property would be the running_time, the total time spent in the
            PLAYING state without being flushed. (deprecated, use the start_time
            on GstElement).
        """

    # gi Methods
    def auto_clock(self) -> None:
        """
            Let `pipeline` select a clock automatically. This is the default
        behaviour.

        Use this function if you previous forced a fixed clock with
        `Gst.Pipeline.use_clock` and want to restore the default
        pipeline clock selection algorithm.

        MT safe.
        """
    @builtins.property
    def get_auto_flush_bus(self) -> bool:
        """
            Check if `pipeline` will automatically flush messages when going to
        the None state.
        """
    def get_bus(self) -> Bus:
        """
            Gets the Gst.Bus of `pipeline`. The bus allows applications to receive
        Gst.Message packets.
        """
    def get_configured_latency(self) -> int:
        """
        Return the configured latency on `pipeline`.
        """
    @builtins.property
    def get_delay(self) -> int:
        """
        Get the configured delay (see `Gst.Pipeline.set_delay`).
        """
    @builtins.property
    def get_latency(self) -> int:
        """
            Gets the latency that should be configured on the pipeline. See
        `Gst.Pipeline.set_latency`.
        """
    def get_pipeline_clock(self) -> Clock:
        """
            Gets the current clock used by `pipeline`.

        Unlike `Gst.Element.get_clock`, this function will always return a
        clock, even if the pipeline is not in the PLAYING state.
        """
    def is_live(self) -> bool:
        """
        Check if `pipeline` is live.
        """
    @classmethod
    def new(cls, name: str | None = None) -> Pipeline:
        """
        Create a new pipeline with the given name.
        """
    def set_auto_flush_bus(self, auto_flush: bool) -> None:
        """
            Usually, when a pipeline goes from READY to None state, it automatically
        flushes all pending messages on the bus, which is done for refcounting
        purposes, to break circular references.

        This means that applications that update state using (async) bus messages
        (e.g. do certain things when a pipeline goes from PAUSED to READY) might
        not get to see messages when the pipeline is shut down, because they might
        be flushed before they can be dispatched in the main thread. This behaviour
        can be disabled using this function.

        It is important that all messages on the bus are handled when the
        automatic flushing is disabled else memory leaks will be introduced.

        MT safe.
        """
    def set_delay(self, delay: int) -> None:
        """
            Set the expected delay needed for all elements to perform the
        PAUSED to PLAYING state change. `delay` will be added to the
        base time of the elements so that they wait an additional `delay`
        amount of time before starting to process buffers and cannot be
        GST_CLOCK_TIME_NONE.

        This option is used for tuning purposes and should normally not be
        used.

        MT safe.
        """
    def set_latency(self, latency: int) -> None:
        """
            Sets the latency that should be configured on the pipeline. Setting
        GST_CLOCK_TIME_NONE will restore the default behaviour of using the minimum
        latency from the LATENCY query. Setting this is usually not required and
        the pipeline will figure out an appropriate latency automatically.

        Setting a too low latency, especially lower than the minimum latency from
        the LATENCY query, will most likely cause the pipeline to fail.
        """
    def use_clock(self, clock: Clock | None = None) -> None:
        """
            Force `pipeline` to use the given `clock`. The pipeline will
        always use the given clock even if new clock providers are added
        to this pipeline.

        If `clock` is None all clocking will be disabled which will make
        the pipeline run as fast as possible.

        MT safe.
        """

    # python methods (overrides?)
    def __init__(
        self,
        name: typing.Any = None,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::auto_flush_bus"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::delay"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::latency"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PipelineClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> BinClass | None: ...

class PipelinePrivate(GObject.GPointer): ...

class Plugin(Object):
    """
    GStreamer is extensible, so Gst.Element instances can be loaded at runtime.
    A plugin system can provide one or more of the basic GStreamer
    Gst.PluginFeature subclasses.

    A plugin should export a symbol `gst_plugin_desc` that is a
    struct of type Gst.PluginDesc.
    the plugin loader will check the version of the core library the plugin was
    linked against and will create a new Gst.Plugin. It will then call the
    Gst.PluginInitFunc function that was provided in the
    `gst_plugin_desc`.

    Once you have a handle to a Gst.Plugin (e.g. from the Gst.Registry), you
    can add any object that subclasses Gst.PluginFeature.

    Usually plugins are always automatically loaded so you don't need to call
    `Gst.Plugin.load` explicitly to bring it into memory. There are options to
    statically link plugins to an app or even use GStreamer without a plugin
    repository in which case `Gst.Plugin.load` can be needed to bring the plugin
    into memory.
    """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize Plugin object with properties.
        """
    def add_dependency(
        self, env_vars: list | None, paths: list | None, names: list | None, flags: PluginDependencyFlags
    ) -> None:
        """
            Make GStreamer aware of external dependencies which affect the feature
        set of this plugin (ie. the elements or typefinders associated with it).

        GStreamer will re-inspect plugins with external dependencies whenever any
        of the external dependencies change. This is useful for plugins which wrap
        other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
        library and makes visualisations available as GStreamer elements, or a
        codec loader which exposes elements and/or caps dependent on what external
        codec libraries are currently installed.
        """
    def add_dependency_simple(
        self, env_vars: str | None, paths: str | None, names: str | None, flags: PluginDependencyFlags
    ) -> None:
        """
            Make GStreamer aware of external dependencies which affect the feature
        set of this plugin (ie. the elements or typefinders associated with it).

        GStreamer will re-inspect plugins with external dependencies whenever any
        of the external dependencies change. This is useful for plugins which wrap
        other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
        library and makes visualisations available as GStreamer elements, or a
        codec loader which exposes elements and/or caps dependent on what external
        codec libraries are currently installed.

        Convenience wrapper function for `Gst.Plugin.add_dependency` which
        takes simple strings as arguments instead of string arrays, with multiple
        arguments separated by predefined delimiters (see above).
        """
    def add_status_error(self, message: str) -> None: ...
    def add_status_info(self, message: str) -> None: ...
    def add_status_warning(self, message: str) -> None: ...
    def get_cache_data(self) -> Structure | None:
        """
            Gets the plugin specific data cache. If it is None there is no cached data
        stored. This is the case when the registry is getting rebuilt.
        """
    def get_description(self) -> str:
        """
        Get the long descriptive name of the plugin
        """
    def get_filename(self) -> str | None:
        """
        get the filename of the plugin
        """
    def get_license(self) -> str:
        """
        get the license of the plugin
        """
    def get_name(self) -> str:
        """
        Get the short name of the plugin
        """
    def get_origin(self) -> str:
        """
        get the URL where the plugin comes from
        """
    def get_package(self) -> str:
        """
        get the package the plugin belongs to.
        """
    def get_release_date_string(self) -> str | None:
        """
            Get the release date (and possibly time) in form of a string, if available.

        For normal GStreamer plugin releases this will usually just be a date in
        the form of "YYYY-MM-DD", while pre-releases and builds from git may contain
        a time component after the date as well, in which case the string will be
        formatted like "YYYY-MM-DDTHH:MMZ" (e.g. "2012-04-30T09:30Z").

        There may be plugins that do not have a valid release date set on them.
        """
    def get_source(self) -> str:
        """
        get the source module the plugin belongs to.
        """
    def get_status_errors(self) -> list | None: ...
    def get_status_infos(self) -> list | None: ...
    def get_status_warnings(self) -> list | None: ...
    def get_version(self) -> str:
        """
        get the version of the plugin
        """
    def is_loaded(self) -> bool:
        """
        queries if the plugin is loaded into memory
        """
    @staticmethod
    def list_free(list: list) -> None:
        """
        Unrefs each member of `list`, then frees the list.
        """
    def load(self) -> Plugin | None:
        """
            Loads `plugin`. Note that the *return value* is the loaded plugin; `plugin` is
        untouched. The normal use pattern of this function goes like this:

        |[
        GstPlugin *loaded_plugin;
        loaded_plugin = gst_plugin_load (plugin);
        // presumably, we're no longer interested in the potentially-unloaded plugin
        gst_object_unref (plugin);
        plugin = loaded_plugin;
        ]|
        """
    @staticmethod
    def load_by_name(name: str) -> Plugin | None:
        """
        Load the named plugin. Refs the plugin.
        """
    @staticmethod
    def load_file(filename: str) -> Plugin:
        """
        Loads the given plugin and refs it.  Caller needs to unref after use.
        """
    @staticmethod
    def register_static(
        major_version: int,
        minor_version: int,
        name: str,
        description: str,
        init_func: PluginInitFunc,
        version: str,
        license: str,
        source: str,
        package: str,
        origin: str,
    ) -> bool:
        """
            Registers a static plugin, ie. a plugin which is private to an application
        or library and contained within the application or library (as opposed to
        being shipped as a separate module file).

        You must make sure that GStreamer has been initialised (with `Gst.init` or
        via `Gst.init_get_option_group`) before calling this function.
        """
    @staticmethod
    def register_static_full(
        major_version: int,
        minor_version: int,
        name: str,
        description: str,
        init_full_func: PluginInitFullFunc,
        version: str,
        license: str,
        source: str,
        package: str,
        origin: str,
        *user_data: object | None,
    ) -> bool:
        """
            Registers a static plugin, ie. a plugin which is private to an application
        or library and contained within the application or library (as opposed to
        being shipped as a separate module file) with a Gst.PluginInitFullFunc
        which allows user data to be passed to the callback function (useful
        for bindings).

        You must make sure that GStreamer has been initialised (with `Gst.init` or
        via `Gst.init_get_option_group`) before calling this function.
        """
    def set_cache_data(self, cache_data: Structure) -> None:
        """
            Adds plugin specific data to cache. Passes the ownership of the structure to
        the `plugin`.

        The cache is flushed every time the registry is rebuilt.
        """

class PluginClass(GObject.GPointer): ...

class PluginDesc(GObject.GPointer):
    """
    A plugin should export a variable of this type called plugin_desc. The plugin
    loader will use the data provided there to initialize the plugin.

    The `licence` parameter must be one of: LGPL, GPL, QPL, GPL/QPL, MPL,
    BSD, MIT/X11, Proprietary, unknown.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    description: str = ...
    """
    description of plugin
    """
    license: str = ...
    """
    effective license of plugin
    """
    major_version: int = ...
    """
    the major version number of core that plugin was compiled for
    """
    minor_version: int = ...
    """
    the minor version number of core that plugin was compiled for
    """
    name: str = ...
    """
    a unique name of the plugin
    """
    origin: str = ...
    """
    URL to provider of plugin
    """
    package: str = ...
    """
    shipped package plugin belongs to
    """
    plugin_init: PluginInitFuncPluginDescCB = ...
    """
    pointer to the init function of this plugin.
    """
    release_datetime: str = ...
    """
    date time string in ISO 8601
        format (or rather, a subset thereof), or None. Allowed are the
        following formats: "YYYY-MM-DD" and "YYY-MM-DDTHH:MMZ" (with
        'T' a separator and 'Z' indicating UTC/Zulu time). This field
        should be set via the GST_PACKAGE_RELEASE_DATETIME
        preprocessor macro.
    """
    source: str = ...
    """
    source module plugin belongs to
    """
    version: str = ...
    """
    version of the plugin
    """

class PluginFeature(Object):
    """
    This is a base class for anything that can be added to a Gst.Plugin.
    """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize PluginFeature object with properties.
        """
    def check_version(self, min_major: int, min_minor: int, min_micro: int) -> bool:
        """
            Checks whether the given plugin feature is at least the required version.

        Note: Since version 1.24 this function no longer returns True if the
        version is a git development version (e.g. 1.23.0.1) and the check is
        for the "next" micro version, that is it will no longer return True for
        e.g. 1.23.0.1 if the check is for 1.23.1. It is still possible to parse
        the nano version from the string and do this check that way if needed.
        """
    def get_plugin(self) -> Plugin | None:
        """
        Get the plugin that provides this feature.
        """
    def get_plugin_name(self) -> str | None:
        """
        Get the name of the plugin that provides this feature.
        """
    def get_rank(self) -> int:
        """
        Gets the rank of a plugin feature.
        """
    @staticmethod
    def list_copy(list: list) -> list:
        """
            Copies the list of features. Caller should call `gst_plugin_feature_list_free`
        when done with the list.
        """
    @staticmethod
    def list_debug(list: list) -> None:
        """
        Debug the plugin feature names in `list`.
        """
    @staticmethod
    def list_free(list: list) -> None:
        """
        Unrefs each member of `list`, then frees the list.
        """
    def load(self) -> PluginFeature | None:
        """
            Loads the plugin containing `feature` if it's not already loaded. `feature` is
        unaffected; use the return value instead.

        Normally this function is used like this:
        |[<!-- language="C" -->
        GstPluginFeature *loaded_feature;

        loaded_feature = gst_plugin_feature_load (feature);
        // presumably, we're no longer interested in the potentially-unloaded feature
        gst_object_unref (feature);
        feature = loaded_feature;
        ]|
        """
    @staticmethod
    def rank_compare_func(p1: object | None = None, p2: object | None = None) -> int:
        """
            Compares the two given Gst.PluginFeature instances. This function can be
        used as a GCompareFunc when sorting by rank and then by name.
        """
    def set_rank(self, rank: int) -> None:
        """
            Specifies a rank for a plugin feature, so that autoplugging uses
        the most appropriate feature.
        """

class PluginFeatureClass(GObject.GPointer): ...

class Poll(GObject.GPointer):
    """
    A Gst.Poll keeps track of file descriptors much like fd_set (used with
    select ()) or a struct pollfd array (used with poll ()). Once created with
    `Gst.Poll.new`, the set can be used to wait for file descriptors to be
    readable and/or writable. It is possible to make this wait be controlled
    by specifying True for the `controllable` flag when creating the set (or
    later calling `Gst.Poll.set_controllable`).

    New file descriptors are added to the set using `Gst.Poll.add_fd`, and
    removed using `Gst.Poll.remove_fd`. Controlling which file descriptors
    should be waited for to become readable and/or writable are done using
    `Gst.Poll.fd_ctl_read`, `Gst.Poll.fd_ctl_write` and `Gst.Poll.fd_ctl_pri`.

    Use `Gst.Poll.wait` to wait for the file descriptors to actually become
    readable and/or writable, or to timeout if no file descriptor is available
    in time. The wait can be controlled by calling `Gst.Poll.restart` and
    `Gst.Poll.set_flushing`.

    Once the file descriptor set has been waited for, one can use
    `Gst.Poll.fd_has_closed` to see if the file descriptor has been closed,
    `Gst.Poll.fd_has_error` to see if it has generated an error,
    `Gst.Poll.fd_can_read` to see if it is possible to read from the file
    descriptor, and `Gst.Poll.fd_can_write` to see if it is possible to
    write to it.
    """

    # gi Methods
    def add_fd(self, fd: PollFD) -> bool:
        """
        Add a file descriptor to the file descriptor set.
        """
    def fd_can_read(self, fd: PollFD) -> bool:
        """
        Check if `fd` in `set` has data to be read.
        """
    def fd_can_write(self, fd: PollFD) -> bool:
        """
        Check if `fd` in `set` can be used for writing.
        """
    def fd_ctl_pri(self, fd: PollFD, active: bool) -> bool:
        """
            Control whether the descriptor `fd` in `set` will be monitored for
        exceptional conditions (POLLPRI).

        Not implemented on Windows (will just return False there).
        """
    def fd_ctl_read(self, fd: PollFD, active: bool) -> bool:
        """
            Control whether the descriptor `fd` in `set` will be monitored for
        readability.
        """
    def fd_ctl_write(self, fd: PollFD, active: bool) -> bool:
        """
            Control whether the descriptor `fd` in `set` will be monitored for
        writability.
        """
    def fd_has_closed(self, fd: PollFD) -> bool:
        """
        Check if `fd` in `set` has closed the connection.
        """
    def fd_has_error(self, fd: PollFD) -> bool:
        """
        Check if `fd` in `set` has an error.
        """
    def fd_has_pri(self, fd: PollFD) -> bool:
        """
            Check if `fd` in `set` has an exceptional condition (POLLPRI).

        Not implemented on Windows (will just return False there).
        """
    def fd_ignored(self, fd: PollFD) -> None:
        """
            Mark `fd` as ignored so that the next call to `Gst.Poll.wait` will yield
        the same result for `fd` as last time. This function must be called if no
        operation (read/write/recv/send/etc.) will be performed on `fd` before
        the next call to `Gst.Poll.wait`.

        The reason why this is needed is because the underlying implementation
        might not allow querying the fd more than once between calls to one of
        the re-enabling operations.
        """
    def free(self) -> None:
        """
        Free a file descriptor set.
        """
    def get_read_gpollfd(self, fd: GLib.PollFD) -> None:
        """
            Get a GPollFD for the reading part of the control socket. This is useful when
        integrating with a GSource and GMainLoop.
        """
    def read_control(self) -> bool:
        """
            Read a byte from the control socket of the controllable `set`.

        This function only works for timer Gst.Poll objects created with
        `Gst.Poll.new_timer`.
        """
    def remove_fd(self, fd: PollFD) -> bool:
        """
        Remove a file descriptor from the file descriptor set.
        """
    def restart(self) -> None:
        """
            Restart any `Gst.Poll.wait` that is in progress. This function is typically
        used after adding or removing descriptors to `set`.

        If `set` is not controllable, then this call will have no effect.

        This function only works for non-timer Gst.Poll objects created with
        `Gst.Poll.new`.
        """
    def set_controllable(self, controllable: bool) -> bool:
        """
            When `controllable` is True, this function ensures that future calls to
        `Gst.Poll.wait` will be affected by `Gst.Poll.restart` and
        `Gst.Poll.set_flushing`.

        This function only works for non-timer Gst.Poll objects created with
        `Gst.Poll.new`.
        """
    def set_flushing(self, flushing: bool) -> None:
        """
            When `flushing` is True, this function ensures that current and future calls
        to `Gst.Poll.wait` will return -1, with errno set to EBUSY.

        Unsetting the flushing state will restore normal operation of `set`.

        This function only works for non-timer Gst.Poll objects created with
        `Gst.Poll.new`.
        """
    def wait(self, timeout: int) -> int:
        """
            Wait for activity on the file descriptors in `set`. This function waits up to
        the specified `timeout`.  A timeout of GST_CLOCK_TIME_NONE waits forever.

        For Gst.Poll objects created with `Gst.Poll.new`, this function can only be
        called from a single thread at a time.  If called from multiple threads,
        -1 will be returned with errno set to EPERM.

        This is not true for timer Gst.Poll objects created with
        `Gst.Poll.new_timer`, where it is allowed to have multiple threads waiting
        simultaneously.
        """
    def write_control(self) -> bool:
        """
            Write a byte to the control socket of the controllable `set`.
        This function is mostly useful for timer Gst.Poll objects created with
        `Gst.Poll.new_timer`.

        It will make any current and future `Gst.Poll.wait` function return with
        1, meaning the control socket is set. After an equal amount of calls to
        `Gst.Poll.read_control` have been performed, calls to `Gst.Poll.wait` will
        block again until their timeout expired.

        This function only works for timer Gst.Poll objects created with
        `Gst.Poll.new_timer`.
        """

class PollFD(GObject.GPointer):
    """
    A file descriptor object.
    """

    # gi Fields
    fd: int = ...
    """
    a file descriptor
    """
    @builtins.property
    def idx(self) -> int: ...

    # gi Methods
    def init(self) -> None:
        """
            Initializes `fd`. Alternatively you can initialize it with
        GST_POLL_FD_INIT.
        """

class Preset(builtins.object):
    """
    This interface offers methods to query and manipulate parameter preset sets.
    A preset is a bunch of property settings, together with meta data and a name.
    The name of a preset serves as key for subsequent method calls to manipulate
    single presets.
    All instances of one type will share the list of presets. The list is created
    on demand, if presets are not used, the list is not created.

    The interface comes with a default implementation that serves most plugins.
    Wrapper plugins will override most methods to implement support for the
    native preset format of those wrapped plugins.
    One method that is useful to be overridden is `Gst.Preset.get_property_names`.
    With that one can control which properties are saved and in which order.
    When implementing support for read-only presets, one should set the vmethods
    for `Gst.Preset.save_preset` and `Gst.Preset.delete_preset` to None.
    Applications can use `Gst.Preset.is_editable` to check for that.

    The default implementation supports presets located in a system directory,
    application specific directory and in the users home directory. When getting
    a list of presets individual presets are read and overlaid in 1) system,
    2) application and 3) user order. Whenever an earlier entry is newer, the
    later entries will be updated. Since 1.8 you can also provide extra paths
    where to find presets through the GST_PRESET_PATH environment variable.
    Presets found in those paths will be considered as "app presets".
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize Preset object with properties.
        """
    def delete_preset(self, name: str) -> bool:
        """
        Delete the given preset.
        """
    @staticmethod
    def get_app_dir() -> str | None:
        """
            Gets the directory for application specific presets if set by the
        application.
        """
    def get_meta(self, name: str, tag: str) -> tuple[bool, str]:
        """
            Gets the `value` for an existing meta data `tag`. Meta data `tag` names can be
        something like e.g. "comment". Returned values need to be released when done.
        """
    def get_preset_names(self) -> list:
        """
        Get a copy of preset names as a None terminated string array.
        """
    def get_property_names(self) -> list:
        """
        Get a the names of the GObject properties that can be used for presets.
        """
    def is_editable(self) -> bool:
        """
        Check if one can add new presets, change existing ones and remove presets.
        """
    def load_preset(self, name: str) -> bool:
        """
        Load the given preset.
        """
    def rename_preset(self, old_name: str, new_name: str) -> bool:
        """
            Renames a preset. If there is already a preset by the `new_name` it will be
        overwritten.
        """
    def save_preset(self, name: str) -> bool:
        """
            Save the current object settings as a preset under the given name. If there
        is already a preset by this `name` it will be overwritten.
        """
    @staticmethod
    def set_app_dir(app_dir: str) -> bool:
        """
            Sets an extra directory as an absolute path that should be considered when
        looking for presets. Any presets in the application dir will shadow the
        system presets.
        """
    def set_meta(self, name: str, tag: str, value: str | None = None) -> bool:
        """
            Sets a new `value` for an existing meta data item or adds a new item. Meta
        data `tag` names can be something like e.g. "comment". Supplying None for the
        `value` will unset an existing value.
        """

class PresetInterface(GObject.GPointer):
    """
    Gst.Preset interface.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def delete_preset(self) -> delete_presetPresetInterfaceCB:
        """
        virtual methods to remove a preset
        """
    @builtins.property
    def get_meta(self) -> get_metaPresetInterfaceCB:
        """
        virtual methods to get textual meta data from a preset
        """
    @builtins.property
    def get_preset_names(self) -> get_preset_namesPresetInterfaceCB:
        """
        virtual method to get list of presets
        """
    @builtins.property
    def get_property_names(self) -> get_property_namesPresetInterfaceCB:
        """
        virtual methods to get properties that are persistent
        """
    @builtins.property
    def load_preset(self) -> load_presetPresetInterfaceCB:
        """
        virtual methods to load a preset into properties
        """
    @builtins.property
    def parent(self) -> GObject.TypeInterface | None:
        """
        parent interface type.
        """
    @builtins.property
    def rename_preset(self) -> rename_presetPresetInterfaceCB:
        """
        virtual methods to rename a preset
        """
    @builtins.property
    def save_preset(self) -> save_presetPresetInterfaceCB:
        """
        virtual methods to save properties into a preset
        """
    @builtins.property
    def set_meta(self) -> set_metaPresetInterfaceCB:
        """
        virtual methods to set textual meta data to a preset
        """

class Promise(GObject.GBoxed):
    """
    The Gst.Promise object implements the container for values that may
    be available later. i.e. a Future or a Promise in
    <https://en.wikipedia.org/wiki/Futures_and_promises>.
    As with all Future/Promise-like functionality, there is the concept of the
    producer of the value and the consumer of the value.

    A Gst.Promise is created with `Gst.Promise.new` by the consumer and passed
    to the producer to avoid thread safety issues with the change callback.
    A Gst.Promise can be replied to with a value (or an error) by the producer
    with `Gst.Promise.reply`. The exact value returned is defined by the API
    contract of the producer and None may be a valid reply.
    `Gst.Promise.interrupt` is for the consumer to
    indicate to the producer that the value is not needed anymore and producing
    that value can stop.  The `GST_PROMISE_RESULT_EXPIRED` state set by a call
    to `Gst.Promise.expire` indicates to the consumer that a value will never
    be produced and is intended to be called by a third party that implements
    some notion of message handling such as Gst.Bus.
    A callback can also be installed at Gst.Promise creation for
    result changes with `Gst.Promise.new_with_change_func`.
    The change callback can be used to chain Gst.Promises's together as in the
    following example.
    |[<!-- language="C" -->
    const GstStructure *reply;
    GstPromise *p;
    if (gst_promise_wait (promise) != GST_PROMISE_RESULT_REPLIED)
      return; // interrupted or expired value
    reply = gst_promise_get_reply (promise);
    if (error in reply)
      return; // propagate error
    p = gst_promise_new_with_change_func (another_promise_change_func, user_data, notify);
    pass p to promise-using API
    ]|

    Each Gst.Promise starts out with a Gst.PromiseResult of
    Gst.PROMISE_RESULT_PENDING and only ever transitions once
    into one of the other Gst.PromiseResult's.

    In order to support multi-threaded code, `Gst.Promise.reply`,
    `Gst.Promise.interrupt` and `Gst.Promise.expire` may all be from
    different threads with some restrictions and the final result of the promise
    is whichever call is made first.  There are two restrictions on ordering:

    1. That `Gst.Promise.reply` and `Gst.Promise.interrupt` cannot be called
    after `Gst.Promise.expire`
    2. That `Gst.Promise.reply` and `Gst.Promise.interrupt`
    cannot be called twice.

    The change function set with `Gst.Promise.new_with_change_func` is
    called directly from either the `Gst.Promise.reply`,
    `Gst.Promise.interrupt` or `Gst.Promise.expire` and can be called
    from an arbitrary thread.  Gst.Promise using APIs can restrict this to
    a single thread or a subset of threads but that is entirely up to the API
    that uses Gst.Promise.
    """

    # gi Fields
    parent: MiniObject | None = ...
    """
    parent Gst.MiniObject
    """

    # gi Methods
    def expire(self) -> None:
        """
            Expire a `promise`.  This will wake up any waiters with
        Gst.PROMISE_RESULT_EXPIRED.  Called by a message loop when the parent
        message is handled and/or destroyed (possibly unanswered).
        """
    def get_reply(self) -> Structure | None:
        """
            Retrieve the reply set on `promise`.  `promise` must be in
        Gst.PROMISE_RESULT_REPLIED and the returned structure is owned by `promise`
        """
    def interrupt(self) -> None:
        """
            Interrupt waiting for a `promise`.  This will wake up any waiters with
        Gst.PROMISE_RESULT_INTERRUPTED.  Called when the consumer does not want
        the value produced anymore.
        """
    def reply(self, s: Structure | None = None) -> None:
        """
            Set a reply on `promise`.  This will wake up any waiters with
        Gst.PROMISE_RESULT_REPLIED.  Called by the producer of the value to
        indicate success (or failure).

        If `promise` has already been interrupted by the consumer, then this reply
        is not visible to the consumer.
        """
    def wait(self) -> PromiseResult:
        """
            Wait for `promise` to move out of the Gst.PROMISE_RESULT_PENDING state.
        If `promise` is not in Gst.PROMISE_RESULT_PENDING then it will return
        immediately with the current result.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
    ) -> Promise:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.Promise
        """
    @classmethod
    def new_with_change_func(
        cls,
        func: typing.Callable,
        user_data: typing.Any = None,
    ) -> Promise:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_with_change_func(func:Gst.PromiseChangeFunc, user_data=None) -> Gst.Promise
        """

class ProtectionMeta(GObject.GPointer):
    """
    Metadata type that holds information about a sample from a protection-protected
    track, including the information needed to decrypt it (if it is encrypted).
    """

    # gi Fields
    info: Structure | None = ...
    """
    the cryptographic information needed to decrypt the sample.
    """
    meta: Meta | None = ...
    """
    the parent Gst.Meta.
    """

    # gi Methods
    @staticmethod
    def get_info() -> MetaInfo: ...

class ProxyPad(Pad):
    # gi Fields
    @builtins.property
    def pad(self) -> Pad | None: ...
    @builtins.property
    def priv(self) -> ProxyPadPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        direction: PadDirection | None = PadDirection.UNKNOWN,
        name: str | None = None,
        offset: int | None = None,
        parent: Object | None = None,
        template: PadTemplate | None = None,
    ) -> None:
        """
        Initialize ProxyPad object with properties.
        """
    @staticmethod
    def chain_default(pad: Pad, parent: Object | None, buffer: Buffer) -> FlowReturn:
        """
        Invoke the default chain function of the proxy pad.
        """
    @staticmethod
    def chain_list_default(pad: Pad, parent: Object | None, list: BufferList) -> FlowReturn:
        """
        Invoke the default chain list function of the proxy pad.
        """
    def get_internal(self) -> ProxyPad | None:
        """
            Get the internal pad of `pad`. Unref target pad after usage.

        The internal pad of a Gst.GhostPad is the internally used
        pad of opposite direction, which is used to link to the target.
        """
    @staticmethod
    def getrange_default(pad: Pad, parent: Object, offset: int, size: int) -> tuple[FlowReturn, Buffer]:
        """
        Invoke the default getrange function of the proxy pad.
        """
    @staticmethod
    def iterate_internal_links_default(pad: Pad, parent: Object | None = None) -> Iterator | None:
        """
        Invoke the default iterate internal links function of the proxy pad.
        """

class ProxyPadClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> PadClass | None: ...

class ProxyPadPrivate(GObject.GPointer): ...

class Query(GObject.GBoxed):
    """
    Queries can be performed on pads (`Gst.Pad.query`) and elements
    (`Gst.Element.query`). Please note that some queries might need a running
    pipeline to work.

    Queries can be created using the gst_query_new_*() functions.
    Query values can be set using gst_query_set_*(), and parsed using
    gst_query_parse_*() helpers.

    The following example shows how to query the duration of a pipeline:
    |[<!-- language="C" -->
      GstQuery *query;
      gboolean res;
      query = gst_query_new_duration (GST_FORMAT_TIME);
      res = gst_element_query (pipeline, query);
      if (res) {
        gint64 duration;
        gst_query_parse_duration (query, None, &duration);
        g_print ("duration = %"GST_TIME_FORMAT, GST_TIME_ARGS (duration));
      } else {
        g_print ("duration query failed...");
      }
      gst_query_unref (query);
    ]|
    """

    # gi Fields
    mini_object: MiniObject | None = ...
    """
    The parent Gst.MiniObject type
    """
    type: QueryType = ...
    """
    the Gst.QueryType
    """

    # gi Methods
    def add_allocation_meta(self, api: GObject.GType, params: Structure | None = None) -> None:
        """
        Add `api` with `params` as one of the supported metadata API to `query`.
        """
    def add_allocation_param(self, allocator: Allocator | None = None, params: AllocationParams | None = None) -> None:
        """
        Add `allocator` and its `params` as a supported memory allocator.
        """
    def add_allocation_pool(self, pool: BufferPool | None, size: int, min_buffers: int, max_buffers: int) -> None:
        """
        Set the pool parameters in `query`.
        """
    def add_buffering_range(self, start: int, stop: int) -> bool:
        """
            Set the buffering-ranges array field in `query`. The current last
        start position of the array should be inferior to `start`.
        """
    def add_scheduling_mode(self, mode: PadMode) -> None:
        """
        Add `mode` as one of the supported scheduling modes to `query`.
        """
    def find_allocation_meta(self, api: GObject.GType) -> tuple[bool, int]:
        """
            Check if `query` has metadata `api` set. When this function returns True,
        `index` will contain the index where the requested API and the parameters
        can be found.
        """
    def get_n_allocation_metas(self) -> int:
        """
            Retrieve the number of values currently stored in the
        meta API array of the query's structure.
        """
    def get_n_allocation_params(self) -> int:
        """
            Retrieve the number of values currently stored in the
        allocator params array of the query's structure.

        If no memory allocator is specified, the downstream element can handle
        the default memory allocator. The first memory allocator in the query
        should be generic and allow mapping to system memory, all following
        allocators should be ordered by preference with the preferred one first.
        """
    def get_n_allocation_pools(self) -> int:
        """
            Retrieve the number of values currently stored in the
        pool array of the query's structure.
        """
    def get_n_buffering_ranges(self) -> int:
        """
            Retrieve the number of values currently stored in the
        buffered-ranges array of the query's structure.
        """
    def get_n_scheduling_modes(self) -> int:
        """
            Retrieve the number of values currently stored in the
        scheduling mode array of the query's structure.
        """
    def get_structure(self) -> Structure | None:
        """
        Get the structure of a query.
        """
    def has_scheduling_mode(self, mode: PadMode) -> bool:
        """
            Check if `query` has scheduling mode set.

        > When checking if upstream supports pull mode, it is usually not
        > enough to just check for GST_PAD_MODE_PULL with this function, you
        > also want to check whether the scheduling flags returned by
        > `Gst.Query.parse_scheduling` have the seeking flag set (meaning
        > random access is supported, not only sequential pulls).
        """
    def has_scheduling_mode_with_flags(self, mode: PadMode, flags: SchedulingFlags) -> bool:
        """
            Check if `query` has scheduling mode set and `flags` is set in
        query scheduling flags.
        """
    def parse_accept_caps(self) -> Caps:
        """
            Get the caps from `query`. The caps remains valid as long as `query` remains
        valid.
        """
    def parse_accept_caps_result(self) -> bool | None:
        """
        Parse the result from `query` and store in `result`.
        """
    def parse_allocation(self) -> tuple[Caps | None, bool]:
        """
            Parse an allocation query, writing the requested caps in `caps` and
        whether a pool is needed in `need_pool`, if the respective parameters
        are non-None.

        Pool details can be retrieved using `Gst.Query.get_n_allocation_pools` and
        `Gst.Query.parse_nth_allocation_pool`.
        """
    def parse_bitrate(self) -> int:
        """
        Get the results of a bitrate query. See also `Gst.Query.set_bitrate`.
        """
    def parse_buffering_percent(self) -> tuple[bool, int]:
        """
            Get the percentage of buffered data. This is a value between 0 and 100.
        The `busy` indicator is True when the buffering is in progress.
        """
    def parse_buffering_range(self) -> tuple[Format, int, int, int]:
        """
            Parse an available query, writing the format into `format`, and
        other results into the passed parameters, if the respective parameters
        are non-None
        """
    def parse_buffering_stats(self) -> tuple[BufferingMode, int, int, int]:
        """
        Extracts the buffering stats values from `query`.
        """
    def parse_caps(self) -> Caps:
        """
            Get the filter from the caps `query`. The caps remains valid as long as
        `query` remains valid.
        """
    def parse_caps_result(self) -> Caps | None:
        """
            Get the caps result from `query`. The caps remains valid as long as
        `query` remains valid.
        """
    def parse_context(self) -> Context | None:
        """
            Get the context from the context `query`. The context remains valid as long as
        `query` remains valid.
        """
    def parse_context_type(self) -> tuple[bool, str]:
        """
        Parse a context type from an existing GST_QUERY_CONTEXT query.
        """
    def parse_convert(self) -> tuple[Format, int, Format, int]:
        """
            Parse a convert query answer. Any of `src_format`, `src_value`, `dest_format`,
        and `dest_value` may be None, in which case that value is omitted.
        """
    def parse_duration(self) -> tuple[Format, int]:
        """
            Parse a duration query answer. Write the format of the duration into `format`,
        and the value into `duration`, if the respective variables are non-None.
        """
    def parse_latency(self) -> tuple[bool, int, int]:
        """
        Parse a latency query answer.
        """
    def parse_n_formats(self) -> int:
        """
        Parse the number of formats in the formats `query`.
        """
    def parse_nth_allocation_meta(self, index: int) -> tuple[GObject.GType, Structure]:
        """
            Parse an available query and get the metadata API
        at `index` of the metadata API array.
        """
    def parse_nth_allocation_param(self, index: int) -> tuple[Allocator | None, AllocationParams]:
        """
            Parse an available query and get the allocator and its params
        at `index` of the allocator array.
        """
    def parse_nth_allocation_pool(self, index: int) -> tuple[BufferPool | None, int, int, int]:
        """
            Get the pool parameters in `query`.

        Unref `pool` with `Gst.Object.unref` when it's not needed any more.
        """
    def parse_nth_buffering_range(self, index: int) -> tuple[bool, int, int]:
        """
            Parse an available query and get the start and stop values stored
        at the `index` of the buffered ranges array.
        """
    def parse_nth_format(self, nth: int) -> Format:
        """
            Parse the format query and retrieve the `nth` format from it into
        `format`. If the list contains less elements than `nth`, `format` will be
        set to GST_FORMAT_UNDEFINED.
        """
    def parse_nth_scheduling_mode(self, index: int) -> PadMode:
        """
            Parse an available query and get the scheduling mode
        at `index` of the scheduling modes array.
        """
    def parse_position(self) -> tuple[Format, int]:
        """
            Parse a position query, writing the format into `format`, and the position
        into `cur`, if the respective parameters are non-None.
        """
    def parse_scheduling(self) -> tuple[SchedulingFlags, int, int, int]:
        """
        Set the scheduling properties.
        """
    def parse_seeking(self) -> tuple[Format, bool, int, int]:
        """
            Parse a seeking query, writing the format into `format`, and
        other results into the passed parameters, if the respective parameters
        are non-None
        """
    def parse_segment(self) -> tuple[float, Format, int, int]:
        """
            Parse a segment query answer. Any of `rate`, `format`, `start_value`, and
        `stop_value` may be None, which will cause this value to be omitted.

        See `Gst.Query.set_segment` for an explanation of the function arguments.
        """
    def parse_selectable(self) -> bool:
        """
        Get the results of a selectable query. See also `Gst.Query.set_selectable`.
        """
    def parse_uri(self) -> str | None:
        """
            Parse an URI query, writing the URI into `uri` as a newly
        allocated string, if the respective parameters are non-None.
        Free the string with `g_free` after usage.
        """
    def parse_uri_redirection(self) -> str | None:
        """
            Parse an URI query, writing the URI into `uri` as a newly
        allocated string, if the respective parameters are non-None.
        Free the string with `g_free` after usage.
        """
    def parse_uri_redirection_permanent(self) -> bool:
        """
            Parse an URI query, and set `permanent` to True if there is a redirection
        and it should be considered permanent. If a redirection is permanent,
        applications should update their internal storage of the URI, otherwise
        they should make all future requests to the original URI.
        """
    def remove_nth_allocation_meta(self, index: int) -> None:
        """
        Remove the metadata API at `index` of the metadata API array.
        """
    def remove_nth_allocation_param(self, index: int) -> None:
        """
        Remove the allocation param at `index` of the allocation param array.
        """
    def remove_nth_allocation_pool(self, index: int) -> None:
        """
        Remove the allocation pool at `index` of the allocation pool array.
        """
    def set_accept_caps_result(self, result: bool) -> None:
        """
        Set `result` as the result for the `query`.
        """
    def set_bitrate(self, nominal_bitrate: int) -> None:
        """
            Set the results of a bitrate query.  The nominal bitrate is the average
        bitrate expected over the length of the stream as advertised in file
        headers (or similar).
        """
    def set_buffering_percent(self, busy: bool, percent: int) -> None:
        """
            Set the percentage of buffered data. This is a value between 0 and 100.
        The `busy` indicator is True when the buffering is in progress.
        """
    def set_buffering_range(self, format: Format, start: int, stop: int, estimated_total: int) -> None:
        """
        Set the available query result fields in `query`.
        """
    def set_buffering_stats(self, mode: BufferingMode, avg_in: int, avg_out: int, buffering_left: int) -> None:
        """
        Configures the buffering stats values in `query`.
        """
    def set_caps_result(self, caps: Caps | None = None) -> None:
        """
        Set the `caps` result in `query`.
        """
    def set_context(self, context: Context | None = None) -> None:
        """
        Answer a context query by setting the requested context.
        """
    def set_convert(self, src_format: Format, src_value: int, dest_format: Format, dest_value: int) -> None:
        """
        Answer a convert query by setting the requested values.
        """
    def set_duration(self, format: Format, duration: int) -> None:
        """
        Answer a duration query by setting the requested value in the given format.
        """
    def set_formatsv(self, n_formats: int, formats: list) -> None:
        """
            Set the formats query result fields in `query`. The number of formats passed
        in the `formats` array must be equal to `n_formats`.
        """
    def set_latency(self, live: bool, min_latency: int, max_latency: int) -> None:
        """
        Answer a latency query by setting the requested values in the given format.
        """
    def set_nth_allocation_param(
        self, index: int, allocator: Allocator | None = None, params: AllocationParams | None = None
    ) -> None:
        """
            Parse an available query and get the allocator and its params
        at `index` of the allocator array.
        """
    def set_nth_allocation_pool(
        self, index: int, pool: BufferPool | None, size: int, min_buffers: int, max_buffers: int
    ) -> None:
        """
        Set the pool parameters in `query`.
        """
    def set_position(self, format: Format, cur: int) -> None:
        """
        Answer a position query by setting the requested value in the given format.
        """
    def set_scheduling(self, flags: SchedulingFlags, minsize: int, maxsize: int, align: int) -> None:
        """
        Set the scheduling properties.
        """
    def set_seeking(self, format: Format, seekable: bool, segment_start: int, segment_end: int) -> None:
        """
        Set the seeking query result fields in `query`.
        """
    def set_segment(self, rate: float, format: Format, start_value: int, stop_value: int) -> None:
        """
            Answer a segment query by setting the requested values. The normal
        playback segment of a pipeline is 0 to duration at the default rate of
        1.0. If a seek was performed on the pipeline to play a different
        segment, this query will return the range specified in the last seek.

        `start_value` and `stop_value` will respectively contain the configured
        playback range start and stop values expressed in `format`.
        The values are always between 0 and the duration of the media and
        `start_value` <= `stop_value`. `rate` will contain the playback rate. For
        negative rates, playback will actually happen from `stop_value` to
        `start_value`.
        """
    def set_selectable(self, selectable: bool) -> None:
        """
            Set the results of a selectable query. If the element answering the query can
        handle stream selection, `selectable` should be set to True.
        """
    def set_uri(self, uri: str | None = None) -> None:
        """
        Answer a URI query by setting the requested URI.
        """
    def set_uri_redirection(self, uri: str | None = None) -> None:
        """
        Answer a URI query by setting the requested URI redirection.
        """
    def set_uri_redirection_permanent(self, permanent: bool) -> None:
        """
            Answer a URI query by setting the requested URI redirection
        to permanent or not.
        """
    def writable_structure(self) -> Structure:
        """
            Get the structure of a query. This method should be called with a writable
        `query` so that the returned structure is guaranteed to be writable.
        """

    # python methods (overrides?)
    @classmethod
    def new_accept_caps(
        cls,
        caps: Caps,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_accept_caps(caps:Gst.Caps) -> Gst.Query
        """
    @classmethod
    def new_allocation(
        cls,
        caps: Caps | None,
        need_pool: bool,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_allocation(caps:Gst.Caps=None, need_pool:bool) -> Gst.Query
        """
    @classmethod
    def new_bitrate(
        cls,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_bitrate() -> Gst.Query
        """
    @classmethod
    def new_buffering(
        cls,
        format: Format,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_buffering(format:Gst.Format) -> Gst.Query
        """
    @classmethod
    def new_caps(
        cls,
        filter: Caps,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_caps(filter:Gst.Caps) -> Gst.Query
        """
    @classmethod
    def new_context(
        cls,
        context_type: str,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_context(context_type:str) -> Gst.Query
        """
    @classmethod
    def new_convert(
        cls,
        src_format: Format,
        value: int,
        dest_format: Format,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_convert(src_format:Gst.Format, value:int, dest_format:Gst.Format) -> Gst.Query
        """
    @classmethod
    def new_custom(
        cls,
        type: QueryType,
        structure: Structure | None = None,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_custom(type:Gst.QueryType, structure:Gst.Structure=None) -> Gst.Query
        """
    @classmethod
    def new_drain(
        cls,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_drain() -> Gst.Query
        """
    @classmethod
    def new_duration(
        cls,
        format: Format,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_duration(format:Gst.Format) -> Gst.Query
        """
    @classmethod
    def new_formats(
        cls,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_formats() -> Gst.Query
        """
    @classmethod
    def new_latency(
        cls,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_latency() -> Gst.Query
        """
    @classmethod
    def new_position(
        cls,
        format: Format,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_position(format:Gst.Format) -> Gst.Query
        """
    @classmethod
    def new_scheduling(
        cls,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_scheduling() -> Gst.Query
        """
    @classmethod
    def new_seeking(
        cls,
        format: Format,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_seeking(format:Gst.Format) -> Gst.Query
        """
    @classmethod
    def new_segment(
        cls,
        format: Format,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_segment(format:Gst.Format) -> Gst.Query
        """
    @classmethod
    def new_selectable(
        cls,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_selectable() -> Gst.Query
        """
    @classmethod
    def new_uri(
        cls,
    ) -> Query:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_uri() -> Gst.Query
        """

class ReferenceTimestampMeta(GObject.GPointer):
    """
    Gst.ReferenceTimestampMeta can be used to attach alternative timestamps and
    possibly durations to a Gst.Buffer. These are generally not according to
    the pipeline clock and could be e.g. the NTP timestamp when the media was
    captured.

    The reference is stored as a Gst.Caps in `reference`. Examples of valid
    references would be

     * `timestamp/x-drivername-stream`: for timestamps that are locally
       generated by some driver named `drivername` when generating the stream,
       e.g. based on a frame counter
     * `timestamp/x-ntp, host=pool.ntp.org, port=123`: for timestamps based on a
       specific NTP server. Note that the host/port parameters might not always
       be given.
     * `timestamp/x-ptp, version=IEEE1588-2008, domain=1`: for timestamps based
       on a given PTP clock.
     * `timestamp/x-unix`: for timestamps based on the UNIX epoch according to
       the local clock.

    Since 1.24 it can be serialized using `Gst.Meta.serialize` and
    `Gst.Meta.deserialize`.
    """

    # gi Fields
    duration: int = ...
    """
    duration, or Gst.CLOCK_TIME_NONE
    """
    parent: Meta | None = ...
    """
    the parent Gst.Meta structure
    """
    reference: Caps | None = ...
    """
    identifier for the timestamp reference.
    """
    timestamp: int = ...
    """
    timestamp
    """

    # gi Methods
    @staticmethod
    def get_info() -> MetaInfo:
        """
        Gets the global Gst.MetaInfo describing the Gst.ReferenceTimestampMeta meta.
        """

class Registry(Object):
    """
    One registry holds the metadata of a set of plugins.

    <emphasis role="bold">Design:</emphasis>

    The Gst.Registry object is a list of plugins and some functions for dealing
    with them. Each Gst.Plugin is matched 1-1 with a file on disk, and may or may
    not be loaded at a given time.

    The primary source, at all times, of plugin information is each plugin file
    itself. Thus, if an application wants information about a particular plugin,
    or wants to search for a feature that satisfies given criteria, the primary
    means of doing so is to load every plugin and look at the resulting
    information that is gathered in the default registry. Clearly, this is a time
    consuming process, so we cache information in the registry file. The format
    and location of the cache file is internal to gstreamer.

    On startup, plugins are searched for in the plugin search path. The following
    locations are checked in this order:

    * location from --gst-plugin-path commandline option.
    * the GST_PLUGIN_PATH environment variable.
    * the GST_PLUGIN_SYSTEM_PATH environment variable.
    * default locations (if GST_PLUGIN_SYSTEM_PATH is not set).
      Those default locations are:
      `$XDG_DATA_HOME/gstreamer-$GST_API_VERSION/plugins/`
      and `$prefix/libs/gstreamer-$GST_API_VERSION/`.
      [$XDG_DATA_HOME](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html) defaults to
      `$HOME/.local/share`.

    The registry cache file is loaded from
    `$XDG_CACHE_HOME/gstreamer-$GST_API_VERSION/registry-$ARCH.bin`
    (where $XDG_CACHE_HOME defaults to `$HOME/.cache`) or the file listed in the `GST_REGISTRY`
    env var. One reason to change the registry location is for testing.

    For each plugin that is found in the plugin search path, there could be 3
    possibilities for cached information:

      * the cache may not contain information about a given file.
      * the cache may have stale information.
      * the cache may have current information.

    In the first two cases, the plugin is loaded and the cache updated. In
    addition to these cases, the cache may have entries for plugins that are not
    relevant to the current process. These are marked as not available to the
    current process. If the cache is updated for whatever reason, it is marked
    dirty.

    A dirty cache is written out at the end of initialization. Each entry is
    checked to make sure the information is minimally valid. If not, the entry is
    simply dropped.

    ## Implementation notes:

    The "cache" and "registry" are different concepts and can represent
    different sets of plugins. For various reasons, at init time, the cache is
    stored in the default registry, and plugins not relevant to the current
    process are marked with the Gst.PLUGIN_FLAG_CACHED bit. These plugins are
    removed at the end of initialization.
    """

    # gi Fields
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def priv(self) -> RegistryPrivate | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize Registry object with properties.
        """
    def add_feature(self, feature: PluginFeature) -> bool:
        """
            Add the feature to the registry. The feature-added signal will be emitted.

        `feature`'s reference count will be incremented, and any floating
        reference will be removed (see `Gst.Object.ref_sink`)
        """
    def add_plugin(self, plugin: Plugin) -> bool:
        """
            Add the plugin to the registry. The plugin-added signal will be emitted.

        `plugin`'s reference count will be incremented, and any floating
        reference will be removed (see `Gst.Object.ref_sink`)
        """
    def check_feature_version(self, feature_name: str, min_major: int, min_minor: int, min_micro: int) -> bool:
        """
            Checks whether a plugin feature by the given name exists in
        `registry` and whether its version is at least the
        version required.
        """
    def feature_filter(self, filter: PluginFeatureFilter, first: bool, *user_data: object | None) -> list:
        """
            Runs a filter against all features of the plugins in the registry
        and returns a GList with the results.
        If the first flag is set, only the first match is
        returned (as a list with a single object).
        """
    def find_feature(self, name: str, type: GObject.GType) -> PluginFeature | None:
        """
        Find the pluginfeature with the given name and type in the registry.
        """
    def find_plugin(self, name: str) -> Plugin | None:
        """
            Find the plugin with the given name in the registry.
        The plugin will be reffed; caller is responsible for unreffing.
        """
    @staticmethod
    def fork_is_enabled() -> bool:
        """
            By default GStreamer will perform scanning and rebuilding of the
        registry file using a helper child process.

        Applications might want to disable this behaviour with the
        `Gst.Registry.fork_set_enabled` function, in which case new plugins
        are scanned (and loaded) into the application process.
        """
    @staticmethod
    def fork_set_enabled(enabled: bool) -> None:
        """
            Applications might want to disable/enable spawning of a child helper process
        when rebuilding the registry. See `Gst.Registry.fork_is_enabled` for more
        information.
        """
    @staticmethod
    def get() -> Registry:
        """
            Retrieves the singleton plugin registry. The caller does not own a
        reference on the registry, as it is alive as long as GStreamer is
        initialized.
        """
    def get_feature_list(self, type: GObject.GType) -> list:
        """
        Retrieves a GList of Gst.PluginFeature of `type`.
        """
    def get_feature_list_by_plugin(self, name: str) -> list:
        """
        Retrieves a GList of features of the plugin with name `name`.
        """
    def get_feature_list_cookie(self) -> int:
        """
            Returns the registry's feature list cookie. This changes
        every time a feature is added or removed from the registry.
        """
    def get_plugin_list(self) -> list:
        """
            Get a copy of all plugins registered in the given registry. The refcount
        of each element in the list in incremented.
        """
    def lookup(self, filename: str) -> Plugin | None:
        """
            Look up a plugin in the given registry with the given filename.
        If found, plugin is reffed.
        """
    def lookup_feature(self, name: str) -> PluginFeature | None:
        """
        Find a Gst.PluginFeature with `name` in `registry`.
        """
    def plugin_filter(self, filter: PluginFilter, first: bool, *user_data: object | None) -> list:
        """
            Runs a filter against all plugins in the registry and returns a GList with
        the results. If the first flag is set, only the first match is
        returned (as a list with a single object).
        Every plugin is reffed; use `Gst.Plugin.list_free` after use, which
        will unref again.
        """
    def remove_feature(self, feature: PluginFeature) -> None:
        """
            Remove the feature from the registry.

        MT safe.
        """
    def remove_plugin(self, plugin: Plugin) -> None:
        """
            Remove the plugin from the registry.

        MT safe.
        """
    def scan_path(self, path: str) -> bool:
        """
            Scan the given path for plugins to add to the registry. The syntax of the
        path is specific to the registry.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["feature-added"],
        handler: typing.Callable[[typing_extensions.Self, PluginFeature], None],
        *args: typing.Any,
    ) -> int:
        """
            Signals that a feature has been added to the registry (possibly
        replacing a previously-added one by the same name)
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["plugin-added"],
        handler: typing.Callable[[typing_extensions.Self, Plugin], None],
        *args: typing.Any,
    ) -> int:
        """
            Signals that a plugin has been added to the registry (possibly
        replacing a previously-added one by the same name)
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class RegistryClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...

class RegistryPrivate(GObject.GPointer): ...

class Sample(GObject.GBoxed):
    """
    A Gst.Sample is a small object containing data, a type, timing and
    extra arbitrary information.
    """

    # gi Methods
    def get_buffer(self) -> Buffer | None:
        """
        Get the buffer associated with `sample`
        """
    def get_buffer_list(self) -> BufferList | None:
        """
        Get the buffer list associated with `sample`
        """
    def get_caps(self) -> Caps | None:
        """
        Get the caps associated with `sample`
        """
    def get_info(self) -> Structure | None:
        """
        Get extra information associated with `sample`.
        """
    def get_segment(self) -> Segment:
        """
        Get the segment associated with `sample`
        """
    def set_buffer(self, buffer: Buffer) -> None:
        """
        Set the buffer associated with `sample`. `sample` must be writable.
        """
    def set_buffer_list(self, buffer_list: BufferList) -> None:
        """
        Set the buffer list associated with `sample`. `sample` must be writable.
        """
    def set_caps(self, caps: Caps) -> None:
        """
        Set the caps associated with `sample`. `sample` must be writable.
        """
    def set_info(self, info: Structure) -> bool:
        """
            Set the info structure associated with `sample`. `sample` must be writable,
        and `info` must not have a parent set already.
        """
    def set_segment(self, segment: Segment) -> None:
        """
        Set the segment associated with `sample`. `sample` must be writable.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        buffer: Buffer | None = None,
        caps: Caps | None = None,
        segment: Segment | None = None,
        info: Structure | None = None,
    ) -> Sample:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(buffer:Gst.Buffer=None, caps:Gst.Caps=None, segment:Gst.Segment=None, info:Gst.Structure=None) -> Gst.Sample
        """

class Segment(GObject.GBoxed):
    """
    This helper structure holds the relevant values for tracking the region of
    interest in a media file, called a segment.

    The structure can be used for two purposes:

      * performing seeks (handling seek events)
      * tracking playback regions (handling newsegment events)

    The segment is usually configured by the application with a seek event which
    is propagated upstream and eventually handled by an element that performs the seek.

    The configured segment is then propagated back downstream with a newsegment event.
    This information is then used to clip media to the segment boundaries.

    A segment structure is initialized with `Gst.Segment.init`, which takes a Gst.Format
    that will be used as the format of the segment values. The segment will be configured
    with a start value of 0 and a stop/duration of -1, which is undefined. The default
    rate and applied_rate is 1.0.

    The public duration field contains the duration of the segment. When using
    the segment for seeking, the start and time members should normally be left
    to their default 0 value. The stop position is left to -1 unless explicitly
    configured to a different value after a seek event.

    The current position in the segment should be set by changing the position
    member in the structure.

    For elements that perform seeks, the current segment should be updated with the
    `Gst.Segment.do_seek` and the values from the seek event. This method will update
    all the segment fields. The position field will contain the new playback position.
    If the start_type was different from GST_SEEK_TYPE_NONE, playback continues from
    the position position, possibly with updated flags or rate.

    For elements that want to use Gst.Segment to track the playback region,
    update the segment fields with the information from the newsegment event.
    The `Gst.Segment.clip` method can be used to check and clip
    the media data to the segment boundaries.

    For elements that want to synchronize to the pipeline clock, `Gst.Segment.to_running_time`
    can be used to convert a timestamp to a value that can be used to synchronize
    to the clock. This function takes into account the base as well as
    any rate or applied_rate conversions.

    For elements that need to perform operations on media data in stream_time,
    `Gst.Segment.to_stream_time` can be used to convert a timestamp and the segment
    info to stream time (which is always between 0 and the duration of the stream).
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    applied_rate: float = ...
    """
    The applied rate is the rate that has been applied to the stream.
                   The effective/resulting playback rate of a stream is
                   `rate * applied_rate`.
                   The applied rate can be set by source elements when a server is
                   sending the stream with an already modified playback speed
                   rate. Filter elements that modify the stream in a way that
                   modifies the playback speed should also modify the applied
                   rate. For example the #videorate element when its
                   #videorate:rate property is set will set the applied rate of
                   the segment it pushed downstream. Also #scaletempo applies the
                   input segment rate to the stream and outputs a segment with
                   rate=1.0 and applied_rate=<inputsegment.rate>.
    """
    base: int = ...
    """
    the running time (plus elapsed time, see offset) of the
                   segment [start](GstSegment.start) ([stop](GstSegment.stop) if
                   rate < 0.0).
    """
    duration: int = ...
    """
    the duration of the segment is the maximum absolute difference
                   between Gst.Segment.start and Gst.Segment.stop if stop is not
                   set, otherwise it should be the difference between those
                   two values. This should be set by elements that know the
                   overall stream duration (like demuxers) and will be used when
                   seeking with GST_SEEK_TYPE_END.
    """
    flags: SegmentFlags = ...
    """
    flags for this segment
    """
    format: Format = ...
    """
    the unit used for all of the segment's values.
    """
    offset: int = ...
    """
    the offset expresses the elapsed time (in buffer timestamps)
                   before a seek with its start (stop if rate < 0.0) seek type
                   set to GST_SEEK_TYPE_NONE, the value is set to the position
                   of the segment at the time of the seek.
    """
    position: int = ...
    """
    the buffer timestamp position in the segment is supposed to be
                   updated by elements such as sources, demuxers or parsers to
                   track progress by setting it to the last pushed buffer' end time
                   ([timestamp](GstBuffer.pts) + Gst.Buffer.duration) for that
                   specific segment. The position is used when reconfiguring the
                   segment with #gst_segment_do_seek when the seek is only
                   updating the segment (see [offset](GstSegment.offset)).
    """
    rate: float = ...
    """
    the playback rate of the segment is set in response to a seek
                   event and, without any seek, the value should be `1.0`. This
                   value is used by elements that synchronize buffer [running
                   times](additional/design/synchronisation.md#running-time) on
                   the clock (usually the sink elements), leading to consuming
                   buffers faster (for a value `> 1.0`) or slower (for `0.0 <
                   value < 1.0`) than normal playback speed. The rate also
                   defines the playback direction, meaning that when the value is
                   lower than `0.0`, the playback happens in reverse, and the
                   [stream-time](additional/design/synchronisation.md#stream-time)
                   is going backward. The `rate` value should never be `0.0`.
    """
    start: int = ...
    """
    the start time of the segment (in buffer timestamps)
                   [(PTS)](GstBuffer.pts), that is the timestamp of the first
                   buffer to output inside the segment (last one during
                   reverse playback). For example decoders will
                   [clip](gst_segment_clip) out the buffers before the start
                   time.
    """
    stop: int = ...
    """
    the stop time of the segment (in buffer timestamps)
                   [(PTS)](GstBuffer.pts), that is the timestamp of the last
                   buffer to output inside the segment (first one during
                   reverse playback). For example decoders will
                   [clip](gst_segment_clip) out buffers after the stop time.
    """
    time: int = ...
    """
    the stream time of the segment [start](GstSegment.start)
                   ([stop](GstSegment.stop) if rate < 0.0).
    """

    # gi Methods
    def clip(self, format: Format, start: int, stop: int) -> tuple[bool, int, int]:
        """
            Clip the given `start` and `stop` values to the segment boundaries given
        in `segment`. `start` and `stop` are compared and clipped to `segment`
        start and stop values.

        If the function returns False, `start` and `stop` are known to fall
        outside of `segment` and `clip_start` and `clip_stop` are not updated.

        When the function returns True, `clip_start` and `clip_stop` will be
        updated. If `clip_start` or `clip_stop` are different from `start` or `stop`
        respectively, the region fell partially in the segment.

        Note that when `stop` is -1, `clip_stop` will be set to the end of the
        segment. Depending on the use case, this may or may not be what you want.
        """
    def copy(self) -> Segment:
        """
            Create a copy of given `segment`.

        Free-function: gst_segment_free
        """
    def copy_into(self, dest: Segment) -> None:
        """
        Copy the contents of `src` into `dest`.
        """
    def do_seek(
        self,
        rate: float,
        format: Format,
        flags: SeekFlags,
        start_type: SeekType,
        start: int,
        stop_type: SeekType,
        stop: int,
    ) -> tuple[bool, bool]:
        """
            Update the segment structure with the field values of a seek event (see
        `Gst.Event.new_seek`).

        After calling this method, the segment field position and time will
        contain the requested new position in the segment. The new requested
        position in the segment depends on `rate` and `start_type` and `stop_type`.

        For positive `rate`, the new position in the segment is the new `segment`
        start field when it was updated with a `start_type` different from
        GST_SEEK_TYPE_NONE. If no update was performed on `segment` start position
        (GST_SEEK_TYPE_NONE), `start` is ignored and `segment` position is
        unmodified.

        For negative `rate`, the new position in the segment is the new `segment`
        stop field when it was updated with a `stop_type` different from
        GST_SEEK_TYPE_NONE. If no stop was previously configured in the segment, the
        duration of the segment will be used to update the stop position.
        If no update was performed on `segment` stop position (GST_SEEK_TYPE_NONE),
        `stop` is ignored and `segment` position is unmodified.

        The applied rate of the segment will be set to 1.0 by default.
        If the caller can apply a rate change, it should update `segment`
        rate and applied_rate after calling this function.

        `update` will be set to True if a seek should be performed to the segment
        position field. This field can be False if, for example, only the `rate`
        has been changed but not the playback position.
        """
    def free(self) -> None:
        """
        Free the allocated segment `segment`.
        """
    def init(self, format: Format) -> None:
        """
            The start/position fields are set to 0 and the stop/duration
        fields are set to -1 (unknown). The default rate of 1.0 and no
        flags are set.

        Initialize `segment` to its default values.
        """
    def is_equal(self, s1: Segment) -> bool:
        """
            Checks for two segments being equal. Equality here is defined
        as perfect equality, including floating point values.
        """
    def offset_running_time(self, format: Format, offset: int) -> bool:
        """
            Adjust the values in `segment` so that `offset` is applied to all
        future running-time calculations.
        """
    def position_from_running_time(self, format: Format, running_time: int) -> int:
        """
            Convert `running_time` into a position in the segment so that
        `Gst.Segment.to_running_time` with that position returns `running_time`.
        """
    def position_from_running_time_full(self, format: Format, running_time: int) -> tuple[int, int]:
        """
            Translate `running_time` to the segment position using the currently configured
        segment. Compared to `Gst.Segment.position_from_running_time` this function can
        return negative segment position.

        This function is typically used by elements that need to synchronize buffers
        against the clock or each other.

        `running_time` can be any value and the result of this function for values
        outside of the segment is extrapolated.

        When 1 is returned, `running_time` resulted in a positive position returned
        in `position`.

        When this function returns -1, the returned `position` was < 0, and the value
        in the position variable should be negated to get the real negative segment
        position.
        """
    def position_from_stream_time(self, format: Format, stream_time: int) -> int:
        """
            Convert `stream_time` into a position in the segment so that
        `Gst.Segment.to_stream_time` with that position returns `stream_time`.
        """
    def position_from_stream_time_full(self, format: Format, stream_time: int) -> tuple[int, int]:
        """
            Translate `stream_time` to the segment position using the currently configured
        segment. Compared to `Gst.Segment.position_from_stream_time` this function can
        return negative segment position.

        This function is typically used by elements that need to synchronize buffers
        against the clock or each other.

        `stream_time` can be any value and the result of this function for values outside
        of the segment is extrapolated.

        When 1 is returned, `stream_time` resulted in a positive position returned
        in `position`.

        When this function returns -1, the returned `position` should be negated
        to get the real negative segment position.
        """
    def set_running_time(self, format: Format, running_time: int) -> bool:
        """
            Adjust the start/stop and base values of `segment` such that the next valid
        buffer will be one with `running_time`.
        """
    @deprecated("deprecated")
    def to_position(self, format: Format, running_time: int) -> int:
        """
            Convert `running_time` into a position in the segment so that
        `Gst.Segment.to_running_time` with that position returns `running_time`.
        """
    def to_running_time(self, format: Format, position: int) -> int:
        """
            Translate `position` to the total running time using the currently configured
        segment. Position is a value between `segment` start and stop time.

        This function is typically used by elements that need to synchronize to the
        global clock in a pipeline. The running time is a constantly increasing value
        starting from 0. When `Gst.Segment.init` is called, this value will reset to
        0.

        This function returns -1 if the position is outside of `segment` start and stop.
        """
    def to_running_time_full(self, format: Format, position: int) -> tuple[int, int]:
        """
            Translate `position` to the total running time using the currently configured
        segment. Compared to `Gst.Segment.to_running_time` this function can return
        negative running-time.

        This function is typically used by elements that need to synchronize buffers
        against the clock or each other.

        `position` can be any value and the result of this function for values outside
        of the segment is extrapolated.

        When 1 is returned, `position` resulted in a positive running-time returned
        in `running_time`.

        When this function returns -1, the returned `running_time` should be negated
        to get the real negative running time.
        """
    def to_stream_time(self, format: Format, position: int) -> int:
        """
            Translate `position` to stream time using the currently configured
        segment. The `position` value must be between `segment` start and
        stop value.

        This function is typically used by elements that need to operate on
        the stream time of the buffers it receives, such as effect plugins.
        In those use cases, `position` is typically the buffer timestamp or
        clock time that one wants to convert to the stream time.
        The stream time is always between 0 and the total duration of the
        media stream.
        """
    def to_stream_time_full(self, format: Format, position: int) -> tuple[int, int]:
        """
            Translate `position` to the total stream time using the currently configured
        segment. Compared to `Gst.Segment.to_stream_time` this function can return
        negative stream-time.

        This function is typically used by elements that need to synchronize buffers
        against the clock or each other.

        `position` can be any value and the result of this function for values outside
        of the segment is extrapolated.

        When 1 is returned, `position` resulted in a positive stream-time returned
        in `stream_time`.

        When this function returns -1, the returned `stream_time` should be negated
        to get the real negative stream time.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
    ) -> Segment:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.Segment
        """

class SharedTaskPool(TaskPool):
    """
    The Gst.SharedTaskPool object.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent(self) -> TaskPool | None: ...
    @builtins.property
    def priv(self) -> SharedTaskPoolPrivate | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize SharedTaskPool object with properties.
        """
    def get_max_threads(self) -> int: ...
    def set_max_threads(self, max_threads: int) -> None:
        """
            Update the maximal number of threads the `pool` may spawn. When
        the maximal number of threads is reduced, existing threads are not
        immediately shut down, see `g_thread_pool_set_max_threads`.

        Setting `max_threads` to 0 effectively freezes the pool.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
    ) -> TaskPool:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.TaskPool
        """

class SharedTaskPoolClass(GObject.GPointer):
    """
    The Gst.SharedTaskPoolClass object.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> TaskPoolClass | None: ...

class SharedTaskPoolPrivate(GObject.GPointer): ...

class StaticCaps(GObject.GPointer):
    """
    Data structure to initialize Gst.Caps from a string description usually
    used in conjunction with `GST_STATIC_CAPS` and `Gst.StaticCaps.get` to
    instantiate a Gst.Caps.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    caps: Caps | None = ...
    """
    the cached Gst.Caps
    """
    string: str = ...
    """
    a string describing a caps
    """

    # gi Methods
    def cleanup(self) -> None:
        """
        Cleans up the cached caps contained in `static_caps`.
        """
    def get(self) -> Caps | None:
        """
        Converts a Gst.StaticCaps to a Gst.Caps.
        """

class StaticPadTemplate(GObject.GPointer):
    """
    Structure describing the Gst.StaticPadTemplate.
    """

    # gi Fields
    direction: PadDirection = ...
    """
    the direction of the template
    """
    name_template: str = ...
    """
    the name of the template
    """
    presence: PadPresence = ...
    """
    the presence of the template
    """
    static_caps: StaticCaps | None = ...
    """
    the caps of the template.
    """

    # gi Methods
    def get(self) -> PadTemplate | None:
        """
        Converts a Gst.StaticPadTemplate into a Gst.PadTemplate.
        """
    def get_caps(self) -> Caps:
        """
        Gets the capabilities of the static pad template.
        """

class Stream(Object):
    """
    A high-level object representing a single stream. It might be backed, or
    not, by an actual flow of data in a pipeline (Gst.Pad).

    A Gst.Stream does not care about data changes (such as decoding, encoding,
    parsing,...) as long as the underlying data flow corresponds to the same
    high-level flow (ex: a certain audio track).

    A Gst.Stream contains all the information pertinent to a stream, such as
    stream-id, tags, caps, type, ...

    Elements can subclass a Gst.Stream for internal usage (to contain information
    pertinent to streams of data).
    """

    class Props(Object.Props):
        caps: Caps | None
        """
        The Gst.Caps of the Gst.Stream.
        """
        stream_flags: StreamFlags  # [stream-flags]: changed because contained invalid characters
        stream_id: str  # [stream-id]: changed because contained invalid characters
        """
        The unique identifier of the Gst.Stream. Can only be set at construction
        time.
        """
        stream_type: StreamType  # [stream-type]: changed because contained invalid characters
        """
        The Gst.StreamType of the Gst.Stream. Can only be set at construction time.
        """
        tags: TagList | None
        """
        The Gst.TagList of the Gst.Stream.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def priv(self) -> StreamPrivate | None: ...
    @builtins.property
    def stream_id(self) -> str:
        """
        The Stream Identifier for this Gst.Stream
        """

    # gi Methods
    def __init__(
        self,
        caps: Caps | None = None,
        name: str | None = None,
        parent: Object | None = None,
        stream_flags: StreamFlags | None = StreamFlags.NONE,
        stream_id: str | None = None,
        stream_type: StreamType | None = StreamType.UNKNOWN,
        tags: TagList | None = None,
    ) -> None:
        """
        Initialize Stream object with properties.
        """
    @builtins.property
    def get_caps(self) -> Caps | None:
        """
        Retrieve the caps for `stream`, if any
        """
    @builtins.property
    def get_stream_flags(self) -> StreamFlags:
        """
        Retrieve the current stream flags for `stream`
        """
    @builtins.property
    def get_stream_id(self) -> str | None:
        """
        Returns the stream ID of `stream`.
        """
    @builtins.property
    def get_stream_type(self) -> StreamType:
        """
        Retrieve the stream type for `stream`
        """
    @builtins.property
    def get_tags(self) -> TagList | None:
        """
        Retrieve the tags for `stream`, if any
        """
    def set_caps(self, caps: Caps | None = None) -> None:
        """
        Set the caps for the Gst.Stream
        """
    def set_stream_flags(self, flags: StreamFlags) -> None:
        """
        Set the `flags` for the `stream`.
        """
    def set_stream_type(self, stream_type: StreamType) -> None:
        """
        Set the stream type of `stream`
        """
    def set_tags(self, tags: TagList | None = None) -> None:
        """
        Set the tags for the Gst.Stream
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        stream_id: str | None,
        caps: Caps | None,
        type: StreamType,
        flags: StreamFlags,
    ) -> Stream:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(stream_id:str=None, caps:Gst.Caps=None, type:Gst.StreamType, flags:Gst.StreamFlags) -> Gst.Stream
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stream_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stream_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stream_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StreamClass(GObject.GPointer):
    """
    GstStream class structure
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        the parent class structure
        """

class StreamCollection(Object):
    """
    A collection of Gst.Stream that are available.

    A Gst.StreamCollection will be provided by elements that can make those
    streams available. Applications can use the collection to show the user
    what streams are available by using %`Gst.StreamCollection.get_stream`

    Once posted, a Gst.StreamCollection is immutable. Updates are made by sending
    a new Gst.StreamCollection message, which may or may not share some of
    the Gst.Stream objects from the collection it replaces. The receiver can check
    the sender of a stream collection message to know which collection is
    obsoleted.

    Several elements in a pipeline can provide Gst.StreamCollection.

    Applications can activate streams from a collection by using the
    GST_EVENT_SELECT_STREAMS event on a pipeline, bin or element.
    """

    class Props(Object.Props):
        upstream_id: str  # [upstream-id]: changed because contained invalid characters
        """
        stream-id
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def priv(self) -> StreamCollectionPrivate | None: ...
    @builtins.property
    def upstream_id(self) -> str: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None, upstream_id: str | None = None) -> None:
        """
        Initialize StreamCollection object with properties.
        """
    def add_stream(self, stream: Stream) -> bool:
        """
        Add the given `stream` to the `collection`.
        """
    def get_size(self) -> int:
        """
        Get the number of streams this collection contains
        """
    def get_stream(self, index: int) -> Stream | None:
        """
            Retrieve the Gst.Stream with index `index` from the collection.

        The caller should not modify the returned Gst.Stream
        """
    @builtins.property
    def get_upstream_id(self) -> str | None:
        """
        Returns the upstream id of the `collection`.
        """

    # python methods (overrides?)
    def do_stream_notify(
        self,
        stream: Stream,
        pspec: GObject.ParamSpec,
    ) -> None:
        """
        stream_notify(self, stream:Gst.Stream, pspec:GObject.ParamSpec)
        """
    @classmethod
    def new(
        cls,
        upstream_id: str | None = None,
    ) -> StreamCollection:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(upstream_id:str=None) -> Gst.StreamCollection
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["stream-notify"],
        handler: typing.Callable[[typing_extensions.Self, Stream, GObject.ParamSpec], None],
        *args: typing.Any,
    ) -> int:
        """
            The stream notify signal is used to be notified of property changes to
        streams within the collection.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::upstream_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StreamCollectionClass(GObject.GPointer):
    """
    GstStreamCollection class structure
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        the parent class structure
        """
    @builtins.property
    def stream_notify(self) -> stream_notifyStreamCollectionClassCB:
        """
        default signal handler for the stream-notify signal
        """

class StreamCollectionPrivate(GObject.GPointer): ...
class StreamPrivate(GObject.GPointer): ...

class Structure(GObject.GBoxed):
    """
    A Gst.Structure is a collection of key/value pairs. The keys are expressed as
    GQuarks and the values can be of any GType.

    In addition to the key/value pairs, a Gst.Structure also has a name. The name
    starts with a letter and can be filled by letters, numbers and any of
    "/-_.:".

    Gst.Structure is used by various GStreamer subsystems to store information in
    a flexible and extensible way. A Gst.Structure does not have a refcount
    because it usually is part of a higher level object such as Gst.Caps,
    Gst.Message, Gst.Event, Gst.Query. It provides a means to enforce mutability
    using the refcount of the parent with the `Gst.Structure.set_parent_refcount`
    method.

    A Gst.Structure can be created with `Gst.Structure.new_empty` or
    `Gst.Structure.new`, which both take a name and an optional set of key/value
    pairs along with the types of the values.

    Field values can be changed with `Gst.Structure.set_value` or
    `Gst.Structure.set`.

    Field values can be retrieved with `Gst.Structure.get_value` or the more
    convenient gst_structure_get_*() functions.

    Fields can be removed with `Gst.Structure.remove_field` or
    `Gst.Structure.remove_fields`.

    Strings in structures must be ASCII or UTF-8 encoded. Other encodings are not
    allowed. Strings may be None however.

    ## The serialization format

    GstStructure serialization format serialize the GstStructure name,
    keys/GType/values in a comma separated list with the structure name as first
    field without value followed by separated key/value pairs in the form
    `key=value`, for example:

    ```
    a-structure, key=value
    ````

    The values type will be inferred if not explicitly specified with the
    `(GTypeName)value` syntax, for example the following struct will have one
    field called 'is-string' which has the string 'true' as a value:

    ```
    a-struct, field-is-string=(string)true, field-is-boolean=true
    ```

    *Note*: without specifying `(string), `field-is-string` type would have been
    inferred as boolean.

    *Note*: we specified `(string)` as a type even if `gchararray` is the actual
    GType name as for convenience some well known types have been aliased or
    abbreviated.

    To avoid specifying the type, you can give some hints to the "type system".
    For example to specify a value as a double, you should add a decimal (ie. `1`
    is an `int` while `1.0` is a `double`).

    *Note*: when a structure is serialized with #gst_structure_to_string, all
    values are explicitly typed.

    Some types have special delimiters:

    - [GstValueArray](GST_TYPE_ARRAY) are inside "less and greater than" (`<` and
      `>`). For example `a-structure, array=<1, 2, 3>
    - Ranges are inside brackets (`[` and `]`). For example `a-structure,
      range=[1, 6, 2]` 1 being the min value, 6 the maximum and 2 the step. To
      specify a GST_TYPE_INT64_RANGE you need to explicitly specify it like:
      `a-structure, a-int64-range=(gint64) [1, 5]`
    - [GstValueList](GST_TYPE_LIST) are inside curly brackets (`{` and `}`).
      For example `a-structure, list={1, 2, 3}`
    - [GStrv](G_TYPE_STRV) are inside "less and greater than" (`<` and
      `>`) and each string is double-quoted.
      For example `a-structure, strv=(GStrv)<"foo", "bar">`. Since 1.26.0.

    Structures are delimited either by a null character `\\0` or a semicolon `;`
    the latter allowing to store multiple structures in the same string (see
    Gst.Caps).

    Quotes are used as "default" delimiters and can be used around any types that
    don't use other delimiters (for example `a-struct, i=(int)"1"`). They are use
    to allow adding spaces or special characters (such as delimiters,
    semicolumns, etc..) inside strings and you can use backslashes `` to escape
    characters inside them, for example:

    ```
    a-struct, special=""{[(;)]}" can be used inside quotes"
    ```

    They also allow for nested structure, such as:

    ```
    a-struct, nested=(GstStructure)"nested-struct, nested=true"
    ```

    Since 1.20, nested structures and caps can be specified using brackets (`[`
    and `]`), for example:

    ```
    a-struct, nested=[nested-struct, nested=true]
    ```

    > *note*: `Gst.Structure.to_string` won't use that syntax for backward
    > compatibility reason, `Gst.Structure.serialize_full` has been added for
    > that purpose.
    """

    # gi Fields
    @builtins.property
    def name(self) -> int: ...
    type: GObject.GType = ...  # type: ignore
    """
    the GType of a structure
    """

    # gi Methods
    def can_intersect(self, struct2: Structure) -> bool:
        """
            Tries intersecting `struct1` and `struct2` and reports whether the result
        would not be empty.
        """
    def copy(self) -> Structure:
        """
            Duplicates a Gst.Structure and all its fields and values.

        Free-function: gst_structure_free
        """
    @deprecated("deprecated")
    def filter_and_map_in_place(self, func: StructureFilterMapFunc, *user_data: object | None) -> None:
        """
            Calls the provided function once for each field in the Gst.Structure. In
        contrast to `Gst.Structure.foreach`, the function may modify the fields.
        In contrast to `Gst.Structure.map_in_place`, the field is removed from
        the structure if False is returned from the function.
        The structure must be mutable.
        """
    def filter_and_map_in_place_id_str(self, func: StructureFilterMapIdStrFunc, *user_data: object | None) -> None:
        """
            Calls the provided function once for each field in the Gst.Structure. In
        contrast to `Gst.Structure.foreach_id_str`, the function may modify the fields.
        In contrast to `Gst.Structure.map_in_place_id_str`, the field is removed from
        the structure if False is returned from the function.
        The structure must be mutable.
        """
    def fixate(self) -> None:
        """
            Fixate all values in `structure` using `Gst.value_fixate`.
        `structure` will be modified in-place and should be writable.
        """
    def fixate_field(self, field_name: str) -> bool:
        """
        Fixates a Gst.Structure by changing the given field with its fixated value.
        """
    def fixate_field_boolean(self, field_name: str, target: bool) -> bool:
        """
            Fixates a Gst.Structure by changing the given `field_name` field to the given
        `target` boolean if that field is not fixed yet.
        """
    def fixate_field_nearest_double(self, field_name: str, target: float) -> bool:
        """
            Fixates a Gst.Structure by changing the given field to the nearest
        double to `target` that is a subset of the existing field.
        """
    def fixate_field_nearest_fraction(self, field_name: str, target_numerator: int, target_denominator: int) -> bool:
        """
            Fixates a Gst.Structure by changing the given field to the nearest
        fraction to `target_numerator`/`target_denominator` that is a subset
        of the existing field.
        """
    def fixate_field_nearest_int(self, field_name: str, target: int) -> bool:
        """
            Fixates a Gst.Structure by changing the given field to the nearest
        integer to `target` that is a subset of the existing field.
        """
    def fixate_field_string(self, field_name: str, target: str) -> bool:
        """
            Fixates a Gst.Structure by changing the given `field_name` field to the given
        `target` string if that field is not fixed yet.
        """
    @deprecated("deprecated")
    def foreach(self, func: StructureForeachFunc, *user_data: object | None) -> bool:
        """
            Calls the provided function once for each field in the Gst.Structure. The
        function must not modify the fields. Also see `Gst.Structure.map_in_place`
        and `Gst.Structure.filter_and_map_in_place`.
        """
    def foreach_id_str(self, func: StructureForeachIdStrFunc, *user_data: object | None) -> bool:
        """
            Calls the provided function once for each field in the Gst.Structure. The
        function must not modify the fields. Also see `Gst.Structure.map_in_place_id_str`
        and `Gst.Structure.filter_and_map_in_place_id_str`.
        """
    def free(self) -> None:
        """
            Frees a Gst.Structure and all its fields and values. The structure must not
        have a parent when this function is called.
        """
    @classmethod
    def from_string(cls, string: str) -> tuple[Structure | None, str]:
        """
            Creates a Gst.Structure from a string representation.
        If end is not None, a pointer to the place inside the given string
        where parsing ended will be returned.

        Free-function: gst_structure_free
        """
    def get_array(self, fieldname: str) -> tuple[bool, GObject.ValueArray]:
        """
            This is useful in language bindings where unknown GValue types are not
        supported. This function will convert the Gst.TYPE_ARRAY into a newly
        allocated GValueArray and return it through `array`. Be aware that this is
        slower then getting the GValue directly.
        """
    def get_boolean(self, fieldname: str) -> tuple[bool, bool]:
        """
            Sets the boolean pointed to by `value` corresponding to the value of the
        given field.  Caller is responsible for making sure the field exists
        and has the correct type.
        """
    def get_clock_time(self, fieldname: str) -> tuple[bool, int]:
        """
            Sets the clock time pointed to by `value` corresponding to the clock time
        of the given field.  Caller is responsible for making sure the field exists
        and has the correct type.
        """
    def get_date(self, fieldname: str) -> tuple[bool, GLib.Date]:
        """
            Sets the date pointed to by `value` corresponding to the date of the
        given field.  Caller is responsible for making sure the field exists
        and has the correct type.

        On success `value` will point to a newly-allocated copy of the date which
        should be freed with `g_date_free` when no longer needed (note: this is
        inconsistent with e.g. `Gst.Structure.get_string` which doesn't return a
        copy of the string).
        """
    def get_date_time(self, fieldname: str) -> tuple[bool, DateTime]:
        """
            Sets the datetime pointed to by `value` corresponding to the datetime of the
        given field. Caller is responsible for making sure the field exists
        and has the correct type.

        On success `value` will point to a reference of the datetime which
        should be unreffed with `Gst.DateTime.unref` when no longer needed
        (note: this is inconsistent with e.g. `Gst.Structure.get_string`
        which doesn't return a copy of the string).
        """
    def get_double(self, fieldname: str) -> tuple[bool, float]:
        """
            Sets the double pointed to by `value` corresponding to the value of the
        given field.  Caller is responsible for making sure the field exists
        and has the correct type.
        """
    def get_enum(self, fieldname: str, enumtype: GObject.GType) -> tuple[bool, int]:
        """
            Sets the int pointed to by `value` corresponding to the value of the
        given field.  Caller is responsible for making sure the field exists,
        has the correct type and that the enumtype is correct.
        """
    def get_field_type(self, fieldname: str) -> GObject.GType:
        """
            Finds the field with the given name, and returns the type of the
        value it contains.  If the field is not found, G_TYPE_INVALID is
        returned.
        """
    def get_flags(self, fieldname: str, flags_type: GObject.GType) -> tuple[bool, int]:
        """
            Sets the unsigned int pointed to by `value` corresponding to the value of the
        given field. Caller is responsible for making sure the field exists,
        has the correct type and that the flagstype is correct.
        """
    def get_flagset(self, fieldname: str) -> tuple[bool, int, int]:
        """
            Read the GstFlagSet flags and mask out of the structure into the
        provided pointers.
        """
    def get_fraction(self, fieldname: str) -> tuple[bool, int, int]:
        """
            Sets the integers pointed to by `value_numerator` and `value_denominator`
        corresponding to the value of the given field.  Caller is responsible
        for making sure the field exists and has the correct type.
        """
    def get_int(self, fieldname: str) -> tuple[bool, int]:
        """
            Sets the int pointed to by `value` corresponding to the value of the
        given field.  Caller is responsible for making sure the field exists
        and has the correct type.
        """
    def get_int64(self, fieldname: str) -> tuple[bool, int]:
        """
            Sets the #gint64 pointed to by `value` corresponding to the value of the
        given field. Caller is responsible for making sure the field exists
        and has the correct type.
        """
    def get_list(self, fieldname: str) -> tuple[bool, GObject.ValueArray]:
        """
            This is useful in language bindings where unknown GValue types are not
        supported. This function will convert the Gst.TYPE_LIST into a newly
        allocated GValueArray and return it through `array`. Be aware that this is
        slower then getting the GValue directly.
        """
    def get_name(self) -> str:
        """
        Get the name of `structure` as a string.
        """
    @deprecated("deprecated")
    def get_name_id(self) -> int:
        """
        Get the name of `structure` as a GQuark.
        """
    def get_name_id_str(self) -> IdStr:
        """
        Get the name of `structure` as a GstIdStr.
        """
    def get_string(self, fieldname: str) -> str | None:
        """
            Finds the field corresponding to `fieldname`, and returns the string
        contained in the field's value.  Caller is responsible for making
        sure the field exists and has the correct type.

        The string should not be modified, and remains valid until the next
        call to a gst_structure_*() function with the given structure.
        """
    def get_uint(self, fieldname: str) -> tuple[bool, int]:
        """
            Sets the uint pointed to by `value` corresponding to the value of the
        given field.  Caller is responsible for making sure the field exists
        and has the correct type.
        """
    def get_uint64(self, fieldname: str) -> tuple[bool, int]:
        """
            Sets the #guint64 pointed to by `value` corresponding to the value of the
        given field. Caller is responsible for making sure the field exists
        and has the correct type.
        """
    def get_value(self, fieldname: str) -> GObject.Value | None:
        """
        Get the value of the field with name `fieldname`.
        """
    def has_field(self, fieldname: str) -> bool:
        """
        Check if `structure` contains a field named `fieldname`.
        """
    def has_field_typed(self, fieldname: str, type: GObject.GType) -> bool:
        """
        Check if `structure` contains a field named `fieldname` and with GType `type`.
        """
    def has_name(self, name: str) -> bool:
        """
        Checks if the structure has the given name
        """
    def id_get_value(self, field: int) -> GObject.Value | None:
        """
        Get the value of the field with GQuark `field`.
        """
    @deprecated("deprecated")
    def id_has_field(self, field: int) -> bool:
        """
        Check if `structure` contains a field named `field`.
        """
    @deprecated("deprecated")
    def id_has_field_typed(self, field: int, type: GObject.GType) -> bool:
        """
        Check if `structure` contains a field named `field` and with GType `type`.
        """
    @deprecated("deprecated")
    def id_set_value(self, field: int, value: GObject.Value) -> None:
        """
            Sets the field with the given GQuark `field` to `value`.  If the field
        does not exist, it is created.  If the field exists, the previous
        value is replaced and freed.
        """
    def id_str_get_field_type(self, fieldname: IdStr) -> GObject.GType:
        """
            Finds the field with the given name, and returns the type of the
        value it contains.  If the field is not found, G_TYPE_INVALID is
        returned.
        """
    def id_str_get_value(self, fieldname: IdStr) -> GObject.Value | None:
        """
        Get the value of the field with name `fieldname`.
        """
    def id_str_has_field(self, fieldname: IdStr) -> bool:
        """
        Check if `structure` contains a field named `fieldname`.
        """
    def id_str_has_field_typed(self, fieldname: IdStr, type: GObject.GType) -> bool:
        """
        Check if `structure` contains a field named `fieldname` and with GType `type`.
        """
    def id_str_nth_field_name(self, index: int) -> IdStr:
        """
            Get the name (as a GstIdStr) of the given field number,
        counting from 0 onwards.
        """
    def id_str_remove_field(self, fieldname: IdStr) -> None:
        """
            Removes the field with the given name.  If the field with the given
        name does not exist, the structure is unchanged.
        """
    def id_str_set_value(self, fieldname: IdStr, value: GObject.Value) -> None:
        """
            Sets the field with the given name `field` to `value`.  If the field
        does not exist, it is created.  If the field exists, the previous
        value is replaced and freed.
        """
    def id_str_take_value(self, fieldname: IdStr, value: GObject.Value) -> None:
        """
            Sets the field with the given GstIdStr `field` to `value`.  If the field
        does not exist, it is created.  If the field exists, the previous
        value is replaced and freed.
        """
    @deprecated("deprecated")
    def id_take_value(self, field: int, value: GObject.Value) -> None:
        """
            Sets the field with the given GQuark `field` to `value`.  If the field
        does not exist, it is created.  If the field exists, the previous
        value is replaced and freed.
        """
    def intersect(self, struct2: Structure) -> Structure | None:
        """
        Intersects `struct1` and `struct2` and returns the intersection.
        """
    def is_equal(self, structure2: Structure) -> bool:
        """
        Tests if the two Gst.Structure are equal.
        """
    def is_subset(self, superset: Structure) -> bool:
        """
            Checks if `subset` is a subset of `superset`, i.e. has the same
        structure name and for all fields that are existing in `superset`,
        `subset` has a value that is a subset of the value in `superset`.
        """
    @deprecated("deprecated")
    def map_in_place(self, func: StructureMapFunc, *user_data: object | None) -> bool:
        """
            Calls the provided function once for each field in the Gst.Structure. In
        contrast to `Gst.Structure.foreach`, the function may modify but not delete the
        fields. The structure must be mutable.
        """
    def map_in_place_id_str(self, func: StructureMapIdStrFunc, *user_data: object | None) -> bool:
        """
            Calls the provided function once for each field in the Gst.Structure. In
        contrast to `Gst.Structure.foreach_id_str`, the function may modify but not delete the
        fields. The structure must be mutable.
        """
    def n_fields(self) -> int:
        """
        Get the number of fields in the structure.
        """
    @classmethod
    def new_empty(cls, name: str) -> Structure:
        """
            Creates a new, empty Gst.Structure with the given `name`.

        See `Gst.Structure.set_name` for constraints on the `name` parameter.

        Free-function: gst_structure_free
        """
    @classmethod
    def new_from_string(cls, string: str) -> Structure | None:
        """
            Creates a Gst.Structure from a string representation.
        If end is not None, a pointer to the place inside the given string
        where parsing ended will be returned.

        The current implementation of serialization will lead to unexpected results
        when there are nested Gst.Caps / Gst.Structure deeper than one level unless
        the `Gst.Structure.serialize` function is used (without
        GST_SERIALIZE_FLAG_BACKWARD_COMPAT)

        Free-function: gst_structure_free
        """
    @deprecated("deprecated")
    @classmethod
    def new_id_empty(cls, quark: int) -> Structure:
        """
            Creates a new, empty Gst.Structure with the given name as a GQuark.

        Free-function: gst_structure_free
        """
    @classmethod
    def new_id_str_empty(cls, name: IdStr) -> Structure:
        """
            Creates a new, empty Gst.Structure with the given name.

        Free-function: gst_structure_free
        """
    @classmethod
    def new_static_str_empty(cls, name: str) -> Structure:
        """
            Creates a new, empty Gst.Structure with the given `name`.

        See `Gst.Structure.set_name` for constraints on the `name` parameter.

        `name` needs to be valid for the remaining lifetime of the process, e.g. has
        to be a static string.

        Free-function: gst_structure_free
        """
    def nth_field_name(self, index: int) -> str:
        """
        Get the name of the given field number, counting from 0 onwards.
        """
    def remove_all_fields(self) -> None:
        """
        Removes all fields in a GstStructure.
        """
    def remove_field(self, fieldname: str) -> None:
        """
            Removes the field with the given name.  If the field with the given
        name does not exist, the structure is unchanged.
        """
    @deprecated("deprecated")
    def serialize(self, flags: SerializeFlags) -> str:
        """
            Converts `structure` to a human-readable string representation.

        This version of the caps serialization function introduces support for nested
        structures and caps but the resulting strings won't be parsable with
        GStreamer prior to 1.20 unless GST_SERIALIZE_FLAG_BACKWARD_COMPAT is passed
        as `flag`.

        Gst.SERIALIZE_FLAG_STRICT flags is not allowed because it would make this
        function nullable which is an API break for bindings.
        Use `Gst.Structure.serialize_full` instead.

        Free-function: g_free
        """
    def serialize_full(self, flags: SerializeFlags) -> str | None:
        """
            Alias for `Gst.Structure.serialize` but with nullable annotation because it
        can return None when Gst.SERIALIZE_FLAG_STRICT flag is set.
        """
    def set_array(self, fieldname: str, array: GObject.ValueArray) -> None:
        """
            This is useful in language bindings where unknown GValue types are not
        supported. This function will convert a `array` to Gst.TYPE_ARRAY and set
        the field specified by `fieldname`.  Be aware that this is slower then using
        Gst.TYPE_ARRAY in a GValue directly.
        """
    def set_list(self, fieldname: str, array: GObject.ValueArray) -> None:
        """
            This is useful in language bindings where unknown GValue types are not
        supported. This function will convert a `array` to Gst.TYPE_LIST and set
        the field specified by `fieldname`. Be aware that this is slower then using
        Gst.TYPE_LIST in a GValue directly.
        """
    def set_name(self, name: str) -> None:
        """
            Sets the name of the structure to the given `name`.  The string
        provided is copied before being used. It must not be empty, start with a
        letter and can be followed by letters, numbers and any of "/-_.:".
        """
    def set_name_id_str(self, name: IdStr) -> None:
        """
            Sets the name of the structure to the given `name`.  The string
        provided is copied before being used. It must not be empty, start with a
        letter and can be followed by letters, numbers and any of "/-_.:".
        """
    def set_name_static_str(self, name: str) -> None:
        """
            Sets the name of the structure to the given `name`.  The string
        provided is copied before being used. It must not be empty, start with a
        letter and can be followed by letters, numbers and any of "/-_.:".

        `name` needs to be valid for the remaining lifetime of the process, e.g. has
        to be a static string.
        """
    def set_parent_refcount(self, refcount: int) -> bool:
        """
            Sets the parent_refcount field of Gst.Structure. This field is used to
        determine whether a structure is mutable or not. This function should only be
        called by code implementing parent objects of Gst.Structure, as described in
        the MT Refcounting section of the design documents.
        """
    def set_value(self, fieldname: str, value: GObject.Value) -> None:
        """
            Sets the field with the given name `field` to `value`.  If the field
        does not exist, it is created.  If the field exists, the previous
        value is replaced and freed.
        """
    def set_value_static_str(self, fieldname: str, value: GObject.Value) -> None:
        """
            Sets the field with the given name `field` to `value`.  If the field
        does not exist, it is created.  If the field exists, the previous
        value is replaced and freed.

        `fieldname` needs to be valid for the remaining lifetime of the process, e.g.
        has to be a static string.
        """
    @staticmethod
    def take(oldstr_ptr: Structure | None = None, newstr: Structure | None = None) -> tuple[bool, Structure | None]:
        """
            Atomically modifies a pointer to point to a new structure.
        The Gst.Structure `oldstr_ptr` is pointing to is freed and
        `newstr` is taken ownership over.

        Either `newstr` and the value pointed to by `oldstr_ptr` may be None.

        It is a programming error if both `newstr` and the value pointed to by
        `oldstr_ptr` refer to the same, non-None structure.
        """
    def take_value(self, fieldname: str, value: GObject.Value) -> None:
        """
            Sets the field with the given name `field` to `value`.  If the field
        does not exist, it is created.  If the field exists, the previous
        value is replaced and freed. The function will take ownership of `value`.
        """
    def take_value_static_str(self, fieldname: str, value: GObject.Value) -> None:
        """
            Sets the field with the given name `field` to `value`.  If the field
        does not exist, it is created.  If the field exists, the previous
        value is replaced and freed. The function will take ownership of `value`.

        `fieldname` needs to be valid for the remaining lifetime of the process, e.g.
        has to be a static string.
        """
    def to_string(self) -> str:
        """
            Converts `structure` to a human-readable string representation.

        For debugging purposes its easier to do something like this: |[<!--
        language="C" --> GST_LOG ("structure is %" GST_PTR_FORMAT, structure);
        ]|
        This prints the structure in human readable form.

        This function will lead to unexpected results when there are nested Gst.Caps
        / Gst.Structure deeper than one level, you should user
        `Gst.Structure.serialize_full` instead for those cases.

        Free-function: g_free
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    def keys(
        self,
    ) -> typing.Any: ...

class SystemClock(Clock):
    """
    The GStreamer core provides a GstSystemClock based on the system time.
    Asynchronous callbacks are scheduled from an internal thread.

    Clock implementors are encouraged to subclass this systemclock as it
    implements the async notification.

    Subclasses can however override all of the important methods for sync and
    async notifications to implement their own callback methods or blocking
    wait operations.
    """

    class Props(Clock.Props):
        clock_type: ClockType  # [clock-type]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def clock(self) -> Clock | None: ...
    @builtins.property
    def priv(self) -> SystemClockPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        clock_type: ClockType | None = ClockType.MONOTONIC,
        name: str | None = None,
        parent: Object | None = None,
        timeout: int | None = None,
        window_size: int | None = None,
        window_threshold: int | None = None,
    ) -> None:
        """
        Initialize SystemClock object with properties.
        """
    @staticmethod
    def obtain() -> Clock:
        """
            Get a handle to the default system clock. The refcount of the
        clock will be increased so you need to unref the clock after
        usage.
        """
    @staticmethod
    def set_default(new_clock: Clock | None = None) -> None:
        """
            Sets the default system clock that can be obtained with
        `Gst.SystemClock.obtain`.

        This is mostly used for testing and debugging purposes when you
        want to have control over the time reported by the default system
        clock.

        MT safe.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::clock_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SystemClockClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ClockClass | None: ...

class SystemClockPrivate(GObject.GPointer): ...

class TagList(GObject.GBoxed):
    """
    List of tags and values used to describe media metadata.

    Strings in structures must be ASCII or UTF-8 encoded. Other encodings are
    not allowed. Strings must not be empty or None.
    """

    # gi Fields
    mini_object: MiniObject | None = ...
    """
    the parent type
    """

    # gi Methods
    def add_value(self, mode: TagMergeMode, tag: str, value: GObject.Value) -> None:
        """
        Sets the GValue for a given tag using the specified mode.
        """
    def copy(self) -> TagList:
        """
            Creates a new Gst.TagList as a copy of the old `taglist`. The new taglist
        will have a refcount of 1, owned by the caller, and will be writable as
        a result.

        Note that this function is the semantic equivalent of a `Gst.TagList.ref`
        followed by a `Gst.TagList.make_writable`. If you only want to hold on to a
        reference to the data, you should use `Gst.TagList.ref`.

        When you are finished with the taglist, call `Gst.TagList.unref` on it.
        """
    @staticmethod
    def copy_value(list: TagList, tag: str) -> tuple[bool, GObject.Value]:
        """
            Copies the contents for the given tag into the value,
        merging multiple values into one if multiple values are associated
        with the tag.
        You must `g_value_unset` the value after use.
        """
    def foreach(self, func: TagForeachFunc, *user_data: object | None) -> None:
        """
            Calls the given function for each tag inside the tag list. Note that if there
        is no tag, the function won't be called at all.
        """
    def get_boolean(self, tag: str) -> tuple[bool, bool]:
        """
            Copies the contents for the given tag into the value, merging multiple values
        into one if multiple values are associated with the tag.
        """
    def get_boolean_index(self, tag: str, index: int) -> tuple[bool, bool]:
        """
            Gets the value that is at the given index for the given tag in the given
        list.
        """
    def get_date(self, tag: str) -> tuple[bool, GLib.Date]:
        """
            Copies the first date for the given tag in the taglist into the variable
        pointed to by `value`. Free the date with `g_date_free` when it is no longer
        needed.

        Free-function: g_date_free
        """
    def get_date_index(self, tag: str, index: int) -> tuple[bool, GLib.Date]:
        """
            Gets the date that is at the given index for the given tag in the given
        list and copies it into the variable pointed to by `value`. Free the date
        with `g_date_free` when it is no longer needed.

        Free-function: g_date_free
        """
    def get_date_time(self, tag: str) -> tuple[bool, DateTime]:
        """
            Copies the first datetime for the given tag in the taglist into the variable
        pointed to by `value`. Unref the date with `Gst.DateTime.unref` when
        it is no longer needed.

        Free-function: gst_date_time_unref
        """
    def get_date_time_index(self, tag: str, index: int) -> tuple[bool, DateTime]:
        """
            Gets the datetime that is at the given index for the given tag in the given
        list and copies it into the variable pointed to by `value`. Unref the datetime
        with `Gst.DateTime.unref` when it is no longer needed.

        Free-function: gst_date_time_unref
        """
    def get_double(self, tag: str) -> tuple[bool, float]:
        """
            Copies the contents for the given tag into the value, merging multiple values
        into one if multiple values are associated with the tag.
        """
    def get_double_index(self, tag: str, index: int) -> tuple[bool, float]:
        """
            Gets the value that is at the given index for the given tag in the given
        list.
        """
    def get_float(self, tag: str) -> tuple[bool, float]:
        """
            Copies the contents for the given tag into the value, merging multiple values
        into one if multiple values are associated with the tag.
        """
    def get_float_index(self, tag: str, index: int) -> tuple[bool, float]:
        """
            Gets the value that is at the given index for the given tag in the given
        list.
        """
    def get_int(self, tag: str) -> tuple[bool, int]:
        """
            Copies the contents for the given tag into the value, merging multiple values
        into one if multiple values are associated with the tag.
        """
    def get_int64(self, tag: str) -> tuple[bool, int]:
        """
            Copies the contents for the given tag into the value, merging multiple values
        into one if multiple values are associated with the tag.
        """
    def get_int64_index(self, tag: str, index: int) -> tuple[bool, int]:
        """
            Gets the value that is at the given index for the given tag in the given
        list.
        """
    def get_int_index(self, tag: str, index: int) -> tuple[bool, int]:
        """
            Gets the value that is at the given index for the given tag in the given
        list.
        """
    def get_pointer(self, tag: str) -> tuple[bool, object | None]:
        """
            Copies the contents for the given tag into the value, merging multiple values
        into one if multiple values are associated with the tag.
        """
    def get_pointer_index(self, tag: str, index: int) -> tuple[bool, object | None]:
        """
            Gets the value that is at the given index for the given tag in the given
        list.
        """
    def get_sample(self, tag: str) -> tuple[bool, Sample]:
        """
            Copies the first sample for the given tag in the taglist into the variable
        pointed to by `sample`. Free the sample with `Gst.Sample.unref` when it is
        no longer needed. You can retrieve the buffer from the sample using
        `Gst.Sample.get_buffer` and the associated caps (if any) with
        `Gst.Sample.get_caps`.

        Free-function: gst_sample_unref
        """
    def get_sample_index(self, tag: str, index: int) -> tuple[bool, Sample]:
        """
            Gets the sample that is at the given index for the given tag in the given
        list and copies it into the variable pointed to by `sample`. Free the sample
        with `Gst.Sample.unref` when it is no longer needed. You can retrieve the
        buffer from the sample using `Gst.Sample.get_buffer` and the associated
        caps (if any) with `Gst.Sample.get_caps`.

        Free-function: gst_sample_unref
        """
    def get_scope(self) -> TagScope:
        """
        Gets the scope of `list`.
        """
    def get_string(self, tag: str) -> tuple[bool, str]:
        """
            Copies the contents for the given tag into the value, possibly merging
        multiple values into one if multiple values are associated with the tag.

        Use gst_tag_list_get_string_index (list, tag, 0, value) if you want
        to retrieve the first string associated with this tag unmodified.

        The resulting string in `value` will be in UTF-8 encoding and should be
        freed by the caller using g_free when no longer needed. The
        returned string is also guaranteed to be non-None and non-empty.

        Free-function: g_free
        """
    def get_string_index(self, tag: str, index: int) -> tuple[bool, str]:
        """
            Gets the value that is at the given index for the given tag in the given
        list.

        The resulting string in `value` will be in UTF-8 encoding and should be
        freed by the caller using g_free when no longer needed. The
        returned string is also guaranteed to be non-None and non-empty.

        Free-function: g_free
        """
    def get_tag_size(self, tag: str) -> int:
        """
        Checks how many value are stored in this tag list for the given tag.
        """
    def get_uint(self, tag: str) -> tuple[bool, int]:
        """
            Copies the contents for the given tag into the value, merging multiple values
        into one if multiple values are associated with the tag.
        """
    def get_uint64(self, tag: str) -> tuple[bool, int]:
        """
            Copies the contents for the given tag into the value, merging multiple values
        into one if multiple values are associated with the tag.
        """
    def get_uint64_index(self, tag: str, index: int) -> tuple[bool, int]:
        """
            Gets the value that is at the given index for the given tag in the given
        list.
        """
    def get_uint_index(self, tag: str, index: int) -> tuple[bool, int]:
        """
            Gets the value that is at the given index for the given tag in the given
        list.
        """
    def get_value_index(self, tag: str, index: int) -> GObject.Value | None:
        """
            Gets the value that is at the given index for the given tag in the given
        list.
        """
    def insert(self, from_: TagList, mode: TagMergeMode) -> None:
        """
        Inserts the tags of the `from` list into the first list using the given mode.
        """
    def is_empty(self) -> bool:
        """
        Checks if the given taglist is empty.
        """
    def is_equal(self, list2: TagList) -> bool:
        """
        Checks if the two given taglists are equal.
        """
    def merge(self, list2: TagList | None, mode: TagMergeMode) -> TagList | None:
        """
            Merges the two given lists into a new list. If one of the lists is None, a
        copy of the other is returned. If both lists are None, None is returned.

        Free-function: gst_tag_list_unref
        """
    def n_tags(self) -> int:
        """
        Get the number of tags in `list`.
        """
    @classmethod
    def new_empty(cls) -> TagList:
        """
            Creates a new empty GstTagList.

        Free-function: gst_tag_list_unref
        """
    @classmethod
    def new_from_string(cls, str: str) -> TagList | None:
        """
        Deserializes a tag list.
        """
    def nth_tag_name(self, index: int) -> str:
        """
        Get the name of the tag in `list` at `index`.
        """
    def peek_string_index(self, tag: str, index: int) -> tuple[bool, str]:
        """
            Peeks at the value that is at the given index for the given tag in the given
        list.

        The resulting string in `value` will be in UTF-8 encoding and doesn't need
        to be freed by the caller. The returned string is also guaranteed to
        be non-None and non-empty.
        """
    def remove_tag(self, tag: str) -> None:
        """
        Removes the given tag from the taglist.
        """
    def set_scope(self, scope: TagScope) -> None:
        """
            Sets the scope of `list` to `scope`. By default the scope
        of a taglist is stream scope.
        """
    def to_string(self) -> str:
        """
        Serializes a tag list to a string.
        """

    # python methods (overrides?)
    def __init__(
        self,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    def enumerate(
        self,
    ) -> typing.Any: ...
    def keys(
        self,
    ) -> typing.Any: ...

class TagSetter(builtins.object):
    """
    Element interface that allows setting of media metadata.

    Elements that support changing a stream's metadata will implement this
    interface. Examples of such elements are 'vorbisenc', 'theoraenc' and
    'id3v2mux'.

    If you just want to retrieve metadata in your application then all you
    need to do is watch for tag messages on your pipeline's bus. This
    interface is only for setting metadata, not for extracting it. To set tags
    from the application, find tagsetter elements and set tags using e.g.
    `Gst.TagSetter.merge_tags` or `Gst.TagSetter.add_tags`. Also consider
    setting the Gst.TagMergeMode that is used for tag events that arrive at the
    tagsetter element (default mode is to keep existing tags).
    The application should do that before the element goes to Gst.STATE_PAUSED.

    Elements implementing the Gst.TagSetter interface often have to merge
    any tags received from upstream and the tags set by the application via
    the interface. This can be done like this:

    |[<!-- language="C" -->
    GstTagMergeMode merge_mode;
    const GstTagList *application_tags;
    const GstTagList *event_tags;
    GstTagSetter *tagsetter;
    GstTagList *result;

    tagsetter = GST_TAG_SETTER (element);

    merge_mode = gst_tag_setter_get_tag_merge_mode (tagsetter);
    application_tags = gst_tag_setter_get_tag_list (tagsetter);
    event_tags = (const GstTagList *) element->event_tags;

    GST_LOG_OBJECT (tagsetter, "merging tags, merge mode = %d", merge_mode);
    GST_LOG_OBJECT (tagsetter, "event tags: %" GST_PTR_FORMAT, event_tags);
    GST_LOG_OBJECT (tagsetter, "set   tags: %" GST_PTR_FORMAT, application_tags);

    result = gst_tag_list_merge (application_tags, event_tags, merge_mode);

    GST_LOG_OBJECT (tagsetter, "final tags: %" GST_PTR_FORMAT, result);
    ]|
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize TagSetter object with properties.
        """
    def add_tag_value(self, mode: TagMergeMode, tag: str, value: GObject.Value) -> None:
        """
        Adds the given tag / GValue pair on the setter using the given merge mode.
        """
    def get_tag_list(self) -> TagList | None:
        """
            Returns the current list of tags the setter uses.  The list should not be
        modified or freed.

        This function is not thread-safe.
        """
    def get_tag_merge_mode(self) -> TagMergeMode:
        """
            Queries the mode by which tags inside the setter are overwritten by tags
        from events
        """
    def merge_tags(self, list: TagList, mode: TagMergeMode) -> None:
        """
        Merges the given list into the setter's list using the given mode.
        """
    def reset_tags(self) -> None:
        """
            Reset the internal taglist. Elements should call this from within the
        state-change handler.
        """
    def set_tag_merge_mode(self, mode: TagMergeMode) -> None:
        """
            Sets the given merge mode that is used for adding tags from events to tags
        specified by this interface. The default is GST_TAG_MERGE_KEEP, which keeps
        the tags set with this interface and discards tags from events.
        """

class TagSetterInterface(GObject.GPointer):
    """
    Gst.TagSetterInterface interface.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        parent interface type.
        """

class Task(Object):
    """
    Gst.Task is used by Gst.Element and Gst.Pad to provide the data passing
    threads in a Gst.Pipeline.

    A Gst.Pad will typically start a Gst.Task to push or pull data to/from the
    peer pads. Most source elements start a Gst.Task to push data. In some cases
    a demuxer element can start a Gst.Task to pull data from a peer element. This
    is typically done when the demuxer can perform random access on the upstream
    peer element for improved performance.

    Although convenience functions exist on Gst.Pad to start/pause/stop tasks, it
    might sometimes be needed to create a Gst.Task manually if it is not related to
    a Gst.Pad.

    Before the Gst.Task can be run, it needs a GRecMutex that can be set with
    `Gst.Task.set_lock`.

    The task can be started, paused and stopped with `Gst.Task.start`, `Gst.Task.pause`
    and `Gst.Task.stop` respectively or with the `Gst.Task.set_state` function.

    A Gst.Task will repeatedly call the Gst.TaskFunction with the user data
    that was provided when creating the task with `Gst.Task.new`. While calling
    the function it will acquire the provided lock. The provided lock is released
    when the task pauses or stops.

    Stopping a task with `Gst.Task.stop` will not immediately make sure the task is
    not running anymore. Use `Gst.Task.join` to make sure the task is completely
    stopped and the thread is stopped.

    After creating a Gst.Task, use `Gst.Object.unref` to free its resources. This can
    only be done when the task is not running anymore.

    Task functions can send a Gst.Message to send out-of-band data to the
    application. The application can receive messages from the Gst.Bus in its
    mainloop.

    For debugging purposes, the task will configure its object name as the thread
    name on Linux. Please note that the object name should be configured before the
    task is started; changing the object name after the task has been started, has
    no effect on the thread name.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def cond(self) -> GLib.Cond | None:
        """
        used to pause/resume the task
        """
    @builtins.property
    def func(self) -> TaskFunctionTaskCB:
        """
        the function executed by this task
        """
    @builtins.property
    def lock(self) -> GLib.RecMutex | None:
        """
        The lock taken when iterating the task function
        """
    @builtins.property
    def notify(self) -> GLib.DestroyNotify:
        """
        GDestroyNotify for `user_data`
        """
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def priv(self) -> TaskPrivate | None: ...
    @builtins.property
    def running(self) -> bool:
        """
        a flag indicating that the task is running
        """
    @builtins.property
    def state(self) -> TaskState:
        """
        the state of the task
        """
    @builtins.property
    def thread(self) -> GLib.Thread | None: ...
    @builtins.property
    def user_data(self) -> object | None:
        """
        user_data passed to the task function
        """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize Task object with properties.
        """
    @staticmethod
    def cleanup_all() -> None:
        """
            Wait for all tasks to be stopped. This is mainly used internally
        to ensure proper cleanup of internal data structures in test suites.

        MT safe.
        """
    def get_pool(self) -> TaskPool:
        """
            Get the Gst.TaskPool that this task will use for its streaming
        threads.

        MT safe.
        """
    def get_state(self) -> TaskState:
        """
        Get the current state of the task.
        """
    def join(self) -> bool:
        """
            Joins `task`. After this call, it is safe to unref the task
        and clean up the lock set with `Gst.Task.set_lock`.

        The task will automatically be stopped with this call.

        This function cannot be called from within a task function as this
        would cause a deadlock. The function will detect this and print a
        g_warning.
        """
    def pause(self) -> bool:
        """
            Pauses `task`. This method can also be called on a task in the
        stopped state, in which case a thread will be started and will remain
        in the paused state. This function does not wait for the task to complete
        the paused state.
        """
    def resume(self) -> bool:
        """
            Resume `task` in case it was paused. If the task was stopped, it will
        remain in that state and this function will return False.
        """
    def set_enter_callback(self, enter_func: TaskThreadFunc, *user_data: object | None) -> None:
        """
            Call `enter_func` when the task function of `task` is entered. `user_data` will
        be passed to `enter_func` and `notify` will be called when `user_data` is no
        longer referenced.
        """
    def set_leave_callback(self, leave_func: TaskThreadFunc, *user_data: object | None) -> None:
        """
            Call `leave_func` when the task function of `task` is left. `user_data` will
        be passed to `leave_func` and `notify` will be called when `user_data` is no
        longer referenced.
        """
    def set_lock(self, mutex: GLib.RecMutex) -> None:
        """
            Set the mutex used by the task. The mutex will be acquired before
        calling the Gst.TaskFunction.

        This function has to be called before calling `Gst.Task.pause` or
        `Gst.Task.start`.

        MT safe.
        """
    def set_pool(self, pool: TaskPool) -> None:
        """
            Set `pool` as the new GstTaskPool for `task`. Any new streaming threads that
        will be created by `task` will now use `pool`.

        MT safe.
        """
    def set_state(self, state: TaskState) -> bool:
        """
            Sets the state of `task` to `state`.

        The `task` must have a lock associated with it using
        `Gst.Task.set_lock` when going to GST_TASK_STARTED or GST_TASK_PAUSED or
        this function will return False.

        MT safe.
        """
    def start(self) -> bool:
        """
            Starts `task`. The `task` must have a lock associated with it using
        `Gst.Task.set_lock` or this function will return False.
        """
    def stop(self) -> bool:
        """
            Stops `task`. This method merely schedules the task to stop and
        will not wait for the task to have completely stopped. Use
        `Gst.Task.join` to stop and wait for completion.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        func: typing.Callable,
        user_data: typing.Any = None,
    ) -> Task:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(func:Gst.TaskFunction, user_data=None) -> Gst.Task
        """

class TaskClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def pool(self) -> TaskPool | None: ...

class TaskPool(Object):
    """
    This object provides an abstraction for creating threads. The default
    implementation uses a regular GThreadPool to start tasks.

    Subclasses can be made to create custom threads.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def pool(self) -> GLib.ThreadPool | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize TaskPool object with properties.
        """
    def cleanup(self) -> None:
        """
            Wait for all tasks to be stopped. This is mainly used internally
        to ensure proper cleanup of internal data structures in test suites.

        MT safe.
        """
    def dispose_handle(self, id: object | None = None) -> None:
        """
            Dispose of the handle returned by `Gst.TaskPool.push`. This does
        not need to be called with the default implementation as the default
        Gst.TaskPoolClass::push implementation always returns None. This does not need to be
        called either when calling `Gst.TaskPool.join`, but should be called
        when joining is not necessary, but `Gst.TaskPool.push` returned a
        non-None value.

        This method should only be called with the same `pool` instance that provided
        `id`.
        """
    def join(self, id: object | None = None) -> None:
        """
            Join a task and/or return it to the pool. `id` is the id obtained from
        `Gst.TaskPool.push`. The default implementation does nothing, as the
        default Gst.TaskPoolClass::push implementation always returns None.

        This method should only be called with the same `pool` instance that provided
        `id`.
        """
    def prepare(self) -> None:
        """
            Prepare the taskpool for accepting `Gst.TaskPool.push` operations.

        MT safe.
        """
    def push(self, func: TaskPoolFunction, *user_data: object | None) -> object | None:
        """
        Start the execution of a new thread from `pool`.
        """

    # python methods (overrides?)
    def do_cleanup(
        self,
    ) -> None:
        """
        cleanup(self)
        """
    def do_dispose_handle(
        self,
        id: typing.Any = None,
    ) -> None:
        """
        dispose_handle(self, id=None)
        """
    def do_join(
        self,
        id: typing.Any = None,
    ) -> None:
        """
        join(self, id=None)
        """
    def do_prepare(
        self,
    ) -> None:
        """
        prepare(self)
        """
    def do_push(
        self,
        func: typing.Callable,
        user_data: typing.Any = None,
    ) -> typing.Any:
        """
        push(self, func:Gst.TaskPoolFunction, user_data=None)
        """
    @classmethod
    def new(
        cls,
    ) -> TaskPool:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gst.TaskPool
        """

class TaskPoolClass(GObject.GPointer):
    """
    The Gst.TaskPoolClass object.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def cleanup(self) -> cleanupTaskPoolClassCB:
        """
        make sure all threads are stopped
        """
    @builtins.property
    def dispose_handle(self) -> dispose_handleTaskPoolClassCB: ...
    @builtins.property
    def join(self) -> joinTaskPoolClassCB:
        """
        join a thread
        """
    @builtins.property
    def parent_class(self) -> ObjectClass | None:
        """
        the parent class structure
        """
    @builtins.property
    def prepare(self) -> prepareTaskPoolClassCB:
        """
        prepare the threadpool
        """
    @builtins.property
    def push(self) -> pushTaskPoolClassCB | None:
        """
        start a new thread
        """

class TaskPrivate(GObject.GPointer): ...

class TimedValue(GObject.GPointer):
    """
    Structure for storing a timestamp and a value.
    """

    # gi Fields
    timestamp: int = ...
    """
    timestamp of the value change
    """
    value: float = ...
    """
    the corresponding value
    """

class Toc(GObject.GBoxed):
    """
    Gst.Toc functions are used to create/free Gst.Toc and Gst.TocEntry structures.
    Also they are used to convert Gst.Toc into Gst.Structure and vice versa.

    Gst.Toc lets you to inform other elements in pipeline or application that playing
    source has some kind of table of contents (TOC). These may be chapters, editions,
    angles or other types. For example: DVD chapters, Matroska chapters or cue sheet
    TOC. Such TOC will be useful for applications to display instead of just a
    playlist.

    Using TOC is very easy. Firstly, create Gst.Toc structure which represents root
    contents of the source. You can also attach TOC-specific tags to it. Then fill
    it with Gst.TocEntry entries by appending them to the Gst.Toc using
    `Gst.Toc.append_entry`, and appending subentries to a Gst.TocEntry using
    `Gst.TocEntry.append_sub_entry`.

    Note that root level of the TOC can contain only either editions or chapters. You
    should not mix them together at the same level. Otherwise you will get serialization
    /deserialization errors. Make sure that no one of the entries has negative start and
     stop values.

    Use `Gst.Event.new_toc` to create a new TOC Gst.Event, and `Gst.Event.parse_toc` to
    parse received TOC event. Use `Gst.Event.new_toc_select` to create a new TOC select Gst.Event,
    and `Gst.Event.parse_toc_select` to parse received TOC select event. The same rule for
    the Gst.Message: `Gst.Message.new_toc` to create new TOC Gst.Message, and
    `Gst.Message.parse_toc` to parse received TOC message.

    TOCs can have global scope or current scope. Global scope TOCs contain
    all entries that can possibly be selected using a toc select event, and
    are what an application is usually interested in. TOCs with current scope
    only contain the parts of the TOC relevant to the currently selected/playing
    stream; the current scope TOC is used by downstream elements such as muxers
    to write correct TOC entries when transcoding files, for example. When
    playing a DVD, the global TOC would contain a hierarchy of all titles,
    chapters and angles, for example, while the current TOC would only contain
    the chapters for the currently playing title if playback of a specific
    title was requested.

    Applications and plugins should not rely on TOCs having a certain kind of
    structure, but should allow for different alternatives. For example, a
    simple CUE sheet embedded in a file may be presented as a flat list of
    track entries, or could have a top-level edition node (or some other
    alternative type entry) with track entries underneath that node; or even
    multiple top-level edition nodes (or some other alternative type entries)
    each with track entries underneath, in case the source file has extracted
    a track listing from different sources).
    """

    # gi Methods
    def append_entry(self, entry: TocEntry) -> None:
        """
        Appends the Gst.TocEntry `entry` to `toc`.
        """
    def dump(self) -> None: ...
    def find_entry(self, uid: str) -> TocEntry | None:
        """
        Find Gst.TocEntry with given `uid` in the `toc`.
        """
    def get_entries(self) -> list:
        """
        Gets the list of Gst.TocEntry of `toc`.
        """
    def get_scope(self) -> TocScope: ...
    def get_tags(self) -> TagList | None:
        """
        Gets the tags for `toc`.
        """
    def merge_tags(self, tags: TagList | None, mode: TagMergeMode) -> None:
        """
        Merge `tags` into the existing tags of `toc` using `mode`.
        """
    def set_tags(self, tags: TagList | None = None) -> None:
        """
        Set a Gst.TagList with tags for the complete `toc`.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        scope: TocScope,
    ) -> Toc:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(scope:Gst.TocScope) -> Gst.Toc
        """

class TocEntry(GObject.GBoxed):
    # gi Methods
    def append_sub_entry(self, subentry: TocEntry) -> None:
        """
        Appends the Gst.TocEntry `subentry` to `entry`.
        """
    def get_entry_type(self) -> TocEntryType: ...
    def get_loop(self) -> tuple[bool, TocLoopType, int]:
        """
            Get `loop_type` and `repeat_count` values from the `entry` and write them into
        appropriate storages. Loops are e.g. used by sampled instruments. GStreamer
        is not automatically applying the loop. The application can process this
        meta data and use it e.g. to send a seek-event to loop a section.
        """
    def get_parent(self) -> TocEntry | None:
        """
        Gets the parent Gst.TocEntry of `entry`.
        """
    def get_start_stop_times(self) -> tuple[bool, int, int]:
        """
            Get `start` and `stop` values from the `entry` and write them into appropriate
        storages.
        """
    def get_sub_entries(self) -> list:
        """
        Gets the sub-entries of `entry`.
        """
    def get_tags(self) -> TagList | None:
        """
        Gets the tags for `entry`.
        """
    def get_toc(self) -> Toc | None:
        """
        Gets the parent Gst.Toc of `entry`.
        """
    def get_uid(self) -> str:
        """
        Gets the UID of `entry`.
        """
    def is_alternative(self) -> bool: ...
    def is_sequence(self) -> bool: ...
    def merge_tags(self, tags: TagList | None, mode: TagMergeMode) -> None:
        """
        Merge `tags` into the existing tags of `entry` using `mode`.
        """
    def set_loop(self, loop_type: TocLoopType, repeat_count: int) -> None:
        """
        Set `loop_type` and `repeat_count` values for the `entry`.
        """
    def set_start_stop_times(self, start: int, stop: int) -> None:
        """
        Set `start` and `stop` values for the `entry`.
        """
    def set_tags(self, tags: TagList | None = None) -> None:
        """
        Set a Gst.TagList with tags for the complete `entry`.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        type: TocEntryType,
        uid: str,
    ) -> TocEntry:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(type:Gst.TocEntryType, uid:str) -> Gst.TocEntry
        """

class TocSetter(builtins.object):
    """
    Element interface that allows setting of the TOC.

    Elements that support some kind of chapters or editions (or tracks like in
    the FLAC cue sheet) will implement this interface.

    If you just want to retrieve the TOC in your application then all you
    need to do is watch for TOC messages on your pipeline's bus (or you can
    perform TOC query). This interface is only for setting TOC data, not for
    extracting it. To set TOC from the application, find proper tocsetter element
    and set TOC using `Gst.TocSetter.set_toc`.

    Elements implementing the Gst.TocSetter interface can extend existing TOC
    by getting extend UID for that (you can use `Gst.Toc.find_entry` to retrieve it)
    with any TOC entries received from downstream.
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize TocSetter object with properties.
        """
    def get_toc(self) -> Toc | None:
        """
            Return current TOC the setter uses. The TOC should not be
        modified without making it writable first.
        """
    def reset(self) -> None:
        """
            Reset the internal TOC. Elements should call this from within the
        state-change handler.
        """
    def set_toc(self, toc: Toc | None = None) -> None:
        """
            Set the given TOC on the setter. Previously set TOC will be
        unreffed before setting a new one.
        """

class TocSetterInterface(GObject.GPointer):
    """
    Gst.TocSetterInterface interface.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        parent interface type.
        """

class Tracer(Object):
    """
    Tracing modules will subclass Gst.Tracer and register through
    `Gst.Tracer.register`. Modules can attach to various hook-types - see
    `Gst.tracing_register_hook`. When invoked they receive hook specific
    contextual data, which they must not modify.
    """

    class Props(Object.Props):
        params: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent(self) -> Object | None: ...
    @builtins.property
    def priv(self) -> TracerPrivate | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, params: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize Tracer object with properties.
        """
    @staticmethod
    def register(plugin: Plugin | None, name: str, type: GObject.GType) -> bool:
        """
            Create a new tracer-factory  capable of instantiating objects of the
        `type` and add the factory to `plugin`.
        """

    # python methods (overrides?)
    @classmethod
    def set_use_structure_params(
        cls,
        use_structure_params: bool,
    ) -> None:
        """
        set_use_structure_params(self, use_structure_params:bool)
        """
    @classmethod
    def uses_structure_params(
        cls,
    ) -> bool:
        """
        uses_structure_params(self) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::params"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TracerClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...

    # gi Methods
    def set_use_structure_params(self, use_structure_params: bool) -> None:
        """
            Sets whether the tracer should use structure parameters for configuration.
        This function configures how parameters should be passed when instantiating
        the tracer.

        This is typically called in the tracer's class initialization function to
        indicate its parameter handling preference.
        """
    def uses_structure_params(self) -> bool:
        """
            If set, the tracer subsystem will consider parameters passed to the
        `GST_TRACERS` environment variable as a Gst.Structure and use its
        fields as properties to instanciate the tracer.
        """

class TracerFactory(PluginFeature):
    """
    Use `Gst.TracerFactory.get_list` to get a list of tracer factories known to
    GStreamer.
    """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize TracerFactory object with properties.
        """
    @staticmethod
    def get_list() -> list:
        """
            Gets the list of all registered tracer factories. You must free the
        list using `Gst.PluginFeature.list_free`.

        The returned factories are sorted by factory name.

        Free-function: gst_plugin_feature_list_free
        """
    def get_tracer_type(self) -> GObject.GType:
        """
            Get the GType for elements managed by this factory. The type can
        only be retrieved if the element factory is loaded, which can be
        assured with `Gst.PluginFeature.load`.
        """

class TracerFactoryClass(GObject.GPointer): ...
class TracerPrivate(GObject.GPointer): ...

class TracerRecord(Object):
    """
    Tracing modules will create instances of this class to announce the data they
    will log and create a log formatter.
    """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize TracerRecord object with properties.
        """

class TracerRecordClass(GObject.GPointer): ...

class TypeFind(GObject.GPointer):
    """
    The following functions allow you to detect the media type of an unknown
    stream.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    data: object | None = ...
    """
    The data used by the caller of the typefinding function.
    """

    # gi Methods
    def get_length(self) -> int:
        """
        Get the length of the data stream.
        """
    def peek(self, offset: int, size: int) -> int | None:
        """
            Returns the `size` bytes of the stream to identify beginning at offset. If
        offset is a positive number, the offset is relative to the beginning of the
        stream, if offset is a negative number the offset is relative to the end of
        the stream. The returned memory is valid until the typefinding function
        returns and must not be freed.
        """
    @staticmethod
    def register(
        plugin: Plugin | None,
        name: str,
        rank: int,
        func: TypeFindFunction,
        extensions: str | None = None,
        possible_caps: Caps | None = None,
        *data: object | None,
    ) -> bool:
        """
            Registers a new typefind function to be used for typefinding. After
        registering this function will be available for typefinding.
        This function is typically called during an element's plugin initialization.
        """
    def suggest(self, probability: int, caps: Caps) -> None:
        """
            If a Gst.TypeFindFunction calls this function it suggests the caps with the
        given probability. A Gst.TypeFindFunction may supply different suggestions
        in one call.
        It is up to the caller of the Gst.TypeFindFunction to interpret these values.
        """
    def suggest_empty_simple(self, probability: int, media_type: str) -> None:
        """
            If a Gst.TypeFindFunction calls this function it suggests caps of the
        given `media_type` with the given `probability`.

        This function is similar to `Gst.TypeFind.suggest_simple`, but uses
        a Gst.Caps with no fields.
        """

class TypeFindFactory(PluginFeature):
    """
    These functions allow querying information about registered typefind
    functions. How to create and register these functions is described in
    the section <link linkend="gstreamer-Writing-typefind-functions">
    "Writing typefind functions"</link>.

    The following example shows how to write a very simple typefinder that
    identifies the given data. You can get quite a bit more complicated than
    that though.
    |[<!-- language="C" -->
      typedef struct {
        guint8 *data;
        guint size;
        guint probability;
        GstCaps *data;
      } MyTypeFind;
      static void
      my_peek (gpointer data, gint64 offset, guint size)
      {
        MyTypeFind *find = (MyTypeFind *) data;
        if (offset >= 0 && offset + size <= find->size) {
          return find->data + offset;
        }
        return None;
      }
      static void
      my_suggest (gpointer data, guint probability, GstCaps *caps)
      {
        MyTypeFind *find = (MyTypeFind *) data;
        if (probability > find->probability) {
          find->probability = probability;
          gst_caps_replace (&find->caps, caps);
        }
      }
      static GstCaps *
      find_type (guint8 *data, guint size)
      {
        GList *walk, *type_list;
        MyTypeFind find = {data, size, 0, None};
        GstTypeFind gst_find = {my_peek, my_suggest, &find, };
        walk = type_list = gst_type_find_factory_get_list ();
        while (walk) {
          GstTypeFindFactory *factory = GST_TYPE_FIND_FACTORY (walk->data);
          walk = g_list_next (walk)
          gst_type_find_factory_call_function (factory, &gst_find);
        }
        g_list_free (type_list);
        return find.caps;
      };
    ]|
    """

    # gi Methods
    def __init__(self, name: str | None = None, parent: Object | None = None) -> None:
        """
        Initialize TypeFindFactory object with properties.
        """
    def call_function(self, find: TypeFind) -> None:
        """
        Calls the Gst.TypeFindFunction associated with this factory.
        """
    def get_caps(self) -> Caps | None:
        """
        Gets the Gst.Caps associated with a typefind factory.
        """
    def get_extensions(self) -> list | None:
        """
            Gets the extensions associated with a Gst.TypeFindFactory. The returned
        array should not be changed. If you need to change stuff in it, you should
        copy it using `g_strdupv`.  This function may return None to indicate
        a 0-length list.
        """
    @staticmethod
    def get_list() -> list:
        """
            Gets the list of all registered typefind factories. You must free the
        list using `Gst.PluginFeature.list_free`.

        The returned factories are sorted by highest rank first, and then by
        factory name.

        Free-function: gst_plugin_feature_list_free
        """
    def has_function(self) -> bool:
        """
            Check whether the factory has a typefind function. Typefind factories
        without typefind functions are a last-effort fallback mechanism to
        e.g. assume a certain media type based on the file extension.
        """

class TypeFindFactoryClass(GObject.GPointer): ...

class URIHandler(builtins.object):
    """
    The Gst.URIHandler is an interface that is implemented by Source and Sink
    Gst.Element to unify handling of URI.

    An application can use the following functions to quickly get an element
    that handles the given URI for reading or writing
    (`Gst.Element.make_from_uri`).

    Source and Sink plugins should implement this interface when possible.
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize URIHandler object with properties.
        """
    def get_protocols(self) -> list | None:
        """
            Gets the list of protocols supported by `handler`. This list may not be
        modified.
        """
    def get_uri(self) -> str | None:
        """
        Gets the currently handled URI.
        """
    def get_uri_type(self) -> URIType:
        """
        Gets the type of the given URI handler
        """
    def set_uri(self, uri: str) -> bool:
        """
        Tries to set the URI of the given handler.
        """

class URIHandlerInterface(GObject.GPointer):
    """
    Any Gst.Element using this interface should implement these methods.
    """

    # gi Fields
    @builtins.property
    def get_protocols(self) -> get_protocolsURIHandlerInterfaceCB:
        """
        Method to return the list of protocols handled by the element.
        """
    @builtins.property
    def get_type(self) -> get_typeURIHandlerInterfaceCB:
        """
        Method to tell whether the element handles source or sink URI.
        """
    @builtins.property
    def get_uri(self) -> get_uriURIHandlerInterfaceCB | None:
        """
        Method to return the URI currently handled by the element.
        """
    @builtins.property
    def parent(self) -> GObject.TypeInterface | None:
        """
        The parent interface type
        """
    @builtins.property
    def set_uri(self) -> set_uriURIHandlerInterfaceCB:
        """
        Method to set a new URI.
        """

class Uri(GObject.GBoxed):
    """
    A Gst.Uri object can be used to parse and split a URI string into its
    constituent parts. Two Gst.Uri objects can be joined to make a new Gst.Uri
    using the algorithm described in RFC3986.
    """

    # gi Methods
    def append_path(self, relative_path: str | None = None) -> bool:
        """
            Append a path onto the end of the path in the URI. The path is not
        normalized, call #`Gst.Uri.normalize` to normalize the path.
        """
    def append_path_segment(self, path_segment: str | None = None) -> bool:
        """
        Append a single path segment onto the end of the URI path.
        """
    @deprecated("deprecated")
    @staticmethod
    def construct(protocol: str, location: str) -> str:
        """
            Constructs a URI for a given valid protocol and location.

        Free-function: g_free
        """
    def equal(self, second: Uri) -> bool:
        """
            Compares two Gst.Uri objects to see if they represent the same normalized
        URI.
        """
    @staticmethod
    def from_string(uri: str) -> Uri | None:
        """
            Parses a URI string into a new Gst.Uri object. Will return None if the URI
        cannot be parsed.
        """
    @staticmethod
    def from_string_escaped(uri: str) -> Uri | None:
        """
            Parses a URI string into a new Gst.Uri object. Will return None if the URI
        cannot be parsed. This is identical to `Gst.Uri.from_string` except that
        the userinfo and fragment components of the URI will not be unescaped while
        parsing.

        Use this when you need to extract a username and password from the userinfo
        such as https://user:password`example`.com since either may contain
        a URI-escaped ':' character. `Gst.Uri.from_string` will unescape the entire
        userinfo component, which will make it impossible to know which ':'
        delineates the username and password.

        The same applies to the fragment component of the URI, such as
        https://example.com/path#fragment which may contain a URI-escaped '#'.
        """
    def from_string_with_base(self, uri: str) -> Uri | None:
        """
        Like `Gst.Uri.from_string` but also joins with a base URI.
        """
    def get_fragment(self) -> str | None:
        """
            Get the fragment name from the URI or None if it doesn't exist.
        If `uri` is None then returns None.
        """
    def get_host(self) -> str | None:
        """
            Get the host name from the URI or None if it doesn't exist.
        If `uri` is None then returns None.
        """
    @staticmethod
    def get_location(uri: str) -> str | None:
        """
            Extracts the location out of a given valid URI, ie. the protocol and "://"
        are stripped from the URI, which means that the location returned includes
        the hostname if one is specified. The returned string must be freed using
        `g_free`.

        Free-function: g_free
        """
    def get_media_fragment_table(self) -> dict | None:
        """
            Get the media fragment table from the URI, as defined by "Media Fragments URI 1.0".
        Hash table returned by this API is a list of "key-value" pairs, and the each
        pair is generated by splitting "URI fragment" per "&" sub-delims, then "key"
        and "value" are split by "=" sub-delims. The "key" returned by this API may
        be undefined keyword by standard.
        A value may be None to indicate that the key should appear in the fragment
        string in the URI, but does not have a value. Free the returned GHashTable
        with #`g_hash_table_unref` when it is no longer required.
        Modifying this hash table does not affect the fragment in the URI.

        See more about Media Fragments URI 1.0 (W3C) at https://www.w3.org/TR/media-frags/
        """
    def get_path(self) -> str | None:
        """
        Extract the path string from the URI object.
        """
    def get_path_segments(self) -> list:
        """
        Get a list of path segments from the URI.
        """
    def get_path_string(self) -> str | None:
        """
        Extract the path string from the URI object as a percent encoded URI path.
        """
    def get_port(self) -> int:
        """
            Get the port number from the URI or Gst.URI_NO_PORT if it doesn't exist.
        If `uri` is None then returns Gst.URI_NO_PORT.
        """
    @staticmethod
    def get_protocol(uri: str) -> str | None:
        """
            Extracts the protocol out of a given valid URI. The returned string must be
        freed using `g_free`.
        """
    def get_query_keys(self) -> list:
        """
        Get a list of the query keys from the URI.
        """
    def get_query_string(self) -> str | None:
        """
        Get a percent encoded URI query string from the `uri`.
        """
    def get_query_string_ordered(self, keys: list | None = None) -> str | None:
        """
            Get a percent encoded URI query string from the `uri`, with query parameters
        in the order provided by the `keys` list. Only parameter keys in the list will
        be added to the resulting URI string. This method can be used by retrieving
        the keys with `Gst.Uri.get_query_keys` and then sorting the list, for
        example.
        """
    def get_query_table(self) -> dict | None:
        """
            Get the query table from the URI. Keys and values in the table are freed
        with g_free when they are deleted. A value may be None to indicate that
        the key should appear in the query string in the URI, but does not have a
        value. Free the returned GHashTable with #`g_hash_table_unref` when it is
        no longer required. Modifying this hash table will modify the query in the
        URI.
        """
    def get_query_value(self, query_key: str) -> str | None:
        """
            Get the value associated with the `query_key` key. Will return None if the
        key has no value or if the key does not exist in the URI query table. Because
        None is returned for both missing keys and keys with no value, you should
        use `Gst.Uri.query_has_key` to determine if a key is present in the URI
        query.
        """
    def get_scheme(self) -> str | None:
        """
            Get the scheme name from the URI or None if it doesn't exist.
        If `uri` is None then returns None.
        """
    def get_userinfo(self) -> str | None:
        """
            Get the userinfo (usually in the form "username:password") from the URI
        or None if it doesn't exist. If `uri` is None then returns None.
        """
    @staticmethod
    def has_protocol(uri: str, protocol: str) -> bool:
        """
        Checks if the protocol of a given valid URI matches `protocol`.
        """
    def is_normalized(self) -> bool:
        """
            Tests the `uri` to see if it is normalized. A None `uri` is considered to be
        normalized.
        """
    @staticmethod
    def is_valid(uri: str) -> bool:
        """
            Tests if the given string is a valid URI identifier. URIs start with a valid
        scheme followed by ":" and maybe a string identifying the location.
        """
    def is_writable(self) -> bool:
        """
            Check if it is safe to write to this Gst.Uri.

        Check if the refcount of `uri` is exactly 1, meaning that no other
        reference exists to the Gst.Uri and that the Gst.Uri is therefore writable.

        Modification of a Gst.Uri should only be done after verifying that it is
        writable.
        """
    def join(self, ref_uri: Uri | None = None) -> Uri | None:
        """
            Join a reference URI onto a base URI using the method from RFC 3986.
        If either URI is None then the other URI will be returned with the ref count
        increased.
        """
    @staticmethod
    def join_strings(base_uri: str, ref_uri: str) -> str | None:
        """
            This is a convenience function to join two URI strings and return the result.
        The returned string should be `g_free`'d after use.
        """
    def make_writable(self) -> Uri:
        """
            Make the Gst.Uri writable.

        Checks if `uri` is writable, and if so the original object is returned. If
        not, then a writable copy is made and returned. This gives away the
        reference to `uri` and returns a reference to the new Gst.Uri.
        If `uri` is None then None is returned.
        """
    def new_with_base(
        self,
        scheme: str | None,
        userinfo: str | None,
        host: str | None,
        port: int,
        path: str | None = None,
        query: str | None = None,
        fragment: str | None = None,
    ) -> Uri:
        """
        Like `Gst.Uri.new`, but joins the new URI onto a base URI.
        """
    def normalize(self) -> bool:
        """
            Normalization will remove extra path segments ("." and "..") from the URI. It
        will also convert the scheme and host name to lower case and any
        percent-encoded values to uppercase.

        The Gst.Uri object must be writable. Check with `Gst.Uri.is_writable` or use
        `Gst.Uri.make_writable` first.
        """
    @staticmethod
    def protocol_is_supported(type: URIType, protocol: str) -> bool:
        """
            Checks if an element exists that supports the given URI protocol. Note
        that a positive return value does not imply that a subsequent call to
        `Gst.Element.make_from_uri` is guaranteed to work.
        """
    @staticmethod
    def protocol_is_valid(protocol: str) -> bool:
        """
            Tests if the given string is a valid protocol identifier. Protocols
        must consist of alphanumeric characters, '+', '-' and '.' and must
        start with a alphabetic character. See RFC 3986 Section 3.1.
        """
    def query_has_key(self, query_key: str) -> bool:
        """
        Check if there is a query table entry for the `query_key` key.
        """
    def remove_query_key(self, query_key: str) -> bool:
        """
        Remove an entry from the query table by key.
        """
    def set_fragment(self, fragment: str | None = None) -> bool:
        """
            Sets the fragment string in the URI. Use a value of None in `fragment` to
        unset the fragment string.
        """
    def set_host(self, host: str) -> bool:
        """
        Set or unset the host for the URI.
        """
    def set_path(self, path: str | None = None) -> bool:
        """
        Sets or unsets the path in the URI.
        """
    def set_path_segments(self, path_segments: list | None = None) -> bool:
        """
        Replace the path segments list in the URI.
        """
    def set_path_string(self, path: str) -> bool:
        """
        Sets or unsets the path in the URI.
        """
    def set_port(self, port: int) -> bool:
        """
        Set or unset the port number for the URI.
        """
    def set_query_string(self, query: str | None = None) -> bool:
        """
        Sets or unsets the query table in the URI.
        """
    def set_query_table(self, query_table: dict | None = None) -> bool:
        """
            Set the query table to use in the URI. The old table is unreferenced and a
        reference to the new one is used instead. A value if None for `query_table`
        will remove the query string from the URI.
        """
    def set_query_value(self, query_key: str, query_value: str | None = None) -> bool:
        """
            This inserts or replaces a key in the query table. A `query_value` of None
        indicates that the key has no associated value, but will still be present in
        the query string.
        """
    def set_scheme(self, scheme: str) -> bool:
        """
        Set or unset the scheme for the URI.
        """
    def set_userinfo(self, userinfo: str) -> bool:
        """
        Set or unset the user information for the URI.
        """
    def to_string(self) -> str:
        """
            Convert the URI to a string.

        Returns the URI as held in this object as a #gchar* nul-terminated string.
        The caller should `g_free` the string once they are finished with it.
        The string is put together as described in RFC 3986.
        """
    def to_string_with_keys(self, keys: list | None = None) -> str:
        """
            Convert the URI to a string, with the query arguments in a specific order.
        Only the keys in the `keys` list will be added to the resulting string.

        Returns the URI as held in this object as a #gchar* nul-terminated string.
        The caller should `g_free` the string once they are finished with it.
        The string is put together as described in RFC 3986.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        scheme: str | None,
        userinfo: str | None,
        host: str | None,
        port: int,
        path: str | None = None,
        query: str | None = None,
        fragment: str | None = None,
    ) -> Uri:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(scheme:str=None, userinfo:str=None, host:str=None, port:int, path:str=None, query:str=None, fragment:str=None) -> Gst.Uri
        """

class ValueArray(builtins.object):
    """
    A fundamental type that describes an ordered list of GValue
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    @staticmethod
    def append_and_take_value(value: GObject.Value, append_value: GObject.Value) -> None:
        """
        Appends `append_value` to the GstValueArray in `value`.
        """
    @staticmethod
    def append_value(value: GObject.Value, append_value: GObject.Value) -> None:
        """
        Appends `append_value` to the GstValueArray in `value`.
        """
    @staticmethod
    def get_size(value: GObject.Value) -> int:
        """
        Gets the number of values contained in `value`.
        """
    @staticmethod
    def get_value(value: GObject.Value, index: int) -> GObject.Value:
        """
            Gets the value that is a member of the array contained in `value` and
        has the index `index`.
        """
    @staticmethod
    def init(value: GObject.Value, prealloc: int) -> GObject.Value:
        """
        Initializes and pre-allocates a GValue of type GST_TYPE_ARRAY.
        """
    @staticmethod
    def prepend_value(value: GObject.Value, prepend_value: GObject.Value) -> None:
        """
        Prepends `prepend_value` to the GstValueArray in `value`.
        """

    # python methods (overrides?)
    def __init__(
        self,
        array: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class ValueList(builtins.object):
    """
    A fundamental type that describes an unordered list of GValue
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    @staticmethod
    def append_and_take_value(value: GObject.Value, append_value: GObject.Value) -> None:
        """
        Appends `append_value` to the GstValueList in `value`.
        """
    @staticmethod
    def append_value(value: GObject.Value, append_value: GObject.Value) -> None:
        """
        Appends `append_value` to the GstValueList in `value`.
        """
    @staticmethod
    def concat(value1: GObject.Value, value2: GObject.Value) -> GObject.Value:
        """
            Concatenates copies of `value1` and `value2` into a list.  Values that are not
        of type GST_TYPE_LIST are treated as if they were lists of length 1.
        `dest` will be initialized to the type GST_TYPE_LIST.
        """
    @staticmethod
    def get_size(value: GObject.Value) -> int:
        """
        Gets the number of values contained in `value`.
        """
    @staticmethod
    def get_value(value: GObject.Value, index: int) -> GObject.Value:
        """
            Gets the value that is a member of the list contained in `value` and
        has the index `index`.
        """
    @staticmethod
    def init(value: GObject.Value, prealloc: int) -> GObject.Value:
        """
        Initializes and pre-allocates a GValue of type GST_TYPE_LIST.
        """
    @staticmethod
    def merge(value1: GObject.Value, value2: GObject.Value) -> GObject.Value:
        """
            Merges copies of `value1` and `value2`.  Values that are not
        of type GST_TYPE_LIST are treated as if they were lists of length 1.

        The result will be put into `dest` and will either be a list that will not
        contain any duplicates, or a non-list type (if `value1` and `value2`
        were equal).
        """
    @staticmethod
    def prepend_value(value: GObject.Value, prepend_value: GObject.Value) -> None:
        """
        Prepends `prepend_value` to the GstValueList in `value`.
        """

    # python methods (overrides?)
    def __init__(
        self,
        array: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class ValueTable(GObject.GPointer):
    """
    VTable for the GValue `type`.
    """

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    compare: ValueCompareFuncValueTableCB = ...
    """
    a Gst.ValueCompareFunc
    """
    deserialize: ValueDeserializeFuncValueTableCB = ...
    """
    a Gst.ValueDeserializeFunc
    """
    deserialize_with_pspec: ValueDeserializeWithPSpecFuncValueTableCB = ...
    """
    a Gst.ValueDeserializeWithPSpecFunc
    """
    serialize: ValueSerializeFuncValueTableCB = ...
    """
    a Gst.ValueSerializeFunc
    """
    type: GObject.GType = ...  # type: ignore
    """
    a GType
    """

###############################################################
# Callbacks
###############################################################

class MemoryMapFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_map
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        maxsize: int,
        flags: MapFlags,
    ) -> object | None: ...

class MemoryUnmapFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_unmap
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
    ) -> None: ...

class MemoryCopyFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_copy
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        offset: int,
        size: int,
    ) -> Memory: ...

class MemoryShareFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_share
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        offset: int,
        size: int,
    ) -> Memory: ...

class MemoryIsSpanFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_is_span
    """
    #  mem1
    def __call__(
        self,
        mem1: Memory,
        mem2: Memory,
        offset: int,
    ) -> bool: ...

class MemoryMapFullFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_map_full
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        info: MapInfo,
        maxsize: int,
    ) -> object | None: ...

class MemoryUnmapFullFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_unmap_full
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        info: MapInfo,
    ) -> None: ...

class allocAllocatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AllocatorClass.alloc
    """
    #  allocator
    def __call__(
        self,
        allocator: Allocator | None,
        size: int,
        params: AllocationParams | None = None,
    ) -> Memory | None: ...

class freeAllocatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AllocatorClass.free
    """
    #  allocator
    def __call__(
        self,
        allocator: Allocator,
        memory: Memory,
    ) -> None: ...

class element_addedBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.element_added
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        child: Element,
    ) -> None: ...

class element_removedBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.element_removed
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        child: Element,
    ) -> None: ...

class add_elementBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.add_element
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        element: Element,
    ) -> bool: ...

class remove_elementBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.remove_element
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        element: Element,
    ) -> bool: ...

class handle_messageBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.handle_message
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        message: Message,
    ) -> None: ...

class do_latencyBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.do_latency
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
    ) -> bool: ...

class deep_element_addedBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.deep_element_added
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        sub_bin: Bin,
        child: Element,
    ) -> None: ...

class deep_element_removedBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.deep_element_removed
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        sub_bin: Bin,
        child: Element,
    ) -> None: ...

class BufferForeachMetaFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach_meta
    """
    #  buffer
    def __call__(
        self,
        buffer: Buffer,
        *user_data: object | None,
    ) -> tuple[bool, Meta | None]: ...

class BufferListFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  idx
    def __call__(
        self,
        idx: int,
        *user_data: object | None,
    ) -> tuple[bool, Buffer | None]: ...

class get_optionsBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.get_options
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> list: ...

class set_configBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.set_config
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        config: Structure,
    ) -> bool: ...

class startBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.start
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> bool: ...

class stopBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.stop
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> bool: ...

class acquire_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.acquire_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        params: BufferPoolAcquireParams | None = None,
    ) -> tuple[FlowReturn, Buffer | None]: ...

class alloc_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.alloc_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        params: BufferPoolAcquireParams | None = None,
    ) -> tuple[FlowReturn, Buffer | None]: ...

class reset_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.reset_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        buffer: Buffer,
    ) -> None: ...

class release_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.release_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        buffer: Buffer,
    ) -> None: ...

class free_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.free_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        buffer: Buffer,
    ) -> None: ...

class flush_startBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.flush_start
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> None: ...

class flush_stopBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.flush_stop
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> None: ...

class BusFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.add_watch
    """
    #  bus
    def __call__(
        self,
        bus: Bus,
        message: Message,
        *user_data: object | None,
    ) -> bool: ...

class BusSyncHandler(typing.Protocol):
    """
    This callback was used in:
        Gst.set_sync_handler
    """
    #  bus
    def __call__(
        self,
        bus: Bus,
        message: Message,
        *user_data: object | None,
    ) -> BusSyncReply: ...

class messageBusClassCB(typing.Protocol):
    """
    This callback was used in:
        BusClass.message
    """
    #  bus
    def __call__(
        self,
        bus: Bus,
        message: Message,
    ) -> None: ...

class sync_messageBusClassCB(typing.Protocol):
    """
    This callback was used in:
        BusClass.sync_message
    """
    #  bus
    def __call__(
        self,
        bus: Bus,
        message: Message,
    ) -> None: ...

class resizeByteArrayInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ByteArrayInterface.resize
    """
    #  self
    def __call__(
        self: ByteArrayInterface,
        length: int,
    ) -> bool: ...

class CapsFilterMapFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.filter_and_map_in_place
    """
    #  features
    def __call__(
        self,
        features: CapsFeatures,
        structure: Structure,
        *user_data: object | None,
    ) -> bool: ...

class CapsForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  features
    def __call__(
        self,
        features: CapsFeatures,
        structure: Structure,
        *user_data: object | None,
    ) -> bool: ...

class CapsMapFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.map_in_place
    """
    #  features
    def __call__(
        self,
        features: CapsFeatures,
        structure: Structure,
        *user_data: object | None,
    ) -> bool: ...

class get_child_by_nameChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.get_child_by_name
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
        name: str,
    ) -> GObject.Object | None: ...

class get_child_by_indexChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.get_child_by_index
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
        index: int,
    ) -> GObject.Object | None: ...

class get_children_countChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.get_children_count
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
    ) -> int: ...

class child_addedChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.child_added
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
        child: GObject.Object,
        name: str,
    ) -> None: ...

class child_removedChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.child_removed
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
        child: GObject.Object,
        name: str,
    ) -> None: ...

class ClockCallback(typing.Protocol):
    """
    This callback was used in:
        Gst.id_wait_async
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        time: int,
        id: object,
        *user_data: object | None,
    ) -> bool: ...

class change_resolutionClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.change_resolution
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        old_resolution: int,
        new_resolution: int,
    ) -> int: ...

class get_resolutionClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.get_resolution
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
    ) -> int: ...

class get_internal_timeClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.get_internal_time
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
    ) -> int: ...

class waitClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.wait
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        entry: ClockEntry,
    ) -> tuple[ClockReturn, int]: ...

class wait_asyncClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.wait_async
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        entry: ClockEntry,
    ) -> ClockReturn: ...

class unscheduleClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.unschedule
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        entry: ClockEntry,
    ) -> None: ...

class ClockCallbackClockEntryCB(typing.Protocol):
    """
    This callback was used in:
        ClockEntry.func
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        time: int,
        id: object,
        *user_data: object | None,
    ) -> bool: ...

DestroyNotify = GLib.DestroyNotify  # type: ignore

class sync_valuesControlBindingClassCB(typing.Protocol):
    """
    This callback was used in:
        ControlBindingClass.sync_values
    """
    #  binding
    def __call__(
        self,
        binding: ControlBinding,
        object: Object,
        timestamp: int,
        last_sync: int,
    ) -> bool: ...

class get_valueControlBindingClassCB(typing.Protocol):
    """
    This callback was used in:
        ControlBindingClass.get_value
    """
    #  binding
    def __call__(
        self,
        binding: ControlBinding,
        timestamp: int,
    ) -> GObject.Value | None: ...

class get_g_value_arrayControlBindingClassCB(typing.Protocol):
    """
    This callback was used in:
        ControlBindingClass.get_g_value_array
    """
    #  binding
    def __call__(
        self,
        binding: ControlBinding,
        timestamp: int,
        interval: int,
        n_values: int,
        values: list,
    ) -> bool: ...

class ControlSourceGetValueControlSourceCB(typing.Protocol):
    """
    This callback was used in:
        ControlSource.get_value
    """
    #  self
    def __call__(
        self: ControlSource,
        timestamp: int,
        value: float,
    ) -> bool: ...

class ControlSourceGetValueArrayControlSourceCB(typing.Protocol):
    """
    This callback was used in:
        ControlSource.get_value_array
    """
    #  self
    def __call__(
        self: ControlSource,
        timestamp: int,
        interval: int,
        n_values: int,
        values: float,
    ) -> bool: ...

class create_elementDeviceClassCB(typing.Protocol):
    """
    This callback was used in:
        DeviceClass.create_element
    """
    #  device
    def __call__(
        self,
        device: Device,
        name: str | None = None,
    ) -> Element | None: ...

class reconfigure_elementDeviceClassCB(typing.Protocol):
    """
    This callback was used in:
        DeviceClass.reconfigure_element
    """
    #  device
    def __call__(
        self,
        device: Device,
        element: Element,
    ) -> bool: ...

class startDeviceProviderClassCB(typing.Protocol):
    """
    This callback was used in:
        DeviceProviderClass.start
    """
    #  provider
    def __call__(
        self,
        provider: DeviceProvider,
    ) -> bool: ...

class stopDeviceProviderClassCB(typing.Protocol):
    """
    This callback was used in:
        DeviceProviderClass.stop
    """
    #  provider
    def __call__(
        self,
        provider: DeviceProvider,
    ) -> None: ...

class ElementCallAsyncFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.call_async
    """
    #  element
    def __call__(
        self,
        element: Element,
        *user_data: object | None,
    ) -> None: ...

class ElementForeachPadFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach_pad, Gst.foreach_sink_pad, Gst.foreach_src_pad
    """
    #  element
    def __call__(
        self,
        element: Element,
        pad: Pad,
        *user_data: object | None,
    ) -> bool: ...

class pad_addedElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.pad_added
    """
    #  element
    def __call__(
        self,
        element: Element,
        pad: Pad,
    ) -> None: ...

class pad_removedElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.pad_removed
    """
    #  element
    def __call__(
        self,
        element: Element,
        pad: Pad,
    ) -> None: ...

class no_more_padsElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.no_more_pads
    """
    #  element
    def __call__(
        self,
        element: Element,
    ) -> None: ...

class request_new_padElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.request_new_pad
    """
    #  element
    def __call__(
        self,
        element: Element,
        templ: PadTemplate,
        name: str | None = None,
        caps: Caps | None = None,
    ) -> Pad | None: ...

class release_padElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.release_pad
    """
    #  element
    def __call__(
        self,
        element: Element,
        pad: Pad,
    ) -> None: ...

class get_stateElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.get_state
    """
    #  element
    def __call__(
        self,
        element: Element,
        timeout: int,
    ) -> tuple[StateChangeReturn, State, State]: ...

class set_stateElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.set_state
    """
    #  element
    def __call__(
        self,
        element: Element,
        state: State,
    ) -> StateChangeReturn: ...

class change_stateElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.change_state
    """
    #  element
    def __call__(
        self,
        element: Element,
        transition: StateChange,
    ) -> StateChangeReturn: ...

class state_changedElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.state_changed
    """
    #  element
    def __call__(
        self,
        element: Element,
        oldstate: State,
        newstate: State,
        pending: State,
    ) -> None: ...

class set_busElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.set_bus
    """
    #  element
    def __call__(
        self,
        element: Element,
        bus: Bus | None = None,
    ) -> None: ...

class provide_clockElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.provide_clock
    """
    #  element
    def __call__(
        self,
        element: Element,
    ) -> Clock | None: ...

class set_clockElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.set_clock
    """
    #  element
    def __call__(
        self,
        element: Element,
        clock: Clock | None = None,
    ) -> bool: ...

class send_eventElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.send_event
    """
    #  element
    def __call__(
        self,
        element: Element,
        event: Event,
    ) -> bool: ...

class queryElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.query
    """
    #  element
    def __call__(
        self,
        element: Element,
        query: Query,
    ) -> bool: ...

class post_messageElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.post_message
    """
    #  element
    def __call__(
        self,
        element: Element,
        message: Message,
    ) -> bool: ...

class set_contextElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.set_context
    """
    #  element
    def __call__(
        self,
        element: Element,
        context: Context,
    ) -> None: ...

class IteratorFoldFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.fold
    """
    #  item
    def __call__(
        self,
        item: GObject.Value,
        ret: GObject.Value,
        *user_data: object | None,
    ) -> bool: ...

class IteratorForeachFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  item
    def __call__(
        self,
        item: GObject.Value,
        *user_data: object | None,
    ) -> None: ...

class IteratorItemFunctionIteratorCB(typing.Protocol):
    """
    This callback was used in:
        Iterator.item
    """
    #  it
    def __call__(
        self,
        it: Iterator,
        item: GObject.Value,
    ) -> IteratorItem: ...

class AllocationMetaParamsAggregator(typing.Protocol):
    """
    This callback was used in:
        Gst.api_type_set_params_aggregator, Gst.meta_api_type_set_params_aggregator
    """
    #  aggregated_params
    def __call__(
        self,
        aggregated_params: Structure,
        params0: Structure,
        params1: Structure,
    ) -> bool: ...

class CustomMetaTransformFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.meta_register_custom, Gst.register_custom
    """
    #  transbuf
    def __call__(
        self,
        transbuf: Buffer,
        meta: CustomMeta,
        buffer: Buffer,
        type: int,
        data: object | None = None,
        *user_data: object | None,
    ) -> bool: ...

class MetaInitFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.init_func
    """
    #  meta
    def __call__(
        self,
        meta: Meta,
        params: object | None,
        buffer: Buffer,
    ) -> bool: ...

class MetaFreeFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.free_func
    """
    #  meta
    def __call__(
        self,
        meta: Meta,
        buffer: Buffer,
    ) -> None: ...

class MetaTransformFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.transform_func
    """
    #  transbuf
    def __call__(
        self,
        transbuf: Buffer,
        meta: Meta,
        buffer: Buffer,
        type: int,
        data: object | None = None,
    ) -> bool: ...

class MetaSerializeFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.serialize_func
    """
    #  meta
    def __call__(
        self,
        meta: Meta,
        data: ByteArrayInterface,
    ) -> tuple[bool, int]: ...

class MetaDeserializeFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.deserialize_func
    """
    #  info
    def __call__(
        self,
        info: MetaInfo,
        buffer: Buffer,
        data: int,
        size: int,
        version: int,
    ) -> Meta | None: ...

class MetaClearFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.clear_func
    """
    #  buffer
    def __call__(
        self,
        buffer: Buffer,
        meta: Meta,
    ) -> None: ...

class MiniObjectCopyFunctionMiniObjectCB(typing.Protocol):
    """
    This callback was used in:
        MiniObject.copy
    """
    #  obj
    def __call__(
        self,
        obj: MiniObject,
    ) -> MiniObject: ...

class MiniObjectDisposeFunctionMiniObjectCB(typing.Protocol):
    """
    This callback was used in:
        MiniObject.dispose
    """
    #  obj
    def __call__(
        self,
        obj: MiniObject,
    ) -> bool: ...

class MiniObjectFreeFunctionMiniObjectCB(typing.Protocol):
    """
    This callback was used in:
        MiniObject.free
    """
    #  obj
    def __call__(
        self,
        obj: MiniObject,
    ) -> None: ...

class deep_notifyObjectClassCB(typing.Protocol):
    """
    This callback was used in:
        ObjectClass.deep_notify
    """
    #  object
    def __call__(
        self,
        object: Object,
        orig: Object,
        pspec: GObject.ParamSpec,
    ) -> None: ...

class PadProbeCallback(typing.Protocol):
    """
    This callback was used in:
        Gst.add_probe
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        info: PadProbeInfo,
        *user_data: object | None,
    ) -> PadProbeReturn: ...

class PadForwardFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.forward
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        *user_data: object | None,
    ) -> bool: ...

class PadActivateFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_activate_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object,
    ) -> bool: ...

class PadActivateModeFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_activatemode_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object,
        mode: PadMode,
        active: bool,
    ) -> bool: ...

class PadChainFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_chain_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        buffer: Buffer,
    ) -> FlowReturn: ...

class PadChainListFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_chain_list_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        list: BufferList,
    ) -> FlowReturn: ...

class PadEventFullFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_event_full_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        event: Event,
    ) -> FlowReturn: ...

class PadEventFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_event_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        event: Event,
    ) -> bool: ...

class PadGetRangeFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_getrange_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        offset: int,
        length: int,
        buffer: Buffer,
    ) -> FlowReturn: ...

class PadIterIntLinkFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_iterate_internal_links_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None = None,
    ) -> Iterator: ...

class PadLinkFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_link_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        peer: Pad,
    ) -> PadLinkReturn: ...

class PadQueryFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_query_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        query: Query,
    ) -> bool: ...

class PadUnlinkFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_unlink_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None = None,
    ) -> None: ...

class TaskFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.new, Gst.start_task
    """
    #  user_data
    def __call__(
        self,
        *user_data: object | None,
    ) -> None: ...

class PadStickyEventsForeachFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.sticky_events_foreach
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        event: Event | None = None,
        *user_data: object | None,
    ) -> bool: ...

class PadActivateFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.activatefunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object,
    ) -> bool: ...

class PadActivateModeFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.activatemodefunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object,
        mode: PadMode,
        active: bool,
    ) -> bool: ...

class PadLinkFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.linkfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        peer: Pad,
    ) -> PadLinkReturn: ...

class PadUnlinkFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.unlinkfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None = None,
    ) -> None: ...

class PadChainFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.chainfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        buffer: Buffer,
    ) -> FlowReturn: ...

class PadChainListFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.chainlistfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        list: BufferList,
    ) -> FlowReturn: ...

class PadGetRangeFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.getrangefunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        offset: int,
        length: int,
        buffer: Buffer,
    ) -> FlowReturn: ...

class PadEventFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.eventfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        event: Event,
    ) -> bool: ...

class PadQueryFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.queryfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        query: Query,
    ) -> bool: ...

class PadIterIntLinkFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.iterintlinkfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None = None,
    ) -> Iterator: ...

class linkedPadClassCB(typing.Protocol):
    """
    This callback was used in:
        PadClass.linked
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        peer: Pad,
    ) -> None: ...

class unlinkedPadClassCB(typing.Protocol):
    """
    This callback was used in:
        PadClass.unlinked
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        peer: Pad,
    ) -> None: ...

class pad_createdPadTemplateClassCB(typing.Protocol):
    """
    This callback was used in:
        PadTemplateClass.pad_created
    """
    #  templ
    def __call__(
        self,
        templ: PadTemplate,
        pad: Pad,
    ) -> None: ...

class PluginInitFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.register_static
    """
    #  plugin
    def __call__(
        self,
        plugin: Plugin,
    ) -> bool: ...

class PluginInitFullFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.register_static_full
    """
    #  plugin
    def __call__(
        self,
        plugin: Plugin,
        *user_data: object | None,
    ) -> bool: ...

class PluginInitFuncPluginDescCB(typing.Protocol):
    """
    This callback was used in:
        PluginDesc.plugin_init
    """
    #  plugin
    def __call__(
        self,
        plugin: Plugin,
    ) -> bool: ...

class get_preset_namesPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.get_preset_names
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
    ) -> list: ...

class get_property_namesPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.get_property_names
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
    ) -> list: ...

class load_presetPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.load_preset
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
    ) -> bool: ...

class save_presetPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.save_preset
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
    ) -> bool: ...

class rename_presetPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.rename_preset
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        old_name: str,
        new_name: str,
    ) -> bool: ...

class delete_presetPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.delete_preset
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
    ) -> bool: ...

class set_metaPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.set_meta
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
        tag: str,
        value: str | None = None,
    ) -> bool: ...

class get_metaPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.get_meta
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
        tag: str,
    ) -> tuple[bool, str]: ...

class PromiseChangeFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.new_with_change_func
    """
    #  promise
    def __call__(
        self,
        promise: Promise,
        *user_data: object | None,
    ) -> None: ...

class PluginFeatureFilter(typing.Protocol):
    """
    This callback was used in:
        Gst.feature_filter
    """
    #  feature
    def __call__(
        self,
        feature: PluginFeature,
        *user_data: object | None,
    ) -> bool: ...

class PluginFilter(typing.Protocol):
    """
    This callback was used in:
        Gst.plugin_filter
    """
    #  plugin
    def __call__(
        self,
        plugin: Plugin,
        *user_data: object | None,
    ) -> bool: ...

class stream_notifyStreamCollectionClassCB(typing.Protocol):
    """
    This callback was used in:
        StreamCollectionClass.stream_notify
    """
    #  collection
    def __call__(
        self,
        collection: StreamCollection,
        stream: Stream,
        pspec: GObject.ParamSpec,
    ) -> None: ...

class StructureFilterMapFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.filter_and_map_in_place
    """
    #  field_id
    def __call__(
        self,
        field_id: int,
        value: GObject.Value,
        *user_data: object | None,
    ) -> bool: ...

class StructureFilterMapIdStrFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.filter_and_map_in_place_id_str
    """
    #  fieldname
    def __call__(
        self,
        fieldname: IdStr,
        value: GObject.Value,
        *user_data: object | None,
    ) -> bool: ...

class StructureForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  field_id
    def __call__(
        self,
        field_id: int,
        value: GObject.Value,
        *user_data: object | None,
    ) -> bool: ...

class StructureForeachIdStrFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach_id_str
    """
    #  fieldname
    def __call__(
        self,
        fieldname: IdStr,
        value: GObject.Value,
        *user_data: object | None,
    ) -> bool: ...

class StructureMapFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.map_in_place
    """
    #  field_id
    def __call__(
        self,
        field_id: int,
        value: GObject.Value,
        *user_data: object | None,
    ) -> bool: ...

class StructureMapIdStrFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.map_in_place_id_str
    """
    #  fieldname
    def __call__(
        self,
        fieldname: IdStr,
        value: GObject.Value,
        *user_data: object | None,
    ) -> bool: ...

class TagForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  list
    def __call__(
        self,
        list: TagList,
        tag: str,
        *user_data: object | None,
    ) -> None: ...

class TaskFunctionTaskCB(typing.Protocol):
    """
    This callback was used in:
        Task.func
    """
    #  user_data
    def __call__(
        self,
        *user_data: object | None,
    ) -> None: ...

class TaskThreadFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.set_enter_callback, Gst.set_leave_callback
    """
    #  task
    def __call__(
        self,
        task: Task,
        thread: GLib.Thread,
        *user_data: object | None,
    ) -> None: ...

class TaskPoolFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.push
    """
    #  user_data
    def __call__(
        self,
        *user_data: object | None,
    ) -> None: ...

class prepareTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.prepare
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
    ) -> None: ...

class cleanupTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.cleanup
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
    ) -> None: ...

class pushTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.push
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
        func: TaskPoolFunction,
        *user_data: object | None,
    ) -> object | None: ...

class joinTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.join
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
        id: object | None = None,
    ) -> None: ...

class dispose_handleTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.dispose_handle
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
        id: object | None = None,
    ) -> None: ...

class TypeFindFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.register, Gst.type_find_register
    """
    #  find
    def __call__(
        self,
        find: TypeFind,
        *user_data: object | None,
    ) -> None: ...

class get_typeURIHandlerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        URIHandlerInterface.get_type
    """
    #  type
    def __call__(
        self,
        type: GObject.GType,
    ) -> URIType: ...

class get_protocolsURIHandlerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        URIHandlerInterface.get_protocols
    """
    #  type
    def __call__(
        self,
        type: GObject.GType,
    ) -> list: ...

class get_uriURIHandlerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        URIHandlerInterface.get_uri
    """
    #  handler
    def __call__(
        self,
        handler: URIHandler,
    ) -> str | None: ...

class set_uriURIHandlerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        URIHandlerInterface.set_uri
    """
    #  handler
    def __call__(
        self,
        handler: URIHandler,
        uri: str,
    ) -> bool: ...

class ValueCompareFuncValueTableCB(typing.Protocol):
    """
    This callback was used in:
        ValueTable.compare
    """
    #  value1
    def __call__(
        self,
        value1: GObject.Value,
        value2: GObject.Value,
    ) -> int: ...

class ValueSerializeFuncValueTableCB(typing.Protocol):
    """
    This callback was used in:
        ValueTable.serialize
    """
    #  value1
    def __call__(
        self,
        value1: GObject.Value,
    ) -> str: ...

class ValueDeserializeFuncValueTableCB(typing.Protocol):
    """
    This callback was used in:
        ValueTable.deserialize
    """
    #  dest
    def __call__(
        self,
        dest: GObject.Value,
        s: str,
    ) -> bool: ...

class ValueDeserializeWithPSpecFuncValueTableCB(typing.Protocol):
    """
    This callback was used in:
        ValueTable.deserialize_with_pspec
    """
    #  dest
    def __call__(
        self,
        dest: GObject.Value,
        s: str,
        pspec: GObject.ParamSpec,
    ) -> bool: ...

class LogFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.debug_add_log_function, Gst.debug_remove_log_function
    """
    #  category
    def __call__(
        self,
        category: DebugCategory,
        level: DebugLevel,
        file: str,
        function: str,
        line: int,
        object: GObject.Object,
        message: DebugMessage,
        *user_data: object | None,
    ) -> None: ...

###############################################################
# Aliases
###############################################################

_lock = _thread._lock  # type: ignore
_overrides_module = ...  # this very module ...
debug = _gi_gst.debug
error = _gi_gst.error
fixme = _gi_gst.fixme
info = _gi_gst.info
log = _gi_gst.log
memdump = _gi_gst.memdump
trace = _gi_gst.trace
warning = _gi_gst.warning
###############################################################
# Constants
###############################################################

ALLOCATOR_SYSMEM: str = ...
BUFFER_COPY_ALL = BufferCopyFlags.NONE
"""
Combination of all possible fields that can be copied with
`Gst.Buffer.copy_into`. 
"""
BUFFER_COPY_METADATA = BufferCopyFlags.NONE
"""
Combination of all possible metadata fields that can be copied with
`Gst.Buffer.copy_into`. 
"""
BUFFER_OFFSET_NONE: int = ...
CAN_INLINE: int = ...
CAPS_FEATURE_MEMORY_SYSTEM_MEMORY: str = ...
CLOCK_TIME_NONE: int = ...
DEBUG_BG_MASK: int = ...
DEBUG_FG_MASK: int = ...
DEBUG_FORMAT_MASK: int = ...
ELEMENT_FACTORY_KLASS_DECODER: str = ...
ELEMENT_FACTORY_KLASS_DECRYPTOR: str = ...
ELEMENT_FACTORY_KLASS_DEMUXER: str = ...
ELEMENT_FACTORY_KLASS_DEPAYLOADER: str = ...
ELEMENT_FACTORY_KLASS_ENCODER: str = ...
ELEMENT_FACTORY_KLASS_ENCRYPTOR: str = ...
ELEMENT_FACTORY_KLASS_FORMATTER: str = ...
ELEMENT_FACTORY_KLASS_HARDWARE: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_AUDIO: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_IMAGE: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_METADATA: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_VIDEO: str = ...
ELEMENT_FACTORY_KLASS_MUXER: str = ...
ELEMENT_FACTORY_KLASS_PARSER: str = ...
ELEMENT_FACTORY_KLASS_PAYLOADER: str = ...
ELEMENT_FACTORY_KLASS_SINK: str = ...
ELEMENT_FACTORY_KLASS_SRC: str = ...
ELEMENT_FACTORY_TYPE_ANY: int = ...
ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS: int = ...
ELEMENT_FACTORY_TYPE_AUDIO_ENCODER: int = ...
ELEMENT_FACTORY_TYPE_DECODABLE: int = ...
ELEMENT_FACTORY_TYPE_DECODER: int = ...
ELEMENT_FACTORY_TYPE_DECRYPTOR: int = ...
ELEMENT_FACTORY_TYPE_DEMUXER: int = ...
ELEMENT_FACTORY_TYPE_DEPAYLOADER: int = ...
ELEMENT_FACTORY_TYPE_ENCODER: int = ...
ELEMENT_FACTORY_TYPE_ENCRYPTOR: int = ...
ELEMENT_FACTORY_TYPE_FORMATTER: int = ...
ELEMENT_FACTORY_TYPE_HARDWARE: int = ...
ELEMENT_FACTORY_TYPE_MAX_ELEMENTS: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_ANY: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_AUDIO: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_IMAGE: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_METADATA: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_VIDEO: int = ...
ELEMENT_FACTORY_TYPE_MUXER: int = ...
ELEMENT_FACTORY_TYPE_PARSER: int = ...
ELEMENT_FACTORY_TYPE_PAYLOADER: int = ...
ELEMENT_FACTORY_TYPE_SINK: int = ...
ELEMENT_FACTORY_TYPE_SRC: int = ...
ELEMENT_FACTORY_TYPE_TIMESTAMPER: int = ...
ELEMENT_FACTORY_TYPE_VIDEO_ENCODER: int = ...
ELEMENT_METADATA_AUTHOR: str = ...
ELEMENT_METADATA_DESCRIPTION: str = ...
ELEMENT_METADATA_DOC_URI: str = ...
ELEMENT_METADATA_ICON_NAME: str = ...
ELEMENT_METADATA_KLASS: str = ...
ELEMENT_METADATA_LONGNAME: str = ...
EVENT_NUM_SHIFT: int = ...
EVENT_TYPE_BOTH = EventTypeFlags(0)
"""
The same thing as GST_EVENT_TYPE_UPSTREAM | GST_EVENT_TYPE_DOWNSTREAM. 
"""
FLAG_SET_MASK_EXACT: int = ...
FORMAT_PERCENT_MAX: int = ...
FORMAT_PERCENT_SCALE: int = ...
GROUP_ID_INVALID: int = ...
LICENSE_UNKNOWN: str = ...
LOCK_FLAG_READWRITE = LockFlags(0)
"""
GstLockFlags value alias for GST_LOCK_FLAG_READ | GST_LOCK_FLAG_WRITE 
"""
MAP_READWRITE = MapFlags(0)
"""
GstMapFlags value alias for GST_MAP_READ | GST_MAP_WRITE 
"""
META_TAG_MEMORY_REFERENCE_STR: str = ...
META_TAG_MEMORY_STR: str = ...
MSECOND: int = ...
NSECOND: int = ...
PARAM_CONDITIONALLY_AVAILABLE: int = ...
PARAM_CONTROLLABLE: int = ...
PARAM_DOC_SHOW_DEFAULT: int = ...
PARAM_MUTABLE_PAUSED: int = ...
PARAM_MUTABLE_PLAYING: int = ...
PARAM_MUTABLE_READY: int = ...
PARAM_USER_SHIFT: int = ...
PROTECTION_SYSTEM_ID_CAPS_FIELD: str = ...
PROTECTION_UNSPECIFIED_SYSTEM_ID: str = ...
QUERY_NUM_SHIFT: int = ...
QUERY_TYPE_BOTH = QueryTypeFlags(0)
"""
The same thing as GST_QUERY_TYPE_UPSTREAM | GST_QUERY_TYPE_DOWNSTREAM. 
"""
SECOND: int = ...
SEGMENT_INSTANT_FLAGS: int = ...
SEQNUM_INVALID: int = ...
TAG_ALBUM: str = ...
TAG_ALBUM_ARTIST: str = ...
TAG_ALBUM_ARTIST_SORTNAME: str = ...
TAG_ALBUM_GAIN: str = ...
TAG_ALBUM_PEAK: str = ...
TAG_ALBUM_SORTNAME: str = ...
TAG_ALBUM_VOLUME_COUNT: str = ...
TAG_ALBUM_VOLUME_NUMBER: str = ...
TAG_APPLICATION_DATA: str = ...
TAG_APPLICATION_NAME: str = ...
TAG_ARTIST: str = ...
TAG_ARTIST_SORTNAME: str = ...
TAG_ATTACHMENT: str = ...
TAG_AUDIO_CODEC: str = ...
TAG_BEATS_PER_MINUTE: str = ...
TAG_BITRATE: str = ...
TAG_CODEC: str = ...
TAG_COMMENT: str = ...
TAG_COMPOSER: str = ...
TAG_COMPOSER_SORTNAME: str = ...
TAG_CONDUCTOR: str = ...
TAG_CONTACT: str = ...
TAG_CONTAINER_FORMAT: str = ...
TAG_CONTAINER_SPECIFIC_TRACK_ID: str = ...
TAG_COPYRIGHT: str = ...
TAG_COPYRIGHT_URI: str = ...
TAG_DATE: str = ...
TAG_DATE_TIME: str = ...
TAG_DESCRIPTION: str = ...
TAG_DEVICE_MANUFACTURER: str = ...
TAG_DEVICE_MODEL: str = ...
TAG_DURATION: str = ...
TAG_ENCODED_BY: str = ...
TAG_ENCODER: str = ...
TAG_ENCODER_VERSION: str = ...
TAG_EXTENDED_COMMENT: str = ...
TAG_GENRE: str = ...
TAG_GEO_LOCATION_CAPTURE_DIRECTION: str = ...
TAG_GEO_LOCATION_CITY: str = ...
TAG_GEO_LOCATION_COUNTRY: str = ...
TAG_GEO_LOCATION_ELEVATION: str = ...
TAG_GEO_LOCATION_HORIZONTAL_ERROR: str = ...
TAG_GEO_LOCATION_LATITUDE: str = ...
TAG_GEO_LOCATION_LONGITUDE: str = ...
TAG_GEO_LOCATION_MOVEMENT_DIRECTION: str = ...
TAG_GEO_LOCATION_MOVEMENT_SPEED: str = ...
TAG_GEO_LOCATION_NAME: str = ...
TAG_GEO_LOCATION_SUBLOCATION: str = ...
TAG_GROUPING: str = ...
TAG_HOMEPAGE: str = ...
TAG_IMAGE: str = ...
TAG_IMAGE_ORIENTATION: str = ...
TAG_INTERPRETED_BY: str = ...
TAG_ISRC: str = ...
TAG_KEYWORDS: str = ...
TAG_LANGUAGE_CODE: str = ...
TAG_LANGUAGE_NAME: str = ...
TAG_LICENSE: str = ...
TAG_LICENSE_URI: str = ...
TAG_LOCATION: str = ...
TAG_LYRICS: str = ...
TAG_MAXIMUM_BITRATE: str = ...
TAG_MIDI_BASE_NOTE: str = ...
TAG_MINIMUM_BITRATE: str = ...
TAG_NOMINAL_BITRATE: str = ...
TAG_ORGANIZATION: str = ...
TAG_PERFORMER: str = ...
TAG_PREVIEW_IMAGE: str = ...
TAG_PRIVATE_DATA: str = ...
TAG_PUBLISHER: str = ...
TAG_REFERENCE_LEVEL: str = ...
TAG_SERIAL: str = ...
TAG_SHOW_EPISODE_NUMBER: str = ...
TAG_SHOW_NAME: str = ...
TAG_SHOW_SEASON_NUMBER: str = ...
TAG_SHOW_SORTNAME: str = ...
TAG_SUBTITLE_CODEC: str = ...
TAG_TITLE: str = ...
TAG_TITLE_SORTNAME: str = ...
TAG_TRACK_COUNT: str = ...
TAG_TRACK_GAIN: str = ...
TAG_TRACK_NUMBER: str = ...
TAG_TRACK_PEAK: str = ...
TAG_USER_RATING: str = ...
TAG_VERSION: str = ...
TAG_VIDEO_CODEC: str = ...
TOC_REPEAT_COUNT_INFINITE: int = ...
URI_NO_PORT: int = ...
USECOND: int = ...
VALUE_EQUAL: int = ...
VALUE_GREATER_THAN: int = ...
VALUE_LESS_THAN: int = ...
VALUE_UNORDERED: int = ...
VERSION_MAJOR: int = ...
VERSION_MICRO: int = ...
VERSION_MINOR: int = ...
VERSION_NANO: int = ...
_namespace: str = ...
_version: str = ...
