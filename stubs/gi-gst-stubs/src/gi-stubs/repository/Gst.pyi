# pyright: reportIncompatibleMethodOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: Gst
Date: 2025-12-24
"""
# we disable method override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401
import builtins  # noqa: F401

import _thread
import typing

# gi.repository imports needed by this Stub
from gi.repository import GLib
from gi.repository import GObject
###############################################################
# Functions
###############################################################

@staticmethod
def buffer_get_max_memory() -> int:
    """
    Gets the maximum amount of memory blocks that a buffer can hold. This is a
    compile time constant that can be queried with the function.

    When more memory blocks are added, existing memory blocks will be merged
    together to make room for the new block.
    """
    ...

@staticmethod
def caps_features_from_string(
    features: str,
) -> CapsFeatures | None:
    """
    Creates a #GstCapsFeatures from a string representation.
    """
    ...

@staticmethod
def caps_from_string(
    string: str,
) -> Caps | None:
    """
    Converts @caps from a string representation.

    The implementation of serialization up to 1.20 would lead to unexpected results
    when there were nested #GstCaps / #GstStructure deeper than one level.
    """
    ...

@staticmethod
def core_error_quark() -> int: ...
@staticmethod
def debug_add_log_function(
    func: LogFunction,
    user_data: object | None,
    notify: GLib.DestroyNotify,  # type: ignore
) -> None:
    """
    Adds the logging function to the list of logging functions.
    Be sure to use #G_GNUC_NO_INSTRUMENT on that function, it is needed.
    """
    ...

@staticmethod
def debug_add_ring_buffer_logger(
    max_size_per_thread: int,
    thread_timeout: int,
) -> None:
    """
    Adds a memory ringbuffer based debug logger that stores up to
    @max_size_per_thread bytes of logs per thread and times out threads after
    @thread_timeout seconds of inactivity.

    Logs can be fetched with gst_debug_ring_buffer_logger_get_logs() and the
    logger can be removed again with gst_debug_remove_ring_buffer_logger().
    Only one logger at a time is possible.
    """
    ...

@staticmethod
def debug_bin_to_dot_data(
    bin: Bin,
    details: DebugGraphDetails,
) -> str:
    """
    To aid debugging applications one can use this method to obtain the whole
    network of gstreamer elements that form the pipeline into a dot file.
    This data can be processed with graphviz to get an image.
    """
    ...

@staticmethod
def debug_bin_to_dot_file(
    bin: Bin,
    details: DebugGraphDetails,
    file_name: str,
) -> None:
    """
    To aid debugging applications one can use this method to write out the whole
    network of gstreamer elements that form the pipeline into a dot file.
    This file can be processed with graphviz to get an image.

    ``` shell
     dot -Tpng -oimage.png graph_lowlevel.dot
    ```
    """
    ...

@staticmethod
def debug_bin_to_dot_file_with_ts(
    bin: Bin,
    details: DebugGraphDetails,
    file_name: str,
) -> None:
    """
    This works like gst_debug_bin_to_dot_file(), but adds the current timestamp
    to the filename, so that it can be used to take multiple snapshots.
    """
    ...

@staticmethod
def debug_construct_term_color(
    colorinfo: int,
) -> str:
    """
    Constructs a string that can be used for getting the desired color in color
    terminals.
    You need to free the string after use.
    """
    ...

@staticmethod
def debug_construct_win_color(
    colorinfo: int,
) -> int:
    """
    Constructs an integer that can be used for getting the desired color in
    windows' terminals (cmd.exe). As there is no mean to underline, we simply
    ignore this attribute.

    This function returns 0 on non-windows machines.
    """
    ...

@staticmethod
def debug_get_all_categories() -> list:
    """
    Returns a snapshot of a all categories that are currently in use . This list
    may change anytime.
    The caller has to free the list after use.
    """
    ...

@staticmethod
def debug_get_color_mode() -> DebugColorMode:
    """
    Changes the coloring mode for debug output.
    """
    ...

@staticmethod
def debug_get_default_threshold() -> DebugLevel:
    """
    Returns the default threshold that is used for new categories.
    """
    ...

@staticmethod
def debug_get_stack_trace(
    flags: StackTraceFlags,
) -> str | None: ...
@staticmethod
def debug_is_active() -> bool:
    """
    Checks if debugging output is activated.
    """
    ...

@staticmethod
def debug_is_colored() -> bool:
    """
    Checks if the debugging output should be colored.
    """
    ...

@staticmethod
def debug_level_get_name(
    level: DebugLevel,
) -> str:
    """
    Get the string representation of a debugging level
    """
    ...

@staticmethod
def debug_log_default(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    object: GObject.Object | None,
    message: DebugMessage,
    user_data: object | None = None,
) -> None:
    """
    The default logging handler used by GStreamer. Logging functions get called
    whenever a macro like GST_DEBUG or similar is used. By default this function
    is setup to output the message and additional info to stderr (or the log file
    specified via the GST_DEBUG_FILE environment variable) as received via
    @user_data.

    You can add other handlers by using gst_debug_add_log_function().
    And you can remove this handler by calling
    gst_debug_remove_log_function(gst_debug_log_default);
    """
    ...

@staticmethod
def debug_log_get_line(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    object: GObject.Object | None,
    message: DebugMessage,
) -> str:
    """
    Returns the string representation for the specified debug log message
    formatted in the same way as gst_debug_log_default() (the default handler),
    without color. The purpose is to make it easy for custom log output
    handlers to get a log output that is identical to what the default handler
    would write out.
    """
    ...

@staticmethod
def debug_log_id_literal(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    id: str | None,
    message_string: str,
) -> None:
    """
    Logs the given message using the currently registered debugging handlers.
    """
    ...

@staticmethod
def debug_log_literal(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    object: GObject.Object | None,
    message_string: str,
) -> None:
    """
    Logs the given message using the currently registered debugging handlers.
    """
    ...

@staticmethod
def debug_print_object(
    ptr: object | None = None,
) -> str:
    """
    Returns a string that represents @ptr. This is safe to call with
    %GstStructure, %GstCapsFeatures, %GstMiniObject s (e.g. %GstCaps,
    %GstBuffer or %GstMessage), and %GObjects (e.g. %GstElement or %GstPad).

    The string representation is meant to be used for debugging purposes and
    might change between GStreamer versions.

    Passing other kind of pointers might or might not work and is generally
    unsafe to do.
    """
    ...

@staticmethod
def debug_print_segment(
    segment: Segment | None = None,
) -> str:
    """
    Returns a string that represents @segments.

    The string representation is meant to be used for debugging purposes and
    might change between GStreamer versions.
    """
    ...

@staticmethod
def debug_print_stack_trace() -> None:
    """
    If libunwind, glibc backtrace or DbgHelp are present
    a stack trace is printed.
    """
    ...

@staticmethod
def debug_remove_log_function(
    func: LogFunction | None = None,
) -> int:
    """
    Removes all registered instances of the given logging functions.
    """
    ...

@staticmethod
def debug_remove_log_function_by_data(
    data: object | None = None,
) -> int:
    """
    Removes all registered instances of log functions with the given user data.
    """
    ...

@staticmethod
def debug_remove_ring_buffer_logger() -> None:
    """
    Removes any previously added ring buffer logger with
    gst_debug_add_ring_buffer_logger().
    """
    ...

@staticmethod
def debug_ring_buffer_logger_get_logs() -> list:
    """
    Fetches the current logs per thread from the ring buffer logger. See
    gst_debug_add_ring_buffer_logger() for details.
    """
    ...

@staticmethod
def debug_set_active(
    active: bool,
) -> None:
    """
    If activated, debugging messages are sent to the debugging
    handlers.
    It makes sense to deactivate it for speed issues.
    > This function is not threadsafe. It makes sense to only call it
    during initialization.
    """
    ...

@staticmethod
def debug_set_color_mode(
    mode: DebugColorMode,
) -> None:
    """
    Changes the coloring mode for debug output.

    This function may be called before gst_init().
    """
    ...

@staticmethod
def debug_set_color_mode_from_string(
    mode: str,
) -> None:
    """
    Changes the coloring mode for debug output.

    This function may be called before gst_init().
    """
    ...

@staticmethod
def debug_set_colored(
    colored: bool,
) -> None:
    """
    Sets or unsets the use of coloured debugging output.
    Same as gst_debug_set_color_mode () with the argument being
    being GST_DEBUG_COLOR_MODE_ON or GST_DEBUG_COLOR_MODE_OFF.

    This function may be called before gst_init().
    """
    ...

@staticmethod
def debug_set_default_threshold(
    level: DebugLevel,
) -> None:
    """
    Sets the default threshold to the given level and updates all categories to
    use this threshold.

    This function may be called before gst_init().
    """
    ...

@staticmethod
def debug_set_threshold_for_name(
    name: str,
    level: DebugLevel,
) -> None:
    """
    Sets all categories which match the given glob style pattern to the given
    level.
    """
    ...

@staticmethod
def debug_set_threshold_from_string(
    list: str,
    reset: bool,
) -> None:
    """
    Sets the debug logging wanted in the same form as with the GST_DEBUG
    environment variable. You can use wildcards such as `*`, but note that
    the order matters when you use wild cards, e.g. `foosrc:6,*src:3,*:2` sets
    everything to log level 2.
    """
    ...

@staticmethod
def debug_unset_threshold_for_name(
    name: str,
) -> None:
    """
    Resets all categories with the given name back to the default level.
    """
    ...

@staticmethod
def deinit() -> None:
    """
    Clean up any resources created by GStreamer in gst_init().

    It is normally not needed to call this function in a normal application
    as the resources will automatically be freed when the program terminates.
    This function is therefore mostly used by testsuites and other memory
    profiling tools.

    After this call GStreamer (including this method) should not be used anymore.
    """
    ...

@staticmethod
def dynamic_type_register(
    plugin: Plugin,
    type: GObject.GType,
) -> bool:
    """
    Registers a new #GstDynamicTypeFactory in the registry
    """
    ...

@staticmethod
def error_get_message(
    domain: int,
    code: int,
) -> str:
    """
    Get a string describing the error message in the current locale.
    """
    ...

@staticmethod
def event_type_get_flags(
    type: EventType,
) -> EventTypeFlags:
    """
    Gets the #GstEventTypeFlags associated with @type.
    """
    ...

@staticmethod
def event_type_get_name(
    type: EventType,
) -> str:
    """
    Get a printable name for the given event type. Do not modify or free.
    """
    ...

@staticmethod
def event_type_to_quark(
    type: EventType,
) -> int:
    """
    Get the unique quark for the given event type.
    """
    ...

@staticmethod
def event_type_to_sticky_ordering(
    type: EventType,
) -> int:
    """
    Converts the #GstEventType to an unsigned integer that
    represents the ordering of sticky events when re-sending them.
    A lower value represents a higher-priority event.
    """
    ...

@staticmethod
def filename_to_uri(
    filename: str,
) -> str | None:
    """
    Similar to g_filename_to_uri(), but attempts to handle relative file paths
    as well. Before converting @filename into an URI, it will be prefixed by
    the current working directory if it is a relative path, and then the path
    will be canonicalised so that it doesn't contain any './' or '../' segments.

    On Windows @filename should be in UTF-8 encoding.
    """
    ...

@staticmethod
def flow_get_name(
    ret: FlowReturn,
) -> str:
    """
    Gets a string representing the given flow return.
    """
    ...

@staticmethod
def flow_to_quark(
    ret: FlowReturn,
) -> int:
    """
    Get the unique quark for the given GstFlowReturn.
    """
    ...

@staticmethod
def format_get_by_nick(
    nick: str,
) -> Format:
    """
    Return the format registered with the given nick.
    """
    ...

@staticmethod
def format_get_details(
    format: Format,
) -> FormatDefinition | None:
    """
    Get details about the given format.
    """
    ...

@staticmethod
def format_get_name(
    format: Format,
) -> str | None:
    """
    Get a printable name for the given format. Do not modify or free.
    """
    ...

@staticmethod
def format_iterate_definitions() -> Iterator:
    """
    Iterate all the registered formats. The format definition is read
    only.
    """
    ...

@staticmethod
def format_register(
    nick: str,
    description: str,
) -> Format:
    """
    Create a new GstFormat based on the nick or return an
    already registered format with that nick.
    """
    ...

@staticmethod
def format_to_quark(
    format: Format,
) -> int:
    """
    Get the unique quark for the given format.
    """
    ...

@staticmethod
def formats_contains(
    formats: list,
    format: Format,
) -> bool:
    """
    See if the given format is inside the format array.
    """
    ...

@staticmethod
def get_main_executable_path() -> str | None:
    """
    This helper is mostly helpful for plugins that need to
    inspect the folder of the main executable to determine
    their set of features.

    When a plugin is initialized from the gst-plugin-scanner
    external process, the returned path will be the same as from the
    parent process.
    """
    ...

@staticmethod
def init(
    argc: int | None = None,
    argv: list | None = None,
) -> tuple[int | None, list | None]:
    """
    Initializes the GStreamer library, setting up internal path lists,
    registering built-in elements, and loading standard plugins.

    Unless the plugin registry is disabled at compile time, the registry will be
    loaded. By default this will also check if the registry cache needs to be
    updated and rescan all plugins if needed. See gst_update_registry() for
    details and section
    <link linkend="gst-running">Running GStreamer Applications</link>
    for how to disable automatic registry updates.

    WARNING: This function will terminate your program if it was unable to
    initialize GStreamer for some reason. If you want your program to fall back,
    use gst_init_check() instead.
    """
    ...

@staticmethod
def init_check(
    argc: int | None = None,
    argv: list | None = None,
) -> tuple[bool, int | None, list | None]:
    """
    Initializes the GStreamer library, setting up internal path lists,
    registering built-in elements, and loading standard plugins.

    This function will return %FALSE if GStreamer could not be initialized
    for some reason.  If you want your program to fail fatally,
    use gst_init() instead.
    """
    ...

@staticmethod
def is_caps_features(
    obj: object | None = None,
) -> bool:
    """
    Checks if @obj is a #GstCapsFeatures
    """
    ...

@staticmethod
def is_initialized() -> bool:
    """
    Use this function to check if GStreamer has been initialized with gst_init()
    or gst_init_check().
    """
    ...

@staticmethod
def library_error_quark() -> int: ...
@staticmethod
def message_type_get_name(
    type: MessageType,
) -> str:
    """
    Get a printable name for the given message type. Do not modify or free.
    """
    ...

@staticmethod
def message_type_to_quark(
    type: MessageType,
) -> int:
    """
    Get the unique quark for the given message type.
    """
    ...

@staticmethod
def meta_api_type_aggregate_params(
    api: GObject.GType,
    aggregated_params: Structure,
    params0: Structure,
    params1: Structure,
) -> bool:
    """
    When a element like `tee` decides the allocation, each downstream element may
    fill different parameters and pass them to gst_query_add_allocation_meta().
    In order to keep these parameters, a merge operation is needed. This
    aggregate function can combine the parameters from @params0 and @param1, and
    write the result back into @aggregated_params.
    """
    ...

@staticmethod
def meta_api_type_get_tags(
    api: GObject.GType,
) -> list: ...
@staticmethod
def meta_api_type_has_tag(
    api: GObject.GType,
    tag: int,
) -> bool:
    """
    Check if @api was registered with @tag.
    """
    ...

@staticmethod
def meta_api_type_register(
    api: str,
    tags: list,
) -> GObject.GType:
    """
    Register and return a GType for the @api and associate it with
    @tags.
    """
    ...

@staticmethod
def meta_api_type_set_params_aggregator(
    api: GObject.GType,
    aggregator: AllocationMetaParamsAggregator,
) -> None:
    """
    This function sets the aggregator function for a specific API type.
    """
    ...

@staticmethod
def meta_deserialize(
    buffer: Buffer,
    data: int,
    size: int,
) -> tuple[Meta | None, int]:
    """
    Recreate a #GstMeta from serialized data returned by
    gst_meta_serialize() and add it to @buffer.

    Note that the meta must have been previously registered by calling one of
    `gst_*_meta_get_info ()` functions.

    @consumed is set to the number of bytes that can be skipped from @data to
    find the next meta serialization, if any. In case of parsing error that does
    not allow to determine that size, @consumed is set to 0.
    """
    ...

@staticmethod
def meta_get_info(
    impl: str,
) -> MetaInfo | None:
    """
    Lookup a previously registered meta info structure by its implementation name
    @impl.
    """
    ...

@staticmethod
def meta_register_custom(
    name: str,
    tags: list,
    transform_func: CustomMetaTransformFunction | None,
    user_data: object | None,
    destroy_data: GLib.DestroyNotify,  # type: ignore
) -> MetaInfo:
    """
    Register a new custom #GstMeta implementation, backed by an opaque
    structure holding a #GstStructure.

    The registered info can be retrieved later with gst_meta_get_info() by using
    @name as the key.

    The backing #GstStructure can be retrieved with
    gst_custom_meta_get_structure(), its mutability is conditioned by the
    writability of the buffer the meta is attached to.

    When @transform_func is %NULL, the meta and its backing #GstStructure
    will always be copied when the transform operation is copy, other operations
    are discarded, copy regions are ignored.
    """
    ...

@staticmethod
def meta_register_custom_simple(
    name: str,
) -> MetaInfo:
    """
    Simplified version of gst_meta_register_custom(), with no tags and no
    transform function.
    """
    ...

@staticmethod
def mini_object_replace(
    olddata: MiniObject | None = None,
    newdata: MiniObject | None = None,
) -> tuple[bool, MiniObject | None]:
    """
    Atomically modifies a pointer to point to a new mini-object.
    The reference count of @olddata is decreased and the reference count of
    @newdata is increased.

    Either @newdata and the value pointed to by @olddata may be %NULL.
    """
    ...

@staticmethod
def mini_object_take(
    olddata: MiniObject,
    newdata: MiniObject,
) -> tuple[bool, MiniObject]:
    """
    Modifies a pointer to point to a new mini-object. The modification
    is done atomically. This version is similar to gst_mini_object_replace()
    except that it does not increase the refcount of @newdata and thus
    takes ownership of @newdata.

    Either @newdata and the value pointed to by @olddata may be %NULL.
    """
    ...

@staticmethod
def pad_mode_get_name(
    mode: PadMode,
) -> str:
    """
    Return the name of a pad mode, for use in debug messages mostly.
    """
    ...

@staticmethod
def param_spec_array(
    name: str,
    nick: str,
    blurb: str,
    element_spec: GObject.ParamSpec,
    flags: GObject.ParamFlags,
) -> GObject.ParamSpec:
    """
    This function creates a GstArray GParamSpec for use by objects/elements
    that want to expose properties of GstArray type. This function is
    typically * used in connection with g_object_class_install_property() in a
    GObjects's instance_init function.
    """
    ...

@staticmethod
def param_spec_fraction(
    name: str,
    nick: str,
    blurb: str,
    min_num: int,
    min_denom: int,
    max_num: int,
    max_denom: int,
    default_num: int,
    default_denom: int,
    flags: GObject.ParamFlags,
) -> GObject.ParamSpec | None:
    """
    This function creates a fraction GParamSpec for use by objects/elements
    that want to expose properties of fraction type. This function is typically
    used in connection with g_object_class_install_property() in a GObjects's
    instance_init function.
    """
    ...

@staticmethod
def parent_buffer_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def parent_buffer_meta_get_info() -> MetaInfo:
    """
    Gets the global #GstMetaInfo describing  the #GstParentBufferMeta meta.
    """
    ...

@staticmethod
def parse_bin_from_description(
    bin_description: str,
    ghost_unlinked_pads: bool,
) -> Bin:
    """
    This is a convenience wrapper around gst_parse_launch() to create a
    #GstBin from a gst-launch-style pipeline description. See
    gst_parse_launch() and the gst-launch man page for details about the
    syntax. Ghost pads on the bin for unlinked source or sink pads
    within the bin can automatically be created (but only a maximum of
    one ghost pad for each direction will be created; if you expect
    multiple unlinked source pads or multiple unlinked sink pads
    and want them all ghosted, you will have to create the ghost pads
    yourself).
    """
    ...

@staticmethod
def parse_bin_from_description_full(
    bin_description: str,
    ghost_unlinked_pads: bool,
    context: ParseContext | None,
    flags: ParseFlags,
) -> Element:
    """
    This is a convenience wrapper around gst_parse_launch() to create a
    #GstBin from a gst-launch-style pipeline description. See
    gst_parse_launch() and the gst-launch man page for details about the
    syntax. Ghost pads on the bin for unlinked source or sink pads
    within the bin can automatically be created (but only a maximum of
    one ghost pad for each direction will be created; if you expect
    multiple unlinked source pads or multiple unlinked sink pads
    and want them all ghosted, you will have to create the ghost pads
    yourself).
    """
    ...

@staticmethod
def parse_error_quark() -> int:
    """
    Get the error quark used by the parsing subsystem.
    """
    ...

@staticmethod
def parse_launch(
    pipeline_description: str,
) -> Element:
    """
    Create a new pipeline based on command line syntax.
    Please note that you might get a return value that is not %NULL even though
    the @error is set. In this case there was a recoverable parsing error and you
    can try to play the pipeline.

    To create a sub-pipeline (bin) for embedding into an existing pipeline
    use gst_parse_bin_from_description().
    """
    ...

@staticmethod
def parse_launch_full(
    pipeline_description: str,
    context: ParseContext | None,
    flags: ParseFlags,
) -> Element:
    """
    Create a new pipeline based on command line syntax.
    Please note that you might get a return value that is not %NULL even though
    the @error is set. In this case there was a recoverable parsing error and you
    can try to play the pipeline.

    To create a sub-pipeline (bin) for embedding into an existing pipeline
    use gst_parse_bin_from_description_full().
    """
    ...

@staticmethod
def parse_launchv(
    argv: list,
) -> Element:
    """
    Create a new element based on command line syntax.
    @error will contain an error message if an erroneous pipeline is specified.
    An error does not mean that the pipeline could not be constructed.
    """
    ...

@staticmethod
def parse_launchv_full(
    argv: list,
    context: ParseContext | None,
    flags: ParseFlags,
) -> Element:
    """
    Create a new element based on command line syntax.
    @error will contain an error message if an erroneous pipeline is specified.
    An error does not mean that the pipeline could not be constructed.
    """
    ...

@staticmethod
def plugin_error_quark() -> int:
    """
    Get the error quark.
    """
    ...

@staticmethod
def preset_get_app_dir() -> str | None:
    """
    Gets the directory for application specific presets if set by the
    application.
    """
    ...

@staticmethod
def preset_set_app_dir(
    app_dir: str,
) -> bool:
    """
    Sets an extra directory as an absolute path that should be considered when
    looking for presets. Any presets in the application dir will shadow the
    system presets.
    """
    ...

@staticmethod
def protection_filter_systems_by_available_decryptors(
    system_identifiers: list,
) -> list | None:
    """
    Iterates the supplied list of UUIDs and checks the GstRegistry for
    all the decryptors supporting one of the supplied UUIDs.
    """
    ...

@staticmethod
def protection_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def protection_meta_get_info() -> MetaInfo: ...
@staticmethod
def protection_select_system(
    system_identifiers: list,
) -> str | None:
    """
    Iterates the supplied list of UUIDs and checks the GstRegistry for
    an element that supports one of the supplied UUIDs. If more than one
    element matches, the system ID of the highest ranked element is selected.
    """
    ...

@staticmethod
def query_type_get_flags(
    type: QueryType,
) -> QueryTypeFlags:
    """
    Gets the #GstQueryTypeFlags associated with @type.
    """
    ...

@staticmethod
def query_type_get_name(
    type: QueryType,
) -> str:
    """
    Get a printable name for the given query type. Do not modify or free.
    """
    ...

@staticmethod
def query_type_to_quark(
    type: QueryType,
) -> int:
    """
    Get the unique quark for the given query type.
    """
    ...

@staticmethod
def reference_timestamp_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def reference_timestamp_meta_get_info() -> MetaInfo:
    """
    Gets the global #GstMetaInfo describing the #GstReferenceTimestampMeta meta.
    """
    ...

@staticmethod
def resource_error_quark() -> int: ...
@staticmethod
def segtrap_is_enabled() -> bool:
    """
    Some functions in the GStreamer core might install a custom SIGSEGV handler
    to better catch and report errors to the application. Currently this feature
    is enabled by default when loading plugins.

    Applications might want to disable this behaviour with the
    gst_segtrap_set_enabled() function. This is typically done if the application
    wants to install its own handler without GStreamer interfering.
    """
    ...

@staticmethod
def segtrap_set_enabled(
    enabled: bool,
) -> None:
    """
    Applications might want to disable/enable the SIGSEGV handling of
    the GStreamer core. See gst_segtrap_is_enabled() for more information.
    """
    ...

@staticmethod
def state_change_get_name(
    transition: StateChange,
) -> str:
    """
    Gets a string representing the given state transition.
    """
    ...

@staticmethod
def stream_error_quark() -> int: ...
@staticmethod
def stream_type_get_name(
    stype: StreamType,
) -> str:
    """
    Get a descriptive string for a given #GstStreamType
    """
    ...

@staticmethod
def structure_take(
    oldstr_ptr: Structure | None = None,
    newstr: Structure | None = None,
) -> tuple[bool, Structure | None]:
    """
    Atomically modifies a pointer to point to a new structure.
    The #GstStructure @oldstr_ptr is pointing to is freed and
    @newstr is taken ownership over.

    Either @newstr and the value pointed to by @oldstr_ptr may be %NULL.

    It is a programming error if both @newstr and the value pointed to by
    @oldstr_ptr refer to the same, non-%NULL structure.
    """
    ...

@staticmethod
def tag_exists(
    tag: str,
) -> bool:
    """
    Checks if the given type is already registered.
    """
    ...

@staticmethod
def tag_get_description(
    tag: str,
) -> str:
    """
    Returns the human-readable description of this tag, You must not change or
    free this string.
    """
    ...

@staticmethod
def tag_get_flag(
    tag: str,
) -> TagFlag:
    """
    Gets the flag of @tag.
    """
    ...

@staticmethod
def tag_get_nick(
    tag: str,
) -> str:
    """
    Returns the human-readable name of this tag, You must not change or free
    this string.
    """
    ...

@staticmethod
def tag_get_type(
    tag: str,
) -> GObject.GType:
    """
    Gets the #GType used for this tag.
    """
    ...

@staticmethod
def tag_is_fixed(
    tag: str,
) -> bool:
    """
    Checks if the given tag is fixed. A fixed tag can only contain one value.
    Unfixed tags can contain lists of values.
    """
    ...

@staticmethod
def tag_list_copy_value(
    list: TagList,
    tag: str,
) -> tuple[bool, GObject.Value]:
    """
    Copies the contents for the given tag into the value,
    merging multiple values into one if multiple values are associated
    with the tag.
    You must g_value_unset() the value after use.
    """
    ...

@staticmethod
def tag_merge_strings_with_comma(
    src: GObject.Value,
) -> GObject.Value:
    """
    This is a convenience function for the func argument of gst_tag_register().
    It concatenates all given strings using a comma. The tag must be registered
    as a G_TYPE_STRING or this function will fail.
    """
    ...

@staticmethod
def tag_merge_use_first(
    src: GObject.Value,
) -> GObject.Value:
    """
    This is a convenience function for the func argument of gst_tag_register().
    It creates a copy of the first value from the list.
    """
    ...

@staticmethod
def toc_entry_type_get_nick(
    type: TocEntryType,
) -> str:
    """
    Converts @type to a string representation.
    """
    ...

@staticmethod
def tracing_get_active_tracers() -> list:
    """
    Get a list of all active tracer objects owned by the tracing framework for
    the entirety of the run-time of the process or till gst_deinit() is called.
    """
    ...

@staticmethod
def tracing_register_hook(
    tracer: Tracer,
    detail: str,
    func: GObject.Callback,  # type: ignore
) -> None:
    """
    Register @func to be called when the trace hook @detail is getting invoked.
    Use %NULL for @detail to register to all hooks.
    """
    ...

@staticmethod
def type_find_register(
    plugin: Plugin | None,
    name: str,
    rank: int,
    func: TypeFindFunction,
    extensions: str | None,
    possible_caps: Caps | None,
    data: object | None,
    data_notify: GLib.DestroyNotify,  # type: ignore
) -> bool:
    """
    Registers a new typefind function to be used for typefinding. After
    registering this function will be available for typefinding.
    This function is typically called during an element's plugin initialization.
    """
    ...

@staticmethod
def type_is_plugin_api(
    type: GObject.GType,
) -> tuple[bool, PluginAPIFlags | None]:
    """
    Checks if @type is plugin API. See gst_type_mark_as_plugin_api() for
    details.
    """
    ...

@staticmethod
def type_mark_as_plugin_api(
    type: GObject.GType,
    flags: PluginAPIFlags,
) -> None:
    """
    Marks @type as plugin API. This should be called in `class_init` of
    elements that expose new types (i.e. enums, flags or internal GObjects) via
    properties, signals or pad templates.

    Types exposed by plugins are not automatically added to the documentation
    as they might originate from another library and should in that case be
    documented via that library instead.

    By marking a type as plugin API it will be included in the documentation of
    the plugin that defines it.
    """
    ...

@staticmethod
def update_registry() -> bool:
    """
    Forces GStreamer to re-scan its plugin paths and update the default
    plugin registry.

    Applications will almost never need to call this function, it is only
    useful if the application knows new plugins have been installed (or old
    ones removed) since the start of the application (or, to be precise, the
    first call to gst_init()) and the application wants to make use of any
    newly-installed plugins without restarting the application.

    Applications should assume that the registry update is neither atomic nor
    thread-safe and should therefore not have any dynamic pipelines running
    (including the playbin and decodebin elements) and should also not create
    any elements or access the GStreamer registry while the update is in
    progress.

    Note that this function may block for a significant amount of time.
    """
    ...

@deprecated("deprecated")
@staticmethod
def uri_construct(
    protocol: str,
    location: str,
) -> str:
    """
    Constructs a URI for a given valid protocol and location.

    Free-function: g_free
    """
    ...

@staticmethod
def uri_error_quark() -> int: ...
@staticmethod
def uri_from_string(
    uri: str,
) -> Uri | None:
    """
    Parses a URI string into a new #GstUri object. Will return NULL if the URI
    cannot be parsed.
    """
    ...

@staticmethod
def uri_from_string_escaped(
    uri: str,
) -> Uri | None:
    """
    Parses a URI string into a new #GstUri object. Will return NULL if the URI
    cannot be parsed. This is identical to gst_uri_from_string() except that
    the userinfo and fragment components of the URI will not be unescaped while
    parsing.

    Use this when you need to extract a username and password from the userinfo
    such as https://user:password@example.com since either may contain
    a URI-escaped ':' character. gst_uri_from_string() will unescape the entire
    userinfo component, which will make it impossible to know which ':'
    delineates the username and password.

    The same applies to the fragment component of the URI, such as
    https://example.com/path#fragment which may contain a URI-escaped '#'.
    """
    ...

@staticmethod
def uri_get_location(
    uri: str,
) -> str | None:
    """
    Extracts the location out of a given valid URI, ie. the protocol and "://"
    are stripped from the URI, which means that the location returned includes
    the hostname if one is specified. The returned string must be freed using
    g_free().

    Free-function: g_free
    """
    ...

@staticmethod
def uri_get_protocol(
    uri: str,
) -> str | None:
    """
    Extracts the protocol out of a given valid URI. The returned string must be
    freed using g_free().
    """
    ...

@staticmethod
def uri_has_protocol(
    uri: str,
    protocol: str,
) -> bool:
    """
    Checks if the protocol of a given valid URI matches @protocol.
    """
    ...

@staticmethod
def uri_is_valid(
    uri: str,
) -> bool:
    """
    Tests if the given string is a valid URI identifier. URIs start with a valid
    scheme followed by ":" and maybe a string identifying the location.
    """
    ...

@staticmethod
def uri_join_strings(
    base_uri: str,
    ref_uri: str,
) -> str | None:
    """
    This is a convenience function to join two URI strings and return the result.
    The returned string should be g_free()'d after use.
    """
    ...

@staticmethod
def uri_protocol_is_supported(
    type: URIType,
    protocol: str,
) -> bool:
    """
    Checks if an element exists that supports the given URI protocol. Note
    that a positive return value does not imply that a subsequent call to
    gst_element_make_from_uri() is guaranteed to work.
    """
    ...

@staticmethod
def uri_protocol_is_valid(
    protocol: str,
) -> bool:
    """
    Tests if the given string is a valid protocol identifier. Protocols
    must consist of alphanumeric characters, '+', '-' and '.' and must
    start with a alphabetic character. See RFC 3986 Section 3.1.
    """
    ...

@staticmethod
def util_array_binary_search(
    array: object | None,
    num_elements: int,
    element_size: int,
    search_func: GLib.CompareDataFunc,  # type: ignore
    mode: SearchMode,
    search_data: object | None = None,
    user_data: object | None = None,
) -> object | None:
    """
    Searches inside @array for @search_data by using the comparison function
    @search_func. @array must be sorted ascending.

    As @search_data is always passed as second argument to @search_func it's
    not required that @search_data has the same type as the array elements.

    The complexity of this search function is O(log (num_elements)).
    """
    ...

@staticmethod
def util_ceil_log2(
    v: int,
) -> int:
    """
    Returns smallest integral value not less than log2(v).
    """
    ...

@staticmethod
def util_double_to_fraction(
    src: float,
) -> tuple[int, int]:
    """
    Transforms a #gdouble to a fraction and simplifies
    the result.
    """
    ...

@staticmethod
def util_dump_buffer(
    buf: Buffer,
) -> None:
    """
    Dumps the buffer memory into a hex representation. Useful for debugging.
    """
    ...

@staticmethod
def util_dump_mem(
    mem: list,
    size: int,
) -> None:
    """
    Dumps the memory block into a hex representation. Useful for debugging.
    """
    ...

@staticmethod
def util_filename_compare(
    a: str,
    b: str,
) -> int:
    """
    Compares the given filenames using natural ordering.
    """
    ...

@staticmethod
def util_floor_log2(
    v: int,
) -> int:
    """
    Returns smallest integral value not bigger than log2(v).
    """
    ...

@staticmethod
def util_fraction_add(
    a_n: int,
    a_d: int,
    b_n: int,
    b_d: int,
) -> tuple[bool, int, int]:
    """
    Adds the fractions @a_n/@a_d and @b_n/@b_d and stores
    the result in @res_n and @res_d.
    """
    ...

@staticmethod
def util_fraction_compare(
    a_n: int,
    a_d: int,
    b_n: int,
    b_d: int,
) -> int:
    """
    Compares the fractions @a_n/@a_d and @b_n/@b_d and returns
    -1 if a < b, 0 if a = b and 1 if a > b.
    """
    ...

@staticmethod
def util_fraction_multiply(
    a_n: int,
    a_d: int,
    b_n: int,
    b_d: int,
) -> tuple[bool, int, int]:
    """
    Multiplies the fractions @a_n/@a_d and @b_n/@b_d and stores
    the result in @res_n and @res_d.
    """
    ...

@staticmethod
def util_fraction_multiply_int64(
    a_n: int,
    a_d: int,
    b_n: int,
    b_d: int,
) -> tuple[bool, int, int]:
    """
    Multiplies the fractions @a_n/@a_d and @b_n/@b_d and stores
    the result in @res_n and @res_d.
    """
    ...

@staticmethod
def util_fraction_to_double(
    src_n: int,
    src_d: int,
) -> float:
    """
    Transforms a fraction to a #gdouble.
    """
    ...

@staticmethod
def util_gdouble_to_guint64(
    value: float,
) -> int: ...
@staticmethod
def util_get_object_array(
    object: GObject.Object,
    name: str,
) -> tuple[bool, GObject.ValueArray]:
    """
    Get a property of type %GST_TYPE_ARRAY and transform it into a
    #GValueArray. This allow language bindings to get GST_TYPE_ARRAY
    properties which are otherwise not an accessible type.
    """
    ...

@staticmethod
def util_get_timestamp() -> int:
    """
    Get a timestamp as GstClockTime to be used for interval measurements.
    The timestamp should not be interpreted in any other way.
    """
    ...

@staticmethod
def util_greatest_common_divisor(
    a: int,
    b: int,
) -> int:
    """
    Calculates the greatest common divisor of @a
    and @b.
    """
    ...

@staticmethod
def util_greatest_common_divisor_int64(
    a: int,
    b: int,
) -> int:
    """
    Calculates the greatest common divisor of @a
    and @b.
    """
    ...

@staticmethod
def util_group_id_next() -> int:
    """
    Return a constantly incrementing group id.

    This function is used to generate a new group-id for the
    stream-start event.

    This function never returns %GST_GROUP_ID_INVALID (which is 0)
    """
    ...

@staticmethod
def util_guint64_to_gdouble(
    value: int,
) -> float: ...
@staticmethod
def util_seqnum_compare(
    s1: int,
    s2: int,
) -> int:
    """
    Compare two sequence numbers, handling wraparound.

    The current implementation just returns (gint32)(@s1 - @s2).
    """
    ...

@staticmethod
def util_seqnum_next() -> int:
    """
    Return a constantly incrementing sequence number.

    This function is used internally to GStreamer to be able to determine which
    events and messages are "the same". For example, elements may set the seqnum
    on a segment-done message to be the same as that of the last seek event, to
    indicate that event and the message correspond to the same segment.

    This function never returns %GST_SEQNUM_INVALID (which is 0).
    """
    ...

@staticmethod
def util_set_object_arg(
    object: GObject.Object,
    name: str,
    value: str,
) -> None:
    """
    Converts the string value to the type of the objects argument and
    sets the argument with it.

    Note that this function silently returns if @object has no property named
    @name or when @value cannot be converted to the type of the property.
    """
    ...

@staticmethod
def util_set_object_array(
    object: GObject.Object,
    name: str,
    array: GObject.ValueArray,
) -> bool:
    """
    Transfer a #GValueArray to %GST_TYPE_ARRAY and set this value on the
    specified property name. This allow language bindings to set GST_TYPE_ARRAY
    properties which are otherwise not an accessible type.
    """
    ...

@staticmethod
def util_set_value_from_string(
    value_str: str,
) -> GObject.Value:
    """
    Converts the string to the type of the value and
    sets the value with it.

    Note that this function is dangerous as it does not return any indication
    if the conversion worked or not.
    """
    ...

@staticmethod
def util_simplify_fraction(
    numerator: int,
    denominator: int,
    n_terms: int,
    threshold: int,
) -> None:
    """
    Calculates the simpler representation of @numerator and @denominator and
    update both values with the resulting simplified fraction.

    Simplify a fraction using a simple continued fraction decomposition.
    The idea here is to convert fractions such as 333333/10000000 to 1/30
    using 32 bit arithmetic only. The algorithm is not perfect and relies
    upon two arbitrary parameters to remove non-significative terms from
    the simple continued fraction decomposition. Using 8 and 333 for
    @n_terms and @threshold respectively seems to give nice results.
    """
    ...

@staticmethod
def util_uint64_scale(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale @val by the rational number @num / @denom, avoiding overflows and
    underflows and without loss of precision.

    This function can potentially be very slow if val and num are both
    greater than G_MAXUINT32.
    """
    ...

@staticmethod
def util_uint64_scale_ceil(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale @val by the rational number @num / @denom, avoiding overflows and
    underflows and without loss of precision.

    This function can potentially be very slow if val and num are both
    greater than G_MAXUINT32.
    """
    ...

@staticmethod
def util_uint64_scale_int(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale @val by the rational number @num / @denom, avoiding overflows and
    underflows and without loss of precision.  @num must be non-negative and
    @denom must be positive.
    """
    ...

@staticmethod
def util_uint64_scale_int_ceil(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale @val by the rational number @num / @denom, avoiding overflows and
    underflows and without loss of precision.  @num must be non-negative and
    @denom must be positive.
    """
    ...

@staticmethod
def util_uint64_scale_int_round(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale @val by the rational number @num / @denom, avoiding overflows and
    underflows and without loss of precision.  @num must be non-negative and
    @denom must be positive.
    """
    ...

@staticmethod
def util_uint64_scale_round(
    val: int,
    num: int,
    denom: int,
) -> int:
    """
    Scale @val by the rational number @num / @denom, avoiding overflows and
    underflows and without loss of precision.

    This function can potentially be very slow if val and num are both
    greater than G_MAXUINT32.
    """
    ...

@staticmethod
def value_can_compare(
    value1: GObject.Value,
    value2: GObject.Value,
) -> bool:
    """
    Determines if @value1 and @value2 can be compared.
    """
    ...

@staticmethod
def value_can_intersect(
    value1: GObject.Value,
    value2: GObject.Value,
) -> bool:
    """
    Determines if intersecting two values will produce a valid result.
    Two values will produce a valid intersection if they have the same
    type.
    """
    ...

@staticmethod
def value_can_subtract(
    minuend: GObject.Value,
    subtrahend: GObject.Value,
) -> bool:
    """
    Checks if it's possible to subtract @subtrahend from @minuend.
    """
    ...

@staticmethod
def value_can_union(
    value1: GObject.Value,
    value2: GObject.Value,
) -> bool:
    """
    Determines if @value1 and @value2 can be non-trivially unioned.
    Any two values can be trivially unioned by adding both of them
    to a GstValueList.  However, certain types have the possibility
    to be unioned in a simpler way.  For example, an integer range
    and an integer can be unioned if the integer is a subset of the
    integer range.  If there is the possibility that two values can
    be unioned, this function returns %TRUE.
    """
    ...

@staticmethod
def value_compare(
    value1: GObject.Value,
    value2: GObject.Value,
) -> int:
    """
    Compares @value1 and @value2.  If @value1 and @value2 cannot be
    compared, the function returns GST_VALUE_UNORDERED.  Otherwise,
    if @value1 is greater than @value2, GST_VALUE_GREATER_THAN is returned.
    If @value1 is less than @value2, GST_VALUE_LESS_THAN is returned.
    If the values are equal, GST_VALUE_EQUAL is returned.
    """
    ...

@staticmethod
def value_deserialize(
    src: str,
) -> tuple[bool, GObject.Value]:
    """
    Tries to deserialize a string into the type specified by the given GValue.
    If the operation succeeds, %TRUE is returned, %FALSE otherwise.
    """
    ...

@staticmethod
def value_deserialize_with_pspec(
    src: str,
    pspec: GObject.ParamSpec | None = None,
) -> tuple[bool, GObject.Value]:
    """
    Tries to deserialize a string into the type specified by the given GValue.
    @pspec may be used to guide the deserializing of nested members.
    If the operation succeeds, %TRUE is returned, %FALSE otherwise.
    """
    ...

@staticmethod
def value_fixate(
    dest: GObject.Value,
    src: GObject.Value,
) -> bool:
    """
    Fixate @src into a new value @dest.
    For ranges, the first element is taken. For lists and arrays, the
    first item is fixated and returned.
    If @src is already fixed, this function returns %FALSE.
    """
    ...

@staticmethod
def value_fraction_multiply(
    product: GObject.Value,
    factor1: GObject.Value,
    factor2: GObject.Value,
) -> bool:
    """
    Multiplies the two #GValue items containing a #GST_TYPE_FRACTION and sets
    @product to the product of the two fractions.
    """
    ...

@staticmethod
def value_fraction_subtract(
    dest: GObject.Value,
    minuend: GObject.Value,
    subtrahend: GObject.Value,
) -> bool:
    """
    Subtracts the @subtrahend from the @minuend and sets @dest to the result.
    """
    ...

@staticmethod
def value_get_bitmask(
    value: GObject.Value,
) -> int:
    """
    Gets the bitmask specified by @value.
    """
    ...

@staticmethod
def value_get_caps(
    value: GObject.Value,
) -> Caps:
    """
    Gets the contents of @value. The reference count of the returned
    #GstCaps will not be modified, therefore the caller must take one
    before getting rid of the @value.
    """
    ...

@staticmethod
def value_get_caps_features(
    value: GObject.Value,
) -> CapsFeatures:
    """
    Gets the contents of @value.
    """
    ...

@staticmethod
def value_get_double_range_max(
    value: GObject.Value,
) -> float:
    """
    Gets the maximum of the range specified by @value.
    """
    ...

@staticmethod
def value_get_double_range_min(
    value: GObject.Value,
) -> float:
    """
    Gets the minimum of the range specified by @value.
    """
    ...

@staticmethod
def value_get_flagset_flags(
    value: GObject.Value,
) -> int:
    """
    Retrieve the flags field of a GstFlagSet @value.
    """
    ...

@staticmethod
def value_get_flagset_mask(
    value: GObject.Value,
) -> int:
    """
    Retrieve the mask field of a GstFlagSet @value.
    """
    ...

@staticmethod
def value_get_fraction_denominator(
    value: GObject.Value,
) -> int:
    """
    Gets the denominator of the fraction specified by @value.
    """
    ...

@staticmethod
def value_get_fraction_numerator(
    value: GObject.Value,
) -> int:
    """
    Gets the numerator of the fraction specified by @value.
    """
    ...

@staticmethod
def value_get_fraction_range_max(
    value: GObject.Value,
) -> GObject.Value | None:
    """
    Gets the maximum of the range specified by @value.
    """
    ...

@staticmethod
def value_get_fraction_range_min(
    value: GObject.Value,
) -> GObject.Value | None:
    """
    Gets the minimum of the range specified by @value.
    """
    ...

@staticmethod
def value_get_int64_range_max(
    value: GObject.Value,
) -> int:
    """
    Gets the maximum of the range specified by @value.
    """
    ...

@staticmethod
def value_get_int64_range_min(
    value: GObject.Value,
) -> int:
    """
    Gets the minimum of the range specified by @value.
    """
    ...

@staticmethod
def value_get_int64_range_step(
    value: GObject.Value,
) -> int:
    """
    Gets the step of the range specified by @value.
    """
    ...

@staticmethod
def value_get_int_range_max(
    value: GObject.Value,
) -> int:
    """
    Gets the maximum of the range specified by @value.
    """
    ...

@staticmethod
def value_get_int_range_min(
    value: GObject.Value,
) -> int:
    """
    Gets the minimum of the range specified by @value.
    """
    ...

@staticmethod
def value_get_int_range_step(
    value: GObject.Value,
) -> int:
    """
    Gets the step of the range specified by @value.
    """
    ...

@staticmethod
def value_get_structure(
    value: GObject.Value,
) -> Structure:
    """
    Gets the contents of @value.
    """
    ...

@staticmethod
def value_init_and_copy(
    src: GObject.Value,
) -> GObject.Value:
    """
    Initialises the target value to be of the same type as source and then copies
    the contents from source to target.
    """
    ...

@staticmethod
def value_intersect(
    value1: GObject.Value,
    value2: GObject.Value,
) -> tuple[bool, GObject.Value | None]:
    """
    Calculates the intersection of two values.  If the values have
    a non-empty intersection, the value representing the intersection
    is placed in @dest, unless %NULL.  If the intersection is non-empty,
    @dest is not modified.
    """
    ...

@staticmethod
def value_is_fixed(
    value: GObject.Value,
) -> bool:
    """
    Tests if the given GValue, if available in a GstStructure (or any other
    container) contains a "fixed" (which means: one value) or an "unfixed"
    (which means: multiple possible values, such as data lists or data
    ranges) value.
    """
    ...

@staticmethod
def value_is_subset(
    value1: GObject.Value,
    value2: GObject.Value,
) -> bool:
    """
    Check that @value1 is a subset of @value2.
    """
    ...

@staticmethod
def value_register(
    table: ValueTable,
) -> None:
    """
    Registers functions to perform calculations on #GValue items of a given
    type. Each type can only be added once.
    """
    ...

@staticmethod
def value_serialize(
    value: GObject.Value,
) -> str | None:
    """
    tries to transform the given @value into a string representation that allows
    getting back this string later on using gst_value_deserialize().

    Free-function: g_free
    """
    ...

@staticmethod
def value_set_bitmask(
    value: GObject.Value,
    bitmask: int,
) -> None:
    """
    Sets @value to the bitmask specified by @bitmask.
    """
    ...

@staticmethod
def value_set_caps(
    value: GObject.Value,
    caps: Caps,
) -> None:
    """
    Sets the contents of @value to @caps. A reference to the
    provided @caps will be taken by the @value.
    """
    ...

@staticmethod
def value_set_caps_features(
    value: GObject.Value,
    features: CapsFeatures,
) -> None:
    """
    Sets the contents of @value to @features.
    """
    ...

@staticmethod
def value_set_double_range(
    value: GObject.Value,
    start: float,
    end: float,
) -> None:
    """
    Sets @value to the range specified by @start and @end.
    """
    ...

@staticmethod
def value_set_flagset(
    value: GObject.Value,
    flags: int,
    mask: int,
) -> None:
    """
    Sets @value to the flags and mask values provided in @flags and @mask.
    The @flags value indicates the values of flags, the @mask represents
    which bits in the flag value have been set, and which are "don't care"
    """
    ...

@staticmethod
def value_set_fraction(
    value: GObject.Value,
    numerator: int,
    denominator: int,
) -> None:
    """
    Sets @value to the fraction specified by @numerator over @denominator.
    The fraction gets reduced to the smallest numerator and denominator,
    and if necessary the sign is moved to the numerator.
    """
    ...

@staticmethod
def value_set_fraction_range(
    value: GObject.Value,
    start: GObject.Value,
    end: GObject.Value,
) -> None:
    """
    Sets @value to the range specified by @start and @end.
    """
    ...

@staticmethod
def value_set_fraction_range_full(
    value: GObject.Value,
    numerator_start: int,
    denominator_start: int,
    numerator_end: int,
    denominator_end: int,
) -> None:
    """
    Sets @value to the range specified by @numerator_start/@denominator_start
    and @numerator_end/@denominator_end.
    """
    ...

@staticmethod
def value_set_int64_range(
    value: GObject.Value,
    start: int,
    end: int,
) -> None:
    """
    Sets @value to the range specified by @start and @end.
    """
    ...

@staticmethod
def value_set_int64_range_step(
    value: GObject.Value,
    start: int,
    end: int,
    step: int,
) -> None:
    """
    Sets @value to the range specified by @start, @end and @step.
    """
    ...

@staticmethod
def value_set_int_range(
    value: GObject.Value,
    start: int,
    end: int,
) -> None:
    """
    Sets @value to the range specified by @start and @end.
    """
    ...

@staticmethod
def value_set_int_range_step(
    value: GObject.Value,
    start: int,
    end: int,
    step: int,
) -> None:
    """
    Sets @value to the range specified by @start, @end and @step.
    """
    ...

@staticmethod
def value_set_structure(
    value: GObject.Value,
    structure: Structure,
) -> None:
    """
    Sets the contents of @value to @structure.
    """
    ...

@staticmethod
def value_subtract(
    minuend: GObject.Value,
    subtrahend: GObject.Value,
) -> tuple[bool, GObject.Value | None]:
    """
    Subtracts @subtrahend from @minuend and stores the result in @dest.
    Note that this means subtraction as in sets, not as in mathematics.
    """
    ...

@staticmethod
def value_union(
    value1: GObject.Value,
    value2: GObject.Value,
) -> tuple[bool, GObject.Value]:
    """
    Creates a GValue corresponding to the union of @value1 and @value2.
    """
    ...

@staticmethod
def version() -> tuple[int, int, int, int]:
    """
    Gets the version number of the GStreamer library.
    """
    ...

@staticmethod
def version_string() -> str:
    """
    This function returns a string that is useful for describing this version
    of GStreamer to the outside world: user agent strings, logging, ...
    """
    ...

###############################################################
# Enums/Flags
###############################################################

class AllocatorFlags(GObject.GFlags):
    """
    Flags for allocators."""

    CUSTOM_ALLOC = 16
    """
    The allocator has a custom alloc function.
       Only elements designed to work with this allocator should be using it,
       other elements should ignore it from allocation propositions.
       This implies %GST_ALLOCATOR_FLAG_NO_COPY.
    """
    NO_COPY = 32
    """
    When copying a #GstMemory allocated with this allocator, the copy will
    instead be allocated using the default allocator. Use this when allocating a
    new memory is an heavy opperation that should only be done with a
    #GstBufferPool for example.
    """
    LAST = 1048576
    """
    first flag that can be used for custom purposes
    """

class BinFlags(GObject.GFlags):
    """
    GstBinFlags are a set of flags specific to bins. Most are set/used
    internally. They can be checked using the GST_OBJECT_FLAG_IS_SET() macro,
    and (un)set using GST_OBJECT_FLAG_SET() and GST_OBJECT_FLAG_UNSET()."""

    NO_RESYNC = 16384
    """
    Don't resync a state change when elements are added or linked in the bin
    """
    STREAMS_AWARE = 32768
    """
    Indicates whether the bin can handle elements that add/remove source pads
    at any point in time without first posting a no-more-pads signal.
    """
    LAST = 524288
    """
    The last enum in the series of flags for bins. Derived classes can use this
    as first value in a list of flags.
    """

class BufferCopyFlags(GObject.GFlags):
    """
    A set of flags that can be provided to the gst_buffer_copy_into()
    function to specify which items should be copied."""

    NONE = 0
    """
    copy nothing
    """
    FLAGS = 1
    """
    flag indicating that buffer flags should be copied
    """
    TIMESTAMPS = 2
    """
    flag indicating that buffer pts, dts,
      duration, offset and offset_end should be copied
    """
    META = 4
    """
    flag indicating that buffer meta should be
      copied
    """
    MEMORY = 8
    """
    flag indicating that buffer memory should be reffed
      and appended to already existing memory. Unless the memory is marked as
      NO_SHARE, no actual copy of the memory is made but it is simply reffed.
      Add @GST_BUFFER_COPY_DEEP to force a real copy.
    """
    MERGE = 16
    """
    flag indicating that buffer memory should be
      merged
    """
    DEEP = 32
    """
    flag indicating that memory should always be copied instead of reffed
    """

class BufferFlags(GObject.GFlags):
    """
    A set of buffer flags used to describe properties of a #GstBuffer."""

    LIVE = 16
    """
    the buffer is live data and should be discarded in
                                    the PAUSED state.
    """
    DECODE_ONLY = 32
    """
    the buffer contains data that should be dropped
                                    because it will be clipped against the segment
                                    boundaries or because it does not contain data
                                    that should be shown to the user.
    """
    DISCONT = 64
    """
    the buffer marks a data discontinuity in the stream.
                                    This typically occurs after a seek or a dropped buffer
                                    from a live or network source.
    """
    RESYNC = 128
    """
    the buffer timestamps might have a discontinuity
                                    and this buffer is a good point to resynchronize.
    """
    CORRUPTED = 256
    """
    the buffer data is corrupted.
    """
    MARKER = 512
    """
    the buffer contains a media specific marker. for
                                    video this is the end of a frame boundary, for audio
                                    this is the start of a talkspurt. for RTP
                                    packets this matches the marker flag in the
                                    RTP packet header.
    """
    HEADER = 1024
    """
    the buffer contains header information that is
                                    needed to decode the following data.
    """
    GAP = 2048
    """
    the buffer has been created to fill a gap in the
                                    stream and contains media neutral data (elements can
                                    switch to optimized code path that ignores the buffer
                                    content).
    """
    DROPPABLE = 4096
    """
    the buffer can be dropped without breaking the
                                    stream, for example to reduce bandwidth.
    """
    DELTA_UNIT = 8192
    """
    this unit cannot be decoded independently.
    """
    TAG_MEMORY = 16384
    """
    this flag is set when memory of the buffer
                                    is added/removed
    """
    SYNC_AFTER = 32768
    """
    Elements which write to disk or permanent storage should ensure the data
    is synced after writing the contents of this buffer.
    """
    NON_DROPPABLE = 65536
    """
    This buffer is important and should not be dropped.
    
    This can be used to mark important buffers, e.g. to flag RTP packets
    carrying keyframes or codec setup data for RTP Forward Error Correction
    purposes, or to prevent still video frames from being dropped by elements
    due to QoS.
    """
    LAST = 1048576
    """
    additional media specific flags can be added starting from
                                    this flag.
    """

class BufferPoolAcquireFlags(GObject.GFlags):
    """
    Additional flags to control the allocation of a buffer"""

    NONE = 0
    """
    no flags
    """
    KEY_UNIT = 1
    """
    buffer is keyframe
    """
    DONTWAIT = 2
    """
    when the bufferpool is empty, acquire_buffer
    will by default block until a buffer is released into the pool again. Setting
    this flag makes acquire_buffer return #GST_FLOW_EOS instead of blocking.
    """
    DISCONT = 4
    """
    buffer is discont
    """
    LAST = 65536
    """
    last flag, subclasses can use private flags
       starting from this value.
    """

class BufferingMode(GObject.GEnum):
    """
    The different types of buffering methods."""

    STREAM = 0
    """
    a small amount of data is buffered
    """
    DOWNLOAD = 1
    """
    the stream is being downloaded
    """
    TIMESHIFT = 2
    """
    the stream is being downloaded in a ringbuffer
    """
    LIVE = 3
    """
    the stream is a live stream
    """

class BusFlags(GObject.GFlags):
    """
    The standard flags that a bus may have."""

    FLUSHING = 16
    """
    The bus is currently dropping all messages
    """
    FLAG_LAST = 32
    """
    offset to define more flags
    """

class BusSyncReply(GObject.GEnum):
    """
    The result values for a GstBusSyncHandler."""

    DROP = 0
    """
    drop the message
    """
    PASS = 1
    ASYNC = 2

class CapsFlags(GObject.GFlags):
    """
    Extra flags for a caps."""

    ANY = 16
    """
    Caps has no specific content, but can contain
       anything.
    """

class CapsIntersectMode(GObject.GEnum):
    """
    Modes of caps intersection

    %GST_CAPS_INTERSECT_ZIG_ZAG tries to preserve overall order of both caps
    by iterating on the caps' structures as the following matrix shows:

    ```
             caps1
          +-------------
          | 1  2  4  7
    caps2 | 3  5  8 10
          | 6  9 11 12
    ```

    Used when there is no explicit precedence of one caps over the other. e.g.
    tee's sink pad getcaps function, it will probe its src pad peers' for their
    caps and intersect them with this mode.

    %GST_CAPS_INTERSECT_FIRST is useful when an element wants to preserve
    another element's caps priority order when intersecting with its own caps.
    Example: If caps1 is `[A, B, C]` and caps2 is `[E, B, D, A]`, the result
    would be `[A, B]`, maintaining the first caps priority on the intersection."""

    ZIG_ZAG = 0
    """
    Zig-zags over both caps.
    """
    FIRST = 1
    """
    Keeps the first caps order.
    """

class ClockEntryType(GObject.GEnum):
    """
    The type of the clock entry"""

    SINGLE = 0
    """
    a single shot timeout
    """
    PERIODIC = 1
    """
    a periodic timeout request
    """

class ClockFlags(GObject.GFlags):
    """
    The capabilities of this clock"""

    CAN_DO_SINGLE_SYNC = 16
    """
    clock can do a single sync timeout request
    """
    CAN_DO_SINGLE_ASYNC = 32
    """
    clock can do a single async timeout request
    """
    CAN_DO_PERIODIC_SYNC = 64
    """
    clock can do sync periodic timeout requests
    """
    CAN_DO_PERIODIC_ASYNC = 128
    """
    clock can do async periodic timeout callbacks
    """
    CAN_SET_RESOLUTION = 256
    """
    clock's resolution can be changed
    """
    CAN_SET_MASTER = 512
    """
    clock can be slaved to a master clock
    """
    NEEDS_STARTUP_SYNC = 1024
    """
    clock needs to be synced before it can be used
    """
    LAST = 4096
    """
    subclasses can add additional flags starting from this flag
    """

class ClockReturn(GObject.GEnum):
    """
    The return value of a clock operation."""

    OK = 0
    """
    The operation succeeded.
    """
    EARLY = 1
    """
    The operation was scheduled too late.
    """
    UNSCHEDULED = 2
    """
    The clockID was unscheduled
    """
    BUSY = 3
    """
    The ClockID is busy
    """
    BADTIME = 4
    """
    A bad time was provided to a function.
    """
    ERROR = 5
    """
    An error occurred
    """
    UNSUPPORTED = 6
    """
    Operation is not supported
    """
    DONE = 7
    """
    The ClockID is done waiting
    """

class ClockType(GObject.GEnum):
    """
    The different kind of clocks."""

    REALTIME = 0
    """
    time since Epoch
    """
    MONOTONIC = 1
    """
    monotonic time since some unspecified starting
                               point
    """
    OTHER = 2
    """
    some other time source is used (Since: 1.0.5)
    """
    TAI = 3
    """
    time since Epoch, but using International Atomic Time
                         as reference (Since: 1.18)
    """

class CoreError(GObject.GEnum):
    """
    Core errors are errors inside the core GStreamer library."""

    FAILED = 1
    """
    a general error which doesn't fit in any other
    category.  Make sure you add a custom message to the error call.
    """
    TOO_LAZY = 2
    """
    do not use this except as a placeholder for
    deciding where to go while developing code.
    """
    NOT_IMPLEMENTED = 3
    """
    use this when you do not want to implement
    this functionality yet.
    """
    STATE_CHANGE = 4
    """
    used for state change errors.
    """
    PAD = 5
    """
    used for pad-related errors.
    """
    THREAD = 6
    """
    used for thread-related errors.
    """
    NEGOTIATION = 7
    """
    used for negotiation-related errors.
    """
    EVENT = 8
    """
    used for event-related errors.
    """
    SEEK = 9
    """
    used for seek-related errors.
    """
    CAPS = 10
    """
    used for caps-related errors.
    """
    TAG = 11
    """
    used for negotiation-related errors.
    """
    MISSING_PLUGIN = 12
    """
    used if a plugin is missing.
    """
    CLOCK = 13
    """
    used for clock related errors.
    """
    DISABLED = 14
    """
    used if functionality has been disabled at
                              compile time.
    """
    NUM_ERRORS = 15
    """
    the number of core error types.
    """

class DebugColorFlags(GObject.GFlags):
    """
    These are some terminal style flags you can use when creating your
    debugging categories to make them stand out in debugging output."""

    FG_BLACK = 0
    """
    Use black as foreground color.
    """
    FG_RED = 1
    """
    Use red as foreground color.
    """
    FG_GREEN = 2
    """
    Use green as foreground color.
    """
    FG_YELLOW = 3
    """
    Use yellow as foreground color.
    """
    FG_BLUE = 4
    """
    Use blue as foreground color.
    """
    FG_MAGENTA = 5
    """
    Use magenta as foreground color.
    """
    FG_CYAN = 6
    """
    Use cyan as foreground color.
    """
    FG_WHITE = 7
    """
    Use white as foreground color.
    """
    BG_BLACK = 0
    """
    Use black as background color.
    """
    BG_RED = 16
    """
    Use red as background color.
    """
    BG_GREEN = 32
    """
    Use green as background color.
    """
    BG_YELLOW = 48
    """
    Use yellow as background color.
    """
    BG_BLUE = 64
    """
    Use blue as background color.
    """
    BG_MAGENTA = 80
    """
    Use magenta as background color.
    """
    BG_CYAN = 96
    """
    Use cyan as background color.
    """
    BG_WHITE = 112
    """
    Use white as background color.
    """
    BOLD = 256
    """
    Make the output bold.
    """
    UNDERLINE = 512
    """
    Underline the output.
    """

class DebugColorMode(GObject.GEnum):
    OFF = 0
    """
    Do not use colors in logs.
    """
    ON = 1
    """
    Paint logs in a platform-specific way.
    """
    UNIX = 2
    """
    Paint logs with UNIX terminal color codes
                                no matter what platform GStreamer is running on.
    """

class DebugGraphDetails(GObject.GFlags):
    """
    Available details for pipeline graphs produced by GST_DEBUG_BIN_TO_DOT_FILE()
    and GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS()."""

    MEDIA_TYPE = 1
    """
    show caps-name on edges
    """
    CAPS_DETAILS = 2
    """
    show caps-details on edges
    """
    NON_DEFAULT_PARAMS = 4
    """
    show modified parameters on
                                              elements
    """
    STATES = 8
    """
    show element states
    """
    FULL_PARAMS = 16
    """
    show full element parameter values even
                                       if they are very long
    """
    ALL = 15
    """
    show all the typical details that one might want
    """
    VERBOSE = 4294967295
    """
    show all details regardless of how large or
                                   verbose they make the resulting output
    """

class DebugLevel(GObject.GEnum):
    """
    The level defines the importance of a debugging message. The more important a
    message is, the greater the probability that the debugging system outputs it."""

    NONE = 0
    """
    No debugging level specified or desired. Used to deactivate
     debugging output.
    """
    ERROR = 1
    """
    Error messages are to be used only when an error occurred
     that stops the application from keeping working correctly.
     An examples is gst_element_error, which outputs a message with this priority.
     It does not mean that the application is terminating as with g_error.
    """
    WARNING = 2
    """
    Warning messages are to inform about abnormal behaviour
     that could lead to problems or weird behaviour later on. An example of this
     would be clocking issues ("your computer is pretty slow") or broken input
     data ("Can't synchronize to stream.")
    """
    FIXME = 3
    """
    Fixme messages are messages that indicate that something
     in the executed code path is not fully implemented or handled yet. Note
     that this does not replace proper error handling in any way, the purpose
     of this message is to make it easier to spot incomplete/unfinished pieces
     of code when reading the debug log.
    """
    INFO = 4
    """
    Informational messages should be used to keep the developer
     updated about what is happening.
     Examples where this should be used are when a typefind function has
     successfully determined the type of the stream or when an mp3 plugin detects
     the format to be used. ("This file has mono sound.")
    """
    DEBUG = 5
    """
    Debugging messages should be used when something common
     happens that is not the expected default behavior, or something that's
     useful to know but doesn't happen all the time (ie. per loop iteration or
     buffer processed or event handled).
     An example would be notifications about state changes or receiving/sending
     of events.
    """
    LOG = 6
    """
    Log messages are messages that are very common but might be
     useful to know. As a rule of thumb a pipeline that is running as expected
     should never output anything else but LOG messages whilst processing data.
     Use this log level to log recurring information in chain functions and
     loop functions, for example.
    """
    TRACE = 7
    """
    Tracing-related messages.
     Examples for this are referencing/dereferencing of objects.
    """
    MEMDUMP = 9
    """
    memory dump messages are used to log (small) chunks of
     data as memory dumps in the log. They will be displayed as hexdump with
     ASCII characters.
    """
    COUNT = 10
    """
    The number of defined debugging levels.
    """

class ElementFlags(GObject.GFlags):
    """
    The standard flags that an element may have."""

    LOCKED_STATE = 16
    """
    ignore state changes from parent
    """
    SINK = 32
    """
    the element is a sink
    """
    SOURCE = 64
    """
    the element is a source.
    """
    PROVIDE_CLOCK = 128
    """
    the element can provide a clock
    """
    REQUIRE_CLOCK = 256
    """
    the element requires a clock
    """
    INDEXABLE = 512
    """
    the element can use an index
    """
    LAST = 16384
    """
    offset to define more flags
    """

class EventType(GObject.GEnum):
    """
    #GstEventType lists the standard event types that can be sent in a pipeline.

    The custom event types can be used for private messages between elements
    that can't be expressed using normal
    GStreamer buffer passing semantics. Custom events carry an arbitrary
    #GstStructure.
    Specific custom events are distinguished by the name of the structure."""

    UNKNOWN = 0
    """
    unknown event.
    """
    FLUSH_START = 2563
    """
    Start a flush operation. This event clears all data
                    from the pipeline and unblock all streaming threads.
    """
    FLUSH_STOP = 5127
    """
    Stop a flush operation. This event resets the
                    running-time of the pipeline.
    """
    STREAM_START = 10254
    """
    Event to mark the start of a new stream. Sent before any
                    other serialized event and only sent at the start of a new stream,
                    not after flushing seeks.
    """
    CAPS = 12814
    """
    #GstCaps event. Notify the pad of a new media type.
    """
    SEGMENT = 17934
    """
    A new media segment follows in the dataflow. The
                    segment events contains information for clipping buffers and
                    converting buffer timestamps to running-time and
                    stream-time.
    """
    STREAM_COLLECTION = 19230
    """
    A new #GstStreamCollection is available (Since: 1.10)
    """
    TAG = 20510
    """
    A new set of metadata tags has been found in the stream.
    """
    BUFFERSIZE = 23054
    """
    Notification of buffering requirements. Currently not
                    used yet.
    """
    SINK_MESSAGE = 25630
    """
    An event that sinks turn into a message. Used to
                             send messages that should be emitted in sync with
                             rendering.
    """
    STREAM_GROUP_DONE = 26894
    """
    Indicates that there is no more data for
                    the stream group ID in the message. Sent before EOS
                    in some instances and should be handled mostly the same. (Since: 1.10)
    """
    EOS = 28174
    """
    End-Of-Stream. No more data is to be expected to follow
                    without either a STREAM_START event, or a FLUSH_STOP and a SEGMENT
                    event.
    """
    TOC = 30750
    """
    An event which indicates that a new table of contents (TOC)
                    was found or updated.
    """
    PROTECTION = 33310
    """
    An event which indicates that new or updated
                    encryption information has been found in the stream.
    """
    SEGMENT_DONE = 38406
    """
    Marks the end of a segment playback.
    """
    GAP = 40966
    """
    Marks a gap in the datastream.
    """
    INSTANT_RATE_CHANGE = 46090
    """
    Notify downstream that a playback rate override
                                    should be applied as soon as possible. (Since: 1.18)
    """
    QOS = 48641
    """
    A quality message. Used to indicate to upstream elements
                    that the downstream elements should adjust their processing
                    rate.
    """
    SEEK = 51201
    """
    A request for a new playback position and rate.
    """
    NAVIGATION = 53761
    """
    Navigation events are usually used for communicating
                           user requests, such as mouse or keyboard movements,
                           to upstream elements.
    """
    LATENCY = 56321
    """
    Notification of new latency adjustment. Sinks will use
                        the latency information to adjust their synchronisation.
    """
    STEP = 58881
    """
    A request for stepping through the media. Sinks will usually
                     execute the step operation.
    """
    RECONFIGURE = 61441
    """
    A request for upstream renegotiating caps and reconfiguring.
    """
    TOC_SELECT = 64001
    """
    A request for a new playback position based on TOC
                           entry's UID.
    """
    SELECT_STREAMS = 66561
    """
    A request to select one or more streams (Since: 1.10)
    """
    INSTANT_RATE_SYNC_TIME = 66817
    """
    Sent by the pipeline to notify elements that handle the
                                       instant-rate-change event about the running-time when
                                       the rate multiplier should be applied (or was applied). (Since: 1.18)
    """
    CUSTOM_UPSTREAM = 69121
    """
    Upstream custom event
    """
    CUSTOM_DOWNSTREAM = 71686
    """
    Downstream custom event that travels in the
                           data flow.
    """
    CUSTOM_DOWNSTREAM_OOB = 74242
    """
    Custom out-of-band downstream event.
    """
    CUSTOM_DOWNSTREAM_STICKY = 76830
    """
    Custom sticky downstream event.
    """
    CUSTOM_BOTH = 79367
    """
    Custom upstream or downstream event.
                            In-band when travelling downstream.
    """
    CUSTOM_BOTH_OOB = 81923
    """
    Custom upstream or downstream out-of-band event.
    """

class EventTypeFlags(GObject.GFlags):
    """
    #GstEventTypeFlags indicate the aspects of the different #GstEventType
    values. You can get the type flags of a #GstEventType with the
    gst_event_type_get_flags() function."""

    UPSTREAM = 1
    """
    Set if the event can travel upstream.
    """
    DOWNSTREAM = 2
    """
    Set if the event can travel downstream.
    """
    SERIALIZED = 4
    """
    Set if the event should be serialized with data
                                  flow.
    """
    STICKY = 8
    """
    Set if the event is sticky on the pads.
    """
    STICKY_MULTI = 16
    """
    Multiple sticky events can be on a pad, each
                                  identified by the event name.
    """

class FlowReturn(GObject.GEnum):
    """
    The result of passing data to a pad.

    Note that the custom return values should not be exposed outside of the
    element scope."""

    CUSTOM_SUCCESS_2 = 102
    """
    Pre-defined custom success code.
    """
    CUSTOM_SUCCESS_1 = 101
    """
    Pre-defined custom success code (define your
                                  custom success code to this to avoid compiler
                                  warnings).
    """
    CUSTOM_SUCCESS = 100
    """
    Elements can use values starting from
                                  this (and higher) to define custom success
                                  codes.
    """
    OK = 0
    """
    Data passing was ok.
    """
    NOT_LINKED = -1
    """
    Pad is not linked.
    """
    FLUSHING = -2
    """
    Pad is flushing.
    """
    EOS = -3
    """
    Pad is EOS.
    """
    NOT_NEGOTIATED = -4
    """
    Pad is not negotiated.
    """
    ERROR = -5
    """
    Some (fatal) error occurred. Element generating
                                  this error should post an error message using
                                  GST_ELEMENT_ERROR() with more details.
    """
    NOT_SUPPORTED = -6
    """
    This operation is not supported.
    """
    CUSTOM_ERROR = -100
    """
    Elements can use values starting from
                                  this (and lower) to define custom error codes.
    """
    CUSTOM_ERROR_1 = -101
    """
    Pre-defined custom error code (define your
                                  custom error code to this to avoid compiler
                                  warnings).
    """
    CUSTOM_ERROR_2 = -102
    """
    Pre-defined custom error code.
    """

class Format(GObject.GEnum):
    """
    Standard predefined formats"""

    UNDEFINED = 0
    """
    undefined format
    """
    DEFAULT = 1
    """
    the default format of the pad/element. This can be
       samples for raw audio, frames/fields for raw video (some, but not all,
       elements support this; use @GST_FORMAT_TIME if you don't have a good
       reason to query for samples/frames)
    """
    BYTES = 2
    """
    bytes
    """
    TIME = 3
    """
    time in nanoseconds
    """
    BUFFERS = 4
    """
    buffers (few, if any, elements implement this as of
        May 2009)
    """
    PERCENT = 5
    """
    percentage of stream (few, if any, elements implement
        this as of May 2009)
    """

class GapFlags(GObject.GFlags):
    """
    The different flags that can be set on #GST_EVENT_GAP events. See
    gst_event_set_gap_flags() for details."""

    DATA = 1
    """
    The #GST_EVENT_GAP signals missing data,
       for example because of packet loss.
    """

class IteratorItem(GObject.GEnum):
    """
    The result of a #GstIteratorItemFunction."""

    SKIP = 0
    """
    Skip this item
    """
    PASS = 1
    END = 2
    """
    Stop after this item.
    """

class IteratorResult(GObject.GEnum):
    """
    The result of gst_iterator_next()."""

    DONE = 0
    """
    No more items in the iterator
    """
    OK = 1
    """
    An item was retrieved
    """
    RESYNC = 2
    """
    Datastructure changed while iterating
    """
    ERROR = 3
    """
    An error happened
    """

class LibraryError(GObject.GEnum):
    """
    Library errors are for errors from the library being used by elements
    (initializing, finalizing, settings, ...)"""

    FAILED = 1
    """
    a general error which doesn't fit in any other
    category.  Make sure you add a custom message to the error call.
    """
    TOO_LAZY = 2
    """
    do not use this except as a placeholder for
    deciding where to go while developing code.
    """
    INIT = 3
    """
    used when the library could not be opened.
    """
    SHUTDOWN = 4
    """
    used when the library could not be closed.
    """
    SETTINGS = 5
    """
    used when the library doesn't accept settings.
    """
    ENCODE = 6
    """
    used when the library generated an encoding error.
    """
    NUM_ERRORS = 7
    """
    the number of library error types.
    """

class LockFlags(GObject.GFlags):
    """
    Flags used when locking miniobjects"""

    READ = 1
    """
    lock for read access
    """
    WRITE = 2
    """
    lock for write access
    """
    EXCLUSIVE = 4
    """
    lock for exclusive access
    """
    LAST = 256
    """
    first flag that can be used for custom purposes
    """

class MapFlags(GObject.GFlags):
    """
    Flags used when mapping memory"""

    READ = 1
    """
    map for read access
    """
    WRITE = 2
    """
    map for write access
    """
    FLAG_LAST = 65536
    """
    first flag that can be used for custom purposes
    """

class MemoryFlags(GObject.GFlags):
    """
    Flags for wrapped memory."""

    READONLY = 2
    """
    memory is readonly. It is not allowed to map the
    memory with #GST_MAP_WRITE.
    """
    NO_SHARE = 16
    """
    memory must not be shared. Copies will have to be
    made when this memory needs to be shared between buffers. (DEPRECATED:
    do not use in new code, instead you should create a custom GstAllocator for
    memory pooling instead of relying on the GstBuffer they were originally
    attached to.)
    """
    ZERO_PREFIXED = 32
    """
    the memory prefix is filled with 0 bytes
    """
    ZERO_PADDED = 64
    """
    the memory padding is filled with 0 bytes
    """
    PHYSICALLY_CONTIGUOUS = 128
    """
    the memory is physically
    contiguous. (Since: 1.2)
    """
    NOT_MAPPABLE = 256
    """
    the memory can't be mapped via
    gst_memory_map() without any preconditions. (Since: 1.2)
    """
    LAST = 1048576
    """
    first flag that can be used for custom purposes
    """

class MessageType(GObject.GFlags):
    """
    The different message types that are available."""

    UNKNOWN = 0
    """
    an undefined message
    """
    EOS = 1
    """
    end-of-stream reached in a pipeline. The application will
    only receive this message in the PLAYING state and every time it sets a
    pipeline to PLAYING that is in the EOS state. The application can perform a
    flushing seek in the pipeline, which will undo the EOS state again.
    """
    ERROR = 2
    """
    an error occurred. When the application receives an error
    message it should stop playback of the pipeline and not assume that more
    data will be played. It is possible to specify a redirection url to the error
    messages by setting a `redirect-location` field into the error message, application
    or high level bins might use the information as required.
    """
    WARNING = 4
    """
    a warning occurred.
    """
    INFO = 8
    """
    an info message occurred
    """
    TAG = 16
    """
    a tag was found.
    """
    BUFFERING = 32
    """
    the pipeline is buffering. When the application
    receives a buffering message in the PLAYING state for a non-live pipeline it
    must PAUSE the pipeline until the buffering completes, when the percentage
    field in the message is 100%. For live pipelines, no action must be
    performed and the buffering percentage can be used to inform the user about
    the progress.
    """
    STATE_CHANGED = 64
    """
    a state change happened
    """
    STATE_DIRTY = 128
    """
    an element changed state in a streaming thread.
    This message is deprecated.
    """
    STEP_DONE = 256
    """
    a stepping operation finished.
    """
    CLOCK_PROVIDE = 512
    """
    an element notifies its capability of providing
                                a clock. This message is used internally and
                                never forwarded to the application.
    """
    CLOCK_LOST = 1024
    """
    The current clock as selected by the pipeline became
                             unusable. The pipeline will select a new clock on
                             the next PLAYING state change. The application
                             should set the pipeline to PAUSED and back to
                             PLAYING when this message is received.
    """
    NEW_CLOCK = 2048
    """
    a new clock was selected in the pipeline.
    """
    STRUCTURE_CHANGE = 4096
    """
    the structure of the pipeline changed. This
    message is used internally and never forwarded to the application.
    """
    STREAM_STATUS = 8192
    """
    status about a stream, emitted when it starts,
                                stops, errors, etc..
    """
    APPLICATION = 16384
    """
    message posted by the application, possibly
                              via an application-specific element.
    """
    ELEMENT = 32768
    """
    element-specific message, see the specific element's
                          documentation
    """
    SEGMENT_START = 65536
    """
    pipeline started playback of a segment. This
    message is used internally and never forwarded to the application.
    """
    SEGMENT_DONE = 131072
    """
    pipeline completed playback of a segment. This
    message is forwarded to the application after all elements that posted
    @GST_MESSAGE_SEGMENT_START posted a GST_MESSAGE_SEGMENT_DONE message.
    """
    DURATION_CHANGED = 262144
    """
    The duration of a pipeline changed. The
    application can get the new duration with a duration query.
    """
    LATENCY = 524288
    """
    Posted by elements when their latency changes. The
    application should recalculate and distribute a new latency.
    """
    ASYNC_START = 1048576
    """
    Posted by elements when they start an ASYNC
    #GstStateChange. This message is not forwarded to the application but is used
    internally.
    """
    ASYNC_DONE = 2097152
    """
    Posted by elements when they complete an ASYNC
    #GstStateChange. The application will only receive this message from the toplevel
    pipeline.
    """
    REQUEST_STATE = 4194304
    """
    Posted by elements when they want the pipeline to
    change state. This message is a suggestion to the application which can
    decide to perform the state change on (part of) the pipeline.
    """
    STEP_START = 8388608
    """
    A stepping operation was started.
    """
    QOS = 16777216
    """
    A buffer was dropped or an element changed its processing
    strategy for Quality of Service reasons.
    """
    PROGRESS = 33554432
    """
    A progress message.
    """
    TOC = 67108864
    """
    A new table of contents (TOC) was found or previously found TOC
    was updated.
    """
    RESET_TIME = 134217728
    """
    Message to request resetting the pipeline's
        running time from the pipeline. This is an internal message which
        applications will likely never receive.
    """
    STREAM_START = 268435456
    """
    Message indicating start of a new stream. Useful
        e.g. when using playbin in gapless playback mode, to get notified when
        the next title actually starts playing (which will be some time after
        the URI for the next title has been set).
    """
    NEED_CONTEXT = 536870912
    """
    Message indicating that an element wants a specific context (Since: 1.2)
    """
    HAVE_CONTEXT = 1073741824
    """
    Message indicating that an element created a context (Since: 1.2)
    """
    EXTENDED = 2147483648
    """
    Message is an extended message type (see below).
        These extended message IDs can't be used directly with mask-based API
        like gst_bus_poll() or gst_bus_timed_pop_filtered(), but you can still
        filter for GST_MESSAGE_EXTENDED and then check the result for the
        specific type. (Since: 1.4)
    """
    DEVICE_ADDED = 2147483649
    """
    Message indicating a #GstDevice was added to
        a #GstDeviceProvider (Since: 1.4)
    """
    DEVICE_REMOVED = 2147483650
    """
    Message indicating a #GstDevice was removed
        from a #GstDeviceProvider (Since: 1.4)
    """
    PROPERTY_NOTIFY = 2147483651
    """
    Message indicating a #GObject property has
        changed (Since: 1.10)
    """
    STREAM_COLLECTION = 2147483652
    """
    Message indicating a new #GstStreamCollection
        is available (Since: 1.10)
    """
    STREAMS_SELECTED = 2147483653
    """
    Message indicating the active selection of
        #GstStreams has changed (Since: 1.10)
    """
    REDIRECT = 2147483654
    """
    Message indicating to request the application to
        try to play the given URL(s). Useful if for example a HTTP 302/303
        response is received with a non-HTTP URL inside. (Since: 1.10)
    """
    DEVICE_CHANGED = 2147483655
    """
    Message indicating a #GstDevice was changed
        a #GstDeviceProvider (Since: 1.16)
    """
    INSTANT_RATE_REQUEST = 2147483656
    """
    Message sent by elements to request the
        running time from the pipeline when an instant rate change should
        be applied (which may be in the past when the answer arrives). (Since: 1.18)
    """
    ANY = 4294967295
    """
    mask for all of the above messages.
    """

class MetaFlags(GObject.GFlags):
    """
    Extra metadata flags."""

    NONE = 0
    """
    no flags
    """
    READONLY = 1
    """
    metadata should not be modified
    """
    POOLED = 2
    """
    metadata is managed by a bufferpool
    """
    LOCKED = 4
    """
    metadata should not be removed
    """
    LAST = 65536
    """
    additional flags can be added starting from this flag.
    """

class MiniObjectFlags(GObject.GFlags):
    """
    Flags for the mini object"""

    LOCKABLE = 1
    """
    the object can be locked and unlocked with
    gst_mini_object_lock() and gst_mini_object_unlock().
    """
    LOCK_READONLY = 2
    """
    the object is permanently locked in
    READONLY mode. Only read locks can be performed on the object.
    """
    MAY_BE_LEAKED = 4
    """
    the object is expected to stay alive
    even after gst_deinit() has been called and so should be ignored by leak
    detection tools. (Since: 1.10)
    """
    LAST = 16
    """
    first flag that can be used by subclasses.
    """

class ObjectFlags(GObject.GFlags):
    """
    The standard flags that an gstobject may have."""

    MAY_BE_LEAKED = 1
    """
    the object is expected to stay alive even
    after gst_deinit() has been called and so should be ignored by leak
    detection tools. (Since: 1.10)
    """
    CONSTRUCTED = 2
    """
    Flag that's set when the object has been constructed. This can be used by
    API such as base class setters to differentiate between the case where
    they're called from a subclass's instance init function (and where the
    object isn't fully constructed yet, and so one shouldn't do anything but
    set values in the instance structure), and the case where the object is
    constructed.
    """
    LAST = 16
    """
    subclasses can add additional flags starting from this flag
    """

class PadDirection(GObject.GEnum):
    """
    The direction of a pad."""

    UNKNOWN = 0
    """
    direction is unknown.
    """
    SRC = 1
    """
    the pad is a source pad.
    """
    SINK = 2
    """
    the pad is a sink pad.
    """

class PadFlags(GObject.GFlags):
    """
    Pad state flags"""

    BLOCKED = 16
    """
    is dataflow on a pad blocked
    """
    FLUSHING = 32
    """
    is pad flushing
    """
    EOS = 64
    """
    is pad in EOS state
    """
    BLOCKING = 128
    """
    is pad currently blocking on a buffer or event
    """
    NEED_PARENT = 256
    """
    ensure that there is a parent object before calling
                          into the pad callbacks.
    """
    NEED_RECONFIGURE = 512
    """
    the pad should be reconfigured/renegotiated.
                               The flag has to be unset manually after
                               reconfiguration happened.
    """
    PENDING_EVENTS = 1024
    """
    the pad has pending events
    """
    FIXED_CAPS = 2048
    """
    the pad is using fixed caps. This means that
        once the caps are set on the pad, the default caps query function
        will only return those caps.
    """
    PROXY_CAPS = 4096
    """
    the default event and query handler will forward
                         all events and queries to the internally linked pads
                         instead of discarding them.
    """
    PROXY_ALLOCATION = 8192
    """
    the default query handler will forward
                         allocation queries to the internally linked pads
                         instead of discarding them.
    """
    PROXY_SCHEDULING = 16384
    """
    the default query handler will forward
                         scheduling queries to the internally linked pads
                         instead of discarding them.
    """
    ACCEPT_INTERSECT = 32768
    """
    the default accept-caps handler will check
                         it the caps intersect the query-caps result instead
                         of checking for a subset. This is interesting for
                         parsers that can accept incompletely specified caps.
    """
    ACCEPT_TEMPLATE = 65536
    """
    the default accept-caps handler will use
                         the template pad caps instead of query caps to
                         compare with the accept caps. Use this in combination
                         with %GST_PAD_FLAG_ACCEPT_INTERSECT. (Since: 1.6)
    """
    LAST = 1048576
    """
    offset to define more flags
    """

class PadLinkCheck(GObject.GFlags):
    """
    The amount of checking to be done when linking pads. @GST_PAD_LINK_CHECK_CAPS
    and @GST_PAD_LINK_CHECK_TEMPLATE_CAPS are mutually exclusive. If both are
    specified, expensive but safe @GST_PAD_LINK_CHECK_CAPS are performed.

    > Only disable some of the checks if you are 100% certain you know the link
    > will not fail because of hierarchy/caps compatibility failures. If uncertain,
    > use the default checks (%GST_PAD_LINK_CHECK_DEFAULT) or the regular methods
    > for linking the pads."""

    NOTHING = 0
    """
    Don't check hierarchy or caps compatibility.
    """
    HIERARCHY = 1
    """
    Check the pads have same parents/grandparents.
      Could be omitted if it is already known that the two elements that own the
      pads are in the same bin.
    """
    TEMPLATE_CAPS = 2
    """
    Check if the pads are compatible by using
      their template caps. This is much faster than @GST_PAD_LINK_CHECK_CAPS, but
      would be unsafe e.g. if one pad has %GST_CAPS_ANY.
    """
    CAPS = 4
    """
    Check if the pads are compatible by comparing the
      caps returned by gst_pad_query_caps().
    """
    NO_RECONFIGURE = 8
    """
    Disables pushing a reconfigure event when pads are
      linked.
    """
    DEFAULT = 5
    """
    The default checks done when linking
      pads (i.e. the ones used by gst_pad_link()).
    """

class PadLinkReturn(GObject.GEnum):
    """
    Result values from gst_pad_link and friends."""

    OK = 0
    """
    link succeeded
    """
    WRONG_HIERARCHY = -1
    """
    pads have no common grandparent
    """
    WAS_LINKED = -2
    """
    pad was already linked
    """
    WRONG_DIRECTION = -3
    """
    pads have wrong direction
    """
    NOFORMAT = -4
    """
    pads do not have common format
    """
    NOSCHED = -5
    """
    pads cannot cooperate in scheduling
    """
    REFUSED = -6
    """
    refused for some reason
    """

class PadMode(GObject.GEnum):
    """
    The status of a GstPad. After activating a pad, which usually happens when the
    parent element goes from READY to PAUSED, the GstPadMode defines if the
    pad operates in push or pull mode."""

    NONE = 0
    """
    Pad will not handle dataflow
    """
    PUSH = 1
    """
    Pad handles dataflow in downstream push mode
    """
    PULL = 2
    """
    Pad handles dataflow in upstream pull mode
    """

class PadPresence(GObject.GEnum):
    """
    Indicates when this pad will become available."""

    ALWAYS = 0
    """
    the pad is always available
    """
    SOMETIMES = 1
    """
    the pad will become available depending on the media stream
    """
    REQUEST = 2
    """
    the pad is only available on request with
     gst_element_request_pad().
    """

class PadProbeReturn(GObject.GEnum):
    """
    Different return values for the #GstPadProbeCallback."""

    DROP = 0
    """
    drop data in data probes. For push mode this means that
           the data item is not sent downstream. For pull mode, it means that
           the data item is not passed upstream. In both cases, no other probes
           are called for this item and %GST_FLOW_OK or %TRUE is returned to the
           caller.
    """
    OK = 1
    """
    normal probe return value. This leaves the probe in
           place, and defers decisions about dropping or passing data to other
           probes, if any. If there are no other probes, the default behaviour
           for the probe type applies ('block' for blocking probes,
           and 'pass' for non-blocking probes).
    """
    REMOVE = 2
    """
    remove this probe, passing the data. For blocking probes
           this will cause data flow to unblock, unless there are also other
           blocking probes installed.
    """
    PASS = 3
    HANDLED = 4
    """
    Data has been handled in the probe and will not be
           forwarded further. For events and buffers this is the same behaviour as
           %GST_PAD_PROBE_DROP (except that in this case you need to unref the buffer
           or event yourself). For queries it will also return %TRUE to the caller.
           The probe can also modify the #GstFlowReturn value by using the
           #GST_PAD_PROBE_INFO_FLOW_RETURN() accessor.
           Note that the resulting query must contain valid entries.
           Since: 1.6
    """

class PadProbeType(GObject.GFlags):
    """
    The different probing types that can occur. When either one of
    @GST_PAD_PROBE_TYPE_IDLE or @GST_PAD_PROBE_TYPE_BLOCK is used, the probe will be a
    blocking probe."""

    INVALID = 0
    """
    invalid probe type
    """
    IDLE = 1
    """
    probe idle pads and block while the callback is called
    """
    BLOCK = 2
    """
    probe and block pads
    """
    BUFFER = 16
    """
    probe buffers
    """
    BUFFER_LIST = 32
    """
    probe buffer lists
    """
    EVENT_DOWNSTREAM = 64
    """
    probe downstream events
    """
    EVENT_UPSTREAM = 128
    """
    probe upstream events
    """
    EVENT_FLUSH = 256
    """
    probe flush events. This probe has to be
        explicitly enabled and is not included in the
        @@GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM or
        @@GST_PAD_PROBE_TYPE_EVENT_UPSTREAM probe types.
    """
    QUERY_DOWNSTREAM = 512
    """
    probe downstream queries
    """
    QUERY_UPSTREAM = 1024
    """
    probe upstream queries
    """
    PUSH = 4096
    """
    probe push
    """
    PULL = 8192
    """
    probe pull
    """
    BLOCKING = 3
    """
    probe and block at the next opportunity, at data flow or when idle
    """
    DATA_DOWNSTREAM = 112
    """
    probe downstream data (buffers, buffer lists, and events)
    """
    DATA_UPSTREAM = 128
    """
    probe upstream data (events)
    """
    DATA_BOTH = 240
    """
    probe upstream and downstream data (buffers, buffer lists, and events)
    """
    BLOCK_DOWNSTREAM = 114
    """
    probe and block downstream data (buffers, buffer lists, and events)
    """
    BLOCK_UPSTREAM = 130
    """
    probe and block upstream data (events)
    """
    EVENT_BOTH = 192
    """
    probe upstream and downstream events
    """
    QUERY_BOTH = 1536
    """
    probe upstream and downstream queries
    """
    ALL_BOTH = 1776
    """
    probe upstream events and queries and downstream buffers, buffer lists, events and queries
    """
    SCHEDULING = 12288
    """
    probe push and pull
    """

class PadTemplateFlags(GObject.GFlags):
    """
    Flags for the padtemplate"""

    LAST = 256
    """
    first flag that can be used by subclasses.
    """

class ParseError(GObject.GEnum):
    """
    The different parsing errors that can occur."""

    SYNTAX = 0
    """
    A syntax error occurred.
    """
    NO_SUCH_ELEMENT = 1
    """
    The description contained an unknown element
    """
    NO_SUCH_PROPERTY = 2
    """
    An element did not have a specified property
    """
    LINK = 3
    """
    There was an error linking two pads.
    """
    COULD_NOT_SET_PROPERTY = 4
    """
    There was an error setting a property
    """
    EMPTY_BIN = 5
    """
    An empty bin was specified.
    """
    EMPTY = 6
    """
    An empty description was specified
    """
    DELAYED_LINK = 7
    """
    A delayed link did not get resolved.
    """

class ParseFlags(GObject.GFlags):
    """
    Parsing options."""

    NONE = 0
    """
    Do not use any special parsing options.
    """
    FATAL_ERRORS = 1
    """
    Always return %NULL when an error occurs
        (default behaviour is to return partially constructed bins or elements
         in some cases)
    """
    NO_SINGLE_ELEMENT_BINS = 2
    """
    If a bin only has a single element,
        just return the element.
    """
    PLACE_IN_BIN = 4
    """
    If more than one toplevel element is described
        by the pipeline description string, put them in a #GstBin instead of a
        #GstPipeline. (Since: 1.10)
    """

class PipelineFlags(GObject.GFlags):
    """
    Pipeline flags"""

    FIXED_CLOCK = 524288
    """
    this pipeline works with a fixed clock
    """
    LAST = 8388608
    """
    offset to define more flags
    """

class PluginAPIFlags(GObject.GFlags):
    MEMBERS = 1
    """
    Ignore enum members when generating
      the plugins cache. This is useful if the members of the enum are generated
      dynamically, in order not to expose incorrect documentation to the end user.
    """

class PluginDependencyFlags(GObject.GFlags):
    """
    Flags used in connection with gst_plugin_add_dependency()."""

    NONE = 0
    """
    no special flags
    """
    RECURSE = 1
    """
    recurse into subdirectories
    """
    PATHS_ARE_DEFAULT_ONLY = 2
    """
    use paths
            argument only if none of the environment variables is set
    """
    FILE_NAME_IS_SUFFIX = 4
    """
    interpret
            filename argument as filter suffix and check all matching files in
            the directory
    """
    FILE_NAME_IS_PREFIX = 8
    """
    interpret
            filename argument as filter prefix and check all matching files in
            the directory. Since: 1.8.
    """
    PATHS_ARE_RELATIVE_TO_EXE = 16
    """
    interpret
      non-absolute paths as relative to the main executable directory. Since
      1.14.
    """

class PluginError(GObject.GEnum):
    """
    The plugin loading errors"""

    MODULE = 0
    """
    The plugin could not be loaded
    """
    DEPENDENCIES = 1
    """
    The plugin has unresolved dependencies
    """
    NAME_MISMATCH = 2
    """
    The plugin has already be loaded from a different file
    """

class PluginFlags(GObject.GFlags):
    """
    The plugin loading state"""

    CACHED = 16
    """
    Temporarily loaded plugins
    """
    BLACKLISTED = 32
    """
    The plugin won't be scanned (again)
    """

class ProgressType(GObject.GEnum):
    """
    The type of a %GST_MESSAGE_PROGRESS. The progress messages inform the
    application of the status of asynchronous tasks."""

    START = 0
    """
    A new task started.
    """
    CONTINUE = 1
    COMPLETE = 2
    """
    A task completed.
    """
    CANCELED = 3
    """
    A task was canceled.
    """
    ERROR = 4
    """
    A task caused an error. An error message is also
             posted on the bus.
    """

class PromiseResult(GObject.GEnum):
    """
    The result of a #GstPromise"""

    PENDING = 0
    """
    Initial state. Waiting for transition to any
    	other state.
    """
    INTERRUPTED = 1
    """
    Interrupted by the consumer as it doesn't
    	want the value anymore.
    """
    REPLIED = 2
    """
    A producer marked a reply
    """
    EXPIRED = 3
    """
    The promise expired (the carrying object
    	lost all refs) and the promise will never be fulfilled.
    """

class QOSType(GObject.GEnum):
    """
    The different types of QoS events that can be given to the
    gst_event_new_qos() method."""

    OVERFLOW = 0
    """
    The QoS event type that is produced when upstream
       elements are producing data too quickly and the element can't keep up
       processing the data. Upstream should reduce their production rate. This
       type is also used when buffers arrive early or in time.
    """
    UNDERFLOW = 1
    """
    The QoS event type that is produced when upstream
       elements are producing data too slowly and need to speed up their
       production rate.
    """
    THROTTLE = 2
    """
    The QoS event type that is produced when the
       application enabled throttling to limit the data rate.
    """

class QueryType(GObject.GEnum):
    """
    Standard predefined Query types"""

    UNKNOWN = 0
    """
    unknown query type
    """
    POSITION = 2563
    """
    current position in stream
    """
    DURATION = 5123
    """
    total duration of the stream
    """
    LATENCY = 7683
    """
    latency of stream
    """
    JITTER = 10243
    """
    current jitter of stream
    """
    RATE = 12803
    """
    current rate of the stream
    """
    SEEKING = 15363
    """
    seeking capabilities
    """
    SEGMENT = 17923
    """
    segment start/stop positions
    """
    CONVERT = 20483
    """
    convert values between formats
    """
    FORMATS = 23043
    """
    query supported formats for convert
    """
    BUFFERING = 28163
    """
    query available media for efficient seeking.
    """
    CUSTOM = 30723
    """
    a custom application or element defined query.
    """
    URI = 33283
    """
    query the URI of the source or sink.
    """
    ALLOCATION = 35846
    """
    the buffer allocation properties
    """
    SCHEDULING = 38401
    """
    the scheduling properties
    """
    ACCEPT_CAPS = 40963
    """
    the accept caps query
    """
    CAPS = 43523
    """
    the caps query
    """
    DRAIN = 46086
    """
    wait till all serialized data is consumed downstream
    """
    CONTEXT = 48643
    """
    query the pipeline-local context from
        downstream or upstream (since 1.2)
    """
    BITRATE = 51202
    """
    the bitrate query (since 1.16)
    """
    SELECTABLE = 53763
    """
    Query stream selection capability.
    """

class QueryTypeFlags(GObject.GFlags):
    """
    #GstQueryTypeFlags indicate the aspects of the different #GstQueryType
    values. You can get the type flags of a #GstQueryType with the
    gst_query_type_get_flags() function."""

    UPSTREAM = 1
    """
    Set if the query can travel upstream.
    """
    DOWNSTREAM = 2
    """
    Set if the query can travel downstream.
    """
    SERIALIZED = 4
    """
    Set if the query should be serialized with data
                                  flow.
    """

class Rank(GObject.GEnum):
    """
    Element priority ranks. Defines the order in which the autoplugger (or
    similar rank-picking mechanisms, such as e.g. gst_element_make_from_uri())
    will choose this element over an alternative one with the same function.

    These constants serve as a rough guidance for defining the rank of a
    #GstPluginFeature. Any value is valid, including values bigger than
    @GST_RANK_PRIMARY."""

    NONE = 0
    """
    will be chosen last or not at all
    """
    MARGINAL = 64
    """
    unlikely to be chosen
    """
    SECONDARY = 128
    """
    likely to be chosen
    """
    PRIMARY = 256
    """
    will be chosen first
    """

class ResourceError(GObject.GEnum):
    """
    Resource errors are for any resource used by an element:
    memory, files, network connections, process space, ...
    They're typically used by source and sink elements."""

    FAILED = 1
    """
    a general error which doesn't fit in any other
    category.  Make sure you add a custom message to the error call.
    """
    TOO_LAZY = 2
    """
    do not use this except as a placeholder for
    deciding where to go while developing code.
    """
    NOT_FOUND = 3
    """
    used when the resource could not be found.
    """
    BUSY = 4
    """
    used when resource is busy.
    """
    OPEN_READ = 5
    """
    used when resource fails to open for reading.
    """
    OPEN_WRITE = 6
    """
    used when resource fails to open for writing.
    """
    OPEN_READ_WRITE = 7
    """
    used when resource cannot be opened for
    both reading and writing, or either (but unspecified which).
    """
    CLOSE = 8
    """
    used when the resource can't be closed.
    """
    READ = 9
    """
    used when the resource can't be read from.
    """
    WRITE = 10
    """
    used when the resource can't be written to.
    """
    SEEK = 11
    """
    used when a seek on the resource fails.
    """
    SYNC = 12
    """
    used when a synchronize on the resource fails.
    """
    SETTINGS = 13
    """
    used when settings can't be manipulated on.
    """
    NO_SPACE_LEFT = 14
    """
    used when the resource has no space left.
    """
    NOT_AUTHORIZED = 15
    """
    used when the resource can't be opened
                                        due to missing authorization.
                                        (Since: 1.2.4)
    """
    NUM_ERRORS = 16
    """
    the number of resource error types.
    """

class SchedulingFlags(GObject.GFlags):
    """
    The different scheduling flags."""

    SEEKABLE = 1
    """
    if seeking is possible
    """
    SEQUENTIAL = 2
    """
    if sequential access is recommended
    """
    BANDWIDTH_LIMITED = 4
    """
    if bandwidth is limited and buffering possible (since 1.2)
    """

class SearchMode(GObject.GEnum):
    """
    The different search modes."""

    EXACT = 0
    """
    Only search for exact matches.
    """
    BEFORE = 1
    """
    Search for an exact match or the element just before.
    """
    AFTER = 2
    """
    Search for an exact match or the element just after.
    """

class SeekFlags(GObject.GFlags):
    """
    Flags to be used with gst_element_seek() or gst_event_new_seek(). All flags
    can be used together.

    A non flushing seek might take some time to perform as the currently
    playing data in the pipeline will not be cleared.

    An accurate seek might be slower for formats that don't have any indexes
    or timestamp markers in the stream. Specifying this flag might require a
    complete scan of the file in those cases.

    When performing a segment seek: after the playback of the segment completes,
    no EOS will be emitted by the element that performed the seek, but a
    %GST_MESSAGE_SEGMENT_DONE message will be posted on the bus by the element.
    When this message is posted, it is possible to send a new seek event to
    continue playback. With this seek method it is possible to perform seamless
    looping or simple linear editing.

    When only changing the playback rate and not the direction, the
    %GST_SEEK_FLAG_INSTANT_RATE_CHANGE flag can be used for a non-flushing seek
    to signal that the rate change should be applied immediately. This requires
    special support in the seek handlers (e.g. demuxers) and any elements
    synchronizing to the clock, and in general can't work in all cases (for example
    UDP streaming where the delivery rate is controlled by a remote server). The
    instant-rate-change mode supports changing the trickmode-related GST_SEEK_ flags,
    but can't be used in conjunction with other seek flags that affect the new
    playback position - as the playback position will not be changing.

    When doing fast forward (rate > 1.0) or fast reverse (rate < -1.0) trickmode
    playback, the %GST_SEEK_FLAG_TRICKMODE flag can be used to instruct decoders
    and demuxers to adjust the playback rate by skipping frames. This can improve
    performance and decrease CPU usage because not all frames need to be decoded.

    Beyond that, the %GST_SEEK_FLAG_TRICKMODE_KEY_UNITS flag can be used to
    request that decoders skip all frames except key units, and
    %GST_SEEK_FLAG_TRICKMODE_NO_AUDIO flags can be used to request that audio
    decoders do no decoding at all, and simple output silence.

    The %GST_SEEK_FLAG_SNAP_BEFORE flag can be used to snap to the previous
    relevant location, and the %GST_SEEK_FLAG_SNAP_AFTER flag can be used to
    select the next relevant location. If %GST_SEEK_FLAG_KEY_UNIT is specified,
    the relevant location is a keyframe. If both flags are specified, the nearest
    of these locations will be selected. If none are specified, the implementation is
    free to select whichever it wants.

    The before and after here are in running time, so when playing backwards,
    the next location refers to the one that will played in next, and not the
    one that is located after in the actual source stream.

    Also see part-seeking.txt in the GStreamer design documentation for more
    details on the meaning of these flags and the behaviour expected of
    elements that handle them."""

    NONE = 0
    """
    no flag
    """
    FLUSH = 1
    """
    flush pipeline
    """
    ACCURATE = 2
    """
    accurate position is requested, this might
                        be considerably slower for some formats.
    """
    KEY_UNIT = 4
    """
    seek to the nearest keyframe. This might be
                        faster but less accurate.
    """
    SEGMENT = 8
    """
    perform a segment seek.
    """
    TRICKMODE = 16
    """
    when doing fast forward or fast reverse playback, allow
                        elements to skip frames instead of generating all
                        frames. (Since: 1.6)
    """
    SKIP = 16
    """
    Deprecated backward compatibility flag, replaced
                        by %GST_SEEK_FLAG_TRICKMODE
    """
    SNAP_BEFORE = 32
    """
    go to a location before the requested position,
                        if %GST_SEEK_FLAG_KEY_UNIT this means the keyframe at or before
                        the requested position the one at or before the seek target.
    """
    SNAP_AFTER = 64
    """
    go to a location after the requested position,
                        if %GST_SEEK_FLAG_KEY_UNIT this means the keyframe at of after the
                        requested position.
    """
    SNAP_NEAREST = 96
    """
    go to a position near the requested position,
                        if %GST_SEEK_FLAG_KEY_UNIT this means the keyframe closest
                        to the requested position, if both keyframes are at an equal
                        distance, behaves like %GST_SEEK_FLAG_SNAP_BEFORE.
    """
    TRICKMODE_KEY_UNITS = 128
    """
    when doing fast forward or fast reverse
                        playback, request that elements only decode keyframes
                        and skip all other content, for formats that have
                        keyframes. (Since: 1.6)
    """
    TRICKMODE_NO_AUDIO = 256
    """
    when doing fast forward or fast reverse
                        playback, request that audio decoder elements skip
                        decoding and output only gap events or silence. (Since: 1.6)
    """
    TRICKMODE_FORWARD_PREDICTED = 512
    """
    When doing fast forward or fast reverse
                        playback, request that elements only decode keyframes and
                        forward predicted frames and skip all other content (for example
                        B-Frames), for formats that have keyframes and forward predicted
                        frames. (Since: 1.18)
    """
    INSTANT_RATE_CHANGE = 1024
    """
    Signals that a rate change should be
                        applied immediately. Only valid if start/stop position
                        are GST_CLOCK_TIME_NONE, the playback direction does not change
                        and the seek is not flushing. (Since: 1.18)
    """

class SeekType(GObject.GEnum):
    """
    The different types of seek events. When constructing a seek event with
    gst_event_new_seek() or when doing gst_segment_do_seek ()."""

    NONE = 0
    """
    no change in position is required
    """
    SET = 1
    """
    absolute position is requested
    """
    END = 2
    """
    relative position to duration is requested
    """

class SegmentFlags(GObject.GFlags):
    """
    Flags for the GstSegment structure. Currently mapped to the corresponding
    values of the seek flags."""

    NONE = 0
    """
    no flags
    """
    RESET = 1
    """
    reset the pipeline running_time to the segment
                             running_time
    """
    TRICKMODE = 16
    """
    perform skip playback (Since: 1.6)
    """
    SKIP = 16
    """
    Deprecated backward compatibility flag, replaced
                            by @GST_SEGMENT_FLAG_TRICKMODE
    """
    SEGMENT = 8
    """
    send SEGMENT_DONE instead of EOS
    """
    TRICKMODE_KEY_UNITS = 128
    """
    Decode only keyframes, where
                                           possible (Since: 1.6)
    """
    TRICKMODE_FORWARD_PREDICTED = 512
    """
    Decode only keyframes or forward
                                           predicted frames, where possible (Since: 1.18)
    """
    TRICKMODE_NO_AUDIO = 256
    """
    Do not decode any audio, where
                                           possible (Since: 1.6)
    """

class SerializeFlags(GObject.GFlags):
    NONE = 0
    """
    No special flags specified.
    """
    BACKWARD_COMPAT = 1
    """
    Serialize using the old format for
                                         nested structures.
    """
    STRICT = 2
    """
    Serialization fails if a value cannot be serialized instead of using
    placeholder "NULL" value (e.g. pointers, objects).
    """

class StackTraceFlags(GObject.GFlags):
    NONE = 0
    """
    Try to retrieve the minimum information
                                available, which may be none on some platforms
                                (Since: 1.18)
    """
    FULL = 1
    """
    Try to retrieve as much information as possible,
                                including source information when getting the
                                stack trace
    """

class State(GObject.GEnum):
    """
    The possible states an element can be in. States can be changed using
    gst_element_set_state() and checked using gst_element_get_state()."""

    VOID_PENDING = 0
    """
    no pending state.
    """
    NULL = 1
    """
    the NULL state or initial state of an element.
    """
    READY = 2
    """
    the element is ready to go to PAUSED.
    """
    PAUSED = 3
    """
    the element is PAUSED, it is ready to accept and
                             process data. Sink elements however only accept one
                             buffer and then block.
    """
    PLAYING = 4
    """
    the element is PLAYING, the #GstClock is running and
                             the data is flowing.
    """

class StateChange(GObject.GEnum):
    """
    These are the different state changes an element goes through.
    %GST_STATE_NULL &rArr; %GST_STATE_PLAYING is called an upwards state change
    and %GST_STATE_PLAYING &rArr; %GST_STATE_NULL a downwards state change."""

    NULL_TO_READY = 10
    """
    state change from NULL to READY.
      * The element must check if the resources it needs are available. Device
        sinks and -sources typically try to probe the device to constrain their
        caps.
      * The element opens the device (in case feature need to be probed).
    """
    READY_TO_PAUSED = 19
    """
    state change from READY to PAUSED.
      * The element pads are activated in order to receive data in PAUSED.
        Streaming threads are started.
      * Some elements might need to return %GST_STATE_CHANGE_ASYNC and complete
        the state change when they have enough information. It is a requirement
        for sinks to return %GST_STATE_CHANGE_ASYNC and complete the state change
        when they receive the first buffer or %GST_EVENT_EOS (preroll).
        Sinks also block the dataflow when in PAUSED.
      * A pipeline resets the running_time to 0.
      * Live sources return %GST_STATE_CHANGE_NO_PREROLL and don't generate data.
    """
    PAUSED_TO_PLAYING = 28
    """
    state change from PAUSED to PLAYING.
      * Most elements ignore this state change.
      * The pipeline selects a #GstClock and distributes this to all the children
        before setting them to PLAYING. This means that it is only allowed to
        synchronize on the #GstClock in the PLAYING state.
      * The pipeline uses the #GstClock and the running_time to calculate the
        base_time. The base_time is distributed to all children when performing
        the state change.
      * Sink elements stop blocking on the preroll buffer or event and start
        rendering the data.
      * Sinks can post %GST_MESSAGE_EOS in the PLAYING state. It is not allowed
        to post %GST_MESSAGE_EOS when not in the PLAYING state.
      * While streaming in PAUSED or PLAYING elements can create and remove
        sometimes pads.
      * Live sources start generating data and return %GST_STATE_CHANGE_SUCCESS.
    """
    PLAYING_TO_PAUSED = 35
    """
    state change from PLAYING to PAUSED.
      * Most elements ignore this state change.
      * The pipeline calculates the running_time based on the last selected
        #GstClock and the base_time. It stores this information to continue
        playback when going back to the PLAYING state.
      * Sinks unblock any #GstClock wait calls.
      * When a sink does not have a pending buffer to play, it returns
        #GST_STATE_CHANGE_ASYNC from this state change and completes the state
        change when it receives a new buffer or an %GST_EVENT_EOS.
      * Any queued %GST_MESSAGE_EOS items are removed since they will be reposted
        when going back to the PLAYING state. The EOS messages are queued in
        #GstBin containers.
      * Live sources stop generating data and return %GST_STATE_CHANGE_NO_PREROLL.
    """
    PAUSED_TO_READY = 26
    """
    state change from PAUSED to READY.
      * Sinks unblock any waits in the preroll.
      * Elements unblock any waits on devices
      * Chain or get_range functions return %GST_FLOW_FLUSHING.
      * The element pads are deactivated so that streaming becomes impossible and
        all streaming threads are stopped.
      * The sink forgets all negotiated formats
      * Elements remove all sometimes pads
    """
    READY_TO_NULL = 17
    """
    state change from READY to NULL.
      * Elements close devices
      * Elements reset any internal state.
    """
    NULL_TO_NULL = 9
    """
    state change from NULL to NULL. (Since: 1.14)
    """
    READY_TO_READY = 18
    """
    state change from READY to READY,
    This might happen when going to PAUSED asynchronously failed, in that case
    elements should make sure they are in a proper, coherent READY state. (Since: 1.14)
    """
    PAUSED_TO_PAUSED = 27
    """
    state change from PAUSED to PAUSED.
    This might happen when elements were in PLAYING state and 'lost state',
    they should make sure to go back to real 'PAUSED' state (prerolling for example). (Since: 1.14)
    """
    PLAYING_TO_PLAYING = 36
    """
    state change from PLAYING to PLAYING. (Since: 1.14)
    """

class StateChangeReturn(GObject.GEnum):
    """
    The possible return values from a state change function such as
    gst_element_set_state(). Only @GST_STATE_CHANGE_FAILURE is a real failure."""

    FAILURE = 0
    """
    the state change failed
    """
    SUCCESS = 1
    """
    the state change succeeded
    """
    ASYNC = 2
    NO_PREROLL = 3
    """
    the state change succeeded but the element
                                  cannot produce data in %GST_STATE_PAUSED.
                                  This typically happens with live sources.
    """

class StreamError(GObject.GEnum):
    """
    Stream errors are for anything related to the stream being processed:
    format errors, media type errors, ...
    They're typically used by decoders, demuxers, converters, ..."""

    FAILED = 1
    """
    a general error which doesn't fit in any other
    category.  Make sure you add a custom message to the error call.
    """
    TOO_LAZY = 2
    """
    do not use this except as a placeholder for
    deciding where to go while developing code.
    """
    NOT_IMPLEMENTED = 3
    """
    use this when you do not want to implement
    this functionality yet.
    """
    TYPE_NOT_FOUND = 4
    """
    used when the element doesn't know the
    stream's type.
    """
    WRONG_TYPE = 5
    """
    used when the element doesn't handle this type
    of stream.
    """
    CODEC_NOT_FOUND = 6
    """
    used when there's no codec to handle the
    stream's type.
    """
    DECODE = 7
    """
    used when decoding fails.
    """
    ENCODE = 8
    """
    used when encoding fails.
    """
    DEMUX = 9
    """
    used when demuxing fails.
    """
    MUX = 10
    """
    used when muxing fails.
    """
    FORMAT = 11
    """
    used when the stream is of the wrong format
    (for example, wrong caps).
    """
    DECRYPT = 12
    """
    used when the stream is encrypted and can't be
    decrypted because this is not supported by the element.
    """
    DECRYPT_NOKEY = 13
    """
    used when the stream is encrypted and
    can't be decrypted because no suitable key is available.
    """
    NUM_ERRORS = 14
    """
    the number of stream error types.
    """

class StreamFlags(GObject.GFlags):
    NONE = 0
    """
    This stream has no special attributes
    """
    SPARSE = 1
    """
    This stream is a sparse stream (e.g. a subtitle
       stream), data may flow only in irregular intervals with large gaps in
       between.
    """
    SELECT = 2
    """
    This stream should be selected by default. This
       flag may be used by demuxers to signal that a stream should be selected
       by default in a playback scenario.
    """
    UNSELECT = 4
    """
    This stream should not be selected by default.
       This flag may be used by demuxers to signal that a stream should not
       be selected by default in a playback scenario, but only if explicitly
       selected by the user (e.g. an audio track for the hard of hearing or
       a director's commentary track).
    """

class StreamStatusType(GObject.GEnum):
    """
    The type of a %GST_MESSAGE_STREAM_STATUS. The stream status messages inform the
    application of new streaming threads and their status."""

    CREATE = 0
    """
    A new thread need to be created.
    """
    ENTER = 1
    """
    a thread entered its loop function
    """
    LEAVE = 2
    """
    a thread left its loop function
    """
    DESTROY = 3
    """
    a thread is destroyed
    """
    START = 8
    """
    a thread is started
    """
    PAUSE = 9
    """
    a thread is paused
    """
    STOP = 10
    """
    a thread is stopped
    """

class StreamType(GObject.GFlags):
    """
    #GstStreamType describes a high level classification set for
    flows of data in #GstStream objects.

    Note that this is a flag, and therefore users should not assume it
    will be a single value. Do not use the equality operator for checking
    whether a stream is of a certain type."""

    UNKNOWN = 1
    """
    The stream is of unknown (unclassified) type.
    """
    AUDIO = 2
    """
    The stream is of audio data
    """
    VIDEO = 4
    """
    The stream carries video data
    """
    CONTAINER = 8
    """
    The stream is a muxed container type
    """
    TEXT = 16
    """
    The stream contains subtitle / subpicture data.
    """

class StructureChangeType(GObject.GEnum):
    """
    The type of a %GST_MESSAGE_STRUCTURE_CHANGE."""

    LINK = 0
    """
    Pad linking is starting or done.
    """
    UNLINK = 1
    """
    Pad unlinking is starting or done.
    """

class TagFlag(GObject.GEnum):
    """
    Extra tag flags used when registering tags."""

    UNDEFINED = 0
    """
    undefined flag
    """
    META = 1
    """
    tag is meta data
    """
    ENCODED = 2
    """
    tag is encoded
    """
    DECODED = 3
    """
    tag is decoded
    """
    COUNT = 4
    """
    number of tag flags
    """

class TagMergeMode(GObject.GEnum):
    """
    The different tag merging modes are basically replace, overwrite and append,
    but they can be seen from two directions. Given two taglists: (A) the tags
    already in the element and (B) the ones that are supplied to the element (
    e.g. via gst_tag_setter_merge_tags() / gst_tag_setter_add_tags() or a
    %GST_EVENT_TAG), how are these tags merged?
    In the table below this is shown for the cases that a tag exists in the list
    (A) or does not exists (!A) and combinations thereof.

    | merge mode  | A + B | A + !B | !A + B | !A + !B |
    | ----------- | ----- | ------ | ------ | ------- |
    | REPLACE_ALL | B     |       | B      |        |
    | REPLACE     | B     | A      | B      |        |
    | APPEND      | A, B  | A      | B      |        |
    | PREPEND     | B, A  | A      | B      |        |
    | KEEP        | A     | A      | B      |        |
    | KEEP_ALL    | A     | A      |       |        |"""

    UNDEFINED = 0
    """
    undefined merge mode
    """
    REPLACE_ALL = 1
    """
    replace all tags (clear list and append)
    """
    REPLACE = 2
    """
    replace tags
    """
    APPEND = 3
    """
    append tags
    """
    PREPEND = 4
    """
    prepend tags
    """
    KEEP = 5
    """
    keep existing tags
    """
    KEEP_ALL = 6
    """
    keep all existing tags
    """
    COUNT = 7
    """
    the number of merge modes
    """

class TagScope(GObject.GEnum):
    """
    GstTagScope specifies if a taglist applies to the complete
    medium or only to one single stream."""

    STREAM = 0
    """
    tags specific to this single stream
    """
    GLOBAL = 1

class TaskState(GObject.GEnum):
    """
    The different states a task can be in"""

    STARTED = 0
    """
    the task is started and running
    """
    STOPPED = 1
    """
    the task is stopped
    """
    PAUSED = 2
    """
    the task is paused
    """

class TocEntryType(GObject.GEnum):
    """
    The different types of TOC entries (see #GstTocEntry).

    There are two types of TOC entries: alternatives or parts in a sequence."""

    ANGLE = -3
    """
    entry is an angle (i.e. an alternative)
    """
    VERSION = -2
    """
    entry is a version (i.e. alternative)
    """
    EDITION = -1
    """
    entry is an edition (i.e. alternative)
    """
    INVALID = 0
    """
    invalid entry type value
    """
    TITLE = 1
    """
    entry is a title (i.e. a part of a sequence)
    """
    TRACK = 2
    """
    entry is a track (i.e. a part of a sequence)
    """
    CHAPTER = 3
    """
    entry is a chapter (i.e. a part of a sequence)
    """

class TocLoopType(GObject.GEnum):
    """
    How a #GstTocEntry should be repeated. By default, entries are played a
    single time."""

    NONE = 0
    """
    single forward playback
    """
    FORWARD = 1
    """
    repeat forward
    """
    REVERSE = 2
    """
    repeat backward
    """
    PING_PONG = 3
    """
    repeat forward and backward
    """

class TocScope(GObject.GEnum):
    """
    The scope of a TOC."""

    GLOBAL = 1
    CURRENT = 2
    """
    TOC for the currently active/selected stream
        (this is a TOC representing the current stream from start to EOS,
        and is what a TOC writer / muxer is usually interested in; it will
        usually be a subset of the global TOC, e.g. just the chapters of
        the current title, or the chapters selected for playback from the
        current title)
    """

class TracerValueFlags(GObject.GFlags):
    """
    Flag that describe the value. These flags help applications processing the
    logs to understand the values."""

    NONE = 0
    """
    no flags
    """
    OPTIONAL = 1
    """
    the value is optional. When using this flag
      one need to have an additional boolean arg before this value in the
      var-args list passed to  gst_tracer_record_log().
    """
    AGGREGATED = 2
    """
    the value is a combined figure, since the
      start of tracing. Examples are averages or timestamps.
    """

class TracerValueScope(GObject.GEnum):
    """
    Tracing record will contain fields that contain a measured value or extra
    meta-data. One such meta data are values that tell where a measurement was
    taken. This enumerating declares to which scope such a meta data field
    relates to. If it is e.g. %GST_TRACER_VALUE_SCOPE_PAD, then each of the log
    events may contain values for different #GstPads."""

    PROCESS = 0
    """
    the value is related to the process
    """
    THREAD = 1
    """
    the value is related to a thread
    """
    ELEMENT = 2
    """
    the value is related to an #GstElement
    """
    PAD = 3
    """
    the value is related to a #GstPad
    """

class TypeFindProbability(GObject.GEnum):
    """
    The probability of the typefind function. Higher values have more certainty
    in doing a reliable typefind."""

    NONE = 0
    """
    type undetected.
    """
    MINIMUM = 1
    """
    unlikely typefind.
    """
    POSSIBLE = 50
    """
    possible type detected.
    """
    LIKELY = 80
    """
    likely a type was detected.
    """
    NEARLY_CERTAIN = 99
    """
    nearly certain that a type was detected.
    """
    MAXIMUM = 100
    """
    very certain a type was detected.
    """

class URIError(GObject.GEnum):
    """
    Different URI-related errors that can occur."""

    UNSUPPORTED_PROTOCOL = 0
    """
    The protocol is not supported
    """
    BAD_URI = 1
    """
    There was a problem with the URI
    """
    BAD_STATE = 2
    """
    Could not set or change the URI because the
        URI handler was in a state where that is not possible or not permitted
    """
    BAD_REFERENCE = 3
    """
    There was a problem with the entity that
        the URI references
    """

class URIType(GObject.GEnum):
    """
    The different types of URI direction."""

    UNKNOWN = 0
    """
    The URI direction is unknown
    """
    SINK = 1
    """
    The URI is a consumer.
    """
    SRC = 2
    """
    The URI is a producer.
    """

###############################################################
# classes
###############################################################

class AllocationParams(GObject.GBoxed):
    # gi Fields
    align: int = ...
    flags: MemoryFlags = ...
    padding: int = ...
    prefix: int = ...

    # gi Methods
    def copy(self) -> AllocationParams | None: ...
    def free(self) -> None: ...
    def init(self) -> None: ...
    @classmethod
    def new(cls) -> AllocationParams: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class Allocator(Object):
    """
    Memory is usually created by allocators with a gst_allocator_alloc()
    method call. When %NULL is used as the allocator, the default allocator will
    be used.

    New allocators can be registered with gst_allocator_register().
    Allocators are identified by name and can be retrieved with
    gst_allocator_find(). gst_allocator_set_default() can be used to change the
    default allocator.

    New memory can be created with gst_memory_new_wrapped() that wraps the memory
    allocated elsewhere.
    """

    # gi Fields
    @builtins.property
    def mem_copy(self) -> MemoryCopyFunctionAllocatorCB: ...
    @builtins.property
    def mem_is_span(self) -> MemoryIsSpanFunctionAllocatorCB: ...
    @builtins.property
    def mem_map(self) -> MemoryMapFunctionAllocatorCB | None: ...
    @builtins.property
    def mem_map_full(self) -> MemoryMapFullFunctionAllocatorCB | None: ...
    @builtins.property
    def mem_share(self) -> MemoryShareFunctionAllocatorCB: ...
    @builtins.property
    def mem_type(self) -> str: ...
    @builtins.property
    def mem_unmap(self) -> MemoryUnmapFunctionAllocatorCB: ...
    @builtins.property
    def mem_unmap_full(self) -> MemoryUnmapFullFunctionAllocatorCB: ...
    @builtins.property
    def object(self) -> Object | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def alloc(self, size: int, params: AllocationParams | None = None) -> Memory | None: ...
    @staticmethod
    def find(name: str | None = None) -> Allocator | None: ...
    def free(self, memory: Memory) -> None: ...
    @staticmethod
    def register(name: str, allocator: Allocator) -> None: ...
    def set_default(self) -> None: ...

    # python methods (overrides?)
    def do_alloc(
        self,
        size: int,
        params: AllocationParams | None = None,
    ) -> Memory | None:
        """
        alloc(self, size:int, params:Gst.AllocationParams=None) -> Gst.Memory or None
        """
    def do_free(
        self,
        memory: Memory,
    ) -> None:
        """
        free(self, memory:Gst.Memory)
        """

class AllocatorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def alloc(self) -> allocAllocatorClassCB | None: ...
    @builtins.property
    def free(self) -> freeAllocatorClassCB: ...
    @builtins.property
    def object_class(self) -> ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AllocatorPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AtomicQueue(GObject.GBoxed):
    # gi Methods
    def length(self) -> int: ...
    @classmethod
    def new(cls, initial_size: int) -> AtomicQueue: ...
    def peek(self) -> object | None: ...
    def pop(self) -> object | None: ...
    def push(self, data: object | None = None) -> None: ...
    def ref(self) -> None: ...
    def unref(self) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class Bin(Element):
    """
    #GstBin is an element that can contain other #GstElement, allowing them to be
    managed as a group.
    Pads from the child elements can be ghosted to the bin, see #GstGhostPad.
    This makes the bin look like any other elements and enables creation of
    higher-level abstraction elements.

    A new #GstBin is created with gst_bin_new(). Use a #GstPipeline instead if you
    want to create a toplevel bin because a normal bin doesn't have a bus or
    handle clock distribution of its own.

    After the bin has been created you will typically add elements to it with
    gst_bin_add(). You can remove elements with gst_bin_remove().

    An element can be retrieved from a bin with gst_bin_get_by_name(), using the
    elements name. gst_bin_get_by_name_recurse_up() is mainly used for internal
    purposes and will query the parent bins when the element is not found in the
    current bin.

    An iterator of elements in a bin can be retrieved with
    gst_bin_iterate_elements(). Various other iterators exist to retrieve the
    elements in a bin.

    gst_object_unref() is used to drop your reference to the bin.

    The #GstBin::element-added signal is fired whenever a new element is added to
    the bin. Likewise the #GstBin::element-removed signal is fired whenever an
    element is removed from the bin.

    A #GstBin internally intercepts every #GstMessage posted by its children and
    implements the following default behaviour for each of them:

    * %GST_MESSAGE_EOS: This message is only posted by sinks in the PLAYING
    state. If all sinks posted the EOS message, this bin will post and EOS
    message upwards.

    * %GST_MESSAGE_SEGMENT_START: Just collected and never forwarded upwards.
      The messages are used to decide when all elements have completed playback
      of their segment.

    * %GST_MESSAGE_SEGMENT_DONE: Is posted by #GstBin when all elements that posted
      a SEGMENT_START have posted a SEGMENT_DONE.

    * %GST_MESSAGE_DURATION_CHANGED: Is posted by an element that detected a change
      in the stream duration. The duration change is posted to the
      application so that it can refetch the new duration with a duration
      query.

      Note that these messages can be posted before the bin is prerolled, in which
      case the duration query might fail.

      Note also that there might be a discrepancy (due to internal buffering/queueing)
      between the stream being currently displayed and the returned duration query.

      Applications might want to also query for duration (and changes) by
      listening to the %GST_MESSAGE_STREAM_START message, signaling the active start
      of a (new) stream.

    * %GST_MESSAGE_CLOCK_LOST: This message is posted by an element when it
      can no longer provide a clock.

      The default bin behaviour is to check if the lost clock was the one provided
      by the bin. If so and the bin is currently in the PLAYING state, the message
      is forwarded to the bin parent.

      This message is also generated when a clock provider is removed from
      the bin. If this message is received by the application, it should
      PAUSE the pipeline and set it back to PLAYING to force a new clock
      distribution.

    * %GST_MESSAGE_CLOCK_PROVIDE: This message is generated when an element
      can provide a clock. This mostly happens when a new clock
      provider is added to the bin.

      The default behaviour of the bin is to mark the currently selected clock as
      dirty, which will perform a clock recalculation the next time the bin is
      asked to provide a clock.

      This message is never sent to the application but is forwarded to
      the parent of the bin.

    * OTHERS: posted upwards.

    A #GstBin implements the following default behaviour for answering to a
    #GstQuery:

    * %GST_QUERY_DURATION: The bin will forward the query to all sink
      elements contained within and will return the maximum value.
      If no sinks are available in the bin, the query fails.

    * %GST_QUERY_POSITION: The query is sent to all sink elements in the bin and the
      MAXIMUM of all values is returned. If no sinks are available in the bin,
      the query fails.

    * OTHERS: the query is forwarded to all sink elements, the result
      of the first sink that answers the query successfully is returned. If no
      sink is in the bin, the query fails.

    A #GstBin will by default forward any event sent to it to all sink
    ( %GST_EVENT_TYPE_UPSTREAM ) or source ( %GST_EVENT_TYPE_DOWNSTREAM ) elements
    depending on the event type.

    If all the elements return %TRUE, the bin will also return %TRUE, else %FALSE
    is returned. If no elements of the required type are in the bin, the event
    handler will return %TRUE.
    """

    class Props(Element.Props):
        async_handling: bool  # [async-handling]: changed because contained invalid characters
        message_forward: bool  # [message-forward]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def child_bus(self) -> Bus | None: ...
    @builtins.property
    def children(self) -> list | None: ...
    @builtins.property
    def children_cookie(self) -> int: ...
    @builtins.property
    def clock_dirty(self) -> bool: ...
    @builtins.property
    def clock_provider(self) -> Element | None: ...
    @builtins.property
    def element(self) -> Element | None: ...
    @builtins.property
    def messages(self) -> list | None: ...
    @builtins.property
    def numchildren(self) -> int: ...
    @builtins.property
    def polling(self) -> bool: ...
    @builtins.property
    def provided_clock(self) -> Clock | None: ...
    @builtins.property
    def state_dirty(self) -> bool: ...

    # gi Methods
    def __init__(self, async_handling: bool = ..., message_forward: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add(self, element: Element) -> bool: ...
    def find_unlinked_pad(self, direction: PadDirection) -> Pad | None: ...
    def get_by_interface(self, iface: GObject.GType) -> Element | None: ...
    def get_by_name(self, name: str) -> Element | None: ...
    def get_by_name_recurse_up(self, name: str) -> Element | None: ...
    def get_suppressed_flags(self) -> ElementFlags: ...
    def iterate_all_by_element_factory_name(self, factory_name: str) -> Iterator | None: ...
    def iterate_all_by_interface(self, iface: GObject.GType) -> Iterator | None: ...
    def iterate_elements(self) -> Iterator | None: ...
    def iterate_recurse(self) -> Iterator | None: ...
    def iterate_sinks(self) -> Iterator | None: ...
    def iterate_sorted(self) -> Iterator | None: ...
    def iterate_sources(self) -> Iterator | None: ...
    @classmethod
    def new(cls, name: str | None = None) -> Element: ...
    def recalculate_latency(self) -> bool: ...
    def remove(self, element: Element) -> bool: ...
    def set_suppressed_flags(self, flags: ElementFlags) -> None: ...
    def sync_children_states(self) -> bool: ...

    # python methods (overrides?)
    def do_add_element(
        self,
        element: Element,
    ) -> bool:
        """
        add_element(self, element:Gst.Element) -> bool
        """
    def do_deep_element_added(
        self,
        sub_bin: Bin,
        child: Element,
    ) -> None:
        """
        deep_element_added(self, sub_bin:Gst.Bin, child:Gst.Element)
        """
    def do_deep_element_removed(
        self,
        sub_bin: Bin,
        child: Element,
    ) -> None:
        """
        deep_element_removed(self, sub_bin:Gst.Bin, child:Gst.Element)
        """
    def do_do_latency(
        self,
    ) -> bool:
        """
        do_latency(self) -> bool
        """
    def do_element_added(
        self,
        child: Element,
    ) -> None:
        """
        element_added(self, child:Gst.Element)
        """
    def do_element_removed(
        self,
        child: Element,
    ) -> None:
        """
        element_removed(self, child:Gst.Element)
        """
    def do_handle_message(
        self,
        message: Message,
    ) -> None:
        """
        handle_message(self, message:Gst.Message)
        """
    def do_remove_element(
        self,
        element: Element,
    ) -> bool:
        """
        remove_element(self, element:Gst.Element) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["deep-element-added"],
        handler: typing.Callable[[typing_extensions.Self, Bin, Element], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["deep-element-removed"],
        handler: typing.Callable[[typing_extensions.Self, Bin, Element], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["do-latency"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["element-added"],
        handler: typing.Callable[[typing_extensions.Self, Element], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["element-removed"],
        handler: typing.Callable[[typing_extensions.Self, Element], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::async_handling"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::message_forward"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BinClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def add_element(self) -> add_elementBinClassCB: ...
    @builtins.property
    def deep_element_added(self) -> deep_element_addedBinClassCB: ...
    @builtins.property
    def deep_element_removed(self) -> deep_element_removedBinClassCB: ...
    @builtins.property
    def do_latency(self) -> do_latencyBinClassCB: ...
    @builtins.property
    def element_added(self) -> element_addedBinClassCB: ...
    @builtins.property
    def element_removed(self) -> element_removedBinClassCB: ...
    @builtins.property
    def handle_message(self) -> handle_messageBinClassCB: ...
    @builtins.property
    def parent_class(self) -> ElementClass | None: ...
    @builtins.property
    def pool(self) -> GLib.ThreadPool | None: ...
    @builtins.property
    def remove_element(self) -> remove_elementBinClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BinPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Bitmask(object):
    """
    A fundamental type that describes a 64-bit bitmask
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Buffer(GObject.GBoxed):
    # gi Fields
    dts: int = ...
    duration: int = ...
    mini_object: MiniObject | None = ...
    offset: int = ...
    offset_end: int = ...
    pool: BufferPool | None = ...
    pts: int = ...

    # gi Methods
    def add_custom_meta(self, name: str) -> CustomMeta | None: ...
    def add_meta(self, info: MetaInfo, params: object | None = None) -> Meta | None: ...
    def add_parent_buffer_meta(self, ref: Buffer) -> ParentBufferMeta | None: ...
    def add_protection_meta(self, info: Structure) -> ProtectionMeta: ...
    def add_reference_timestamp_meta(
        self, reference: Caps, timestamp: int, duration: int
    ) -> ReferenceTimestampMeta | None: ...
    def append(self, buf2: Buffer) -> Buffer: ...
    def append_memory(self, mem: Memory) -> None: ...
    def append_region(self, buf2: Buffer, offset: int, size: int) -> Buffer: ...
    def copy_deep(self) -> Buffer | None: ...
    def copy_into(self, src: Buffer, flags: BufferCopyFlags, offset: int, size: int) -> bool: ...
    def copy_region(self, flags: BufferCopyFlags, offset: int, size: int) -> Buffer | None: ...
    def extract(self, offset: int, size: int) -> tuple[int, list]: ...
    def extract_dup(self, offset: int, size: int) -> tuple[list, int]: ...
    def fill(self, offset: int, src: list, size: int) -> int: ...
    def find_memory(self, offset: int, size: int) -> tuple[bool, int, int, int]: ...
    def foreach_meta(self, func: BufferForeachMetaFunc, user_data: object | None = None) -> bool: ...
    def get_all_memory(self) -> Memory | None: ...
    def get_custom_meta(self, name: str) -> CustomMeta | None: ...
    def get_flags(self) -> BufferFlags: ...
    @staticmethod
    def get_max_memory() -> int: ...
    def get_memory(self, idx: int) -> Memory | None: ...
    def get_memory_range(self, idx: int, length: int) -> Memory | None: ...
    def get_meta(self, api: GObject.GType) -> Meta | None: ...
    def get_n_meta(self, api_type: GObject.GType) -> int: ...
    def get_reference_timestamp_meta(self, reference: Caps | None = None) -> ReferenceTimestampMeta | None: ...
    def get_size(self) -> int: ...
    def get_sizes(self) -> tuple[int, int | None, int | None]: ...
    def get_sizes_range(self, idx: int, length: int) -> tuple[int, int | None, int | None]: ...
    def has_flags(self, flags: BufferFlags) -> bool: ...
    def insert_memory(self, idx: int, mem: Memory) -> None: ...
    def is_all_memory_writable(self) -> bool: ...
    def is_memory_range_writable(self, idx: int, length: int) -> bool: ...
    def map(self, flags: MapFlags) -> tuple[bool, MapInfo]: ...
    def map_range(self, idx: int, length: int, flags: MapFlags) -> tuple[bool, MapInfo]: ...
    def memcmp(self, offset: int, mem: list, size: int) -> int: ...
    def memset(self, offset: int, val: int, size: int) -> int: ...
    def n_memory(self) -> int: ...
    @classmethod
    def new(cls) -> Buffer: ...
    @classmethod
    def new_allocate(
        cls, allocator: Allocator | None, size: int, params: AllocationParams | None = None
    ) -> Buffer | None: ...
    @classmethod
    def new_memdup(cls, data: list, size: int) -> Buffer: ...
    @classmethod
    def new_wrapped(cls, data: list, size: int) -> Buffer: ...
    @classmethod
    def new_wrapped_bytes(cls, bytes: GLib.Bytes) -> Buffer: ...
    @classmethod
    def new_wrapped_full(
        cls,
        flags: MemoryFlags,
        data: list,
        maxsize: int,
        offset: int,
        size: int,
        user_data: object | None = None,
        notify: GLib.DestroyNotify | None = None,
    ) -> Buffer: ...
    def peek_memory(self, idx: int) -> Memory | None: ...
    def prepend_memory(self, mem: Memory) -> None: ...
    def remove_all_memory(self) -> None: ...
    def remove_memory(self, idx: int) -> None: ...
    def remove_memory_range(self, idx: int, length: int) -> None: ...
    def remove_meta(self, meta: Meta) -> bool: ...
    def replace_all_memory(self, mem: Memory) -> None: ...
    def replace_memory(self, idx: int, mem: Memory) -> None: ...
    def replace_memory_range(self, idx: int, length: int, mem: Memory) -> None: ...
    def resize(self, offset: int, size: int) -> None: ...
    def resize_range(self, idx: int, length: int, offset: int, size: int) -> bool: ...
    def set_flags(self, flags: BufferFlags) -> bool: ...
    def set_size(self, size: int) -> None: ...
    def unmap(self, info: MapInfo) -> None: ...
    def unset_flags(self, flags: BufferFlags) -> bool: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class BufferList(GObject.GBoxed):
    # gi Methods
    def calculate_size(self) -> int: ...
    def copy_deep(self) -> BufferList: ...
    def foreach(self, func: BufferListFunc, user_data: object | None = None) -> bool: ...
    def get(self, idx: int) -> Buffer: ...
    def get_writable(self, idx: int) -> Buffer: ...
    def insert(self, idx: int, buffer: Buffer) -> None: ...
    def length(self) -> int: ...
    @classmethod
    def new(cls) -> BufferList: ...
    @classmethod
    def new_sized(cls, size: int) -> BufferList: ...
    def remove(self, idx: int, length: int) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class BufferPool(Object):
    """
    A #GstBufferPool is an object that can be used to pre-allocate and recycle
    buffers of the same size and with the same properties.

    A #GstBufferPool is created with gst_buffer_pool_new().

    Once a pool is created, it needs to be configured. A call to
    gst_buffer_pool_get_config() returns the current configuration structure from
    the pool. With gst_buffer_pool_config_set_params() and
    gst_buffer_pool_config_set_allocator() the bufferpool parameters and
    allocator can be configured. Other properties can be configured in the pool
    depending on the pool implementation.

    A bufferpool can have extra options that can be enabled with
    gst_buffer_pool_config_add_option(). The available options can be retrieved
    with gst_buffer_pool_get_options(). Some options allow for additional
    configuration properties to be set.

    After the configuration structure has been configured,
    gst_buffer_pool_set_config() updates the configuration in the pool. This can
    fail when the configuration structure is not accepted.

    After the pool has been configured, it can be activated with
    gst_buffer_pool_set_active(). This will preallocate the configured resources
    in the pool.

    When the pool is active, gst_buffer_pool_acquire_buffer() can be used to
    retrieve a buffer from the pool.

    Buffers allocated from a bufferpool will automatically be returned to the
    pool with gst_buffer_pool_release_buffer() when their refcount drops to 0.

    The bufferpool can be deactivated again with gst_buffer_pool_set_active().
    All further gst_buffer_pool_acquire_buffer() calls will return an error. When
    all buffers are returned to the pool they will be freed.
    """

    # gi Fields
    @builtins.property
    def flushing(self) -> int: ...
    @builtins.property
    def object(self) -> Object | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def acquire_buffer(self, params: BufferPoolAcquireParams | None = None) -> tuple[FlowReturn, Buffer | None]: ...
    @staticmethod
    def config_add_option(config: Structure, option: str) -> None: ...
    @staticmethod
    def config_get_allocator(config: Structure) -> tuple[bool, Allocator | None, AllocationParams | None]: ...
    @staticmethod
    def config_get_option(config: Structure, index: int) -> str | None: ...
    @staticmethod
    def config_get_params(config: Structure) -> tuple[bool, Caps | None, int | None, int | None, int | None]: ...
    @staticmethod
    def config_has_option(config: Structure, option: str) -> bool: ...
    @staticmethod
    def config_n_options(config: Structure) -> int: ...
    @staticmethod
    def config_set_allocator(
        config: Structure, allocator: Allocator | None = None, params: AllocationParams | None = None
    ) -> None: ...
    @staticmethod
    def config_set_params(
        config: Structure, caps: Caps | None, size: int, min_buffers: int, max_buffers: int
    ) -> None: ...
    @staticmethod
    def config_validate_params(
        config: Structure, caps: Caps | None, size: int, min_buffers: int, max_buffers: int
    ) -> bool: ...
    def get_config(self) -> Structure: ...
    def get_options(self) -> list: ...
    def has_option(self, option: str) -> bool: ...
    def is_active(self) -> bool: ...
    @classmethod
    def new(cls) -> BufferPool: ...
    def release_buffer(self, buffer: Buffer) -> None: ...
    def set_active(self, active: bool) -> bool: ...
    def set_config(self, config: Structure) -> bool: ...
    def set_flushing(self, flushing: bool) -> None: ...

    # python methods (overrides?)
    def do_acquire_buffer(
        self,
        params: BufferPoolAcquireParams | None = None,
    ) -> tuple:
        """
        acquire_buffer(self, params:Gst.BufferPoolAcquireParams=None) -> Gst.FlowReturn, buffer:Gst.Buffer
        """
    def do_alloc_buffer(
        self,
        params: BufferPoolAcquireParams | None = None,
    ) -> tuple:
        """
        alloc_buffer(self, params:Gst.BufferPoolAcquireParams=None) -> Gst.FlowReturn, buffer:Gst.Buffer
        """
    def do_flush_start(
        self,
    ) -> None:
        """
        flush_start(self)
        """
    def do_flush_stop(
        self,
    ) -> None:
        """
        flush_stop(self)
        """
    def do_free_buffer(
        self,
        buffer: Buffer,
    ) -> None:
        """
        free_buffer(self, buffer:Gst.Buffer)
        """
    def do_get_options(
        self,
    ) -> list:
        """
        get_options(self) -> list
        """
    def do_release_buffer(
        self,
        buffer: Buffer,
    ) -> None:
        """
        release_buffer(self, buffer:Gst.Buffer)
        """
    def do_reset_buffer(
        self,
        buffer: Buffer,
    ) -> None:
        """
        reset_buffer(self, buffer:Gst.Buffer)
        """
    def do_set_config(
        self,
        config: Structure,
    ) -> bool:
        """
        set_config(self, config:Gst.Structure) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """

class BufferPoolAcquireParams(GObject.GPointer):
    # gi Fields
    flags: BufferPoolAcquireFlags = ...
    format: Format = ...
    start: int = ...
    stop: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BufferPoolClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def acquire_buffer(self) -> acquire_bufferBufferPoolClassCB: ...
    @builtins.property
    def alloc_buffer(self) -> alloc_bufferBufferPoolClassCB: ...
    @builtins.property
    def flush_start(self) -> flush_startBufferPoolClassCB: ...
    @builtins.property
    def flush_stop(self) -> flush_stopBufferPoolClassCB: ...
    @builtins.property
    def free_buffer(self) -> free_bufferBufferPoolClassCB: ...
    @builtins.property
    def get_options(self) -> get_optionsBufferPoolClassCB: ...
    @builtins.property
    def object_class(self) -> ObjectClass | None: ...
    @builtins.property
    def release_buffer(self) -> release_bufferBufferPoolClassCB: ...
    @builtins.property
    def reset_buffer(self) -> reset_bufferBufferPoolClassCB: ...
    @builtins.property
    def set_config(self) -> set_configBufferPoolClassCB: ...
    @builtins.property
    def start(self) -> startBufferPoolClassCB: ...
    @builtins.property
    def stop(self) -> stopBufferPoolClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BufferPoolPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Bus(Object):
    """
    The #GstBus is an object responsible for delivering #GstMessage packets in
    a first-in first-out way from the streaming threads (see #GstTask) to the
    application.

    Since the application typically only wants to deal with delivery of these
    messages from one thread, the GstBus will marshall the messages between
    different threads. This is important since the actual streaming of media
    is done in another thread than the application.

    The GstBus provides support for #GSource based notifications. This makes it
    possible to handle the delivery in the glib #GMainLoop.

    The #GSource callback function gst_bus_async_signal_func() can be used to
    convert all bus messages into signal emissions.

    A message is posted on the bus with the gst_bus_post() method. With the
    gst_bus_peek() and gst_bus_pop() methods one can look at or retrieve a
    previously posted message.

    The bus can be polled with the gst_bus_poll() method. This methods blocks
    up to the specified timeout value until one of the specified messages types
    is posted on the bus. The application can then gst_bus_pop() the messages
    from the bus to handle them.
    Alternatively the application can register an asynchronous bus function
    using gst_bus_add_watch_full() or gst_bus_add_watch(). This function will
    install a #GSource in the default glib main loop and will deliver messages
    a short while after they have been posted. Note that the main loop should
    be running for the asynchronous callbacks.

    It is also possible to get messages from the bus without any thread
    marshalling with the gst_bus_set_sync_handler() method. This makes it
    possible to react to a message in the same thread that posted the
    message on the bus. This should only be used if the application is able
    to deal with messages from different threads.

    Every #GstPipeline has one bus.

    Note that a #GstPipeline will set its bus into flushing state when changing
    from READY to NULL state.
    """

    class Props(Object.Props):
        enable_async: bool  # [enable-async]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def object(self) -> Object | None: ...

    # gi Methods
    def __init__(self, enable_async: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_signal_watch(self) -> None: ...
    def add_signal_watch_full(self, priority: int) -> None: ...
    def add_watch(self, priority: int, func: BusFunc, user_data: object | None, notify: GLib.DestroyNotify) -> int: ...
    def async_signal_func(self, message: Message, data: object | None = None) -> bool: ...
    def create_watch(self) -> GLib.Source | None: ...
    def disable_sync_message_emission(self) -> None: ...
    def enable_sync_message_emission(self) -> None: ...
    def get_pollfd(self) -> GLib.PollFD: ...
    def have_pending(self) -> bool: ...
    @classmethod
    def new(cls) -> Bus: ...
    def peek(self) -> Message | None: ...
    def poll(self, events: MessageType, timeout: int) -> Message | None: ...
    def pop(self) -> Message | None: ...
    def pop_filtered(self, types: MessageType) -> Message | None: ...
    def post(self, message: Message) -> bool: ...
    def remove_signal_watch(self) -> None: ...
    def remove_watch(self) -> bool: ...
    def set_flushing(self, flushing: bool) -> None: ...
    def set_sync_handler(
        self, func: BusSyncHandler | None, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def sync_signal_handler(self, message: Message, data: object | None = None) -> BusSyncReply: ...
    def timed_pop(self, timeout: int) -> Message | None: ...
    def timed_pop_filtered(self, timeout: int, types: MessageType) -> Message | None: ...

    # python methods (overrides?)
    def do_message(
        self,
        message: Message,
    ) -> None:
        """
        message(self, message:Gst.Message)
        """
    def do_sync_message(
        self,
        message: Message,
    ) -> None:
        """
        sync_message(self, message:Gst.Message)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["message"],
        handler: typing.Callable[[typing_extensions.Self, Message], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["sync-message"],
        handler: typing.Callable[[typing_extensions.Self, Message], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_async"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BusClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def message(self) -> messageBusClassCB: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def sync_message(self) -> sync_messageBusClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BusPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ByteArrayInterface(GObject.GPointer):
    # gi Fields
    data: int = ...
    len: int = ...
    @builtins.property
    def resize(self) -> resizeByteArrayInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Caps(GObject.GBoxed):
    # gi Fields
    mini_object: MiniObject | None = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, caps2: Caps) -> None: ...
    def append_structure(self, structure: Structure) -> None: ...
    def append_structure_full(self, structure: Structure, features: CapsFeatures | None = None) -> None: ...
    def can_intersect(self, caps2: Caps) -> bool: ...
    def copy(self) -> Caps: ...
    def copy_nth(self, nth: int) -> Caps: ...
    def filter_and_map_in_place(self, func: CapsFilterMapFunc, user_data: object | None = None) -> None: ...
    def fixate(self) -> Caps: ...
    def foreach(self, func: CapsForeachFunc, user_data: object | None = None) -> bool: ...
    @staticmethod
    def from_string(string: str) -> Caps | None: ...
    def get_features(self, index: int) -> CapsFeatures | None: ...
    def get_size(self) -> int: ...
    def get_structure(self, index: int) -> Structure: ...
    def id_str_set_value(self, field: IdStr, value: GObject.Value) -> None: ...
    def intersect(self, caps2: Caps) -> Caps: ...
    def intersect_full(self, caps2: Caps, mode: CapsIntersectMode) -> Caps: ...
    def is_always_compatible(self, caps2: Caps) -> bool: ...
    def is_any(self) -> bool: ...
    def is_empty(self) -> bool: ...
    def is_equal(self, caps2: Caps) -> bool: ...
    def is_equal_fixed(self, caps2: Caps) -> bool: ...
    def is_fixed(self) -> bool: ...
    def is_strictly_equal(self, caps2: Caps) -> bool: ...
    def is_subset(self, superset: Caps) -> bool: ...
    def is_subset_structure(self, structure: Structure) -> bool: ...
    def is_subset_structure_full(self, structure: Structure, features: CapsFeatures | None = None) -> bool: ...
    def map_in_place(self, func: CapsMapFunc, user_data: object | None = None) -> bool: ...
    def merge(self, caps2: Caps) -> Caps: ...
    def merge_structure(self, structure: Structure) -> Caps: ...
    def merge_structure_full(self, structure: Structure, features: CapsFeatures | None = None) -> Caps: ...
    @classmethod
    def new_any(cls) -> Caps: ...
    @classmethod
    def new_empty(cls) -> Caps: ...
    @classmethod
    def new_empty_simple(cls, media_type: str) -> Caps: ...
    @classmethod
    def new_id_str_empty_simple(cls, media_type: IdStr) -> Caps: ...
    @classmethod
    def new_static_str_empty_simple(cls, media_type: str) -> Caps: ...
    def normalize(self) -> Caps: ...
    def remove_structure(self, idx: int) -> None: ...
    def serialize(self, flags: SerializeFlags) -> str: ...
    def set_features(self, index: int, features: CapsFeatures | None = None) -> None: ...
    def set_features_simple(self, features: CapsFeatures | None = None) -> None: ...
    def set_value(self, field: str, value: GObject.Value) -> None: ...
    def set_value_static_str(self, field: str, value: GObject.Value) -> None: ...
    def simplify(self) -> Caps: ...
    def steal_structure(self, index: int) -> Structure | None: ...
    def subtract(self, subtrahend: Caps) -> Caps: ...
    def to_string(self) -> str: ...
    def truncate(self) -> Caps: ...

class CapsFeatures(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add(self, feature: str) -> None: ...
    @deprecated("deprecated")
    def add_id(self, feature: int) -> None: ...
    def add_id_str(self, feature: IdStr) -> None: ...
    def add_static_str(self, feature: str) -> None: ...
    def contains(self, feature: str) -> bool: ...
    @deprecated("deprecated")
    def contains_id(self, feature: int) -> bool: ...
    def contains_id_str(self, feature: IdStr) -> bool: ...
    def copy(self) -> CapsFeatures: ...
    def free(self) -> None: ...
    @staticmethod
    def from_string(features: str) -> CapsFeatures | None: ...
    def get_nth(self, i: int) -> str | None: ...
    @deprecated("deprecated")
    def get_nth_id(self, i: int) -> int: ...
    def get_nth_id_str(self, i: int) -> IdStr: ...
    def get_size(self) -> int: ...
    def is_any(self) -> bool: ...
    def is_equal(self, features2: CapsFeatures) -> bool: ...
    @classmethod
    def new_any(cls) -> CapsFeatures: ...
    @classmethod
    def new_empty(cls) -> CapsFeatures: ...
    @classmethod
    def new_single(cls, feature: str) -> CapsFeatures: ...
    @classmethod
    def new_single_static_str(cls, feature: str) -> CapsFeatures: ...
    def remove(self, feature: str) -> None: ...
    @deprecated("deprecated")
    def remove_id(self, feature: int) -> None: ...
    def remove_id_str(self, feature: IdStr) -> None: ...
    def set_parent_refcount(self, refcount: int) -> bool: ...
    def to_string(self) -> str: ...

class ChildProxy(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def child_added(self, child: GObject.Object, name: str) -> None: ...
    def child_removed(self, child: GObject.Object, name: str) -> None: ...
    def get_child_by_index(self, index: int) -> GObject.Object | None: ...
    def get_child_by_name(self, name: str) -> GObject.Object | None: ...
    def get_child_by_name_recurse(self, name: str) -> GObject.Object | None: ...
    def get_children_count(self) -> int: ...
    def get_property(self, name: str) -> GObject.Value: ...
    def lookup(self, name: str) -> tuple[bool, GObject.Object | None, GObject.ParamSpec | None]: ...
    def set_property(self, name: str, value: GObject.Value) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["child-added"],
        handler: typing.Callable[[typing_extensions.Self, GObject.Object, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["child-removed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.Object, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ChildProxyInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def child_added(self) -> child_addedChildProxyInterfaceCB: ...
    @builtins.property
    def child_removed(self) -> child_removedChildProxyInterfaceCB: ...
    @builtins.property
    def get_child_by_index(self) -> get_child_by_indexChildProxyInterfaceCB | None: ...
    @builtins.property
    def get_child_by_name(self) -> get_child_by_nameChildProxyInterfaceCB | None: ...
    @builtins.property
    def get_children_count(self) -> get_children_countChildProxyInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Clock(Object):
    """
    GStreamer uses a global clock to synchronize the plugins in a pipeline.
    Different clock implementations are possible by implementing this abstract
    base class or, more conveniently, by subclassing #GstSystemClock.

    The #GstClock returns a monotonically increasing time with the method
    gst_clock_get_time(). Its accuracy and base time depend on the specific
    clock implementation but time is always expressed in nanoseconds. Since the
    baseline of the clock is undefined, the clock time returned is not
    meaningful in itself, what matters are the deltas between two clock times.
    The time returned by a clock is called the absolute time.

    The pipeline uses the clock to calculate the running time. Usually all
    renderers synchronize to the global clock using the buffer timestamps, the
    #GST_EVENT_SEGMENT events and the element's base time, see #GstPipeline.

    A clock implementation can support periodic and single shot clock
    notifications both synchronous and asynchronous.

    One first needs to create a #GstClockID for the periodic or single shot
    notification using gst_clock_new_single_shot_id() or
    gst_clock_new_periodic_id().

    To perform a blocking wait for the specific time of the #GstClockID use
    gst_clock_id_wait(). To receive a callback when the specific time is reached
    in the clock use gst_clock_id_wait_async(). Both these calls can be
    interrupted with the gst_clock_id_unschedule() call. If the blocking wait is
    unscheduled a return value of #GST_CLOCK_UNSCHEDULED is returned.

    Periodic callbacks scheduled async will be repeatedly called automatically
    until they are unscheduled. To schedule a sync periodic callback,
    gst_clock_id_wait() should be called repeatedly.

    The async callbacks can happen from any thread, either provided by the core
    or from a streaming thread. The application should be prepared for this.

    A #GstClockID that has been unscheduled cannot be used again for any wait
    operation, a new #GstClockID should be created and the old unscheduled one
    should be destroyed with gst_clock_id_unref().

    It is possible to perform a blocking wait on the same #GstClockID from
    multiple threads. However, registering the same #GstClockID for multiple
    async notifications is not possible, the callback will only be called for
    the thread registering the entry last.

    None of the wait operations unref the #GstClockID, the owner is responsible
    for unreffing the ids itself. This holds for both periodic and single shot
    notifications. The reason being that the owner of the #GstClockID has to
    keep a handle to the #GstClockID to unblock the wait on FLUSHING events or
    state changes and if the entry would be unreffed automatically, the handle
    might become invalid without any notification.

    These clock operations do not operate on the running time, so the callbacks
    will also occur when not in PLAYING state as if the clock just keeps on
    running. Some clocks however do not progress when the element that provided
    the clock is not PLAYING.

    When a clock has the #GST_CLOCK_FLAG_CAN_SET_MASTER flag set, it can be
    slaved to another #GstClock with gst_clock_set_master(). The clock will
    then automatically be synchronized to this master clock by repeatedly
    sampling the master clock and the slave clock and recalibrating the slave
    clock with gst_clock_set_calibration(). This feature is mostly useful for
    plugins that have an internal clock but must operate with another clock
    selected by the #GstPipeline.  They can track the offset and rate difference
    of their internal clock relative to the master clock by using the
    gst_clock_get_calibration() function.

    The master/slave synchronisation can be tuned with the #GstClock:timeout,
    #GstClock:window-size and #GstClock:window-threshold properties.
    The #GstClock:timeout property defines the interval to sample the master
    clock and run the calibration functions. #GstClock:window-size defines the
    number of samples to use when calibrating and #GstClock:window-threshold
    defines the minimum number of samples before the calibration is performed.
    """

    class Props(Object.Props):
        timeout: int
        window_size: int  # [window-size]: changed because contained invalid characters
        window_threshold: int  # [window-threshold]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def object(self) -> Object | None: ...

    # gi Methods
    def __init__(self, timeout: int = ..., window_size: int = ..., window_threshold: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_observation(self, observation_internal: int, observation_external: int) -> tuple[bool, float]: ...
    def add_observation_unapplied(
        self, observation_internal: int, observation_external: int
    ) -> tuple[bool, float, int | None, int | None, int | None, int | None]: ...
    def adjust_unlocked(self, internal: int) -> int: ...
    def adjust_with_calibration(
        self, internal_target: int, cinternal: int, cexternal: int, cnum: int, cdenom: int
    ) -> int: ...
    def get_calibration(self) -> tuple[int | None, int | None, int | None, int | None]: ...
    def get_internal_time(self) -> int: ...
    def get_master(self) -> Clock | None: ...
    def get_resolution(self) -> int: ...
    def get_time(self) -> int: ...
    @builtins.property
    def get_timeout(self) -> int: ...
    @staticmethod
    def id_compare_func(id1: object | None = None, id2: object | None = None) -> int: ...
    @staticmethod
    def id_get_clock(id: object) -> Clock | None: ...
    @staticmethod
    def id_get_time(id: object) -> int: ...
    @staticmethod
    def id_ref(id: object) -> object: ...
    @staticmethod
    def id_unref(id: object) -> None: ...
    @staticmethod
    def id_unschedule(id: object) -> None: ...
    @staticmethod
    def id_uses_clock(id: object, clock: Clock) -> bool: ...
    @staticmethod
    def id_wait(id: object) -> tuple[ClockReturn, int | None]: ...
    @staticmethod
    def id_wait_async(
        id: object, func: ClockCallback, user_data: object | None, destroy_data: GLib.DestroyNotify
    ) -> ClockReturn: ...
    def is_synced(self) -> bool: ...
    def new_periodic_id(self, start_time: int, interval: int) -> object: ...
    def new_single_shot_id(self, time: int) -> object: ...
    def periodic_id_reinit(self, id: object, start_time: int, interval: int) -> bool: ...
    def set_calibration(self, internal: int, external: int, rate_num: int, rate_denom: int) -> None: ...
    def set_master(self, master: Clock | None = None) -> bool: ...
    def set_resolution(self, resolution: int) -> int: ...
    def set_synced(self, synced: bool) -> None: ...
    def set_timeout(self, timeout: int) -> None: ...
    def single_shot_id_reinit(self, id: object, time: int) -> bool: ...
    def unadjust_unlocked(self, external: int) -> int: ...
    def unadjust_with_calibration(
        self, external_target: int, cinternal: int, cexternal: int, cnum: int, cdenom: int
    ) -> int: ...
    def wait_for_sync(self, timeout: int) -> bool: ...

    # python methods (overrides?)
    def do_change_resolution(
        self,
        old_resolution: int,
        new_resolution: int,
    ) -> int:
        """
        change_resolution(self, old_resolution:int, new_resolution:int) -> int
        """
    def do_get_internal_time(
        self,
    ) -> int:
        """
        get_internal_time(self) -> int
        """
    def do_get_resolution(
        self,
    ) -> int:
        """
        get_resolution(self) -> int
        """
    def do_unschedule(
        self,
        entry: ClockEntry,
    ) -> None:
        """
        unschedule(self, entry:Gst.ClockEntry)
        """
    def do_wait(
        self,
        entry: ClockEntry,
    ) -> tuple:
        """
        wait(self, entry:Gst.ClockEntry) -> Gst.ClockReturn, jitter:int
        """
    def do_wait_async(
        self,
        entry: ClockEntry,
    ) -> ClockReturn:
        """
        wait_async(self, entry:Gst.ClockEntry) -> Gst.ClockReturn
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["synced"],
        handler: typing.Callable[[typing_extensions.Self, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::window_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::window_threshold"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ClockClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def change_resolution(self) -> change_resolutionClockClassCB: ...
    @builtins.property
    def get_internal_time(self) -> get_internal_timeClockClassCB: ...
    @builtins.property
    def get_resolution(self) -> get_resolutionClockClassCB: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def unschedule(self) -> unscheduleClockClassCB: ...
    @builtins.property
    def wait(self) -> waitClockClassCB: ...
    @builtins.property
    def wait_async(self) -> wait_asyncClockClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ClockEntry(GObject.GPointer):
    # gi Fields
    @builtins.property
    def clock(self) -> Clock | None: ...
    @builtins.property
    def destroy_data(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def func(self) -> ClockCallbackClockEntryCB: ...
    @builtins.property
    def interval(self) -> int: ...
    refcount: int = ...
    @builtins.property
    def status(self) -> ClockReturn: ...
    @builtins.property
    def time(self) -> int: ...
    @builtins.property
    def type(self) -> ClockEntryType: ...
    @builtins.property
    def unscheduled(self) -> bool: ...
    @builtins.property
    def woken_up(self) -> bool: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ClockPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Context(GObject.GBoxed):
    # gi Methods
    def get_context_type(self) -> str: ...
    def get_structure(self) -> Structure: ...
    def has_context_type(self, context_type: str) -> bool: ...
    def is_persistent(self) -> bool: ...
    @classmethod
    def new(cls, context_type: str, persistent: bool) -> Context: ...
    def writable_structure(self) -> Structure: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class ControlBinding(Object):
    """
    A base class for value mapping objects that attaches control sources to #GObject
    properties. Such an object is taking one or more #GstControlSource instances,
    combines them and maps the resulting value to the type and value range of the
    bound property.
    """

    class Props(Object.Props):
        name: str
        object: Object | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def disabled(self) -> bool: ...
    @builtins.property
    def name(self) -> str: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def pspec(self) -> GObject.ParamSpec | None: ...

    # gi Methods
    def __init__(self, name: str = ..., object: Object | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_g_value_array(self, timestamp: int, interval: int, n_values: int, values: list) -> bool: ...
    def get_value(self, timestamp: int) -> GObject.Value | None: ...
    def is_disabled(self) -> bool: ...
    def set_disabled(self, disabled: bool) -> None: ...
    def sync_values(self, object: Object, timestamp: int, last_sync: int) -> bool: ...

    # python methods (overrides?)
    def do_get_g_value_array(
        self,
        timestamp: int,
        interval: int,
        values: list,
    ) -> bool:
        """
        get_g_value_array(self, timestamp:int, interval:int, values:list) -> bool
        """
    def do_get_value(
        self,
        timestamp: int,
    ) -> GObject.Value | None:
        """
        get_value(self, timestamp:int) -> GObject.Value or None
        """
    def do_sync_values(
        self,
        object: Object,
        timestamp: int,
        last_sync: int,
    ) -> bool:
        """
        sync_values(self, object:Gst.Object, timestamp:int, last_sync:int) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::object"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ControlBindingClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def get_g_value_array(self) -> get_g_value_arrayControlBindingClassCB: ...
    @builtins.property
    def get_value(self) -> get_valueControlBindingClassCB | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def sync_values(self) -> sync_valuesControlBindingClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ControlBindingPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ControlSource(Object):
    """
    The #GstControlSource is a base class for control value sources that could
    be used to get timestamp-value pairs. A control source essentially is a
    function over time.

    A #GstControlSource is used by first getting an instance of a specific
    control-source, creating a binding for the control-source to the target property
    of the element and then adding the binding to the element. The binding will
    convert the data types and value range to fit to the bound property.

    For implementing a new #GstControlSource one has to implement
    #GstControlSourceGetValue and #GstControlSourceGetValueArray functions.
    These are then used by gst_control_source_get_value() and
    gst_control_source_get_value_array() to get values for specific timestamps.
    """

    # gi Fields
    @builtins.property
    def get_value(self) -> ControlSourceGetValueControlSourceCB: ...
    @builtins.property
    def get_value_array(self) -> ControlSourceGetValueArrayControlSourceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def control_source_get_value(self, timestamp: int) -> tuple[bool, float]: ...
    def control_source_get_value_array(self, timestamp: int, interval: int, n_values: int, values: list) -> bool: ...

class ControlSourceClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CustomMeta(GObject.GPointer):
    # gi Fields
    meta: Meta | None = ...
    structure: Structure | None = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_structure(self) -> Structure: ...
    def has_name(self, name: str) -> bool: ...

class DateTime(GObject.GBoxed):
    # gi Methods
    def get_day(self) -> int: ...
    def get_hour(self) -> int: ...
    def get_microsecond(self) -> int: ...
    def get_minute(self) -> int: ...
    def get_month(self) -> int: ...
    def get_second(self) -> int: ...
    def get_time_zone_offset(self) -> float: ...
    def get_year(self) -> int: ...
    def has_day(self) -> bool: ...
    def has_month(self) -> bool: ...
    def has_second(self) -> bool: ...
    def has_time(self) -> bool: ...
    def has_year(self) -> bool: ...
    @classmethod
    def new(
        cls, tzoffset: float, year: int, month: int, day: int, hour: int, minute: int, seconds: float
    ) -> DateTime | None: ...
    @classmethod
    def new_from_g_date_time(cls, dt: GLib.DateTime | None = None) -> DateTime | None: ...
    @classmethod
    def new_from_iso8601_string(cls, string: str) -> DateTime | None: ...
    @classmethod
    def new_from_unix_epoch_local_time(cls, secs: int) -> DateTime | None: ...
    @classmethod
    def new_from_unix_epoch_local_time_usecs(cls, usecs: int) -> DateTime | None: ...
    @classmethod
    def new_from_unix_epoch_utc(cls, secs: int) -> DateTime | None: ...
    @classmethod
    def new_from_unix_epoch_utc_usecs(cls, usecs: int) -> DateTime | None: ...
    @classmethod
    def new_local_time(
        cls, year: int, month: int, day: int, hour: int, minute: int, seconds: float
    ) -> DateTime | None: ...
    @classmethod
    def new_now_local_time(cls) -> DateTime | None: ...
    @classmethod
    def new_now_utc(cls) -> DateTime | None: ...
    @classmethod
    def new_y(cls, year: int) -> DateTime | None: ...
    @classmethod
    def new_ym(cls, year: int, month: int) -> DateTime | None: ...
    @classmethod
    def new_ymd(cls, year: int, month: int, day: int) -> DateTime | None: ...
    def ref(self) -> DateTime: ...
    def to_g_date_time(self) -> GLib.DateTime | None: ...
    def to_iso8601_string(self) -> str | None: ...
    def unref(self) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class DebugCategory(GObject.GPointer):
    # gi Fields
    @builtins.property
    def color(self) -> int: ...
    @builtins.property
    def description(self) -> str: ...
    @builtins.property
    def name(self) -> str: ...
    @builtins.property
    def threshold(self) -> int: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def free(self) -> None: ...
    def get_color(self) -> int: ...
    def get_description(self) -> str: ...
    def get_name(self) -> str: ...
    def get_threshold(self) -> DebugLevel: ...
    def reset_threshold(self) -> None: ...
    def set_threshold(self, level: DebugLevel) -> None: ...

class DebugMessage(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get(self) -> str | None: ...
    def get_id(self) -> str | None: ...

class Device(Object):
    """
    #GstDevice are objects representing a device, they contain
    relevant metadata about the device, such as its class and the #GstCaps
    representing the media types it can produce or handle.

    #GstDevice are created by #GstDeviceProvider objects which can be
    aggregated by #GstDeviceMonitor objects.
    """

    class Props(Object.Props):
        caps: Caps | None
        device_class: str  # [device-class]: changed because contained invalid characters
        display_name: str  # [display-name]: changed because contained invalid characters
        properties: Structure | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        caps: Caps | None = ...,
        device_class: str = ...,
        display_name: str = ...,
        properties: Structure | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def create_element(self, name: str | None = None) -> Element | None: ...
    @builtins.property
    def get_caps(self) -> Caps | None: ...
    @builtins.property
    def get_device_class(self) -> str: ...
    @builtins.property
    def get_display_name(self) -> str: ...
    @builtins.property
    def get_properties(self) -> Structure | None: ...
    def has_classes(self, classes: str) -> bool: ...
    def has_classesv(self, classes: list) -> bool: ...
    def reconfigure_element(self, element: Element) -> bool: ...

    # python methods (overrides?)
    def do_create_element(
        self,
        name: str | None = None,
    ) -> Element | None:
        """
        create_element(self, name:str=None) -> Gst.Element or None
        """
    def do_reconfigure_element(
        self,
        element: Element,
    ) -> bool:
        """
        reconfigure_element(self, element:Gst.Element) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["removed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::device_class"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::display_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::properties"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DeviceClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def create_element(self) -> create_elementDeviceClassCB | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def reconfigure_element(self) -> reconfigure_elementDeviceClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DeviceMonitor(Object):
    """
    Applications should create a #GstDeviceMonitor when they want
    to probe, list and monitor devices of a specific type. The
    #GstDeviceMonitor will create the appropriate
    #GstDeviceProvider objects and manage them. It will then post
    messages on its #GstBus for devices that have been added and
    removed.

    The device monitor will monitor all devices matching the filters that
    the application has set.

    The basic use pattern of a device monitor is as follows:
    |[
      static gboolean
      my_bus_func (GstBus * bus, GstMessage * message, gpointer user_data)
      {
         GstDevice *device;
         gchar *name;

         switch (GST_MESSAGE_TYPE (message)) {
           case GST_MESSAGE_DEVICE_ADDED:
             gst_message_parse_device_added (message, &device);
             name = gst_device_get_display_name (device);
             g_print("Device added: %s\\n", name);
             g_free (name);
             gst_object_unref (device);
             break;
           case GST_MESSAGE_DEVICE_REMOVED:
             gst_message_parse_device_removed (message, &device);
             name = gst_device_get_display_name (device);
             g_print("Device removed: %s\\n", name);
             g_free (name);
             gst_object_unref (device);
             break;
           default:
             break;
         }

         return G_SOURCE_CONTINUE;
      }

      GstDeviceMonitor *
      setup_raw_video_source_device_monitor (void) {
         GstDeviceMonitor *monitor;
         GstBus *bus;
         GstCaps *caps;

         monitor = gst_device_monitor_new ();

         bus = gst_device_monitor_get_bus (monitor);
         gst_bus_add_watch (bus, my_bus_func, NULL);
         gst_object_unref (bus);

         caps = gst_caps_new_empty_simple ("video/x-raw");
         gst_device_monitor_add_filter (monitor, "Video/Source", caps);
         gst_caps_unref (caps);

         gst_device_monitor_start (monitor);

         return monitor;
      }
    ]|
    """

    class Props(Object.Props):
        show_all: bool  # [show-all]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, show_all: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_filter(self, classes: str | None = None, caps: Caps | None = None) -> int: ...
    def get_bus(self) -> Bus: ...
    def get_devices(self) -> list | None: ...
    def get_providers(self) -> list: ...
    def get_show_all_devices(self) -> bool: ...
    @classmethod
    def new(cls) -> DeviceMonitor: ...
    def remove_filter(self, filter_id: int) -> bool: ...
    def set_show_all_devices(self, show_all: bool) -> None: ...
    def start(self) -> bool: ...
    def stop(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_all"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DeviceMonitorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DeviceMonitorPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DevicePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DeviceProvider(Object):
    """
    A #GstDeviceProvider subclass is provided by a plugin that handles devices
    if there is a way to programmatically list connected devices. It can also
    optionally provide updates to the list of connected devices.

    Each #GstDeviceProvider subclass is a singleton, a plugin should
    normally provide a single subclass for all devices.

    Applications would normally use a #GstDeviceMonitor to monitor devices
    from all relevant providers.
    """

    # gi Fields
    @builtins.property
    def devices(self) -> list | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_monitor(self) -> bool: ...
    def device_add(self, device: Device) -> None: ...
    def device_changed(self, device: Device, changed_device: Device) -> None: ...
    def device_remove(self, device: Device) -> None: ...
    def get_bus(self) -> Bus: ...
    def get_devices(self) -> list: ...
    def get_factory(self) -> DeviceProviderFactory | None: ...
    def get_hidden_providers(self) -> list: ...
    def get_metadata(self, key: str) -> str: ...
    def hide_provider(self, name: str) -> None: ...
    def is_started(self) -> bool: ...
    @staticmethod
    def register(plugin: Plugin | None, name: str, rank: int, type: GObject.GType) -> bool: ...
    def start(self) -> bool: ...
    def stop(self) -> None: ...
    def unhide_provider(self, name: str) -> None: ...

    # python methods (overrides?)
    @classmethod
    def add_metadata(
        cls,
        key: str,
        value: str,
    ) -> None:
        """
        add_metadata(self, key:str, value:str)
        """
    @classmethod
    def add_static_metadata(
        cls,
        key: str,
        value: str,
    ) -> None:
        """
        add_static_metadata(self, key:str, value:str)
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> None:
        """
        stop(self)
        """
    @classmethod
    def set_metadata(
        cls,
        longname: str,
        classification: str,
        description: str,
        author: str,
    ) -> None:
        """
        set_metadata(self, longname:str, classification:str, description:str, author:str)
        """
    @classmethod
    def set_static_metadata(
        cls,
        longname: str,
        classification: str,
        description: str,
        author: str,
    ) -> None:
        """
        set_static_metadata(self, longname:str, classification:str, description:str, author:str)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["provider-hidden"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["provider-unhidden"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DeviceProviderClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def factory(self) -> DeviceProviderFactory | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def start(self) -> startDeviceProviderClassCB: ...
    @builtins.property
    def stop(self) -> stopDeviceProviderClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_metadata(self, key: str, value: str) -> None: ...
    def add_static_metadata(self, key: str, value: str) -> None: ...
    def get_metadata(self, key: str) -> str | None: ...
    def set_metadata(self, longname: str, classification: str, description: str, author: str) -> None: ...
    def set_static_metadata(self, longname: str, classification: str, description: str, author: str) -> None: ...

class DeviceProviderFactory(PluginFeature):
    """
    #GstDeviceProviderFactory is used to create instances of device providers. A
    GstDeviceProviderfactory can be added to a #GstPlugin as it is also a
    #GstPluginFeature.

    Use the gst_device_provider_factory_find() and
    gst_device_provider_factory_get() functions to create device
    provider instances or use gst_device_provider_factory_get_by_name() as a
    convenient shortcut.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def find(name: str) -> DeviceProviderFactory | None: ...
    def get(self) -> DeviceProvider | None: ...
    @staticmethod
    def get_by_name(factoryname: str) -> DeviceProvider | None: ...
    def get_device_provider_type(self) -> GObject.GType: ...
    def get_metadata(self, key: str) -> str | None: ...
    def get_metadata_keys(self) -> list | None: ...
    def has_classes(self, classes: str | None = None) -> bool: ...
    def has_classesv(self, classes: list | None = None) -> bool: ...
    @staticmethod
    def list_get_device_providers(minrank: Rank) -> list: ...

class DeviceProviderFactoryClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DeviceProviderPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DoubleRange(object):
    """
    A fundamental type that describes a #gdouble range
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DynamicTypeFactory(PluginFeature):
    """
    #GstDynamicTypeFactory is used to represent a type that can be
    automatically loaded the first time it is used. For example,
    a non-standard type for use in caps fields.

    In general, applications and plugins don't need to use the factory
    beyond registering the type in a plugin init function. Once that is
    done, the type is stored in the registry, and ready as soon as the
    registry is loaded.

    ## Registering a type for dynamic loading

    |[<!-- language="C" -->

    static gboolean
    plugin_init (GstPlugin * plugin)
    {
      return gst_dynamic_type_register (plugin, GST_TYPE_CUSTOM_CAPS_FIELD);
    }
    ]|
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def load(factoryname: str) -> GObject.GType: ...

class DynamicTypeFactoryClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Element(Object):
    """
    GstElement is the abstract base class needed to construct an element that
    can be used in a GStreamer pipeline. Please refer to the plugin writers
    guide for more information on creating #GstElement subclasses.

    The name of a #GstElement can be get with gst_element_get_name() and set with
    gst_element_set_name().  For speed, GST_ELEMENT_NAME() can be used in the
    core when using the appropriate locking. Do not use this in plug-ins or
    applications in order to retain ABI compatibility.

    Elements can have pads (of the type #GstPad).  These pads link to pads on
    other elements.  #GstBuffer flow between these linked pads.
    A #GstElement has a #GList of #GstPad structures for all their input (or sink)
    and output (or source) pads.
    Core and plug-in writers can add and remove pads with gst_element_add_pad()
    and gst_element_remove_pad().

    An existing pad of an element can be retrieved by name with
    gst_element_get_static_pad(). A new dynamic pad can be created using
    gst_element_request_pad() with a #GstPadTemplate.
    An iterator of all pads can be retrieved with gst_element_iterate_pads().

    Elements can be linked through their pads.
    If the link is straightforward, use the gst_element_link()
    convenience function to link two elements, or gst_element_link_many()
    for more elements in a row.
    Use gst_element_link_filtered() to link two elements constrained by
    a specified set of #GstCaps.
    For finer control, use gst_element_link_pads() and
    gst_element_link_pads_filtered() to specify the pads to link on
    each element by name.

    Each element has a state (see #GstState).  You can get and set the state
    of an element with gst_element_get_state() and gst_element_set_state().
    Setting a state triggers a #GstStateChange. To get a string representation
    of a #GstState, use gst_element_state_get_name().

    You can get and set a #GstClock on an element using gst_element_get_clock()
    and gst_element_set_clock().
    Some elements can provide a clock for the pipeline if
    the #GST_ELEMENT_FLAG_PROVIDE_CLOCK flag is set. With the
    gst_element_provide_clock() method one can retrieve the clock provided by
    such an element.
    Not all elements require a clock to operate correctly. If the
    #GST_ELEMENT_FLAG_REQUIRE_CLOCK() flag is set, a clock should be set on the
    element with gst_element_set_clock().

    Note that clock selection and distribution is normally handled by the
    toplevel #GstPipeline so the clock functions are only to be used in very
    specific situations.
    """

    # gi Fields
    @builtins.property
    def base_time(self) -> int: ...
    @builtins.property
    def bus(self) -> Bus | None: ...
    @builtins.property
    def clock(self) -> Clock | None: ...
    @builtins.property
    def contexts(self) -> list | None: ...
    @builtins.property
    def current_state(self) -> State: ...
    @builtins.property
    def last_return(self) -> StateChangeReturn: ...
    @builtins.property
    def next_state(self) -> State: ...
    @builtins.property
    def numpads(self) -> int: ...
    @builtins.property
    def numsinkpads(self) -> int: ...
    @builtins.property
    def numsrcpads(self) -> int: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def pads(self) -> list | None: ...
    @builtins.property
    def pads_cookie(self) -> int: ...
    @builtins.property
    def pending_state(self) -> State: ...
    @builtins.property
    def sinkpads(self) -> list | None: ...
    @builtins.property
    def srcpads(self) -> list | None: ...
    @builtins.property
    def start_time(self) -> int: ...
    @builtins.property
    def state_cond(self) -> GLib.Cond | None: ...
    @builtins.property
    def state_cookie(self) -> int: ...
    @builtins.property
    def state_lock(self) -> GLib.RecMutex | None: ...
    @builtins.property
    def target_state(self) -> State: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def abort_state(self) -> None: ...
    def add_pad(self, pad: Pad) -> bool: ...
    def add_property_deep_notify_watch(self, property_name: str | None, include_value: bool) -> int: ...
    def add_property_notify_watch(self, property_name: str | None, include_value: bool) -> int: ...
    def call_async(
        self, func: ElementCallAsyncFunc, user_data: object | None, destroy_notify: GLib.DestroyNotify
    ) -> None: ...
    def change_state(self, transition: StateChange) -> StateChangeReturn: ...
    def continue_state(self, ret: StateChangeReturn) -> StateChangeReturn: ...
    def create_all_pads(self) -> None: ...
    def decorate_stream_id(self, stream_id: str) -> str: ...
    def foreach_pad(self, func: ElementForeachPadFunc, user_data: object | None = None) -> bool: ...
    def foreach_sink_pad(self, func: ElementForeachPadFunc, user_data: object | None = None) -> bool: ...
    def foreach_src_pad(self, func: ElementForeachPadFunc, user_data: object | None = None) -> bool: ...
    def get_base_time(self) -> int: ...
    def get_bus(self) -> Bus | None: ...
    def get_clock(self) -> Clock | None: ...
    def get_compatible_pad(self, pad: Pad, caps: Caps | None = None) -> Pad | None: ...
    def get_compatible_pad_template(self, compattempl: PadTemplate) -> PadTemplate | None: ...
    def get_context(self, context_type: str) -> Context | None: ...
    def get_context_unlocked(self, context_type: str) -> Context | None: ...
    def get_contexts(self) -> list: ...
    def get_current_clock_time(self) -> int: ...
    def get_current_running_time(self) -> int: ...
    def get_factory(self) -> ElementFactory | None: ...
    def get_metadata(self, key: str) -> str: ...
    def get_pad_template(self, name: str) -> PadTemplate | None: ...
    def get_pad_template_list(self) -> list: ...
    @deprecated("deprecated")
    def get_request_pad(self, name: str) -> Pad | None: ...
    def get_start_time(self) -> int: ...
    def get_state(self, timeout: int) -> tuple[StateChangeReturn, State | None, State | None]: ...
    def get_static_pad(self, name: str) -> Pad | None: ...
    def is_locked_state(self) -> bool: ...
    def iterate_pads(self) -> Iterator: ...
    def iterate_sink_pads(self) -> Iterator: ...
    def iterate_src_pads(self) -> Iterator: ...
    def link(self, dest: Element) -> bool: ...
    def link_filtered(self, dest: Element, filter: Caps | None = None) -> bool: ...
    def link_pads(self, srcpadname: str | None, dest: Element, destpadname: str | None = None) -> bool: ...
    def link_pads_filtered(
        self, srcpadname: str | None, dest: Element, destpadname: str | None = None, filter: Caps | None = None
    ) -> bool: ...
    def link_pads_full(
        self, srcpadname: str | None, dest: Element, destpadname: str | None, flags: PadLinkCheck
    ) -> bool: ...
    def lost_state(self) -> None: ...
    @staticmethod
    def make_from_uri(type: URIType, uri: str, elementname: str | None = None) -> Element: ...
    def message_full(
        self,
        type: MessageType,
        domain: int,
        code: int,
        text: str | None,
        debug: str | None,
        file: str,
        function: str,
        line: int,
    ) -> None: ...
    def message_full_with_details(
        self,
        type: MessageType,
        domain: int,
        code: int,
        text: str | None,
        debug: str | None,
        file: str,
        function: str,
        line: int,
        structure: Structure,
    ) -> None: ...
    def no_more_pads(self) -> None: ...
    def post_message(self, message: Message) -> bool: ...
    def provide_clock(self) -> Clock | None: ...
    def query(self, query: Query) -> bool: ...
    def query_convert(self, src_format: Format, src_val: int, dest_format: Format) -> tuple[bool, int]: ...
    def query_duration(self, format: Format) -> tuple[bool, int | None]: ...
    def query_position(self, format: Format) -> tuple[bool, int | None]: ...
    @staticmethod
    def register(plugin: Plugin | None, name: str, rank: int, type: GObject.GType) -> bool: ...
    def release_request_pad(self, pad: Pad) -> None: ...
    def remove_pad(self, pad: Pad) -> bool: ...
    def remove_property_notify_watch(self, watch_id: int) -> None: ...
    def request_pad(self, templ: PadTemplate, name: str | None = None, caps: Caps | None = None) -> Pad | None: ...
    def request_pad_simple(self, name: str) -> Pad | None: ...
    def seek(
        self,
        rate: float,
        format: Format,
        flags: SeekFlags,
        start_type: SeekType,
        start: int,
        stop_type: SeekType,
        stop: int,
    ) -> bool: ...
    def seek_simple(self, format: Format, seek_flags: SeekFlags, seek_pos: int) -> bool: ...
    def send_event(self, event: Event) -> bool: ...
    def set_base_time(self, time: int) -> None: ...
    def set_bus(self, bus: Bus | None = None) -> None: ...
    def set_clock(self, clock: Clock | None = None) -> bool: ...
    def set_context(self, context: Context) -> None: ...
    def set_locked_state(self, locked_state: bool) -> bool: ...
    def set_start_time(self, time: int) -> None: ...
    def set_state(self, state: State) -> StateChangeReturn: ...
    @staticmethod
    def state_change_return_get_name(state_ret: StateChangeReturn) -> str: ...
    @staticmethod
    def state_get_name(state: State) -> str: ...
    def sync_state_with_parent(self) -> bool: ...
    @staticmethod
    def type_set_skip_documentation(type: GObject.GType) -> None: ...
    def unlink(self, dest: Element) -> None: ...
    def unlink_pads(self, srcpadname: str, dest: Element, destpadname: str) -> None: ...

    # python methods (overrides?)
    @classmethod
    def add_metadata(
        cls,
        key: str,
        value: str,
    ) -> None:
        """
        add_metadata(self, key:str, value:str)
        """
    @classmethod
    def add_pad_template(
        cls,
        templ: PadTemplate,
    ) -> None:
        """
        add_pad_template(self, templ:Gst.PadTemplate)
        """
    @classmethod
    def add_static_metadata(
        cls,
        key: str,
        value: str,
    ) -> None:
        """
        add_static_metadata(self, key:str, value:str)
        """
    @classmethod
    def add_static_pad_template(
        cls,
        static_templ: StaticPadTemplate,
    ) -> None:
        """
        add_static_pad_template(self, static_templ:Gst.StaticPadTemplate)
        """
    @classmethod
    def add_static_pad_template_with_gtype(
        cls,
        static_templ: StaticPadTemplate,
        pad_type: GObject.GType,
    ) -> None:
        """
        add_static_pad_template_with_gtype(self, static_templ:Gst.StaticPadTemplate, pad_type:GType)
        """
    def do_change_state(
        self,
        transition: StateChange,
    ) -> StateChangeReturn:
        """
        change_state(self, transition:Gst.StateChange) -> Gst.StateChangeReturn
        """
    def do_get_state(
        self,
        timeout: int,
    ) -> tuple:
        """
        get_state(self, timeout:int) -> Gst.StateChangeReturn, state:Gst.State, pending:Gst.State
        """
    def do_no_more_pads(
        self,
    ) -> None:
        """
        no_more_pads(self)
        """
    def do_pad_added(
        self,
        pad: Pad,
    ) -> None:
        """
        pad_added(self, pad:Gst.Pad)
        """
    def do_pad_removed(
        self,
        pad: Pad,
    ) -> None:
        """
        pad_removed(self, pad:Gst.Pad)
        """
    def do_post_message(
        self,
        message: Message,
    ) -> bool:
        """
        post_message(self, message:Gst.Message) -> bool
        """
    def do_provide_clock(
        self,
    ) -> Clock | None:
        """
        provide_clock(self) -> Gst.Clock or None
        """
    def do_query(
        self,
        query: Query,
    ) -> bool:
        """
        query(self, query:Gst.Query) -> bool
        """
    def do_release_pad(
        self,
        pad: Pad,
    ) -> None:
        """
        release_pad(self, pad:Gst.Pad)
        """
    def do_request_new_pad(
        self,
        templ: PadTemplate,
        name: str | None = None,
        caps: Caps | None = None,
    ) -> Pad | None:
        """
        request_new_pad(self, templ:Gst.PadTemplate, name:str=None, caps:Gst.Caps=None) -> Gst.Pad or None
        """
    def do_send_event(
        self,
        event: Event,
    ) -> bool:
        """
        send_event(self, event:Gst.Event) -> bool
        """
    def do_set_bus(
        self,
        bus: Bus | None = None,
    ) -> None:
        """
        set_bus(self, bus:Gst.Bus=None)
        """
    def do_set_clock(
        self,
        clock: Clock | None = None,
    ) -> bool:
        """
        set_clock(self, clock:Gst.Clock=None) -> bool
        """
    def do_set_context(
        self,
        context: Context,
    ) -> None:
        """
        set_context(self, context:Gst.Context)
        """
    def do_set_state(
        self,
        state: State,
    ) -> StateChangeReturn:
        """
        set_state(self, state:Gst.State) -> Gst.StateChangeReturn
        """
    def do_state_changed(
        self,
        oldstate: State,
        newstate: State,
        pending: State,
    ) -> None:
        """
        state_changed(self, oldstate:Gst.State, newstate:Gst.State, pending:Gst.State)
        """
    @classmethod
    def set_metadata(
        cls,
        longname: str,
        classification: str,
        description: str,
        author: str,
    ) -> None:
        """
        set_metadata(self, longname:str, classification:str, description:str, author:str)
        """
    @classmethod
    def set_static_metadata(
        cls,
        longname: str,
        classification: str,
        description: str,
        author: str,
    ) -> None:
        """
        set_static_metadata(self, longname:str, classification:str, description:str, author:str)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["no-more-pads"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pad-added"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pad-removed"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ElementClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def change_state(self) -> change_stateElementClassCB: ...
    @builtins.property
    def elementfactory(self) -> ElementFactory | None: ...
    @builtins.property
    def get_state(self) -> get_stateElementClassCB: ...
    @builtins.property
    def no_more_pads(self) -> no_more_padsElementClassCB: ...
    @builtins.property
    def numpadtemplates(self) -> int: ...
    @builtins.property
    def pad_added(self) -> pad_addedElementClassCB: ...
    @builtins.property
    def pad_removed(self) -> pad_removedElementClassCB: ...
    @builtins.property
    def pad_templ_cookie(self) -> int: ...
    @builtins.property
    def padtemplates(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def post_message(self) -> post_messageElementClassCB: ...
    @builtins.property
    def provide_clock(self) -> provide_clockElementClassCB | None: ...
    @builtins.property
    def query(self) -> queryElementClassCB: ...
    @builtins.property
    def release_pad(self) -> release_padElementClassCB: ...
    @builtins.property
    def request_new_pad(self) -> request_new_padElementClassCB | None: ...
    @builtins.property
    def send_event(self) -> send_eventElementClassCB: ...
    @builtins.property
    def set_bus(self) -> set_busElementClassCB: ...
    @builtins.property
    def set_clock(self) -> set_clockElementClassCB: ...
    @builtins.property
    def set_context(self) -> set_contextElementClassCB: ...
    @builtins.property
    def set_state(self) -> set_stateElementClassCB: ...
    @builtins.property
    def state_changed(self) -> state_changedElementClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_metadata(self, key: str, value: str) -> None: ...
    def add_pad_template(self, templ: PadTemplate) -> None: ...
    def add_static_metadata(self, key: str, value: str) -> None: ...
    def add_static_pad_template(self, static_templ: StaticPadTemplate) -> None: ...
    def add_static_pad_template_with_gtype(self, static_templ: StaticPadTemplate, pad_type: GObject.GType) -> None: ...
    def get_metadata(self, key: str) -> str: ...
    def get_pad_template(self, name: str) -> PadTemplate | None: ...
    def get_pad_template_list(self) -> list: ...
    def set_metadata(self, longname: str, classification: str, description: str, author: str) -> None: ...
    def set_static_metadata(self, longname: str, classification: str, description: str, author: str) -> None: ...

class ElementFactory(PluginFeature):
    """
    #GstElementFactory is used to create instances of elements. A
    GstElementFactory can be added to a #GstPlugin as it is also a
    #GstPluginFeature.

    Use the gst_element_factory_find() and gst_element_factory_create()
    functions to create element instances or use gst_element_factory_make() as a
    convenient shortcut.

    The following code example shows you how to create a GstFileSrc element.

    ## Using an element factory
    |[<!-- language="C" -->
      #include <gst/gst.h>

      GstElement *src;
      GstElementFactory *srcfactory;

      gst_init (&argc, &argv);

      srcfactory = gst_element_factory_find ("filesrc");
      g_return_if_fail (srcfactory != NULL);
      src = gst_element_factory_create (srcfactory, "src");
      g_return_if_fail (src != NULL);
      ...
    ]|
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_sink_all_caps(self, caps: Caps) -> bool: ...
    def can_sink_any_caps(self, caps: Caps) -> bool: ...
    def can_src_all_caps(self, caps: Caps) -> bool: ...
    def can_src_any_caps(self, caps: Caps) -> bool: ...
    def create(self, name: str | None = None) -> Element | None: ...
    def create_with_properties(
        self, n: int, names: list | None = None, values: list | None = None
    ) -> Element | None: ...
    @staticmethod
    def find(name: str) -> ElementFactory | None: ...
    def get_element_type(self) -> GObject.GType: ...
    def get_metadata(self, key: str) -> str | None: ...
    def get_metadata_keys(self) -> list | None: ...
    def get_num_pad_templates(self) -> int: ...
    def get_skip_documentation(self) -> bool: ...
    def get_static_pad_templates(self) -> list: ...
    def get_uri_protocols(self) -> list: ...
    def get_uri_type(self) -> URIType: ...
    def has_interface(self, interfacename: str) -> bool: ...
    @staticmethod
    def list_filter(list: list, caps: Caps, direction: PadDirection, subsetonly: bool) -> list: ...
    @staticmethod
    def list_get_elements(type: int, minrank: Rank) -> list: ...
    def list_is_type(self, type: int) -> bool: ...
    @staticmethod
    def make(factoryname: str, name: str | None = None) -> Element | None: ...
    @staticmethod
    def make_with_properties(
        factoryname: str, n: int, names: list | None = None, values: list | None = None
    ) -> Element | None: ...

class ElementFactoryClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Event(GObject.GBoxed):
    # gi Fields
    mini_object: MiniObject | None = ...
    seqnum: int = ...
    timestamp: int = ...
    type: EventType = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def copy_segment(self, segment: Segment) -> None: ...
    def get_running_time_offset(self) -> int: ...
    def get_seqnum(self) -> int: ...
    def get_structure(self) -> Structure | None: ...
    def has_name(self, name: str) -> bool: ...
    @deprecated("deprecated")
    def has_name_id(self, name: int) -> bool: ...
    @classmethod
    def new_buffer_size(cls, format: Format, minsize: int, maxsize: int, async_: bool) -> Event: ...
    @classmethod
    def new_caps(cls, caps: Caps) -> Event: ...
    @classmethod
    def new_custom(cls, type: EventType, structure: Structure) -> Event: ...
    @classmethod
    def new_eos(cls) -> Event: ...
    @classmethod
    def new_flush_start(cls) -> Event: ...
    @classmethod
    def new_flush_stop(cls, reset_time: bool) -> Event: ...
    @classmethod
    def new_gap(cls, timestamp: int, duration: int) -> Event: ...
    @classmethod
    def new_instant_rate_change(cls, rate_multiplier: float, new_flags: SegmentFlags) -> Event: ...
    @classmethod
    def new_instant_rate_sync_time(
        cls, rate_multiplier: float, running_time: int, upstream_running_time: int
    ) -> Event: ...
    @classmethod
    def new_latency(cls, latency: int) -> Event: ...
    @classmethod
    def new_navigation(cls, structure: Structure) -> Event: ...
    @classmethod
    def new_protection(cls, system_id: str, data: Buffer, origin: str) -> Event: ...
    @classmethod
    def new_qos(cls, type: QOSType, proportion: float, diff: int, timestamp: int) -> Event: ...
    @classmethod
    def new_reconfigure(cls) -> Event: ...
    @classmethod
    def new_seek(
        cls,
        rate: float,
        format: Format,
        flags: SeekFlags,
        start_type: SeekType,
        start: int,
        stop_type: SeekType,
        stop: int,
    ) -> Event: ...
    @classmethod
    def new_segment(cls, segment: Segment) -> Event: ...
    @classmethod
    def new_segment_done(cls, format: Format, position: int) -> Event: ...
    @classmethod
    def new_select_streams(cls, streams: list) -> Event: ...
    @classmethod
    def new_sink_message(cls, name: str, msg: Message) -> Event: ...
    @classmethod
    def new_step(cls, format: Format, amount: int, rate: float, flush: bool, intermediate: bool) -> Event: ...
    @classmethod
    def new_stream_collection(cls, collection: StreamCollection) -> Event: ...
    @classmethod
    def new_stream_group_done(cls, group_id: int) -> Event: ...
    @classmethod
    def new_stream_start(cls, stream_id: str) -> Event: ...
    @classmethod
    def new_tag(cls, taglist: TagList) -> Event: ...
    @classmethod
    def new_toc(cls, toc: Toc, updated: bool) -> Event: ...
    @classmethod
    def new_toc_select(cls, uid: str) -> Event: ...
    def parse_buffer_size(self) -> tuple[Format | None, int | None, int | None, bool | None]: ...
    def parse_caps(self) -> Caps | None: ...
    def parse_flush_stop(self) -> bool | None: ...
    def parse_gap(self) -> tuple[int | None, int | None]: ...
    def parse_gap_flags(self) -> GapFlags | None: ...
    def parse_group_id(self) -> tuple[bool, int | None]: ...
    def parse_instant_rate_change(self) -> tuple[float | None, SegmentFlags | None]: ...
    def parse_instant_rate_sync_time(self) -> tuple[float | None, int | None, int | None]: ...
    def parse_latency(self) -> int | None: ...
    def parse_protection(self) -> tuple[str | None, Buffer | None, str | None]: ...
    def parse_qos(self) -> tuple[QOSType | None, float | None, int | None, int | None]: ...
    def parse_seek(
        self,
    ) -> tuple[
        float | None, Format | None, SeekFlags | None, SeekType | None, int | None, SeekType | None, int | None
    ]: ...
    def parse_seek_trickmode_interval(self) -> int | None: ...
    def parse_segment(self) -> Segment | None: ...
    def parse_segment_done(self) -> tuple[Format | None, int | None]: ...
    def parse_select_streams(self) -> list | None: ...
    def parse_sink_message(self) -> Message | None: ...
    def parse_step(self) -> tuple[Format | None, int | None, float | None, bool | None, bool | None]: ...
    def parse_stream(self) -> Stream | None: ...
    def parse_stream_collection(self) -> StreamCollection | None: ...
    def parse_stream_flags(self) -> StreamFlags | None: ...
    def parse_stream_group_done(self) -> int | None: ...
    def parse_stream_start(self) -> str | None: ...
    def parse_tag(self) -> TagList | None: ...
    def parse_toc(self) -> tuple[Toc | None, bool | None]: ...
    def parse_toc_select(self) -> str | None: ...
    def set_gap_flags(self, flags: GapFlags) -> None: ...
    def set_group_id(self, group_id: int) -> None: ...
    def set_running_time_offset(self, offset: int) -> None: ...
    def set_seek_trickmode_interval(self, interval: int) -> None: ...
    def set_seqnum(self, seqnum: int) -> None: ...
    def set_stream(self, stream: Stream) -> None: ...
    def set_stream_flags(self, flags: StreamFlags) -> None: ...
    def writable_structure(self) -> Structure: ...

class FlagSet(object):
    """
    A fundamental type that describes a 32-bit flag bitfield, with 32-bit
    mask indicating which of the bits in the field are explicitly set.
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def register(flags_type: GObject.GType) -> GObject.GType: ...

class FormatDefinition(GObject.GPointer):
    # gi Fields
    description: str = ...
    nick: str = ...
    quark: int = ...
    value: Format = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Fraction(object):
    """
    A fundamental type that describes a fraction of an integer numerator
    over an integer denominator
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FractionRange(object):
    """
    A fundamental type that describes a #GstFractionRange range
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GhostPad(ProxyPad):
    """
    GhostPads are useful when organizing pipelines with #GstBin like elements.
    The idea here is to create hierarchical element graphs. The bin element
    contains a sub-graph. Now one would like to treat the bin-element like any
    other #GstElement. This is where GhostPads come into play. A GhostPad acts as
    a proxy for another pad. Thus the bin can have sink and source ghost-pads
    that are associated with sink and source pads of the child elements.

    If the target pad is known at creation time, gst_ghost_pad_new() is the
    function to use to get a ghost-pad. Otherwise one can use gst_ghost_pad_new_no_target()
    to create the ghost-pad and use gst_ghost_pad_set_target() to establish the
    association later on.

    Note that GhostPads add overhead to the data processing of a pipeline.
    """

    # gi Fields
    @builtins.property
    def pad(self) -> ProxyPad | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def activate_mode_default(pad: Pad, parent: Object | None, mode: PadMode, active: bool) -> bool: ...
    @deprecated("deprecated")
    def construct(self) -> bool: ...
    def get_target(self) -> Pad | None: ...
    @staticmethod
    def internal_activate_mode_default(pad: Pad, parent: Object | None, mode: PadMode, active: bool) -> bool: ...
    @classmethod
    def new(cls, name: str | None, target: Pad) -> Pad | None: ...
    @classmethod
    def new_from_template(cls, name: str | None, target: Pad, templ: PadTemplate) -> Pad | None: ...
    @classmethod
    def new_no_target(cls, name: str | None, dir: PadDirection) -> Pad | None: ...
    @classmethod
    def new_no_target_from_template(cls, name: str | None, templ: PadTemplate) -> Pad | None: ...
    def set_target(self, newtarget: Pad | None = None) -> bool: ...

class GhostPadClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ProxyPadClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GhostPadPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IdStr(GObject.GBoxed):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...

    # gi Methods
    def as_str(self) -> str: ...
    def clear(self) -> None: ...
    def copy(self) -> IdStr: ...
    def copy_into(self, s: IdStr) -> None: ...
    def free(self) -> None: ...
    def get_len(self) -> int: ...
    def init(self) -> None: ...
    def is_equal(self, s2: IdStr) -> bool: ...
    def is_equal_to_str(self, s2: str) -> bool: ...
    def is_equal_to_str_with_len(self, s2: str, len: int) -> bool: ...
    def move(self, s: IdStr) -> None: ...
    @classmethod
    def new(cls) -> IdStr: ...
    def set(self, value: str) -> None: ...
    def set_static_str(self, value: str) -> None: ...
    def set_static_str_with_len(self, value: str, len: int) -> None: ...
    def set_with_len(self, value: str, len: int) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class Int64Range(object):
    """
    A fundamental type that describes a #gint64 range
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IntRange(object):
    """
    A fundamental type that describes a #gint range
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Iterator(GObject.GBoxed):
    # gi Fields
    cookie: int = ...
    item: IteratorItemFunctionIteratorCB = ...
    lock: GLib.Mutex | None = ...  # type: ignore
    master_cookie: int = ...
    pushed: Iterator | None = ...
    size: int = ...
    type: GObject.GType = ...  # type: ignore

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def copy(self) -> Iterator: ...
    def filter(self, func: GLib.CompareFunc, user_data: GObject.Value) -> Iterator: ...
    def find_custom(self, func: GLib.CompareFunc, user_data: object | None = None) -> tuple[bool, GObject.Value]: ...
    def fold(
        self, func: IteratorFoldFunction, ret: GObject.Value, user_data: object | None = None
    ) -> IteratorResult: ...
    def foreach(self, func: IteratorForeachFunction, user_data: object | None = None) -> IteratorResult: ...
    def free(self) -> None: ...
    @classmethod
    def new_single(cls, type: GObject.GType, object: GObject.Value) -> Iterator: ...
    def next(self) -> tuple[IteratorResult, GObject.Value]: ...
    def push(self, other: Iterator) -> None: ...
    def resync(self) -> None: ...

class MapInfo(GObject.GPointer):
    # gi Fields
    data: list | None = ...
    flags: MapFlags = ...
    maxsize: int = ...
    memory: Memory | None = ...
    size: int = ...
    user_data: list | None = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Memory(GObject.GBoxed):
    # gi Fields
    align: int = ...
    allocator: Allocator | None = ...
    maxsize: int = ...
    mini_object: MiniObject | None = ...
    offset: int = ...
    size: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def copy(self, offset: int, size: int) -> Memory | None: ...
    def get_sizes(self) -> tuple[int, int | None, int | None]: ...
    def is_span(self, mem2: Memory) -> tuple[bool, int]: ...
    def is_type(self, mem_type: str) -> bool: ...
    def make_mapped(self, flags: MapFlags) -> tuple[Memory | None, MapInfo]: ...
    def map(self, flags: MapFlags) -> tuple[bool, MapInfo]: ...
    @classmethod
    def new_wrapped(
        cls,
        flags: MemoryFlags,
        data: list,
        maxsize: int,
        offset: int,
        size: int,
        user_data: object | None = None,
        notify: GLib.DestroyNotify | None = None,
    ) -> Memory | None: ...
    def resize(self, offset: int, size: int) -> None: ...
    def share(self, offset: int, size: int) -> Memory: ...
    def unmap(self, info: MapInfo) -> None: ...

class Message(GObject.GBoxed):
    # gi Fields
    @builtins.property
    def cond(self) -> GLib.Cond | None: ...
    @builtins.property
    def lock(self) -> GLib.Mutex | None: ...
    mini_object: MiniObject | None = ...
    seqnum: int = ...
    src: Object | None = ...
    timestamp: int = ...
    type: MessageType = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_redirect_entry(
        self, location: str, tag_list: TagList | None = None, entry_struct: Structure | None = None
    ) -> None: ...
    def get_details(self) -> Structure | None: ...
    def get_num_redirect_entries(self) -> int: ...
    def get_seqnum(self) -> int: ...
    def get_stream_status_object(self) -> GObject.Value | None: ...
    def get_structure(self) -> Structure | None: ...
    def has_name(self, name: str) -> bool: ...
    @classmethod
    def new_application(cls, src: Object | None, structure: Structure) -> Message: ...
    @classmethod
    def new_async_done(cls, src: Object | None, running_time: int) -> Message: ...
    @classmethod
    def new_async_start(cls, src: Object | None = None) -> Message: ...
    @classmethod
    def new_buffering(cls, src: Object | None, percent: int) -> Message: ...
    @classmethod
    def new_clock_lost(cls, src: Object | None, clock: Clock) -> Message: ...
    @classmethod
    def new_clock_provide(cls, src: Object | None, clock: Clock, ready: bool) -> Message: ...
    @classmethod
    def new_custom(
        cls, type: MessageType, src: Object | None = None, structure: Structure | None = None
    ) -> Message: ...
    @classmethod
    def new_device_added(cls, src: Object | None, device: Device) -> Message: ...
    @classmethod
    def new_device_changed(cls, src: Object | None, device: Device, changed_device: Device) -> Message: ...
    @classmethod
    def new_device_removed(cls, src: Object | None, device: Device) -> Message: ...
    @classmethod
    def new_duration_changed(cls, src: Object | None = None) -> Message: ...
    @classmethod
    def new_element(cls, src: Object | None, structure: Structure) -> Message: ...
    @classmethod
    def new_eos(cls, src: Object | None = None) -> Message: ...
    @classmethod
    def new_error(cls, src: Object | None, error: None, debug: str) -> Message: ...
    @classmethod
    def new_error_with_details(
        cls, src: Object | None, error: None, debug: str, details: Structure | None = None
    ) -> Message: ...
    @classmethod
    def new_have_context(cls, src: Object | None, context: Context) -> Message: ...
    @classmethod
    def new_info(cls, src: Object | None, error: None, debug: str) -> Message: ...
    @classmethod
    def new_info_with_details(
        cls, src: Object | None, error: None, debug: str, details: Structure | None = None
    ) -> Message: ...
    @classmethod
    def new_instant_rate_request(cls, src: Object | None, rate_multiplier: float) -> Message: ...
    @classmethod
    def new_latency(cls, src: Object | None = None) -> Message: ...
    @classmethod
    def new_need_context(cls, src: Object | None, context_type: str) -> Message: ...
    @classmethod
    def new_new_clock(cls, src: Object | None, clock: Clock) -> Message: ...
    @classmethod
    def new_progress(cls, src: Object | None, type: ProgressType, code: str, text: str) -> Message: ...
    @classmethod
    def new_property_notify(cls, src: Object, property_name: str, val: GObject.Value | None = None) -> Message: ...
    @classmethod
    def new_qos(
        cls, src: Object | None, live: bool, running_time: int, stream_time: int, timestamp: int, duration: int
    ) -> Message: ...
    @classmethod
    def new_redirect(
        cls, src: Object | None, location: str, tag_list: TagList | None = None, entry_struct: Structure | None = None
    ) -> Message: ...
    @classmethod
    def new_request_state(cls, src: Object | None, state: State) -> Message: ...
    @classmethod
    def new_reset_time(cls, src: Object | None, running_time: int) -> Message: ...
    @classmethod
    def new_segment_done(cls, src: Object | None, format: Format, position: int) -> Message: ...
    @classmethod
    def new_segment_start(cls, src: Object | None, format: Format, position: int) -> Message: ...
    @classmethod
    def new_state_changed(cls, src: Object | None, oldstate: State, newstate: State, pending: State) -> Message: ...
    @classmethod
    def new_state_dirty(cls, src: Object | None = None) -> Message: ...
    @classmethod
    def new_step_done(
        cls,
        src: Object | None,
        format: Format,
        amount: int,
        rate: float,
        flush: bool,
        intermediate: bool,
        duration: int,
        eos: bool,
    ) -> Message: ...
    @classmethod
    def new_step_start(
        cls, src: Object | None, active: bool, format: Format, amount: int, rate: float, flush: bool, intermediate: bool
    ) -> Message: ...
    @classmethod
    def new_stream_collection(cls, src: Object | None, collection: StreamCollection) -> Message: ...
    @classmethod
    def new_stream_start(cls, src: Object | None = None) -> Message: ...
    @classmethod
    def new_stream_status(cls, src: Object | None, type: StreamStatusType, owner: Element) -> Message: ...
    @classmethod
    def new_streams_selected(cls, src: Object | None, collection: StreamCollection) -> Message: ...
    @classmethod
    def new_structure_change(
        cls, src: Object | None, type: StructureChangeType, owner: Element, busy: bool
    ) -> Message: ...
    @classmethod
    def new_tag(cls, src: Object | None, tag_list: TagList) -> Message: ...
    @classmethod
    def new_toc(cls, src: Object | None, toc: Toc, updated: bool) -> Message: ...
    @classmethod
    def new_warning(cls, src: Object | None, error: None, debug: str) -> Message: ...
    @classmethod
    def new_warning_with_details(
        cls, src: Object | None, error: None, debug: str, details: Structure | None = None
    ) -> Message: ...
    def parse_async_done(self) -> int | None: ...
    def parse_buffering(self) -> int | None: ...
    def parse_buffering_stats(self) -> tuple[BufferingMode | None, int | None, int | None, int | None]: ...
    def parse_clock_lost(self) -> Clock | None: ...
    def parse_clock_provide(self) -> tuple[Clock | None, bool | None]: ...
    def parse_context_type(self) -> tuple[bool, str | None]: ...
    def parse_device_added(self) -> Device | None: ...
    def parse_device_changed(self) -> tuple[Device | None, Device | None]: ...
    def parse_device_removed(self) -> Device | None: ...
    def parse_error(self) -> tuple[None | None, str | None]: ...
    def parse_error_details(self) -> Structure | None: ...
    def parse_error_writable_details(self) -> Structure | None: ...
    def parse_group_id(self) -> tuple[bool, int | None]: ...
    def parse_have_context(self) -> Context | None: ...
    def parse_info(self) -> tuple[None | None, str | None]: ...
    def parse_info_details(self) -> Structure | None: ...
    def parse_info_writable_details(self) -> Structure | None: ...
    def parse_instant_rate_request(self) -> float | None: ...
    def parse_new_clock(self) -> Clock | None: ...
    def parse_progress(self) -> tuple[ProgressType | None, str | None, str | None]: ...
    def parse_property_notify(self) -> tuple[Object | None, str | None, GObject.Value | None]: ...
    def parse_qos(self) -> tuple[bool | None, int | None, int | None, int | None, int | None]: ...
    def parse_qos_stats(self) -> tuple[Format | None, int | None, int | None]: ...
    def parse_qos_values(self) -> tuple[int | None, float | None, int | None]: ...
    def parse_redirect_entry(self, entry_index: int) -> tuple[str | None, TagList | None, Structure | None]: ...
    def parse_request_state(self) -> State | None: ...
    def parse_reset_time(self) -> int | None: ...
    def parse_segment_done(self) -> tuple[Format | None, int | None]: ...
    def parse_segment_start(self) -> tuple[Format | None, int | None]: ...
    def parse_state_changed(self) -> tuple[State | None, State | None, State | None]: ...
    def parse_step_done(
        self,
    ) -> tuple[Format | None, int | None, float | None, bool | None, bool | None, int | None, bool | None]: ...
    def parse_step_start(
        self,
    ) -> tuple[bool | None, Format | None, int | None, float | None, bool | None, bool | None]: ...
    def parse_stream_collection(self) -> StreamCollection | None: ...
    def parse_stream_status(self) -> tuple[StreamStatusType, Element]: ...
    def parse_streams_selected(self) -> StreamCollection | None: ...
    def parse_structure_change(self) -> tuple[StructureChangeType, Element | None, bool | None]: ...
    def parse_tag(self) -> TagList: ...
    def parse_toc(self) -> tuple[Toc, bool]: ...
    def parse_warning(self) -> tuple[None | None, str | None]: ...
    def parse_warning_details(self) -> Structure | None: ...
    def parse_warning_writable_details(self) -> Structure | None: ...
    def set_buffering_stats(self, mode: BufferingMode, avg_in: int, avg_out: int, buffering_left: int) -> None: ...
    def set_details(self, details: Structure | None = None) -> None: ...
    def set_group_id(self, group_id: int) -> None: ...
    def set_qos_stats(self, format: Format, processed: int, dropped: int) -> None: ...
    def set_qos_values(self, jitter: int, proportion: float, quality: int) -> None: ...
    def set_seqnum(self, seqnum: int) -> None: ...
    def set_stream_status_object(self, object: GObject.Value) -> None: ...
    def streams_selected_add(self, stream: Stream) -> None: ...
    def streams_selected_get_size(self) -> int: ...
    def streams_selected_get_stream(self, idx: int) -> Stream | None: ...
    def writable_details(self) -> Structure: ...
    def writable_structure(self) -> Structure: ...

class Meta(GObject.GPointer):
    # gi Fields
    flags: MetaFlags = ...
    info: MetaInfo | None = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def api_type_aggregate_params(
        api: GObject.GType, aggregated_params: Structure, params0: Structure, params1: Structure
    ) -> bool: ...
    @staticmethod
    def api_type_get_tags(api: GObject.GType) -> list: ...
    @staticmethod
    def api_type_has_tag(api: GObject.GType, tag: int) -> bool: ...
    @staticmethod
    def api_type_register(api: str, tags: list) -> GObject.GType: ...
    @staticmethod
    def api_type_set_params_aggregator(api: GObject.GType, aggregator: AllocationMetaParamsAggregator) -> None: ...
    def compare_seqnum(self, meta2: Meta) -> int: ...
    @staticmethod
    def deserialize(buffer: Buffer, data: int, size: int) -> tuple[Meta | None, int]: ...
    @staticmethod
    def get_info(impl: str) -> MetaInfo | None: ...
    def get_seqnum(self) -> int: ...
    @staticmethod
    def register_custom(
        name: str,
        tags: list,
        transform_func: CustomMetaTransformFunction | None,
        user_data: object | None,
        destroy_data: GLib.DestroyNotify,
    ) -> MetaInfo: ...
    @staticmethod
    def register_custom_simple(name: str) -> MetaInfo: ...
    def serialize(self, data: ByteArrayInterface) -> bool: ...
    def serialize_simple(self, data: list) -> bool: ...

class MetaInfo(GObject.GPointer):
    # gi Fields
    api: GObject.GType = ...  # type: ignore
    clear_func: MetaClearFunctionMetaInfoCB = ...
    deserialize_func: MetaDeserializeFunctionMetaInfoCB | None = ...
    free_func: MetaFreeFunctionMetaInfoCB = ...
    init_func: MetaInitFunctionMetaInfoCB = ...
    serialize_func: MetaSerializeFunctionMetaInfoCB = ...
    size: int = ...
    transform_func: MetaTransformFunctionMetaInfoCB = ...
    type: GObject.GType = ...  # type: ignore

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def is_custom(self) -> bool: ...
    def register(self) -> MetaInfo: ...

class MetaTransformCopy(GObject.GPointer):
    # gi Fields
    offset: int = ...
    region: bool = ...
    size: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MiniObject(GObject.GBoxed):
    # gi Fields
    copy: MiniObjectCopyFunctionMiniObjectCB = ...
    dispose: MiniObjectDisposeFunctionMiniObjectCB = ...
    flags: int = ...
    free: MiniObjectFreeFunctionMiniObjectCB = ...
    lockstate: int = ...
    @builtins.property
    def priv_uint(self) -> int: ...
    refcount: int = ...
    type: GObject.GType = ...  # type: ignore

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_parent(self, parent: MiniObject) -> None: ...
    def get_qdata(self, quark: int) -> object | None: ...
    def is_writable(self) -> bool: ...
    def lock(self, flags: LockFlags) -> bool: ...
    def remove_parent(self, parent: MiniObject) -> None: ...
    @staticmethod
    def replace(
        olddata: MiniObject | None = None, newdata: MiniObject | None = None
    ) -> tuple[bool, MiniObject | None]: ...
    def set_qdata(self, quark: int, data: object | None, destroy: GLib.DestroyNotify) -> None: ...
    def steal_qdata(self, quark: int) -> object | None: ...
    @staticmethod
    def take(olddata: MiniObject, newdata: MiniObject) -> tuple[bool, MiniObject]: ...
    def unlock(self, flags: LockFlags) -> None: ...

class Object(GObject.InitiallyUnowned):
    """
    #GstObject provides a root for the object hierarchy tree filed in by the
    GStreamer library.  It is currently a thin wrapper on top of
    #GInitiallyUnowned. It is an abstract class that is not very usable on its own.

    #GstObject gives us basic refcounting, parenting functionality and locking.
    Most of the functions are just extended for special GStreamer needs and can be
    found under the same name in the base class of #GstObject which is #GObject
    (e.g. g_object_ref() becomes gst_object_ref()).

    Since #GstObject derives from #GInitiallyUnowned, it also inherits the
    floating reference. Be aware that functions such as gst_bin_add() and
    gst_element_add_pad() take ownership of the floating reference.

    In contrast to #GObject instances, #GstObject adds a name property. The functions
    gst_object_set_name() and gst_object_get_name() are used to set/get the name
    of the object.

    ## controlled properties

    Controlled properties offers a lightweight way to adjust gobject properties
    over stream-time. It works by using time-stamped value pairs that are queued
    for element-properties. At run-time the elements continuously pull value
    changes for the current stream-time.

    What needs to be changed in a #GstElement?
    Very little - it is just two steps to make a plugin controllable!

      * mark gobject-properties paramspecs that make sense to be controlled,
        by GST_PARAM_CONTROLLABLE.

      * when processing data (get, chain, loop function) at the beginning call
        gst_object_sync_values(element,timestamp).
        This will make the controller update all GObject properties that are
        under its control with the current values based on the timestamp.

    What needs to be done in applications? Again it's not a lot to change.

      * create a #GstControlSource.
        csource = gst_interpolation_control_source_new ();
        g_object_set (csource, "mode", GST_INTERPOLATION_MODE_LINEAR, NULL);

      * Attach the #GstControlSource on the controller to a property.
        gst_object_add_control_binding (object, gst_direct_control_binding_new (object, "prop1", csource));

      * Set the control values
        gst_timed_value_control_source_set ((GstTimedValueControlSource *)csource,0 * GST_SECOND, value1);
        gst_timed_value_control_source_set ((GstTimedValueControlSource *)csource,1 * GST_SECOND, value2);

      * start your pipeline
    """

    class Props(GObject.InitiallyUnowned.Props):
        name: str
        parent: Object | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def control_bindings(self) -> list | None: ...
    @builtins.property
    def control_rate(self) -> int: ...
    @builtins.property
    def flags(self) -> int: ...
    @builtins.property
    def last_sync(self) -> int: ...
    @builtins.property
    def lock(self) -> GLib.Mutex | None: ...
    @builtins.property
    def name(self) -> str: ...
    @builtins.property
    def object(self) -> GObject.InitiallyUnowned | None: ...

    # gi Methods
    def __init__(self, name: str = ..., parent: Object | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_control_binding(self, binding: ControlBinding) -> bool: ...
    @staticmethod
    def check_uniqueness(list: list, name: str) -> bool: ...
    @staticmethod
    def default_deep_notify(
        object: GObject.Object, orig: Object, pspec: GObject.ParamSpec, excluded_props: list | None = None
    ) -> None: ...
    def default_error(self, error: None, debug: str | None = None) -> None: ...
    def get_control_binding(self, property_name: str) -> ControlBinding | None: ...
    def get_control_rate(self) -> int: ...
    def get_g_value_array(
        self, property_name: str, timestamp: int, interval: int, n_values: int, values: list
    ) -> bool: ...
    @builtins.property
    def get_name(self) -> str | None: ...
    @builtins.property
    def get_parent(self) -> Object | None: ...
    def get_path_string(self) -> str: ...
    def get_value(self, property_name: str, timestamp: int) -> GObject.Value | None: ...
    def has_active_control_bindings(self) -> bool: ...
    @deprecated("deprecated")
    def has_ancestor(self, ancestor: Object) -> bool: ...
    def has_as_ancestor(self, ancestor: Object) -> bool: ...
    def has_as_parent(self, parent: Object) -> bool: ...
    def ref(self) -> Object: ...
    def remove_control_binding(self, binding: ControlBinding) -> bool: ...
    @staticmethod
    def replace(oldobj: Object | None = None, newobj: Object | None = None) -> tuple[bool, Object | None]: ...
    def set_control_binding_disabled(self, property_name: str, disabled: bool) -> None: ...
    def set_control_bindings_disabled(self, disabled: bool) -> None: ...
    def set_control_rate(self, control_rate: int) -> None: ...
    def set_name(self, name: str | None = None) -> bool: ...
    def set_parent(self, parent: Object) -> bool: ...
    def suggest_next_sync(self) -> int: ...
    def sync_values(self, timestamp: int) -> bool: ...
    def unparent(self) -> None: ...
    def unref(self) -> None: ...

    # python methods (overrides?)
    def do_deep_notify(
        self,
        orig: Object,
        pspec: GObject.ParamSpec,
    ) -> None:
        """
        deep_notify(self, orig:Gst.Object, pspec:GObject.ParamSpec)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["deep-notify"],
        handler: typing.Callable[[typing_extensions.Self, Object, GObject.ParamSpec], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ObjectClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def deep_notify(self) -> deep_notifyObjectClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.InitiallyUnownedClass | None: ...
    @builtins.property
    def path_string_separator(self) -> str: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Pad(Object):
    """
    A #GstElement is linked to other elements via "pads", which are extremely
    light-weight generic link points.

    Pads have a #GstPadDirection, source pads produce data, sink pads consume
    data.

    Pads are typically created from a #GstPadTemplate with
    gst_pad_new_from_template() and are then added to a #GstElement. This usually
    happens when the element is created but it can also happen dynamically based
    on the data that the element is processing or based on the pads that the
    application requests.

    Pads without pad templates can be created with gst_pad_new(),
    which takes a direction and a name as an argument.  If the name is %NULL,
    then a guaranteed unique name will be assigned to it.

    A #GstElement creating a pad will typically use the various
    gst_pad_set_*_function() calls to register callbacks for events, queries or
    dataflow on the pads.

    gst_pad_get_parent() will retrieve the #GstElement that owns the pad.

    After two pads are retrieved from an element by gst_element_get_static_pad(),
    the pads can be linked with gst_pad_link(). (For quick links,
    you can also use gst_element_link(), which will make the obvious
    link for you if it's straightforward.). Pads can be unlinked again with
    gst_pad_unlink(). gst_pad_get_peer() can be used to check what the pad is
    linked to.

    Before dataflow is possible on the pads, they need to be activated with
    gst_pad_set_active().

    gst_pad_query() and gst_pad_peer_query() can be used to query various
    properties of the pad and the stream.

    To send a #GstEvent on a pad, use gst_pad_send_event() and
    gst_pad_push_event(). Some events will be sticky on the pad, meaning that
    after they pass on the pad they can be queried later with
    gst_pad_get_sticky_event() and gst_pad_sticky_events_foreach().
    gst_pad_get_current_caps() and gst_pad_has_current_caps() are convenience
    functions to query the current sticky CAPS event on a pad.

    GstElements will use gst_pad_push() and gst_pad_pull_range() to push out
    or pull in a buffer.

    The dataflow, events and queries that happen on a pad can be monitored with
    probes that can be installed with gst_pad_add_probe(). gst_pad_is_blocked()
    can be used to check if a block probe is installed on the pad.
    gst_pad_is_blocking() checks if the blocking probe is currently blocking the
    pad. gst_pad_remove_probe() is used to remove a previously installed probe
    and unblock blocking probes if any.

    Pad have an offset that can be retrieved with gst_pad_get_offset(). This
    offset will be applied to the running_time of all data passing over the pad.
    gst_pad_set_offset() can be used to change the offset.

    Convenience functions exist to start, pause and stop the task on a pad with
    gst_pad_start_task(), gst_pad_pause_task() and gst_pad_stop_task()
    respectively.
    """

    class Props(Object.Props):
        caps: Caps | None
        direction: PadDirection
        offset: int
        template: PadTemplate | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def activatefunc(self) -> PadActivateFunctionPadCB: ...
    @builtins.property
    def activatemodefunc(self) -> PadActivateModeFunctionPadCB: ...
    @builtins.property
    def activatemodenotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def activatenotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def block_cond(self) -> GLib.Cond | None: ...
    @builtins.property
    def chainfunc(self) -> PadChainFunctionPadCB: ...
    @builtins.property
    def chainlistfunc(self) -> PadChainListFunctionPadCB: ...
    @builtins.property
    def chainlistnotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def chainnotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def direction(self) -> PadDirection: ...
    @builtins.property
    def eventfunc(self) -> PadEventFunctionPadCB: ...
    @builtins.property
    def eventnotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def getrangefunc(self) -> PadGetRangeFunctionPadCB: ...
    @builtins.property
    def getrangenotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def iterintlinkfunc(self) -> PadIterIntLinkFunctionPadCB: ...
    @builtins.property
    def iterintlinknotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def linkfunc(self) -> PadLinkFunctionPadCB: ...
    @builtins.property
    def linknotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def mode(self) -> PadMode: ...
    @builtins.property
    def num_blocked(self) -> int: ...
    @builtins.property
    def num_probes(self) -> int: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def offset(self) -> int: ...
    @builtins.property
    def padtemplate(self) -> PadTemplate | None: ...
    @builtins.property
    def peer(self) -> Pad | None: ...
    @builtins.property
    def probes(self) -> GLib.HookList | None: ...
    @builtins.property
    def queryfunc(self) -> PadQueryFunctionPadCB: ...
    @builtins.property
    def querynotify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def stream_rec_lock(self) -> GLib.RecMutex | None: ...
    @builtins.property
    def task(self) -> Task | None: ...
    @builtins.property
    def unlinkfunc(self) -> PadUnlinkFunctionPadCB: ...
    @builtins.property
    def unlinknotify(self) -> GLib.DestroyNotify: ...

    # gi Methods
    def __init__(self, direction: PadDirection = ..., offset: int = ..., template: PadTemplate | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def activate_mode(self, mode: PadMode, active: bool) -> bool: ...
    def add_probe(
        self, mask: PadProbeType, callback: PadProbeCallback, user_data: object | None, destroy_data: GLib.DestroyNotify
    ) -> int: ...
    def can_link(self, sinkpad: Pad) -> bool: ...
    def chain(self, buffer: Buffer) -> FlowReturn: ...
    def chain_list(self, list: BufferList) -> FlowReturn: ...
    def check_reconfigure(self) -> bool: ...
    def create_stream_id(self, parent: Element, stream_id: str | None = None) -> str: ...
    def event_default(self, parent: Object | None, event: Event) -> bool: ...
    def forward(self, forward: PadForwardFunction, user_data: object | None = None) -> bool: ...
    def get_allowed_caps(self) -> Caps | None: ...
    def get_current_caps(self) -> Caps | None: ...
    @builtins.property
    def get_direction(self) -> PadDirection: ...
    def get_element_private(self) -> object | None: ...
    def get_last_flow_return(self) -> FlowReturn: ...
    @builtins.property
    def get_offset(self) -> int: ...
    def get_pad_template(self) -> PadTemplate | None: ...
    def get_pad_template_caps(self) -> Caps: ...
    def get_parent_element(self) -> Element | None: ...
    def get_peer(self) -> Pad | None: ...
    def get_range(self, offset: int, size: int) -> tuple[FlowReturn, Buffer]: ...
    def get_single_internal_link(self) -> Pad | None: ...
    def get_sticky_event(self, event_type: EventType, idx: int) -> Event | None: ...
    def get_stream(self) -> Stream | None: ...
    def get_stream_id(self) -> str | None: ...
    def get_task_state(self) -> TaskState: ...
    def has_current_caps(self) -> bool: ...
    def is_active(self) -> bool: ...
    def is_blocked(self) -> bool: ...
    def is_blocking(self) -> bool: ...
    def is_linked(self) -> bool: ...
    def iterate_internal_links(self) -> Iterator | None: ...
    def iterate_internal_links_default(self, parent: Object | None = None) -> Iterator | None: ...
    def link(self, sinkpad: Pad) -> PadLinkReturn: ...
    def link_full(self, sinkpad: Pad, flags: PadLinkCheck) -> PadLinkReturn: ...
    @staticmethod
    def link_get_name(ret: PadLinkReturn) -> str: ...
    def link_maybe_ghosting(self, sink: Pad) -> bool: ...
    def link_maybe_ghosting_full(self, sink: Pad, flags: PadLinkCheck) -> bool: ...
    def mark_reconfigure(self) -> None: ...
    def needs_reconfigure(self) -> bool: ...
    @classmethod
    def new(cls, name: str | None, direction: PadDirection) -> Pad: ...
    @classmethod
    def new_from_static_template(cls, templ: StaticPadTemplate, name: str) -> Pad: ...
    @classmethod
    def new_from_template(cls, templ: PadTemplate, name: str | None = None) -> Pad: ...
    def pause_task(self) -> bool: ...
    def peer_query(self, query: Query) -> bool: ...
    def peer_query_accept_caps(self, caps: Caps) -> bool: ...
    def peer_query_caps(self, filter: Caps | None = None) -> Caps: ...
    def peer_query_convert(self, src_format: Format, src_val: int, dest_format: Format) -> tuple[bool, int]: ...
    def peer_query_duration(self, format: Format) -> tuple[bool, int | None]: ...
    def peer_query_position(self, format: Format) -> tuple[bool, int | None]: ...
    def proxy_query_accept_caps(self, query: Query) -> bool: ...
    def proxy_query_caps(self, query: Query) -> bool: ...
    def pull_range(self, offset: int, size: int) -> tuple[FlowReturn, Buffer]: ...
    def push(self, buffer: Buffer) -> FlowReturn: ...
    def push_event(self, event: Event) -> bool: ...
    def push_list(self, list: BufferList) -> FlowReturn: ...
    def query(self, query: Query) -> bool: ...
    def query_accept_caps(self, caps: Caps) -> bool: ...
    def query_caps(self, filter: Caps | None = None) -> Caps: ...
    def query_convert(self, src_format: Format, src_val: int, dest_format: Format) -> tuple[bool, int]: ...
    def query_default(self, parent: Object | None, query: Query) -> bool: ...
    def query_duration(self, format: Format) -> tuple[bool, int | None]: ...
    def query_position(self, format: Format) -> tuple[bool, int | None]: ...
    def remove_probe(self, id: int) -> None: ...
    def send_event(self, event: Event) -> bool: ...
    def set_activate_function_full(
        self, activate: PadActivateFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_activatemode_function_full(
        self, activatemode: PadActivateModeFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_active(self, active: bool) -> bool: ...
    def set_chain_function_full(
        self, chain: PadChainFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_chain_list_function_full(
        self, chainlist: PadChainListFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_element_private(self, priv: object | None = None) -> None: ...
    def set_event_full_function_full(
        self, event: PadEventFullFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_event_function_full(
        self, event: PadEventFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_getrange_function_full(
        self, get: PadGetRangeFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_iterate_internal_links_function_full(
        self, iterintlink: PadIterIntLinkFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_link_function_full(
        self, link: PadLinkFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_offset(self, offset: int) -> None: ...
    def set_query_function_full(
        self, query: PadQueryFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_unlink_function_full(
        self, unlink: PadUnlinkFunction, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def start_task(self, func: TaskFunction, user_data: object | None, notify: GLib.DestroyNotify) -> bool: ...
    def sticky_events_foreach(
        self, foreach_func: PadStickyEventsForeachFunction, user_data: object | None = None
    ) -> None: ...
    def stop_task(self) -> bool: ...
    def store_sticky_event(self, event: Event) -> FlowReturn: ...
    def unlink(self, sinkpad: Pad) -> bool: ...
    def use_fixed_caps(self) -> None: ...

    # python methods (overrides?)
    def do_linked(
        self,
        peer: Pad,
    ) -> None:
        """
        linked(self, peer:Gst.Pad)
        """
    def do_unlinked(
        self,
        peer: Pad,
    ) -> None:
        """
        unlinked(self, peer:Gst.Pad)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["linked"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["unlinked"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::direction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::offset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::template"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PadClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def linked(self) -> linkedPadClassCB: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def unlinked(self) -> unlinkedPadClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PadPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PadProbeInfo(GObject.GPointer):
    # gi Fields
    id: int = ...
    offset: int = ...
    size: int = ...
    type: PadProbeType = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_buffer(self) -> Buffer | None: ...
    def get_buffer_list(self) -> BufferList | None: ...
    def get_event(self) -> Event | None: ...
    def get_query(self) -> Query | None: ...

class PadTemplate(Object):
    """
    Padtemplates describe the possible media types a pad or an elementfactory can
    handle. This allows for both inspection of handled types before loading the
    element plugin as well as identifying pads on elements that are not yet
    created (request or sometimes pads).

    Pad and PadTemplates have #GstCaps attached to it to describe the media type
    they are capable of dealing with. gst_pad_template_get_caps() or
    GST_PAD_TEMPLATE_CAPS() are used to get the caps of a padtemplate. It's not
    possible to modify the caps of a padtemplate after creation.

    PadTemplates have a #GstPadPresence property which identifies the lifetime
    of the pad and that can be retrieved with GST_PAD_TEMPLATE_PRESENCE(). Also
    the direction of the pad can be retrieved from the #GstPadTemplate with
    GST_PAD_TEMPLATE_DIRECTION().

    The GST_PAD_TEMPLATE_NAME_TEMPLATE () is important for GST_PAD_REQUEST pads
    because it has to be used as the name in the gst_element_request_pad_simple()
    call to instantiate a pad from this template.

    Padtemplates can be created with gst_pad_template_new() or with
    gst_static_pad_template_get (), which creates a #GstPadTemplate from a
    #GstStaticPadTemplate that can be filled with the
    convenient GST_STATIC_PAD_TEMPLATE() macro.

    A padtemplate can be used to create a pad (see gst_pad_new_from_template()
    or gst_pad_new_from_static_template ()) or to add to an element class
    (see gst_element_class_add_static_pad_template ()).

    The following code example shows the code to create a pad from a padtemplate.
    |[<!-- language="C" -->
      GstStaticPadTemplate my_template =
      GST_STATIC_PAD_TEMPLATE (
        "sink",          // the name of the pad
        GST_PAD_SINK,    // the direction of the pad
        GST_PAD_ALWAYS,  // when this pad will be present
        GST_STATIC_CAPS (        // the capabilities of the padtemplate
          "audio/x-raw, "
            "channels = (int) [ 1, 6 ]"
        )
      );
      void
      my_method (void)
      {
        GstPad *pad;
        pad = gst_pad_new_from_static_template (&my_template, "sink");
        ...
      }
    ]|

    The following example shows you how to add the padtemplate to an
    element class, this is usually done in the class_init of the class:
    |[<!-- language="C" -->
      static void
      my_element_class_init (GstMyElementClass *klass)
      {
        GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);

        gst_element_class_add_static_pad_template (gstelement_class, &my_template);
      }
    ]|
    """

    class Props(Object.Props):
        caps: Caps | None
        direction: PadDirection
        gtype: GObject.GType
        name_template: str  # [name-template]: changed because contained invalid characters
        presence: PadPresence

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def caps(self) -> Caps | None: ...
    @builtins.property
    def direction(self) -> PadDirection: ...
    @builtins.property
    def name_template(self) -> str: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def presence(self) -> PadPresence: ...

    # gi Methods
    def __init__(
        self,
        caps: Caps | None = ...,
        direction: PadDirection = ...,
        gtype: GObject.GType = ...,
        name_template: str = ...,
        presence: PadPresence = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_caps(self) -> Caps: ...
    def get_documentation_caps(self) -> Caps: ...
    @classmethod
    def new(
        cls, name_template: str, direction: PadDirection, presence: PadPresence, caps: Caps
    ) -> PadTemplate | None: ...
    @classmethod
    def new_from_static_pad_template_with_gtype(
        cls, pad_template: StaticPadTemplate, pad_type: GObject.GType
    ) -> PadTemplate | None: ...
    @classmethod
    def new_with_gtype(
        cls, name_template: str, direction: PadDirection, presence: PadPresence, caps: Caps, pad_type: GObject.GType
    ) -> PadTemplate | None: ...
    def pad_created(self, pad: Pad) -> None: ...
    def set_documentation_caps(self, caps: Caps) -> None: ...

    # python methods (overrides?)
    def do_pad_created(
        self,
        pad: Pad,
    ) -> None:
        """
        pad_created(self, pad:Gst.Pad)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pad-created"],
        handler: typing.Callable[[typing_extensions.Self, Pad], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::direction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtype"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name_template"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::presence"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PadTemplateClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def pad_created(self) -> pad_createdPadTemplateClassCB: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ParamArray(GObject.ParamSpec):
    """
    A fundamental type that describes a #GParamSpec for arrays of
    values
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ParamFraction(GObject.ParamSpec):
    """
    A fundamental type that describes a #GParamSpec for fractional
    properties
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ParamSpecArray(GObject.GPointer):
    # gi Fields
    element_spec: GObject.ParamSpec | None = ...  # type: ignore

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ParamSpecFraction(GObject.GPointer):
    # gi Fields
    def_den: int = ...
    def_num: int = ...
    max_den: int = ...
    max_num: int = ...
    min_den: int = ...
    min_num: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ParentBufferMeta(GObject.GPointer):
    # gi Fields
    buffer: Buffer | None = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_info() -> MetaInfo: ...

class ParseContext(GObject.GBoxed):
    # gi Methods
    def copy(self) -> ParseContext | None: ...
    def free(self) -> None: ...
    def get_missing_elements(self) -> list | None: ...
    @classmethod
    def new(cls) -> ParseContext | None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class Pipeline(Bin):
    """
    A #GstPipeline is a special #GstBin used as the toplevel container for
    the filter graph. The #GstPipeline will manage the selection and
    distribution of a global #GstClock as well as provide a #GstBus to the
    application.

    gst_pipeline_new() is used to create a pipeline. when you are done with
    the pipeline, use gst_object_unref() to free its resources including all
    added #GstElement objects (if not otherwise referenced).

    Elements are added and removed from the pipeline using the #GstBin
    methods like gst_bin_add() and gst_bin_remove() (see #GstBin).

    Before changing the state of the #GstPipeline (see #GstElement) a #GstBus
    should be retrieved with gst_pipeline_get_bus(). This #GstBus should then
    be used to receive #GstMessage from the elements in the pipeline. Listening
    to the #GstBus is necessary for retrieving error messages from the
    #GstPipeline and otherwise the #GstPipeline might stop without any
    indication, why. Furthermore, the #GstPipeline posts messages even if
    nobody listens on the #GstBus, which will pile up and use up memory.

    By default, a #GstPipeline will automatically flush the pending #GstBus
    messages when going to the NULL state to ensure that no circular
    references exist when no messages are read from the #GstBus. This
    behaviour can be changed with gst_pipeline_set_auto_flush_bus().

    When the #GstPipeline performs the PAUSED to PLAYING state change it will
    select a clock for the elements. The clock selection algorithm will by
    default select a clock provided by an element that is most upstream
    (closest to the source). For live pipelines (ones that return
    #GST_STATE_CHANGE_NO_PREROLL from the gst_element_set_state() call) this
    will select the clock provided by the live source. For normal pipelines
    this will select a clock provided by the sinks (most likely the audio
    sink). If no element provides a clock, a default #GstSystemClock is used.

    The clock selection can be controlled with the gst_pipeline_use_clock()
    method, which will enforce a given clock on the pipeline. With
    gst_pipeline_auto_clock() the default clock selection algorithm can be
    restored.

    A #GstPipeline maintains a running time for the elements. The running
    time is defined as the difference between the current clock time and
    the base time. When the pipeline goes to READY or a flushing seek is
    performed on it, the running time is reset to 0. When the pipeline is
    set from PLAYING to PAUSED, the current clock time is sampled and used to
    configure the base time for the elements when the pipeline is set
    to PLAYING again. The effect is that the running time (as the difference
    between the clock time and the base time) will count how much time was spent
    in the PLAYING state. This default behaviour can be changed with the
    gst_element_set_start_time() method.
    """

    class Props(Bin.Props):
        auto_flush_bus: bool  # [auto-flush-bus]: changed because contained invalid characters
        delay: int
        latency: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def bin(self) -> Bin | None: ...
    @builtins.property
    def delay(self) -> int: ...
    @builtins.property
    def fixed_clock(self) -> Clock | None: ...
    @builtins.property
    def stream_time(self) -> int: ...

    # gi Methods
    def __init__(self, auto_flush_bus: bool = ..., delay: int = ..., latency: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def auto_clock(self) -> None: ...
    @builtins.property
    def get_auto_flush_bus(self) -> bool: ...
    def get_bus(self) -> Bus: ...
    def get_configured_latency(self) -> int: ...
    @builtins.property
    def get_delay(self) -> int: ...
    @builtins.property
    def get_latency(self) -> int: ...
    def get_pipeline_clock(self) -> Clock: ...
    def is_live(self) -> bool: ...
    @classmethod
    def new(cls, name: str | None = None) -> Element: ...
    def set_auto_flush_bus(self, auto_flush: bool) -> None: ...
    def set_delay(self, delay: int) -> None: ...
    def set_latency(self, latency: int) -> None: ...
    def use_clock(self, clock: Clock | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::auto_flush_bus"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::delay"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::latency"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PipelineClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> BinClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PipelinePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Plugin(Object):
    """
    GStreamer is extensible, so #GstElement instances can be loaded at runtime.
    A plugin system can provide one or more of the basic GStreamer
    #GstPluginFeature subclasses.

    A plugin should export a symbol `gst_plugin_desc` that is a
    struct of type #GstPluginDesc.
    the plugin loader will check the version of the core library the plugin was
    linked against and will create a new #GstPlugin. It will then call the
    #GstPluginInitFunc function that was provided in the
    `gst_plugin_desc`.

    Once you have a handle to a #GstPlugin (e.g. from the #GstRegistry), you
    can add any object that subclasses #GstPluginFeature.

    Usually plugins are always automatically loaded so you don't need to call
    gst_plugin_load() explicitly to bring it into memory. There are options to
    statically link plugins to an app or even use GStreamer without a plugin
    repository in which case gst_plugin_load() can be needed to bring the plugin
    into memory.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_dependency(
        self, env_vars: list | None, paths: list | None, names: list | None, flags: PluginDependencyFlags
    ) -> None: ...
    def add_dependency_simple(
        self, env_vars: str | None, paths: str | None, names: str | None, flags: PluginDependencyFlags
    ) -> None: ...
    def add_status_error(self, message: str) -> None: ...
    def add_status_info(self, message: str) -> None: ...
    def add_status_warning(self, message: str) -> None: ...
    def get_cache_data(self) -> Structure | None: ...
    def get_description(self) -> str: ...
    def get_filename(self) -> str | None: ...
    def get_license(self) -> str: ...
    def get_name(self) -> str: ...
    def get_origin(self) -> str: ...
    def get_package(self) -> str: ...
    def get_release_date_string(self) -> str | None: ...
    def get_source(self) -> str: ...
    def get_status_errors(self) -> list | None: ...
    def get_status_infos(self) -> list | None: ...
    def get_status_warnings(self) -> list | None: ...
    def get_version(self) -> str: ...
    def is_loaded(self) -> bool: ...
    @staticmethod
    def list_free(list: list) -> None: ...
    def load(self) -> Plugin | None: ...
    @staticmethod
    def load_by_name(name: str) -> Plugin | None: ...
    @staticmethod
    def load_file(filename: str) -> Plugin: ...
    @staticmethod
    def register_static(
        major_version: int,
        minor_version: int,
        name: str,
        description: str,
        init_func: PluginInitFunc,
        version: str,
        license: str,
        source: str,
        package: str,
        origin: str,
    ) -> bool: ...
    @staticmethod
    def register_static_full(
        major_version: int,
        minor_version: int,
        name: str,
        description: str,
        init_full_func: PluginInitFullFunc,
        version: str,
        license: str,
        source: str,
        package: str,
        origin: str,
        user_data: object | None = None,
    ) -> bool: ...
    def set_cache_data(self, cache_data: Structure) -> None: ...

class PluginClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PluginDesc(GObject.GPointer):
    # gi Fields
    description: str = ...
    license: str = ...
    major_version: int = ...
    minor_version: int = ...
    name: str = ...
    origin: str = ...
    package: str = ...
    plugin_init: PluginInitFuncPluginDescCB = ...
    release_datetime: str = ...
    source: str = ...
    version: str = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PluginFeature(Object):
    """
    This is a base class for anything that can be added to a #GstPlugin.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def check_version(self, min_major: int, min_minor: int, min_micro: int) -> bool: ...
    def get_plugin(self) -> Plugin | None: ...
    def get_plugin_name(self) -> str | None: ...
    def get_rank(self) -> int: ...
    @staticmethod
    def list_copy(list: list) -> list: ...
    @staticmethod
    def list_debug(list: list) -> None: ...
    @staticmethod
    def list_free(list: list) -> None: ...
    def load(self) -> PluginFeature | None: ...
    @staticmethod
    def rank_compare_func(p1: object | None = None, p2: object | None = None) -> int: ...
    def set_rank(self, rank: int) -> None: ...

class PluginFeatureClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Poll(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_fd(self, fd: PollFD) -> bool: ...
    def fd_can_read(self, fd: PollFD) -> bool: ...
    def fd_can_write(self, fd: PollFD) -> bool: ...
    def fd_ctl_pri(self, fd: PollFD, active: bool) -> bool: ...
    def fd_ctl_read(self, fd: PollFD, active: bool) -> bool: ...
    def fd_ctl_write(self, fd: PollFD, active: bool) -> bool: ...
    def fd_has_closed(self, fd: PollFD) -> bool: ...
    def fd_has_error(self, fd: PollFD) -> bool: ...
    def fd_has_pri(self, fd: PollFD) -> bool: ...
    def fd_ignored(self, fd: PollFD) -> None: ...
    def free(self) -> None: ...
    def get_read_gpollfd(self, fd: GLib.PollFD) -> None: ...
    def read_control(self) -> bool: ...
    def remove_fd(self, fd: PollFD) -> bool: ...
    def restart(self) -> None: ...
    def set_controllable(self, controllable: bool) -> bool: ...
    def set_flushing(self, flushing: bool) -> None: ...
    def wait(self, timeout: int) -> int: ...
    def write_control(self) -> bool: ...

class PollFD(GObject.GPointer):
    # gi Fields
    fd: int = ...
    @builtins.property
    def idx(self) -> int: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def init(self) -> None: ...

class Preset(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def delete_preset(self, name: str) -> bool: ...
    @staticmethod
    def get_app_dir() -> str | None: ...
    def get_meta(self, name: str, tag: str) -> tuple[bool, str]: ...
    def get_preset_names(self) -> list: ...
    def get_property_names(self) -> list: ...
    def is_editable(self) -> bool: ...
    def load_preset(self, name: str) -> bool: ...
    def rename_preset(self, old_name: str, new_name: str) -> bool: ...
    def save_preset(self, name: str) -> bool: ...
    @staticmethod
    def set_app_dir(app_dir: str) -> bool: ...
    def set_meta(self, name: str, tag: str, value: str | None = None) -> bool: ...

class PresetInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def delete_preset(self) -> delete_presetPresetInterfaceCB: ...
    @builtins.property
    def get_meta(self) -> get_metaPresetInterfaceCB: ...
    @builtins.property
    def get_preset_names(self) -> get_preset_namesPresetInterfaceCB: ...
    @builtins.property
    def get_property_names(self) -> get_property_namesPresetInterfaceCB: ...
    @builtins.property
    def load_preset(self) -> load_presetPresetInterfaceCB: ...
    @builtins.property
    def rename_preset(self) -> rename_presetPresetInterfaceCB: ...
    @builtins.property
    def save_preset(self) -> save_presetPresetInterfaceCB: ...
    @builtins.property
    def set_meta(self) -> set_metaPresetInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Promise(GObject.GBoxed):
    # gi Methods
    def expire(self) -> None: ...
    def get_reply(self) -> Structure | None: ...
    def interrupt(self) -> None: ...
    @classmethod
    def new(cls) -> Promise: ...
    @classmethod
    def new_with_change_func(
        cls, func: PromiseChangeFunc, user_data: object | None, notify: GLib.DestroyNotify
    ) -> Promise: ...
    def reply(self, s: Structure | None = None) -> None: ...
    def wait(self) -> PromiseResult: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class ProtectionMeta(GObject.GPointer):
    # gi Fields
    info: Structure | None = ...
    meta: Meta | None = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_info() -> MetaInfo: ...

class ProxyPad(Pad):
    # gi Fields
    @builtins.property
    def pad(self) -> Pad | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def chain_default(pad: Pad, parent: Object | None, buffer: Buffer) -> FlowReturn: ...
    @staticmethod
    def chain_list_default(pad: Pad, parent: Object | None, list: BufferList) -> FlowReturn: ...
    def get_internal(self) -> ProxyPad | None: ...
    @staticmethod
    def getrange_default(pad: Pad, parent: Object, offset: int, size: int) -> tuple[FlowReturn, Buffer]: ...
    @staticmethod
    def iterate_internal_links_default(pad: Pad, parent: Object | None = None) -> Iterator | None: ...

class ProxyPadClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> PadClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ProxyPadPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Query(GObject.GBoxed):
    # gi Fields
    mini_object: MiniObject | None = ...
    type: QueryType = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_allocation_meta(self, api: GObject.GType, params: Structure | None = None) -> None: ...
    def add_allocation_param(
        self, allocator: Allocator | None = None, params: AllocationParams | None = None
    ) -> None: ...
    def add_allocation_pool(self, pool: BufferPool | None, size: int, min_buffers: int, max_buffers: int) -> None: ...
    def add_buffering_range(self, start: int, stop: int) -> bool: ...
    def add_scheduling_mode(self, mode: PadMode) -> None: ...
    def find_allocation_meta(self, api: GObject.GType) -> tuple[bool, int | None]: ...
    def get_n_allocation_metas(self) -> int: ...
    def get_n_allocation_params(self) -> int: ...
    def get_n_allocation_pools(self) -> int: ...
    def get_n_buffering_ranges(self) -> int: ...
    def get_n_scheduling_modes(self) -> int: ...
    def get_structure(self) -> Structure | None: ...
    def has_scheduling_mode(self, mode: PadMode) -> bool: ...
    def has_scheduling_mode_with_flags(self, mode: PadMode, flags: SchedulingFlags) -> bool: ...
    @classmethod
    def new_accept_caps(cls, caps: Caps) -> Query: ...
    @classmethod
    def new_allocation(cls, caps: Caps | None, need_pool: bool) -> Query: ...
    @classmethod
    def new_bitrate(cls) -> Query: ...
    @classmethod
    def new_buffering(cls, format: Format) -> Query: ...
    @classmethod
    def new_caps(cls, filter: Caps) -> Query: ...
    @classmethod
    def new_context(cls, context_type: str) -> Query: ...
    @classmethod
    def new_convert(cls, src_format: Format, value: int, dest_format: Format) -> Query: ...
    @classmethod
    def new_custom(cls, type: QueryType, structure: Structure | None = None) -> Query: ...
    @classmethod
    def new_drain(cls) -> Query: ...
    @classmethod
    def new_duration(cls, format: Format) -> Query: ...
    @classmethod
    def new_formats(cls) -> Query: ...
    @classmethod
    def new_latency(cls) -> Query: ...
    @classmethod
    def new_position(cls, format: Format) -> Query: ...
    @classmethod
    def new_scheduling(cls) -> Query: ...
    @classmethod
    def new_seeking(cls, format: Format) -> Query: ...
    @classmethod
    def new_segment(cls, format: Format) -> Query: ...
    @classmethod
    def new_selectable(cls) -> Query: ...
    @classmethod
    def new_uri(cls) -> Query: ...
    def parse_accept_caps(self) -> Caps: ...
    def parse_accept_caps_result(self) -> bool | None: ...
    def parse_allocation(self) -> tuple[Caps | None, bool | None]: ...
    def parse_bitrate(self) -> int | None: ...
    def parse_buffering_percent(self) -> tuple[bool | None, int | None]: ...
    def parse_buffering_range(self) -> tuple[Format | None, int | None, int | None, int | None]: ...
    def parse_buffering_stats(self) -> tuple[BufferingMode | None, int | None, int | None, int | None]: ...
    def parse_caps(self) -> Caps: ...
    def parse_caps_result(self) -> Caps | None: ...
    def parse_context(self) -> Context | None: ...
    def parse_context_type(self) -> tuple[bool, str | None]: ...
    def parse_convert(self) -> tuple[Format | None, int | None, Format | None, int | None]: ...
    def parse_duration(self) -> tuple[Format | None, int | None]: ...
    def parse_latency(self) -> tuple[bool | None, int | None, int | None]: ...
    def parse_n_formats(self) -> int | None: ...
    def parse_nth_allocation_meta(self, index: int) -> tuple[GObject.GType, Structure | None]: ...
    def parse_nth_allocation_param(self, index: int) -> tuple[Allocator | None, AllocationParams | None]: ...
    def parse_nth_allocation_pool(self, index: int) -> tuple[BufferPool | None, int | None, int | None, int | None]: ...
    def parse_nth_buffering_range(self, index: int) -> tuple[bool, int | None, int | None]: ...
    def parse_nth_format(self, nth: int) -> Format | None: ...
    def parse_nth_scheduling_mode(self, index: int) -> PadMode: ...
    def parse_position(self) -> tuple[Format | None, int | None]: ...
    def parse_scheduling(self) -> tuple[SchedulingFlags | None, int | None, int | None, int | None]: ...
    def parse_seeking(self) -> tuple[Format | None, bool | None, int | None, int | None]: ...
    def parse_segment(self) -> tuple[float | None, Format | None, int | None, int | None]: ...
    def parse_selectable(self) -> bool | None: ...
    def parse_uri(self) -> str | None: ...
    def parse_uri_redirection(self) -> str | None: ...
    def parse_uri_redirection_permanent(self) -> bool | None: ...
    def remove_nth_allocation_meta(self, index: int) -> None: ...
    def remove_nth_allocation_param(self, index: int) -> None: ...
    def remove_nth_allocation_pool(self, index: int) -> None: ...
    def set_accept_caps_result(self, result: bool) -> None: ...
    def set_bitrate(self, nominal_bitrate: int) -> None: ...
    def set_buffering_percent(self, busy: bool, percent: int) -> None: ...
    def set_buffering_range(self, format: Format, start: int, stop: int, estimated_total: int) -> None: ...
    def set_buffering_stats(self, mode: BufferingMode, avg_in: int, avg_out: int, buffering_left: int) -> None: ...
    def set_caps_result(self, caps: Caps | None = None) -> None: ...
    def set_context(self, context: Context | None = None) -> None: ...
    def set_convert(self, src_format: Format, src_value: int, dest_format: Format, dest_value: int) -> None: ...
    def set_duration(self, format: Format, duration: int) -> None: ...
    def set_formatsv(self, n_formats: int, formats: list) -> None: ...
    def set_latency(self, live: bool, min_latency: int, max_latency: int) -> None: ...
    def set_nth_allocation_param(
        self, index: int, allocator: Allocator | None = None, params: AllocationParams | None = None
    ) -> None: ...
    def set_nth_allocation_pool(
        self, index: int, pool: BufferPool | None, size: int, min_buffers: int, max_buffers: int
    ) -> None: ...
    def set_position(self, format: Format, cur: int) -> None: ...
    def set_scheduling(self, flags: SchedulingFlags, minsize: int, maxsize: int, align: int) -> None: ...
    def set_seeking(self, format: Format, seekable: bool, segment_start: int, segment_end: int) -> None: ...
    def set_segment(self, rate: float, format: Format, start_value: int, stop_value: int) -> None: ...
    def set_selectable(self, selectable: bool) -> None: ...
    def set_uri(self, uri: str | None = None) -> None: ...
    def set_uri_redirection(self, uri: str | None = None) -> None: ...
    def set_uri_redirection_permanent(self, permanent: bool) -> None: ...
    def writable_structure(self) -> Structure: ...

class ReferenceTimestampMeta(GObject.GPointer):
    # gi Fields
    duration: int = ...
    reference: Caps | None = ...
    timestamp: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_info() -> MetaInfo: ...

class Registry(Object):
    """
    One registry holds the metadata of a set of plugins.

    <emphasis role="bold">Design:</emphasis>

    The #GstRegistry object is a list of plugins and some functions for dealing
    with them. Each #GstPlugin is matched 1-1 with a file on disk, and may or may
    not be loaded at a given time.

    The primary source, at all times, of plugin information is each plugin file
    itself. Thus, if an application wants information about a particular plugin,
    or wants to search for a feature that satisfies given criteria, the primary
    means of doing so is to load every plugin and look at the resulting
    information that is gathered in the default registry. Clearly, this is a time
    consuming process, so we cache information in the registry file. The format
    and location of the cache file is internal to gstreamer.

    On startup, plugins are searched for in the plugin search path. The following
    locations are checked in this order:

    * location from --gst-plugin-path commandline option.
    * the GST_PLUGIN_PATH environment variable.
    * the GST_PLUGIN_SYSTEM_PATH environment variable.
    * default locations (if GST_PLUGIN_SYSTEM_PATH is not set).
      Those default locations are:
      `$XDG_DATA_HOME/gstreamer-$GST_API_VERSION/plugins/`
      and `$prefix/libs/gstreamer-$GST_API_VERSION/`.
      [$XDG_DATA_HOME](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html) defaults to
      `$HOME/.local/share`.

    The registry cache file is loaded from
    `$XDG_CACHE_HOME/gstreamer-$GST_API_VERSION/registry-$ARCH.bin`
    (where $XDG_CACHE_HOME defaults to `$HOME/.cache`) or the file listed in the `GST_REGISTRY`
    env var. One reason to change the registry location is for testing.

    For each plugin that is found in the plugin search path, there could be 3
    possibilities for cached information:

      * the cache may not contain information about a given file.
      * the cache may have stale information.
      * the cache may have current information.

    In the first two cases, the plugin is loaded and the cache updated. In
    addition to these cases, the cache may have entries for plugins that are not
    relevant to the current process. These are marked as not available to the
    current process. If the cache is updated for whatever reason, it is marked
    dirty.

    A dirty cache is written out at the end of initialization. Each entry is
    checked to make sure the information is minimally valid. If not, the entry is
    simply dropped.

    ## Implementation notes:

    The "cache" and "registry" are different concepts and can represent
    different sets of plugins. For various reasons, at init time, the cache is
    stored in the default registry, and plugins not relevant to the current
    process are marked with the %GST_PLUGIN_FLAG_CACHED bit. These plugins are
    removed at the end of initialization.
    """

    # gi Fields
    @builtins.property
    def object(self) -> Object | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_feature(self, feature: PluginFeature) -> bool: ...
    def add_plugin(self, plugin: Plugin) -> bool: ...
    def check_feature_version(self, feature_name: str, min_major: int, min_minor: int, min_micro: int) -> bool: ...
    def feature_filter(self, filter: PluginFeatureFilter, first: bool, user_data: object | None = None) -> list: ...
    def find_feature(self, name: str, type: GObject.GType) -> PluginFeature | None: ...
    def find_plugin(self, name: str) -> Plugin | None: ...
    @staticmethod
    def fork_is_enabled() -> bool: ...
    @staticmethod
    def fork_set_enabled(enabled: bool) -> None: ...
    @staticmethod
    def get() -> Registry: ...
    def get_feature_list(self, type: GObject.GType) -> list: ...
    def get_feature_list_by_plugin(self, name: str) -> list: ...
    def get_feature_list_cookie(self) -> int: ...
    def get_plugin_list(self) -> list: ...
    def lookup(self, filename: str) -> Plugin | None: ...
    def lookup_feature(self, name: str) -> PluginFeature | None: ...
    def plugin_filter(self, filter: PluginFilter, first: bool, user_data: object | None = None) -> list: ...
    def remove_feature(self, feature: PluginFeature) -> None: ...
    def remove_plugin(self, plugin: Plugin) -> None: ...
    def scan_path(self, path: str) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["feature-added"],
        handler: typing.Callable[[typing_extensions.Self, PluginFeature], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["plugin-added"],
        handler: typing.Callable[[typing_extensions.Self, Plugin], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class RegistryClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class RegistryPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Sample(GObject.GBoxed):
    # gi Methods
    def get_buffer(self) -> Buffer | None: ...
    def get_buffer_list(self) -> BufferList | None: ...
    def get_caps(self) -> Caps | None: ...
    def get_info(self) -> Structure | None: ...
    def get_segment(self) -> Segment: ...
    @classmethod
    def new(
        cls,
        buffer: Buffer | None = None,
        caps: Caps | None = None,
        segment: Segment | None = None,
        info: Structure | None = None,
    ) -> Sample: ...
    def set_buffer(self, buffer: Buffer) -> None: ...
    def set_buffer_list(self, buffer_list: BufferList) -> None: ...
    def set_caps(self, caps: Caps) -> None: ...
    def set_info(self, info: Structure) -> bool: ...
    def set_segment(self, segment: Segment) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class Segment(GObject.GBoxed):
    # gi Fields
    applied_rate: float = ...
    base: int = ...
    duration: int = ...
    flags: SegmentFlags = ...
    format: Format = ...
    offset: int = ...
    position: int = ...
    rate: float = ...
    start: int = ...
    stop: int = ...
    time: int = ...

    # gi Methods
    def clip(self, format: Format, start: int, stop: int) -> tuple[bool, int | None, int | None]: ...
    def copy(self) -> Segment: ...
    def copy_into(self, dest: Segment) -> None: ...
    def do_seek(
        self,
        rate: float,
        format: Format,
        flags: SeekFlags,
        start_type: SeekType,
        start: int,
        stop_type: SeekType,
        stop: int,
    ) -> tuple[bool, bool | None]: ...
    def free(self) -> None: ...
    def init(self, format: Format) -> None: ...
    def is_equal(self, s1: Segment) -> bool: ...
    @classmethod
    def new(cls) -> Segment: ...
    def offset_running_time(self, format: Format, offset: int) -> bool: ...
    def position_from_running_time(self, format: Format, running_time: int) -> int: ...
    def position_from_running_time_full(self, format: Format, running_time: int) -> tuple[int, int]: ...
    def position_from_stream_time(self, format: Format, stream_time: int) -> int: ...
    def position_from_stream_time_full(self, format: Format, stream_time: int) -> tuple[int, int]: ...
    def set_running_time(self, format: Format, running_time: int) -> bool: ...
    @deprecated("deprecated")
    def to_position(self, format: Format, running_time: int) -> int: ...
    def to_running_time(self, format: Format, position: int) -> int: ...
    def to_running_time_full(self, format: Format, position: int) -> tuple[int, int | None]: ...
    def to_stream_time(self, format: Format, position: int) -> int: ...
    def to_stream_time_full(self, format: Format, position: int) -> tuple[int, int]: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class SharedTaskPool(TaskPool):
    """
    The #GstSharedTaskPool object.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_max_threads(self) -> int: ...
    @classmethod
    def new(cls) -> TaskPool: ...
    def set_max_threads(self, max_threads: int) -> None: ...

class SharedTaskPoolClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> TaskPoolClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SharedTaskPoolPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class StaticCaps(GObject.GPointer):
    # gi Fields
    caps: Caps | None = ...
    string: str = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def cleanup(self) -> None: ...
    def get(self) -> Caps | None: ...

class StaticPadTemplate(GObject.GPointer):
    # gi Fields
    direction: PadDirection = ...
    name_template: str = ...
    presence: PadPresence = ...
    static_caps: StaticCaps | None = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get(self) -> PadTemplate | None: ...
    def get_caps(self) -> Caps: ...

class Stream(Object):
    """
    A high-level object representing a single stream. It might be backed, or
    not, by an actual flow of data in a pipeline (#GstPad).

    A #GstStream does not care about data changes (such as decoding, encoding,
    parsing,...) as long as the underlying data flow corresponds to the same
    high-level flow (ex: a certain audio track).

    A #GstStream contains all the information pertinent to a stream, such as
    stream-id, tags, caps, type, ...

    Elements can subclass a #GstStream for internal usage (to contain information
    pertinent to streams of data).
    """

    class Props(Object.Props):
        caps: Caps | None
        stream_flags: StreamFlags  # [stream-flags]: changed because contained invalid characters
        stream_id: str  # [stream-id]: changed because contained invalid characters
        stream_type: StreamType  # [stream-type]: changed because contained invalid characters
        tags: TagList | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def stream_id(self) -> str: ...

    # gi Methods
    def __init__(
        self,
        caps: Caps | None = ...,
        stream_flags: StreamFlags = ...,
        stream_id: str = ...,
        stream_type: StreamType = ...,
        tags: TagList | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_caps(self) -> Caps | None: ...
    @builtins.property
    def get_stream_flags(self) -> StreamFlags: ...
    @builtins.property
    def get_stream_id(self) -> str | None: ...
    @builtins.property
    def get_stream_type(self) -> StreamType: ...
    @builtins.property
    def get_tags(self) -> TagList | None: ...
    @classmethod
    def new(cls, stream_id: str | None, caps: Caps | None, type: StreamType, flags: StreamFlags) -> Stream: ...
    def set_caps(self, caps: Caps | None = None) -> None: ...
    def set_stream_flags(self, flags: StreamFlags) -> None: ...
    def set_stream_type(self, stream_type: StreamType) -> None: ...
    def set_tags(self, tags: TagList | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stream_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stream_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stream_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class StreamCollection(Object):
    """
    A collection of #GstStream that are available.

    A #GstStreamCollection will be provided by elements that can make those
    streams available. Applications can use the collection to show the user
    what streams are available by using %gst_stream_collection_get_stream()

    Once posted, a #GstStreamCollection is immutable. Updates are made by sending
    a new #GstStreamCollection message, which may or may not share some of
    the #GstStream objects from the collection it replaces. The receiver can check
    the sender of a stream collection message to know which collection is
    obsoleted.

    Several elements in a pipeline can provide #GstStreamCollection.

    Applications can activate streams from a collection by using the
    #GST_EVENT_SELECT_STREAMS event on a pipeline, bin or element.
    """

    class Props(Object.Props):
        upstream_id: str  # [upstream-id]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def upstream_id(self) -> str: ...

    # gi Methods
    def __init__(self, upstream_id: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_stream(self, stream: Stream) -> bool: ...
    def get_size(self) -> int: ...
    def get_stream(self, index: int) -> Stream | None: ...
    @builtins.property
    def get_upstream_id(self) -> str | None: ...
    @classmethod
    def new(cls, upstream_id: str | None = None) -> StreamCollection: ...

    # python methods (overrides?)
    def do_stream_notify(
        self,
        stream: Stream,
        pspec: GObject.ParamSpec,
    ) -> None:
        """
        stream_notify(self, stream:Gst.Stream, pspec:GObject.ParamSpec)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["stream-notify"],
        handler: typing.Callable[[typing_extensions.Self, Stream, GObject.ParamSpec], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::upstream_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StreamCollectionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def stream_notify(self) -> stream_notifyStreamCollectionClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class StreamCollectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class StreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Structure(GObject.GBoxed):
    # gi Fields
    @builtins.property
    def name(self) -> int: ...
    type: GObject.GType = ...  # type: ignore

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_intersect(self, struct2: Structure) -> bool: ...
    def copy(self) -> Structure: ...
    @deprecated("deprecated")
    def filter_and_map_in_place(self, func: StructureFilterMapFunc, user_data: object | None = None) -> None: ...
    def filter_and_map_in_place_id_str(
        self, func: StructureFilterMapIdStrFunc, user_data: object | None = None
    ) -> None: ...
    def fixate(self) -> None: ...
    def fixate_field(self, field_name: str) -> bool: ...
    def fixate_field_boolean(self, field_name: str, target: bool) -> bool: ...
    def fixate_field_nearest_double(self, field_name: str, target: float) -> bool: ...
    def fixate_field_nearest_fraction(
        self, field_name: str, target_numerator: int, target_denominator: int
    ) -> bool: ...
    def fixate_field_nearest_int(self, field_name: str, target: int) -> bool: ...
    def fixate_field_string(self, field_name: str, target: str) -> bool: ...
    @deprecated("deprecated")
    def foreach(self, func: StructureForeachFunc, user_data: object | None = None) -> bool: ...
    def foreach_id_str(self, func: StructureForeachIdStrFunc, user_data: object | None = None) -> bool: ...
    def free(self) -> None: ...
    @classmethod
    def from_string(cls, string: str) -> tuple[Structure | None, str | None]: ...
    def get_array(self, fieldname: str) -> tuple[bool, GObject.ValueArray]: ...
    def get_boolean(self, fieldname: str) -> tuple[bool, bool]: ...
    def get_clock_time(self, fieldname: str) -> tuple[bool, int]: ...
    def get_date(self, fieldname: str) -> tuple[bool, GLib.Date]: ...
    def get_date_time(self, fieldname: str) -> tuple[bool, DateTime]: ...
    def get_double(self, fieldname: str) -> tuple[bool, float]: ...
    def get_enum(self, fieldname: str, enumtype: GObject.GType) -> tuple[bool, int]: ...
    def get_field_type(self, fieldname: str) -> GObject.GType: ...
    def get_flags(self, fieldname: str, flags_type: GObject.GType) -> tuple[bool, int]: ...
    def get_flagset(self, fieldname: str) -> tuple[bool, int | None, int | None]: ...
    def get_fraction(self, fieldname: str) -> tuple[bool, int, int]: ...
    def get_int(self, fieldname: str) -> tuple[bool, int]: ...
    def get_int64(self, fieldname: str) -> tuple[bool, int]: ...
    def get_list(self, fieldname: str) -> tuple[bool, GObject.ValueArray]: ...
    def get_name(self) -> str: ...
    @deprecated("deprecated")
    def get_name_id(self) -> int: ...
    def get_name_id_str(self) -> IdStr: ...
    def get_string(self, fieldname: str) -> str | None: ...
    def get_uint(self, fieldname: str) -> tuple[bool, int]: ...
    def get_uint64(self, fieldname: str) -> tuple[bool, int]: ...
    def get_value(self, fieldname: str) -> GObject.Value | None: ...
    def has_field(self, fieldname: str) -> bool: ...
    def has_field_typed(self, fieldname: str, type: GObject.GType) -> bool: ...
    def has_name(self, name: str) -> bool: ...
    def id_get_value(self, field: int) -> GObject.Value | None: ...
    @deprecated("deprecated")
    def id_has_field(self, field: int) -> bool: ...
    @deprecated("deprecated")
    def id_has_field_typed(self, field: int, type: GObject.GType) -> bool: ...
    @deprecated("deprecated")
    def id_set_value(self, field: int, value: GObject.Value) -> None: ...
    def id_str_get_field_type(self, fieldname: IdStr) -> GObject.GType: ...
    def id_str_get_value(self, fieldname: IdStr) -> GObject.Value | None: ...
    def id_str_has_field(self, fieldname: IdStr) -> bool: ...
    def id_str_has_field_typed(self, fieldname: IdStr, type: GObject.GType) -> bool: ...
    def id_str_nth_field_name(self, index: int) -> IdStr: ...
    def id_str_remove_field(self, fieldname: IdStr) -> None: ...
    def id_str_set_value(self, fieldname: IdStr, value: GObject.Value) -> None: ...
    def id_str_take_value(self, fieldname: IdStr, value: GObject.Value) -> None: ...
    @deprecated("deprecated")
    def id_take_value(self, field: int, value: GObject.Value) -> None: ...
    def intersect(self, struct2: Structure) -> Structure | None: ...
    def is_equal(self, structure2: Structure) -> bool: ...
    def is_subset(self, superset: Structure) -> bool: ...
    @deprecated("deprecated")
    def map_in_place(self, func: StructureMapFunc, user_data: object | None = None) -> bool: ...
    def map_in_place_id_str(self, func: StructureMapIdStrFunc, user_data: object | None = None) -> bool: ...
    def n_fields(self) -> int: ...
    @classmethod
    def new_empty(cls, name: str) -> Structure: ...
    @classmethod
    def new_from_string(cls, string: str) -> Structure | None: ...
    @deprecated("deprecated")
    @classmethod
    def new_id_empty(cls, quark: int) -> Structure: ...
    @classmethod
    def new_id_str_empty(cls, name: IdStr) -> Structure: ...
    @classmethod
    def new_static_str_empty(cls, name: str) -> Structure: ...
    def nth_field_name(self, index: int) -> str: ...
    def remove_all_fields(self) -> None: ...
    def remove_field(self, fieldname: str) -> None: ...
    @deprecated("deprecated")
    def serialize(self, flags: SerializeFlags) -> str: ...
    def serialize_full(self, flags: SerializeFlags) -> str | None: ...
    def set_array(self, fieldname: str, array: GObject.ValueArray) -> None: ...
    def set_list(self, fieldname: str, array: GObject.ValueArray) -> None: ...
    def set_name(self, name: str) -> None: ...
    def set_name_id_str(self, name: IdStr) -> None: ...
    def set_name_static_str(self, name: str) -> None: ...
    def set_parent_refcount(self, refcount: int) -> bool: ...
    def set_value(self, fieldname: str, value: GObject.Value) -> None: ...
    def set_value_static_str(self, fieldname: str, value: GObject.Value) -> None: ...
    @staticmethod
    def take(oldstr_ptr: Structure | None = None, newstr: Structure | None = None) -> tuple[bool, Structure | None]: ...
    def take_value(self, fieldname: str, value: GObject.Value) -> None: ...
    def take_value_static_str(self, fieldname: str, value: GObject.Value) -> None: ...
    def to_string(self) -> str: ...

class SystemClock(Clock):
    """
    The GStreamer core provides a GstSystemClock based on the system time.
    Asynchronous callbacks are scheduled from an internal thread.

    Clock implementors are encouraged to subclass this systemclock as it
    implements the async notification.

    Subclasses can however override all of the important methods for sync and
    async notifications to implement their own callback methods or blocking
    wait operations.
    """

    class Props(Clock.Props):
        clock_type: ClockType  # [clock-type]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def clock(self) -> Clock | None: ...

    # gi Methods
    def __init__(self, clock_type: ClockType = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def obtain() -> Clock: ...
    @staticmethod
    def set_default(new_clock: Clock | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::clock_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SystemClockClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ClockClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SystemClockPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TagList(GObject.GBoxed):
    # gi Fields
    mini_object: MiniObject | None = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_value(self, mode: TagMergeMode, tag: str, value: GObject.Value) -> None: ...
    def copy(self) -> TagList: ...
    @staticmethod
    def copy_value(list: TagList, tag: str) -> tuple[bool, GObject.Value]: ...
    def foreach(self, func: TagForeachFunc, user_data: object | None = None) -> None: ...
    def get_boolean(self, tag: str) -> tuple[bool, bool]: ...
    def get_boolean_index(self, tag: str, index: int) -> tuple[bool, bool]: ...
    def get_date(self, tag: str) -> tuple[bool, GLib.Date]: ...
    def get_date_index(self, tag: str, index: int) -> tuple[bool, GLib.Date]: ...
    def get_date_time(self, tag: str) -> tuple[bool, DateTime]: ...
    def get_date_time_index(self, tag: str, index: int) -> tuple[bool, DateTime]: ...
    def get_double(self, tag: str) -> tuple[bool, float]: ...
    def get_double_index(self, tag: str, index: int) -> tuple[bool, float]: ...
    def get_float(self, tag: str) -> tuple[bool, float]: ...
    def get_float_index(self, tag: str, index: int) -> tuple[bool, float]: ...
    def get_int(self, tag: str) -> tuple[bool, int]: ...
    def get_int64(self, tag: str) -> tuple[bool, int]: ...
    def get_int64_index(self, tag: str, index: int) -> tuple[bool, int]: ...
    def get_int_index(self, tag: str, index: int) -> tuple[bool, int]: ...
    def get_pointer(self, tag: str) -> tuple[bool, object | None]: ...
    def get_pointer_index(self, tag: str, index: int) -> tuple[bool, object | None]: ...
    def get_sample(self, tag: str) -> tuple[bool, Sample]: ...
    def get_sample_index(self, tag: str, index: int) -> tuple[bool, Sample]: ...
    def get_scope(self) -> TagScope: ...
    def get_string(self, tag: str) -> tuple[bool, str]: ...
    def get_string_index(self, tag: str, index: int) -> tuple[bool, str]: ...
    def get_tag_size(self, tag: str) -> int: ...
    def get_uint(self, tag: str) -> tuple[bool, int]: ...
    def get_uint64(self, tag: str) -> tuple[bool, int]: ...
    def get_uint64_index(self, tag: str, index: int) -> tuple[bool, int]: ...
    def get_uint_index(self, tag: str, index: int) -> tuple[bool, int]: ...
    def get_value_index(self, tag: str, index: int) -> GObject.Value | None: ...
    def insert(self, from_: TagList, mode: TagMergeMode) -> None: ...
    def is_empty(self) -> bool: ...
    def is_equal(self, list2: TagList) -> bool: ...
    def merge(self, list2: TagList | None, mode: TagMergeMode) -> TagList | None: ...
    def n_tags(self) -> int: ...
    @classmethod
    def new_empty(cls) -> TagList: ...
    @classmethod
    def new_from_string(cls, str: str) -> TagList | None: ...
    def nth_tag_name(self, index: int) -> str: ...
    def peek_string_index(self, tag: str, index: int) -> tuple[bool, str]: ...
    def remove_tag(self, tag: str) -> None: ...
    def set_scope(self, scope: TagScope) -> None: ...
    def to_string(self) -> str: ...

class TagSetter(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_tag_value(self, mode: TagMergeMode, tag: str, value: GObject.Value) -> None: ...
    def get_tag_list(self) -> TagList | None: ...
    def get_tag_merge_mode(self) -> TagMergeMode: ...
    def merge_tags(self, list: TagList, mode: TagMergeMode) -> None: ...
    def reset_tags(self) -> None: ...
    def set_tag_merge_mode(self, mode: TagMergeMode) -> None: ...

class TagSetterInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Task(Object):
    """
    #GstTask is used by #GstElement and #GstPad to provide the data passing
    threads in a #GstPipeline.

    A #GstPad will typically start a #GstTask to push or pull data to/from the
    peer pads. Most source elements start a #GstTask to push data. In some cases
    a demuxer element can start a #GstTask to pull data from a peer element. This
    is typically done when the demuxer can perform random access on the upstream
    peer element for improved performance.

    Although convenience functions exist on #GstPad to start/pause/stop tasks, it
    might sometimes be needed to create a #GstTask manually if it is not related to
    a #GstPad.

    Before the #GstTask can be run, it needs a #GRecMutex that can be set with
    gst_task_set_lock().

    The task can be started, paused and stopped with gst_task_start(), gst_task_pause()
    and gst_task_stop() respectively or with the gst_task_set_state() function.

    A #GstTask will repeatedly call the #GstTaskFunction with the user data
    that was provided when creating the task with gst_task_new(). While calling
    the function it will acquire the provided lock. The provided lock is released
    when the task pauses or stops.

    Stopping a task with gst_task_stop() will not immediately make sure the task is
    not running anymore. Use gst_task_join() to make sure the task is completely
    stopped and the thread is stopped.

    After creating a #GstTask, use gst_object_unref() to free its resources. This can
    only be done when the task is not running anymore.

    Task functions can send a #GstMessage to send out-of-band data to the
    application. The application can receive messages from the #GstBus in its
    mainloop.

    For debugging purposes, the task will configure its object name as the thread
    name on Linux. Please note that the object name should be configured before the
    task is started; changing the object name after the task has been started, has
    no effect on the thread name.
    """

    # gi Fields
    @builtins.property
    def cond(self) -> GLib.Cond | None: ...
    @builtins.property
    def func(self) -> TaskFunctionTaskCB: ...
    @builtins.property
    def lock(self) -> GLib.RecMutex | None: ...
    @builtins.property
    def notify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def running(self) -> bool: ...
    @builtins.property
    def state(self) -> TaskState: ...
    @builtins.property
    def thread(self) -> GLib.Thread | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def cleanup_all() -> None: ...
    def get_pool(self) -> TaskPool: ...
    def get_state(self) -> TaskState: ...
    def join(self) -> bool: ...
    @classmethod
    def new(cls, func: TaskFunction, user_data: object | None, notify: GLib.DestroyNotify) -> Task: ...
    def pause(self) -> bool: ...
    def resume(self) -> bool: ...
    def set_enter_callback(
        self, enter_func: TaskThreadFunc, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_leave_callback(
        self, leave_func: TaskThreadFunc, user_data: object | None, notify: GLib.DestroyNotify
    ) -> None: ...
    def set_lock(self, mutex: GLib.RecMutex) -> None: ...
    def set_pool(self, pool: TaskPool) -> None: ...
    def set_state(self, state: TaskState) -> bool: ...
    def start(self) -> bool: ...
    def stop(self) -> bool: ...

class TaskClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def pool(self) -> TaskPool | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TaskPool(Object):
    """
    This object provides an abstraction for creating threads. The default
    implementation uses a regular GThreadPool to start tasks.

    Subclasses can be made to create custom threads.
    """

    # gi Fields
    @builtins.property
    def object(self) -> Object | None: ...
    @builtins.property
    def pool(self) -> GLib.ThreadPool | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def cleanup(self) -> None: ...
    def dispose_handle(self, id: object | None = None) -> None: ...
    def join(self, id: object | None = None) -> None: ...
    @classmethod
    def new(cls) -> TaskPool: ...
    def prepare(self) -> None: ...
    def push(self, func: TaskPoolFunction, user_data: object | None = None) -> object | None: ...

    # python methods (overrides?)
    def do_cleanup(
        self,
    ) -> None:
        """
        cleanup(self)
        """
    def do_dispose_handle(
        self,
        id: typing.Any = None,
    ) -> None:
        """
        dispose_handle(self, id=None)
        """
    def do_join(
        self,
        id: typing.Any = None,
    ) -> None:
        """
        join(self, id=None)
        """
    def do_prepare(
        self,
    ) -> None:
        """
        prepare(self)
        """
    def do_push(
        self,
        func: typing.Callable,
        user_data: typing.Any = None,
    ) -> typing.Any:
        """
        push(self, func:Gst.TaskPoolFunction, user_data=None)
        """

class TaskPoolClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def cleanup(self) -> cleanupTaskPoolClassCB: ...
    @builtins.property
    def dispose_handle(self) -> dispose_handleTaskPoolClassCB: ...
    @builtins.property
    def join(self) -> joinTaskPoolClassCB: ...
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...
    @builtins.property
    def prepare(self) -> prepareTaskPoolClassCB: ...
    @builtins.property
    def push(self) -> pushTaskPoolClassCB | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TaskPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TimedValue(GObject.GPointer):
    # gi Fields
    timestamp: int = ...
    value: float = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Toc(GObject.GBoxed):
    # gi Methods
    def append_entry(self, entry: TocEntry) -> None: ...
    def dump(self) -> None: ...
    def find_entry(self, uid: str) -> TocEntry | None: ...
    def get_entries(self) -> list: ...
    def get_scope(self) -> TocScope: ...
    def get_tags(self) -> TagList | None: ...
    def merge_tags(self, tags: TagList | None, mode: TagMergeMode) -> None: ...
    @classmethod
    def new(cls, scope: TocScope) -> Toc: ...
    def set_tags(self, tags: TagList | None = None) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class TocEntry(GObject.GBoxed):
    # gi Methods
    def append_sub_entry(self, subentry: TocEntry) -> None: ...
    def get_entry_type(self) -> TocEntryType: ...
    def get_loop(self) -> tuple[bool, TocLoopType | None, int | None]: ...
    def get_parent(self) -> TocEntry | None: ...
    def get_start_stop_times(self) -> tuple[bool, int | None, int | None]: ...
    def get_sub_entries(self) -> list: ...
    def get_tags(self) -> TagList | None: ...
    def get_toc(self) -> Toc | None: ...
    def get_uid(self) -> str: ...
    def is_alternative(self) -> bool: ...
    def is_sequence(self) -> bool: ...
    def merge_tags(self, tags: TagList | None, mode: TagMergeMode) -> None: ...
    @classmethod
    def new(cls, type: TocEntryType, uid: str) -> TocEntry: ...
    def set_loop(self, loop_type: TocLoopType, repeat_count: int) -> None: ...
    def set_start_stop_times(self, start: int, stop: int) -> None: ...
    def set_tags(self, tags: TagList | None = None) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class TocSetter(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_toc(self) -> Toc | None: ...
    def reset(self) -> None: ...
    def set_toc(self, toc: Toc | None = None) -> None: ...

class TocSetterInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Tracer(Object):
    """
    Tracing modules will subclass #GstTracer and register through
    gst_tracer_register(). Modules can attach to various hook-types - see
    gst_tracing_register_hook(). When invoked they receive hook specific
    contextual data, which they must not modify.
    """

    class Props(Object.Props):
        params: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, params: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def register(plugin: Plugin | None, name: str, type: GObject.GType) -> bool: ...

    # python methods (overrides?)
    @classmethod
    def set_use_structure_params(
        cls,
        use_structure_params: bool,
    ) -> None:
        """
        set_use_structure_params(self, use_structure_params:bool)
        """
    @classmethod
    def uses_structure_params(
        cls,
    ) -> bool:
        """
        uses_structure_params(self) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::params"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TracerClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def set_use_structure_params(self, use_structure_params: bool) -> None: ...
    def uses_structure_params(self) -> bool: ...

class TracerFactory(PluginFeature):
    """
    Use gst_tracer_factory_get_list() to get a list of tracer factories known to
    GStreamer.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_list() -> list: ...
    def get_tracer_type(self) -> GObject.GType: ...

class TracerFactoryClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TracerPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TracerRecord(Object):
    """
    Tracing modules will create instances of this class to announce the data they
    will log and create a log formatter.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TracerRecordClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TypeFind(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_length(self) -> int: ...
    def peek(self, offset: int, size: int) -> int | None: ...
    @staticmethod
    def register(
        plugin: Plugin | None,
        name: str,
        rank: int,
        func: TypeFindFunction,
        extensions: str | None,
        possible_caps: Caps | None,
        data: object | None,
        data_notify: GLib.DestroyNotify,
    ) -> bool: ...
    def suggest(self, probability: int, caps: Caps) -> None: ...
    def suggest_empty_simple(self, probability: int, media_type: str) -> None: ...

class TypeFindFactory(PluginFeature):
    """
    These functions allow querying information about registered typefind
    functions. How to create and register these functions is described in
    the section <link linkend="gstreamer-Writing-typefind-functions">
    "Writing typefind functions"</link>.

    The following example shows how to write a very simple typefinder that
    identifies the given data. You can get quite a bit more complicated than
    that though.
    |[<!-- language="C" -->
      typedef struct {
        guint8 *data;
        guint size;
        guint probability;
        GstCaps *data;
      } MyTypeFind;
      static void
      my_peek (gpointer data, gint64 offset, guint size)
      {
        MyTypeFind *find = (MyTypeFind *) data;
        if (offset >= 0 && offset + size <= find->size) {
          return find->data + offset;
        }
        return NULL;
      }
      static void
      my_suggest (gpointer data, guint probability, GstCaps *caps)
      {
        MyTypeFind *find = (MyTypeFind *) data;
        if (probability > find->probability) {
          find->probability = probability;
          gst_caps_replace (&find->caps, caps);
        }
      }
      static GstCaps *
      find_type (guint8 *data, guint size)
      {
        GList *walk, *type_list;
        MyTypeFind find = {data, size, 0, NULL};
        GstTypeFind gst_find = {my_peek, my_suggest, &find, };
        walk = type_list = gst_type_find_factory_get_list ();
        while (walk) {
          GstTypeFindFactory *factory = GST_TYPE_FIND_FACTORY (walk->data);
          walk = g_list_next (walk)
          gst_type_find_factory_call_function (factory, &gst_find);
        }
        g_list_free (type_list);
        return find.caps;
      };
    ]|
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def call_function(self, find: TypeFind) -> None: ...
    def get_caps(self) -> Caps | None: ...
    def get_extensions(self) -> list | None: ...
    @staticmethod
    def get_list() -> list: ...
    def has_function(self) -> bool: ...

class TypeFindFactoryClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class URIHandler(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_protocols(self) -> list | None: ...
    def get_uri(self) -> str | None: ...
    def get_uri_type(self) -> URIType: ...
    def set_uri(self, uri: str) -> bool: ...

class URIHandlerInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def get_protocols(self) -> get_protocolsURIHandlerInterfaceCB: ...
    @builtins.property
    def get_type(self) -> get_typeURIHandlerInterfaceCB: ...
    @builtins.property
    def get_uri(self) -> get_uriURIHandlerInterfaceCB | None: ...
    @builtins.property
    def set_uri(self) -> set_uriURIHandlerInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Uri(GObject.GBoxed):
    # gi Methods
    def append_path(self, relative_path: str | None = None) -> bool: ...
    def append_path_segment(self, path_segment: str | None = None) -> bool: ...
    @deprecated("deprecated")
    @staticmethod
    def construct(protocol: str, location: str) -> str: ...
    def equal(self, second: Uri) -> bool: ...
    @staticmethod
    def from_string(uri: str) -> Uri | None: ...
    @staticmethod
    def from_string_escaped(uri: str) -> Uri | None: ...
    def from_string_with_base(self, uri: str) -> Uri | None: ...
    def get_fragment(self) -> str | None: ...
    def get_host(self) -> str | None: ...
    @staticmethod
    def get_location(uri: str) -> str | None: ...
    def get_media_fragment_table(self) -> dict | None: ...
    def get_path(self) -> str | None: ...
    def get_path_segments(self) -> list: ...
    def get_path_string(self) -> str | None: ...
    def get_port(self) -> int: ...
    @staticmethod
    def get_protocol(uri: str) -> str | None: ...
    def get_query_keys(self) -> list: ...
    def get_query_string(self) -> str | None: ...
    def get_query_string_ordered(self, keys: list | None = None) -> str | None: ...
    def get_query_table(self) -> dict | None: ...
    def get_query_value(self, query_key: str) -> str | None: ...
    def get_scheme(self) -> str | None: ...
    def get_userinfo(self) -> str | None: ...
    @staticmethod
    def has_protocol(uri: str, protocol: str) -> bool: ...
    def is_normalized(self) -> bool: ...
    @staticmethod
    def is_valid(uri: str) -> bool: ...
    def is_writable(self) -> bool: ...
    def join(self, ref_uri: Uri | None = None) -> Uri | None: ...
    @staticmethod
    def join_strings(base_uri: str, ref_uri: str) -> str | None: ...
    def make_writable(self) -> Uri: ...
    @classmethod
    def new(
        cls,
        scheme: str | None,
        userinfo: str | None,
        host: str | None,
        port: int,
        path: str | None = None,
        query: str | None = None,
        fragment: str | None = None,
    ) -> Uri: ...
    def new_with_base(
        self,
        scheme: str | None,
        userinfo: str | None,
        host: str | None,
        port: int,
        path: str | None = None,
        query: str | None = None,
        fragment: str | None = None,
    ) -> Uri: ...
    def normalize(self) -> bool: ...
    @staticmethod
    def protocol_is_supported(type: URIType, protocol: str) -> bool: ...
    @staticmethod
    def protocol_is_valid(protocol: str) -> bool: ...
    def query_has_key(self, query_key: str) -> bool: ...
    def remove_query_key(self, query_key: str) -> bool: ...
    def set_fragment(self, fragment: str | None = None) -> bool: ...
    def set_host(self, host: str) -> bool: ...
    def set_path(self, path: str | None = None) -> bool: ...
    def set_path_segments(self, path_segments: list | None = None) -> bool: ...
    def set_path_string(self, path: str) -> bool: ...
    def set_port(self, port: int) -> bool: ...
    def set_query_string(self, query: str | None = None) -> bool: ...
    def set_query_table(self, query_table: dict | None = None) -> bool: ...
    def set_query_value(self, query_key: str, query_value: str | None = None) -> bool: ...
    def set_scheme(self, scheme: str) -> bool: ...
    def set_userinfo(self, userinfo: str) -> bool: ...
    def to_string(self) -> str: ...
    def to_string_with_keys(self, keys: list | None = None) -> str: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class ValueArray(object):
    """
    A fundamental type that describes an ordered list of #GValue
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def append_and_take_value(value: GObject.Value, append_value: GObject.Value) -> None: ...
    @staticmethod
    def append_value(value: GObject.Value, append_value: GObject.Value) -> None: ...
    @staticmethod
    def get_size(value: GObject.Value) -> int: ...
    @staticmethod
    def get_value(value: GObject.Value, index: int) -> GObject.Value: ...
    @staticmethod
    def init(value: GObject.Value, prealloc: int) -> GObject.Value: ...
    @staticmethod
    def prepend_value(value: GObject.Value, prepend_value: GObject.Value) -> None: ...

class ValueList(object):
    """
    A fundamental type that describes an unordered list of #GValue
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def append_and_take_value(value: GObject.Value, append_value: GObject.Value) -> None: ...
    @staticmethod
    def append_value(value: GObject.Value, append_value: GObject.Value) -> None: ...
    @staticmethod
    def concat(value1: GObject.Value, value2: GObject.Value) -> GObject.Value: ...
    @staticmethod
    def get_size(value: GObject.Value) -> int: ...
    @staticmethod
    def get_value(value: GObject.Value, index: int) -> GObject.Value: ...
    @staticmethod
    def init(value: GObject.Value, prealloc: int) -> GObject.Value: ...
    @staticmethod
    def merge(value1: GObject.Value, value2: GObject.Value) -> GObject.Value: ...
    @staticmethod
    def prepend_value(value: GObject.Value, prepend_value: GObject.Value) -> None: ...

class ValueTable(GObject.GPointer):
    # gi Fields
    compare: ValueCompareFuncValueTableCB = ...
    deserialize: ValueDeserializeFuncValueTableCB = ...
    deserialize_with_pspec: ValueDeserializeWithPSpecFuncValueTableCB = ...
    serialize: ValueSerializeFuncValueTableCB = ...
    type: GObject.GType = ...  # type: ignore

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

###############################################################
# Callbacks
###############################################################

class MemoryMapFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_map
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        maxsize: int,
        flags: MapFlags,
    ) -> object | None: ...

class MemoryUnmapFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_unmap
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
    ) -> None: ...

class MemoryCopyFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_copy
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        offset: int,
        size: int,
    ) -> Memory: ...

class MemoryShareFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_share
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        offset: int,
        size: int,
    ) -> Memory: ...

class MemoryIsSpanFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_is_span
    """
    #  mem1
    def __call__(
        self,
        mem1: Memory,
        mem2: Memory,
        offset: int,
    ) -> bool: ...

class MemoryMapFullFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_map_full
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        info: MapInfo,
        maxsize: int,
    ) -> object | None: ...

class MemoryUnmapFullFunctionAllocatorCB(typing.Protocol):
    """
    This callback was used in:
        Allocator.mem_unmap_full
    """
    #  mem
    def __call__(
        self,
        mem: Memory,
        info: MapInfo,
    ) -> None: ...

class allocAllocatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AllocatorClass.alloc
    """
    #  allocator
    def __call__(
        self,
        allocator: Allocator | None,
        size: int,
        params: AllocationParams | None = None,
    ) -> Memory | None: ...

class freeAllocatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AllocatorClass.free
    """
    #  allocator
    def __call__(
        self,
        allocator: Allocator,
        memory: Memory,
    ) -> None: ...

class element_addedBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.element_added
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        child: Element,
    ) -> None: ...

class element_removedBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.element_removed
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        child: Element,
    ) -> None: ...

class add_elementBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.add_element
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        element: Element,
    ) -> bool: ...

class remove_elementBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.remove_element
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        element: Element,
    ) -> bool: ...

class handle_messageBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.handle_message
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        message: Message,
    ) -> None: ...

class do_latencyBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.do_latency
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
    ) -> bool: ...

class deep_element_addedBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.deep_element_added
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        sub_bin: Bin,
        child: Element,
    ) -> None: ...

class deep_element_removedBinClassCB(typing.Protocol):
    """
    This callback was used in:
        BinClass.deep_element_removed
    """
    #  bin
    def __call__(
        self,
        bin: Bin,
        sub_bin: Bin,
        child: Element,
    ) -> None: ...

class BufferForeachMetaFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach_meta
    """
    #  buffer
    def __call__(
        self,
        buffer: Buffer,
        user_data: object | None = None,
    ) -> tuple[bool, Meta | None]: ...

class BufferListFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  idx
    def __call__(
        self,
        idx: int,
        user_data: object | None = None,
    ) -> tuple[bool, Buffer | None]: ...

class get_optionsBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.get_options
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> list: ...

class set_configBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.set_config
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        config: Structure,
    ) -> bool: ...

class startBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.start
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> bool: ...

class stopBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.stop
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> bool: ...

class acquire_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.acquire_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        params: BufferPoolAcquireParams | None = None,
    ) -> tuple[FlowReturn, Buffer | None]: ...

class alloc_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.alloc_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        params: BufferPoolAcquireParams | None = None,
    ) -> tuple[FlowReturn, Buffer | None]: ...

class reset_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.reset_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        buffer: Buffer,
    ) -> None: ...

class release_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.release_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        buffer: Buffer,
    ) -> None: ...

class free_bufferBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.free_buffer
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
        buffer: Buffer,
    ) -> None: ...

class flush_startBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.flush_start
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> None: ...

class flush_stopBufferPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferPoolClass.flush_stop
    """
    #  pool
    def __call__(
        self,
        pool: BufferPool,
    ) -> None: ...

class BusFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.add_watch
    """
    #  bus
    def __call__(
        self,
        bus: Bus,
        message: Message,
        user_data: object | None = None,
    ) -> bool: ...

class BusSyncHandler(typing.Protocol):
    """
    This callback was used in:
        Gst.set_sync_handler
    """
    #  bus
    def __call__(
        self,
        bus: Bus,
        message: Message,
        user_data: object | None = None,
    ) -> BusSyncReply: ...

class messageBusClassCB(typing.Protocol):
    """
    This callback was used in:
        BusClass.message
    """
    #  bus
    def __call__(
        self,
        bus: Bus,
        message: Message,
    ) -> None: ...

class sync_messageBusClassCB(typing.Protocol):
    """
    This callback was used in:
        BusClass.sync_message
    """
    #  bus
    def __call__(
        self,
        bus: Bus,
        message: Message,
    ) -> None: ...

class resizeByteArrayInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ByteArrayInterface.resize
    """
    #  self
    def __call__(
        self: ByteArrayInterface,
        length: int,
    ) -> bool: ...

class CapsFilterMapFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.filter_and_map_in_place
    """
    #  features
    def __call__(
        self,
        features: CapsFeatures,
        structure: Structure,
        user_data: object | None = None,
    ) -> bool: ...

class CapsForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  features
    def __call__(
        self,
        features: CapsFeatures,
        structure: Structure,
        user_data: object | None = None,
    ) -> bool: ...

class CapsMapFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.map_in_place
    """
    #  features
    def __call__(
        self,
        features: CapsFeatures,
        structure: Structure,
        user_data: object | None = None,
    ) -> bool: ...

class get_child_by_nameChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.get_child_by_name
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
        name: str,
    ) -> GObject.Object | None: ...

class get_child_by_indexChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.get_child_by_index
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
        index: int,
    ) -> GObject.Object | None: ...

class get_children_countChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.get_children_count
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
    ) -> int: ...

class child_addedChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.child_added
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
        child: GObject.Object,
        name: str,
    ) -> None: ...

class child_removedChildProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ChildProxyInterface.child_removed
    """
    #  parent
    def __call__(
        self,
        parent: ChildProxy,
        child: GObject.Object,
        name: str,
    ) -> None: ...

class ClockCallback(typing.Protocol):
    """
    This callback was used in:
        Gst.id_wait_async
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        time: int,
        id: object,
        user_data: object | None = None,
    ) -> bool: ...

class change_resolutionClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.change_resolution
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        old_resolution: int,
        new_resolution: int,
    ) -> int: ...

class get_resolutionClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.get_resolution
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
    ) -> int: ...

class get_internal_timeClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.get_internal_time
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
    ) -> int: ...

class waitClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.wait
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        entry: ClockEntry,
    ) -> tuple[ClockReturn, int | None]: ...

class wait_asyncClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.wait_async
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        entry: ClockEntry,
    ) -> ClockReturn: ...

class unscheduleClockClassCB(typing.Protocol):
    """
    This callback was used in:
        ClockClass.unschedule
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        entry: ClockEntry,
    ) -> None: ...

class ClockCallbackClockEntryCB(typing.Protocol):
    """
    This callback was used in:
        ClockEntry.func
    """
    #  clock
    def __call__(
        self,
        clock: Clock,
        time: int,
        id: object,
        user_data: object | None = None,
    ) -> bool: ...

DestroyNotify = GLib.DestroyNotify  # type: ignore

class sync_valuesControlBindingClassCB(typing.Protocol):
    """
    This callback was used in:
        ControlBindingClass.sync_values
    """
    #  binding
    def __call__(
        self,
        binding: ControlBinding,
        object: Object,
        timestamp: int,
        last_sync: int,
    ) -> bool: ...

class get_valueControlBindingClassCB(typing.Protocol):
    """
    This callback was used in:
        ControlBindingClass.get_value
    """
    #  binding
    def __call__(
        self,
        binding: ControlBinding,
        timestamp: int,
    ) -> GObject.Value | None: ...

class get_g_value_arrayControlBindingClassCB(typing.Protocol):
    """
    This callback was used in:
        ControlBindingClass.get_g_value_array
    """
    #  binding
    def __call__(
        self,
        binding: ControlBinding,
        timestamp: int,
        interval: int,
        n_values: int,
        values: list,
    ) -> bool: ...

class ControlSourceGetValueControlSourceCB(typing.Protocol):
    """
    This callback was used in:
        ControlSource.get_value
    """
    #  self
    def __call__(
        self: ControlSource,
        timestamp: int,
        value: float,
    ) -> bool: ...

class ControlSourceGetValueArrayControlSourceCB(typing.Protocol):
    """
    This callback was used in:
        ControlSource.get_value_array
    """
    #  self
    def __call__(
        self: ControlSource,
        timestamp: int,
        interval: int,
        n_values: int,
        values: float,
    ) -> bool: ...

class create_elementDeviceClassCB(typing.Protocol):
    """
    This callback was used in:
        DeviceClass.create_element
    """
    #  device
    def __call__(
        self,
        device: Device,
        name: str | None = None,
    ) -> Element | None: ...

class reconfigure_elementDeviceClassCB(typing.Protocol):
    """
    This callback was used in:
        DeviceClass.reconfigure_element
    """
    #  device
    def __call__(
        self,
        device: Device,
        element: Element,
    ) -> bool: ...

class startDeviceProviderClassCB(typing.Protocol):
    """
    This callback was used in:
        DeviceProviderClass.start
    """
    #  provider
    def __call__(
        self,
        provider: DeviceProvider,
    ) -> bool: ...

class stopDeviceProviderClassCB(typing.Protocol):
    """
    This callback was used in:
        DeviceProviderClass.stop
    """
    #  provider
    def __call__(
        self,
        provider: DeviceProvider,
    ) -> None: ...

class ElementCallAsyncFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.call_async
    """
    #  element
    def __call__(
        self,
        element: Element,
        user_data: object | None = None,
    ) -> None: ...

class ElementForeachPadFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach_pad, Gst.foreach_sink_pad, Gst.foreach_src_pad
    """
    #  element
    def __call__(
        self,
        element: Element,
        pad: Pad,
        user_data: object | None = None,
    ) -> bool: ...

class pad_addedElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.pad_added
    """
    #  element
    def __call__(
        self,
        element: Element,
        pad: Pad,
    ) -> None: ...

class pad_removedElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.pad_removed
    """
    #  element
    def __call__(
        self,
        element: Element,
        pad: Pad,
    ) -> None: ...

class no_more_padsElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.no_more_pads
    """
    #  element
    def __call__(
        self,
        element: Element,
    ) -> None: ...

class request_new_padElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.request_new_pad
    """
    #  element
    def __call__(
        self,
        element: Element,
        templ: PadTemplate,
        name: str | None = None,
        caps: Caps | None = None,
    ) -> Pad | None: ...

class release_padElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.release_pad
    """
    #  element
    def __call__(
        self,
        element: Element,
        pad: Pad,
    ) -> None: ...

class get_stateElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.get_state
    """
    #  element
    def __call__(
        self,
        element: Element,
        timeout: int,
    ) -> tuple[StateChangeReturn, State | None, State | None]: ...

class set_stateElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.set_state
    """
    #  element
    def __call__(
        self,
        element: Element,
        state: State,
    ) -> StateChangeReturn: ...

class change_stateElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.change_state
    """
    #  element
    def __call__(
        self,
        element: Element,
        transition: StateChange,
    ) -> StateChangeReturn: ...

class state_changedElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.state_changed
    """
    #  element
    def __call__(
        self,
        element: Element,
        oldstate: State,
        newstate: State,
        pending: State,
    ) -> None: ...

class set_busElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.set_bus
    """
    #  element
    def __call__(
        self,
        element: Element,
        bus: Bus | None = None,
    ) -> None: ...

class provide_clockElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.provide_clock
    """
    #  element
    def __call__(
        self,
        element: Element,
    ) -> Clock | None: ...

class set_clockElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.set_clock
    """
    #  element
    def __call__(
        self,
        element: Element,
        clock: Clock | None = None,
    ) -> bool: ...

class send_eventElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.send_event
    """
    #  element
    def __call__(
        self,
        element: Element,
        event: Event,
    ) -> bool: ...

class queryElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.query
    """
    #  element
    def __call__(
        self,
        element: Element,
        query: Query,
    ) -> bool: ...

class post_messageElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.post_message
    """
    #  element
    def __call__(
        self,
        element: Element,
        message: Message,
    ) -> bool: ...

class set_contextElementClassCB(typing.Protocol):
    """
    This callback was used in:
        ElementClass.set_context
    """
    #  element
    def __call__(
        self,
        element: Element,
        context: Context,
    ) -> None: ...

class IteratorItemFunctionIteratorCB(typing.Protocol):
    """
    This callback was used in:
        Iterator.item
    """
    #  it
    def __call__(
        self,
        it: Iterator,
        item: GObject.Value,
    ) -> IteratorItem: ...

class IteratorFoldFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.fold
    """
    #  item
    def __call__(
        self,
        item: GObject.Value,
        ret: GObject.Value,
        user_data: object | None = None,
    ) -> bool: ...

class IteratorForeachFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  item
    def __call__(
        self,
        item: GObject.Value,
        user_data: object | None = None,
    ) -> None: ...

class AllocationMetaParamsAggregator(typing.Protocol):
    """
    This callback was used in:
        Gst.api_type_set_params_aggregator, Gst.meta_api_type_set_params_aggregator
    """
    #  aggregated_params
    def __call__(
        self,
        aggregated_params: Structure,
        params0: Structure,
        params1: Structure,
    ) -> bool: ...

class CustomMetaTransformFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.meta_register_custom, Gst.register_custom
    """
    #  transbuf
    def __call__(
        self,
        transbuf: Buffer,
        meta: CustomMeta,
        buffer: Buffer,
        type: int,
        data: object | None = None,
        user_data: object | None = None,
    ) -> bool: ...

class MetaInitFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.init_func
    """
    #  meta
    def __call__(
        self,
        meta: Meta,
        params: object | None,
        buffer: Buffer,
    ) -> bool: ...

class MetaFreeFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.free_func
    """
    #  meta
    def __call__(
        self,
        meta: Meta,
        buffer: Buffer,
    ) -> None: ...

class MetaTransformFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.transform_func
    """
    #  transbuf
    def __call__(
        self,
        transbuf: Buffer,
        meta: Meta,
        buffer: Buffer,
        type: int,
        data: object | None = None,
    ) -> bool: ...

class MetaSerializeFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.serialize_func
    """
    #  meta
    def __call__(
        self,
        meta: Meta,
        data: ByteArrayInterface,
    ) -> tuple[bool, int]: ...

class MetaDeserializeFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.deserialize_func
    """
    #  info
    def __call__(
        self,
        info: MetaInfo,
        buffer: Buffer,
        data: int,
        size: int,
        version: int,
    ) -> Meta | None: ...

class MetaClearFunctionMetaInfoCB(typing.Protocol):
    """
    This callback was used in:
        MetaInfo.clear_func
    """
    #  buffer
    def __call__(
        self,
        buffer: Buffer,
        meta: Meta,
    ) -> None: ...

class MiniObjectCopyFunctionMiniObjectCB(typing.Protocol):
    """
    This callback was used in:
        MiniObject.copy
    """
    #  obj
    def __call__(
        self,
        obj: MiniObject,
    ) -> MiniObject: ...

class MiniObjectDisposeFunctionMiniObjectCB(typing.Protocol):
    """
    This callback was used in:
        MiniObject.dispose
    """
    #  obj
    def __call__(
        self,
        obj: MiniObject,
    ) -> bool: ...

class MiniObjectFreeFunctionMiniObjectCB(typing.Protocol):
    """
    This callback was used in:
        MiniObject.free
    """
    #  obj
    def __call__(
        self,
        obj: MiniObject,
    ) -> None: ...

class deep_notifyObjectClassCB(typing.Protocol):
    """
    This callback was used in:
        ObjectClass.deep_notify
    """
    #  object
    def __call__(
        self,
        object: Object,
        orig: Object,
        pspec: GObject.ParamSpec,
    ) -> None: ...

class PadActivateFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.activatefunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object,
    ) -> bool: ...

class PadActivateModeFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.activatemodefunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object,
        mode: PadMode,
        active: bool,
    ) -> bool: ...

class PadLinkFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.linkfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        peer: Pad,
    ) -> PadLinkReturn: ...

class PadUnlinkFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.unlinkfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None = None,
    ) -> None: ...

class PadChainFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.chainfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        buffer: Buffer,
    ) -> FlowReturn: ...

class PadChainListFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.chainlistfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        list: BufferList,
    ) -> FlowReturn: ...

class PadGetRangeFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.getrangefunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        offset: int,
        length: int,
        buffer: Buffer,
    ) -> FlowReturn: ...

class PadEventFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.eventfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        event: Event,
    ) -> bool: ...

class PadQueryFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.queryfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        query: Query,
    ) -> bool: ...

class PadIterIntLinkFunctionPadCB(typing.Protocol):
    """
    This callback was used in:
        Pad.iterintlinkfunc
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None = None,
    ) -> Iterator: ...

class PadProbeCallback(typing.Protocol):
    """
    This callback was used in:
        Gst.add_probe
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        info: PadProbeInfo,
        user_data: object | None = None,
    ) -> PadProbeReturn: ...

class PadForwardFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.forward
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        user_data: object | None = None,
    ) -> bool: ...

class PadActivateFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_activate_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object,
    ) -> bool: ...

class PadActivateModeFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_activatemode_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object,
        mode: PadMode,
        active: bool,
    ) -> bool: ...

class PadChainFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_chain_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        buffer: Buffer,
    ) -> FlowReturn: ...

class PadChainListFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_chain_list_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        list: BufferList,
    ) -> FlowReturn: ...

class PadEventFullFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_event_full_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        event: Event,
    ) -> FlowReturn: ...

class PadEventFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_event_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        event: Event,
    ) -> bool: ...

class PadGetRangeFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_getrange_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        offset: int,
        length: int,
        buffer: Buffer,
    ) -> FlowReturn: ...

class PadIterIntLinkFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_iterate_internal_links_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None = None,
    ) -> Iterator: ...

class PadLinkFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_link_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        peer: Pad,
    ) -> PadLinkReturn: ...

class PadQueryFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_query_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None,
        query: Query,
    ) -> bool: ...

class PadUnlinkFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.set_unlink_function_full
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        parent: Object | None = None,
    ) -> None: ...

class TaskFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.new, Gst.start_task
    """
    #  user_data
    def __call__(
        self,
        user_data: object | None = None,
    ) -> None: ...

class PadStickyEventsForeachFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.sticky_events_foreach
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        event: Event | None = None,
        user_data: object | None = None,
    ) -> bool: ...

class linkedPadClassCB(typing.Protocol):
    """
    This callback was used in:
        PadClass.linked
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        peer: Pad,
    ) -> None: ...

class unlinkedPadClassCB(typing.Protocol):
    """
    This callback was used in:
        PadClass.unlinked
    """
    #  pad
    def __call__(
        self,
        pad: Pad,
        peer: Pad,
    ) -> None: ...

class pad_createdPadTemplateClassCB(typing.Protocol):
    """
    This callback was used in:
        PadTemplateClass.pad_created
    """
    #  templ
    def __call__(
        self,
        templ: PadTemplate,
        pad: Pad,
    ) -> None: ...

class PluginInitFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.register_static
    """
    #  plugin
    def __call__(
        self,
        plugin: Plugin,
    ) -> bool: ...

class PluginInitFullFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.register_static_full
    """
    #  plugin
    def __call__(
        self,
        plugin: Plugin,
        user_data: object | None = None,
    ) -> bool: ...

class PluginInitFuncPluginDescCB(typing.Protocol):
    """
    This callback was used in:
        PluginDesc.plugin_init
    """
    #  plugin
    def __call__(
        self,
        plugin: Plugin,
    ) -> bool: ...

class get_preset_namesPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.get_preset_names
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
    ) -> list: ...

class get_property_namesPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.get_property_names
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
    ) -> list: ...

class load_presetPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.load_preset
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
    ) -> bool: ...

class save_presetPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.save_preset
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
    ) -> bool: ...

class rename_presetPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.rename_preset
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        old_name: str,
        new_name: str,
    ) -> bool: ...

class delete_presetPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.delete_preset
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
    ) -> bool: ...

class set_metaPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.set_meta
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
        tag: str,
        value: str | None = None,
    ) -> bool: ...

class get_metaPresetInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PresetInterface.get_meta
    """
    #  preset
    def __call__(
        self,
        preset: Preset,
        name: str,
        tag: str,
    ) -> tuple[bool, str]: ...

class PromiseChangeFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.new_with_change_func
    """
    #  promise
    def __call__(
        self,
        promise: Promise,
        user_data: object | None = None,
    ) -> None: ...

class PluginFeatureFilter(typing.Protocol):
    """
    This callback was used in:
        Gst.feature_filter
    """
    #  feature
    def __call__(
        self,
        feature: PluginFeature,
        user_data: object | None = None,
    ) -> bool: ...

class PluginFilter(typing.Protocol):
    """
    This callback was used in:
        Gst.plugin_filter
    """
    #  plugin
    def __call__(
        self,
        plugin: Plugin,
        user_data: object | None = None,
    ) -> bool: ...

class stream_notifyStreamCollectionClassCB(typing.Protocol):
    """
    This callback was used in:
        StreamCollectionClass.stream_notify
    """
    #  collection
    def __call__(
        self,
        collection: StreamCollection,
        stream: Stream,
        pspec: GObject.ParamSpec,
    ) -> None: ...

class StructureFilterMapFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.filter_and_map_in_place
    """
    #  field_id
    def __call__(
        self,
        field_id: int,
        value: GObject.Value,
        user_data: object | None = None,
    ) -> bool: ...

class StructureFilterMapIdStrFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.filter_and_map_in_place_id_str
    """
    #  fieldname
    def __call__(
        self,
        fieldname: IdStr,
        value: GObject.Value,
        user_data: object | None = None,
    ) -> bool: ...

class StructureForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  field_id
    def __call__(
        self,
        field_id: int,
        value: GObject.Value,
        user_data: object | None = None,
    ) -> bool: ...

class StructureForeachIdStrFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach_id_str
    """
    #  fieldname
    def __call__(
        self,
        fieldname: IdStr,
        value: GObject.Value,
        user_data: object | None = None,
    ) -> bool: ...

class StructureMapFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.map_in_place
    """
    #  field_id
    def __call__(
        self,
        field_id: int,
        value: GObject.Value,
        user_data: object | None = None,
    ) -> bool: ...

class StructureMapIdStrFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.map_in_place_id_str
    """
    #  fieldname
    def __call__(
        self,
        fieldname: IdStr,
        value: GObject.Value,
        user_data: object | None = None,
    ) -> bool: ...

class TagForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.foreach
    """
    #  list
    def __call__(
        self,
        list: TagList,
        tag: str,
        user_data: object | None = None,
    ) -> None: ...

class TaskFunctionTaskCB(typing.Protocol):
    """
    This callback was used in:
        Task.func
    """
    #  user_data
    def __call__(
        self,
        user_data: object | None = None,
    ) -> None: ...

class TaskThreadFunc(typing.Protocol):
    """
    This callback was used in:
        Gst.set_enter_callback, Gst.set_leave_callback
    """
    #  task
    def __call__(
        self,
        task: Task,
        thread: GLib.Thread,
        user_data: object | None = None,
    ) -> None: ...

class TaskPoolFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.push
    """
    #  user_data
    def __call__(
        self,
        user_data: object | None = None,
    ) -> None: ...

class prepareTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.prepare
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
    ) -> None: ...

class cleanupTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.cleanup
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
    ) -> None: ...

class pushTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.push
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
        func: TaskPoolFunction,
        user_data: object | None = None,
    ) -> object | None: ...

class joinTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.join
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
        id: object | None = None,
    ) -> None: ...

class dispose_handleTaskPoolClassCB(typing.Protocol):
    """
    This callback was used in:
        TaskPoolClass.dispose_handle
    """
    #  pool
    def __call__(
        self,
        pool: TaskPool,
        id: object | None = None,
    ) -> None: ...

class TypeFindFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.register, Gst.type_find_register
    """
    #  find
    def __call__(
        self,
        find: TypeFind,
        user_data: object | None = None,
    ) -> None: ...

class get_typeURIHandlerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        URIHandlerInterface.get_type
    """
    #  type
    def __call__(
        self,
        type: GObject.GType,
    ) -> URIType: ...

class get_protocolsURIHandlerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        URIHandlerInterface.get_protocols
    """
    #  type
    def __call__(
        self,
        type: GObject.GType,
    ) -> list: ...

class get_uriURIHandlerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        URIHandlerInterface.get_uri
    """
    #  handler
    def __call__(
        self,
        handler: URIHandler,
    ) -> str | None: ...

class set_uriURIHandlerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        URIHandlerInterface.set_uri
    """
    #  handler
    def __call__(
        self,
        handler: URIHandler,
        uri: str,
    ) -> bool: ...

class ValueCompareFuncValueTableCB(typing.Protocol):
    """
    This callback was used in:
        ValueTable.compare
    """
    #  value1
    def __call__(
        self,
        value1: GObject.Value,
        value2: GObject.Value,
    ) -> int: ...

class ValueSerializeFuncValueTableCB(typing.Protocol):
    """
    This callback was used in:
        ValueTable.serialize
    """
    #  value1
    def __call__(
        self,
        value1: GObject.Value,
    ) -> str: ...

class ValueDeserializeFuncValueTableCB(typing.Protocol):
    """
    This callback was used in:
        ValueTable.deserialize
    """
    #  dest
    def __call__(
        self,
        dest: GObject.Value,
        s: str,
    ) -> bool: ...

class ValueDeserializeWithPSpecFuncValueTableCB(typing.Protocol):
    """
    This callback was used in:
        ValueTable.deserialize_with_pspec
    """
    #  dest
    def __call__(
        self,
        dest: GObject.Value,
        s: str,
        pspec: GObject.ParamSpec,
    ) -> bool: ...

class LogFunction(typing.Protocol):
    """
    This callback was used in:
        Gst.debug_add_log_function, Gst.debug_remove_log_function
    """
    #  category
    def __call__(
        self,
        category: DebugCategory,
        level: DebugLevel,
        file: str,
        function: str,
        line: int,
        object: GObject.Object,
        message: DebugMessage,
        user_data: object | None = None,
    ) -> None: ...

###############################################################
# Aliases
###############################################################

_lock = _thread._lock  # type: ignore
###############################################################
# Constants
###############################################################

ALLOCATOR_SYSMEM: str = ...
BUFFER_COPY_ALL = BufferCopyFlags.NONE
"""
Combination of all possible fields that can be copied with
gst_buffer_copy_into(). 
"""
BUFFER_COPY_METADATA = BufferCopyFlags.NONE
"""
Combination of all possible metadata fields that can be copied with
gst_buffer_copy_into(). 
"""
BUFFER_OFFSET_NONE: int = ...
CAN_INLINE: int = ...
CAPS_FEATURE_MEMORY_SYSTEM_MEMORY: str = ...
CLOCK_TIME_NONE: int = ...
DEBUG_BG_MASK: int = ...
DEBUG_FG_MASK: int = ...
DEBUG_FORMAT_MASK: int = ...
ELEMENT_FACTORY_KLASS_DECODER: str = ...
ELEMENT_FACTORY_KLASS_DECRYPTOR: str = ...
ELEMENT_FACTORY_KLASS_DEMUXER: str = ...
ELEMENT_FACTORY_KLASS_DEPAYLOADER: str = ...
ELEMENT_FACTORY_KLASS_ENCODER: str = ...
ELEMENT_FACTORY_KLASS_ENCRYPTOR: str = ...
ELEMENT_FACTORY_KLASS_FORMATTER: str = ...
ELEMENT_FACTORY_KLASS_HARDWARE: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_AUDIO: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_IMAGE: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_METADATA: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE: str = ...
ELEMENT_FACTORY_KLASS_MEDIA_VIDEO: str = ...
ELEMENT_FACTORY_KLASS_MUXER: str = ...
ELEMENT_FACTORY_KLASS_PARSER: str = ...
ELEMENT_FACTORY_KLASS_PAYLOADER: str = ...
ELEMENT_FACTORY_KLASS_SINK: str = ...
ELEMENT_FACTORY_KLASS_SRC: str = ...
ELEMENT_FACTORY_TYPE_ANY: int = ...
ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS: int = ...
ELEMENT_FACTORY_TYPE_AUDIO_ENCODER: int = ...
ELEMENT_FACTORY_TYPE_DECODABLE: int = ...
ELEMENT_FACTORY_TYPE_DECODER: int = ...
ELEMENT_FACTORY_TYPE_DECRYPTOR: int = ...
ELEMENT_FACTORY_TYPE_DEMUXER: int = ...
ELEMENT_FACTORY_TYPE_DEPAYLOADER: int = ...
ELEMENT_FACTORY_TYPE_ENCODER: int = ...
ELEMENT_FACTORY_TYPE_ENCRYPTOR: int = ...
ELEMENT_FACTORY_TYPE_FORMATTER: int = ...
ELEMENT_FACTORY_TYPE_HARDWARE: int = ...
ELEMENT_FACTORY_TYPE_MAX_ELEMENTS: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_ANY: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_AUDIO: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_IMAGE: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_METADATA: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE: int = ...
ELEMENT_FACTORY_TYPE_MEDIA_VIDEO: int = ...
ELEMENT_FACTORY_TYPE_MUXER: int = ...
ELEMENT_FACTORY_TYPE_PARSER: int = ...
ELEMENT_FACTORY_TYPE_PAYLOADER: int = ...
ELEMENT_FACTORY_TYPE_SINK: int = ...
ELEMENT_FACTORY_TYPE_SRC: int = ...
ELEMENT_FACTORY_TYPE_TIMESTAMPER: int = ...
ELEMENT_FACTORY_TYPE_VIDEO_ENCODER: int = ...
ELEMENT_METADATA_AUTHOR: str = ...
ELEMENT_METADATA_DESCRIPTION: str = ...
ELEMENT_METADATA_DOC_URI: str = ...
ELEMENT_METADATA_ICON_NAME: str = ...
ELEMENT_METADATA_KLASS: str = ...
ELEMENT_METADATA_LONGNAME: str = ...
EVENT_NUM_SHIFT: int = ...
EVENT_TYPE_BOTH = EventTypeFlags(0)
"""
The same thing as #GST_EVENT_TYPE_UPSTREAM | #GST_EVENT_TYPE_DOWNSTREAM. 
"""
FLAG_SET_MASK_EXACT: int = ...
FORMAT_PERCENT_MAX: int = ...
FORMAT_PERCENT_SCALE: int = ...
GROUP_ID_INVALID: int = ...
LICENSE_UNKNOWN: str = ...
LOCK_FLAG_READWRITE = LockFlags(0)
"""
GstLockFlags value alias for GST_LOCK_FLAG_READ | GST_LOCK_FLAG_WRITE 
"""
MAP_READWRITE = MapFlags(0)
"""
GstMapFlags value alias for GST_MAP_READ | GST_MAP_WRITE 
"""
META_TAG_MEMORY_REFERENCE_STR: str = ...
META_TAG_MEMORY_STR: str = ...
MSECOND: int = ...
NSECOND: int = ...
PARAM_CONDITIONALLY_AVAILABLE: int = ...
PARAM_CONTROLLABLE: int = ...
PARAM_DOC_SHOW_DEFAULT: int = ...
PARAM_MUTABLE_PAUSED: int = ...
PARAM_MUTABLE_PLAYING: int = ...
PARAM_MUTABLE_READY: int = ...
PARAM_USER_SHIFT: int = ...
PROTECTION_SYSTEM_ID_CAPS_FIELD: str = ...
PROTECTION_UNSPECIFIED_SYSTEM_ID: str = ...
QUERY_NUM_SHIFT: int = ...
QUERY_TYPE_BOTH = QueryTypeFlags(0)
"""
The same thing as #GST_QUERY_TYPE_UPSTREAM | #GST_QUERY_TYPE_DOWNSTREAM. 
"""
SECOND: int = ...
SEGMENT_INSTANT_FLAGS: int = ...
SEQNUM_INVALID: int = ...
TAG_ALBUM: str = ...
TAG_ALBUM_ARTIST: str = ...
TAG_ALBUM_ARTIST_SORTNAME: str = ...
TAG_ALBUM_GAIN: str = ...
TAG_ALBUM_PEAK: str = ...
TAG_ALBUM_SORTNAME: str = ...
TAG_ALBUM_VOLUME_COUNT: str = ...
TAG_ALBUM_VOLUME_NUMBER: str = ...
TAG_APPLICATION_DATA: str = ...
TAG_APPLICATION_NAME: str = ...
TAG_ARTIST: str = ...
TAG_ARTIST_SORTNAME: str = ...
TAG_ATTACHMENT: str = ...
TAG_AUDIO_CODEC: str = ...
TAG_BEATS_PER_MINUTE: str = ...
TAG_BITRATE: str = ...
TAG_CODEC: str = ...
TAG_COMMENT: str = ...
TAG_COMPOSER: str = ...
TAG_COMPOSER_SORTNAME: str = ...
TAG_CONDUCTOR: str = ...
TAG_CONTACT: str = ...
TAG_CONTAINER_FORMAT: str = ...
TAG_CONTAINER_SPECIFIC_TRACK_ID: str = ...
TAG_COPYRIGHT: str = ...
TAG_COPYRIGHT_URI: str = ...
TAG_DATE: str = ...
TAG_DATE_TIME: str = ...
TAG_DESCRIPTION: str = ...
TAG_DEVICE_MANUFACTURER: str = ...
TAG_DEVICE_MODEL: str = ...
TAG_DURATION: str = ...
TAG_ENCODED_BY: str = ...
TAG_ENCODER: str = ...
TAG_ENCODER_VERSION: str = ...
TAG_EXTENDED_COMMENT: str = ...
TAG_GENRE: str = ...
TAG_GEO_LOCATION_CAPTURE_DIRECTION: str = ...
TAG_GEO_LOCATION_CITY: str = ...
TAG_GEO_LOCATION_COUNTRY: str = ...
TAG_GEO_LOCATION_ELEVATION: str = ...
TAG_GEO_LOCATION_HORIZONTAL_ERROR: str = ...
TAG_GEO_LOCATION_LATITUDE: str = ...
TAG_GEO_LOCATION_LONGITUDE: str = ...
TAG_GEO_LOCATION_MOVEMENT_DIRECTION: str = ...
TAG_GEO_LOCATION_MOVEMENT_SPEED: str = ...
TAG_GEO_LOCATION_NAME: str = ...
TAG_GEO_LOCATION_SUBLOCATION: str = ...
TAG_GROUPING: str = ...
TAG_HOMEPAGE: str = ...
TAG_IMAGE: str = ...
TAG_IMAGE_ORIENTATION: str = ...
TAG_INTERPRETED_BY: str = ...
TAG_ISRC: str = ...
TAG_KEYWORDS: str = ...
TAG_LANGUAGE_CODE: str = ...
TAG_LANGUAGE_NAME: str = ...
TAG_LICENSE: str = ...
TAG_LICENSE_URI: str = ...
TAG_LOCATION: str = ...
TAG_LYRICS: str = ...
TAG_MAXIMUM_BITRATE: str = ...
TAG_MIDI_BASE_NOTE: str = ...
TAG_MINIMUM_BITRATE: str = ...
TAG_NOMINAL_BITRATE: str = ...
TAG_ORGANIZATION: str = ...
TAG_PERFORMER: str = ...
TAG_PREVIEW_IMAGE: str = ...
TAG_PRIVATE_DATA: str = ...
TAG_PUBLISHER: str = ...
TAG_REFERENCE_LEVEL: str = ...
TAG_SERIAL: str = ...
TAG_SHOW_EPISODE_NUMBER: str = ...
TAG_SHOW_NAME: str = ...
TAG_SHOW_SEASON_NUMBER: str = ...
TAG_SHOW_SORTNAME: str = ...
TAG_SUBTITLE_CODEC: str = ...
TAG_TITLE: str = ...
TAG_TITLE_SORTNAME: str = ...
TAG_TRACK_COUNT: str = ...
TAG_TRACK_GAIN: str = ...
TAG_TRACK_NUMBER: str = ...
TAG_TRACK_PEAK: str = ...
TAG_USER_RATING: str = ...
TAG_VERSION: str = ...
TAG_VIDEO_CODEC: str = ...
TOC_REPEAT_COUNT_INFINITE: int = ...
URI_NO_PORT: int = ...
USECOND: int = ...
VALUE_EQUAL: int = ...
VALUE_GREATER_THAN: int = ...
VALUE_LESS_THAN: int = ...
VALUE_UNORDERED: int = ...
VERSION_MAJOR: int = ...
VERSION_MICRO: int = ...
VERSION_MINOR: int = ...
VERSION_NANO: int = ...
_namespace: str = ...
_version: str = ...
###############################################################
# Unknowns/Not Parsed
###############################################################
