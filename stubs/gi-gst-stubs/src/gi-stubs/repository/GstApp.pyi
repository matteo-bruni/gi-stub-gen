# pyright: reportIncompatibleMethodOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: GstApp
Date: 2025-12-27
"""
# we disable method override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401
import builtins  # noqa: F401

import _thread
import typing

# gi.repository imports needed by this Stub
from gi.repository import GObject
from gi.repository import Gst
from gi.repository import GstBase
###############################################################
# Enums/Flags
###############################################################

class AppLeakyType(GObject.GEnum):
    NONE = 0
    UPSTREAM = 1
    DOWNSTREAM = 2

class AppStreamType(GObject.GEnum):
    STREAM = 0
    SEEKABLE = 1
    RANDOM_ACCESS = 2

###############################################################
# classes
###############################################################

class AppSink(GstBase.BaseSink):
    class Props(GstBase.BaseSink.Props):
        buffer_list: bool  # [buffer-list]: changed because contained invalid characters
        caps: Gst.Caps | None
        drop: bool
        emit_signals: bool  # [emit-signals]: changed because contained invalid characters
        eos: bool
        max_buffers: int  # [max-buffers]: changed because contained invalid characters
        max_bytes: int  # [max-bytes]: changed because contained invalid characters
        max_time: int  # [max-time]: changed because contained invalid characters
        wait_on_eos: bool  # [wait-on-eos]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def basesink(self) -> GstBase.BaseSink | None: ...
    @builtins.property
    def priv(self) -> AppSinkPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        name: str | None = None,
        parent: Gst.Object | None = None,
        sync: bool | None = None,
        max_lateness: int | None = None,
        qos: bool | None = None,
        async_: bool | None = None,
        ts_offset: int | None = None,
        enable_last_sample: bool | None = None,
        blocksize: int | None = None,
        render_delay: int | None = None,
        throttle_time: int | None = None,
        max_bitrate: int | None = None,
        processing_deadline: int | None = None,
        caps: Gst.Caps | None = None,
        emit_signals: bool | None = None,
        max_buffers: int | None = None,
        drop: bool | None = None,
        wait_on_eos: bool | None = None,
        buffer_list: bool | None = None,
        max_time: int | None = None,
        max_bytes: int | None = None,
    ) -> None:
        """
        Initialize AppSink object with properties.
        """
    def get_buffer_list_support(self) -> bool: ...
    @builtins.property
    def get_caps(self) -> Gst.Caps | None: ...
    @builtins.property
    def get_drop(self) -> bool: ...
    @builtins.property
    def get_emit_signals(self) -> bool: ...
    @builtins.property
    def get_max_buffers(self) -> int: ...
    @builtins.property
    def get_max_bytes(self) -> int: ...
    @builtins.property
    def get_max_time(self) -> int: ...
    @builtins.property
    def get_wait_on_eos(self) -> bool: ...
    @builtins.property
    def is_eos(self) -> bool: ...
    def pull_preroll(self) -> Gst.Sample | None: ...
    def pull_sample(self) -> Gst.Sample | None: ...
    def set_buffer_list_support(self, enable_lists: bool) -> None: ...
    def set_caps(self, caps: Gst.Caps | None = None) -> None: ...
    def set_drop(self, drop: bool) -> None: ...
    def set_emit_signals(self, emit: bool) -> None: ...
    def set_max_buffers(self, max: int) -> None: ...
    def set_max_bytes(self, max: int) -> None: ...
    def set_max_time(self, max: int) -> None: ...
    def set_wait_on_eos(self, wait: bool) -> None: ...
    def try_pull_preroll(self, timeout: int) -> Gst.Sample | None: ...
    def try_pull_sample(self, timeout: int) -> Gst.Sample | None: ...

    # python methods (overrides?)
    def do_eos(
        self,
    ) -> None:
        """
        eos(self)
        """
    def do_new_preroll(
        self,
    ) -> Gst.FlowReturn:
        """
        new_preroll(self) -> Gst.FlowReturn
        """
    def do_new_sample(
        self,
    ) -> Gst.FlowReturn:
        """
        new_sample(self) -> Gst.FlowReturn
        """
    def do_pull_preroll(
        self,
    ) -> Gst.Sample | None:
        """
        pull_preroll(self) -> Gst.Sample or None
        """
    def do_pull_sample(
        self,
    ) -> Gst.Sample | None:
        """
        pull_sample(self) -> Gst.Sample or None
        """
    def do_try_pull_preroll(
        self,
        timeout: int,
    ) -> Gst.Sample | None:
        """
        try_pull_preroll(self, timeout:int) -> Gst.Sample or None
        """
    def do_try_pull_sample(
        self,
        timeout: int,
    ) -> Gst.Sample | None:
        """
        try_pull_sample(self, timeout:int) -> Gst.Sample or None
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["eos"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["new-preroll"],
        handler: typing.Callable[..., Gst.FlowReturn],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["new-sample"],
        handler: typing.Callable[..., Gst.FlowReturn],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["new-serialized-event"],
        handler: typing.Callable[..., bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["propose-allocation"],
        handler: typing.Callable[[typing_extensions.Self, Gst.Query], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pull-preroll"],
        handler: typing.Callable[..., Gst.Sample | None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pull-sample"],
        handler: typing.Callable[..., Gst.Sample | None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["try-pull-object"],
        handler: typing.Callable[[typing_extensions.Self, int], Gst.MiniObject | None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["try-pull-preroll"],
        handler: typing.Callable[[typing_extensions.Self, int], Gst.Sample | None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["try-pull-sample"],
        handler: typing.Callable[[typing_extensions.Self, int], Gst.Sample | None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer_list"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::drop"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::emit_signals"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::eos"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_buffers"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wait_on_eos"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AppSinkClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def basesink_class(self) -> GstBase.BaseSinkClass | None: ...
    @builtins.property
    def eos(self) -> eosAppSinkClassCB: ...
    @builtins.property
    def new_preroll(self) -> new_prerollAppSinkClassCB: ...
    @builtins.property
    def new_sample(self) -> new_sampleAppSinkClassCB: ...
    @builtins.property
    def pull_preroll(self) -> pull_prerollAppSinkClassCB | None: ...
    @builtins.property
    def pull_sample(self) -> pull_sampleAppSinkClassCB | None: ...
    @builtins.property
    def try_pull_object(self) -> try_pull_objectAppSinkClassCB | None: ...
    @builtins.property
    def try_pull_preroll(self) -> try_pull_prerollAppSinkClassCB | None: ...
    @builtins.property
    def try_pull_sample(self) -> try_pull_sampleAppSinkClassCB | None: ...

class AppSinkPrivate(GObject.GPointer): ...

class AppSrc(GstBase.BaseSrc):
    class Props(GstBase.BaseSrc.Props):
        block: bool
        caps: Gst.Caps | None
        current_level_buffers: int  # [current-level-buffers]: changed because contained invalid characters
        current_level_bytes: int  # [current-level-bytes]: changed because contained invalid characters
        current_level_time: int  # [current-level-time]: changed because contained invalid characters
        duration: int
        emit_signals: bool  # [emit-signals]: changed because contained invalid characters
        format: Gst.Format
        handle_segment_change: bool  # [handle-segment-change]: changed because contained invalid characters
        is_live: bool  # [is-live]: changed because contained invalid characters
        leaky_type: AppLeakyType  # [leaky-type]: changed because contained invalid characters
        max_buffers: int  # [max-buffers]: changed because contained invalid characters
        max_bytes: int  # [max-bytes]: changed because contained invalid characters
        max_latency: int  # [max-latency]: changed because contained invalid characters
        max_time: int  # [max-time]: changed because contained invalid characters
        min_latency: int  # [min-latency]: changed because contained invalid characters
        min_percent: int  # [min-percent]: changed because contained invalid characters
        size: int
        stream_type: AppStreamType  # [stream-type]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def basesrc(self) -> GstBase.BaseSrc | None: ...
    @builtins.property
    def priv(self) -> AppSrcPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        name: str | None = None,
        parent: Gst.Object | None = None,
        blocksize: int | None = None,
        num_buffers: int | None = None,
        typefind: bool | None = None,
        do_timestamp: bool | None = None,
        automatic_eos: bool | None = None,
        caps: Gst.Caps | None = None,
        size: int | None = None,
        stream_type: AppStreamType | None = AppStreamType.STREAM,
        max_bytes: int | None = None,
        max_buffers: int | None = None,
        max_time: int | None = None,
        format: Gst.Format | None = Gst.Format.BYTES,
        block: bool | None = None,
        is_live: bool | None = None,
        min_latency: int | None = None,
        max_latency: int | None = None,
        emit_signals: bool | None = None,
        min_percent: int | None = None,
        duration: int | None = None,
        handle_segment_change: bool | None = None,
        leaky_type: AppLeakyType | None = AppLeakyType.NONE,
    ) -> None:
        """
        Initialize AppSrc object with properties.
        """
    def end_of_stream(self) -> Gst.FlowReturn: ...
    @builtins.property
    def get_caps(self) -> Gst.Caps | None: ...
    @builtins.property
    def get_current_level_buffers(self) -> int: ...
    @builtins.property
    def get_current_level_bytes(self) -> int: ...
    @builtins.property
    def get_current_level_time(self) -> int: ...
    @builtins.property
    def get_duration(self) -> int: ...
    @builtins.property
    def get_emit_signals(self) -> bool: ...
    def get_latency(self) -> tuple[int, int]: ...
    @builtins.property
    def get_leaky_type(self) -> AppLeakyType: ...
    @builtins.property
    def get_max_buffers(self) -> int: ...
    @builtins.property
    def get_max_bytes(self) -> int: ...
    @builtins.property
    def get_max_time(self) -> int: ...
    @builtins.property
    def get_size(self) -> int: ...
    @builtins.property
    def get_stream_type(self) -> AppStreamType: ...
    def push_buffer(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def push_buffer_list(self, buffer_list: Gst.BufferList) -> Gst.FlowReturn: ...
    def push_sample(self, sample: Gst.Sample) -> Gst.FlowReturn: ...
    def set_caps(self, caps: Gst.Caps | None = None) -> None: ...
    def set_duration(self, duration: int) -> None: ...
    def set_emit_signals(self, emit: bool) -> None: ...
    def set_latency(self, min: int, max: int) -> None: ...
    def set_leaky_type(self, leaky: AppLeakyType) -> None: ...
    def set_max_buffers(self, max: int) -> None: ...
    def set_max_bytes(self, max: int) -> None: ...
    def set_max_time(self, max: int) -> None: ...
    def set_size(self, size: int) -> None: ...
    def set_stream_type(self, type: AppStreamType) -> None: ...

    # python methods (overrides?)
    def do_end_of_stream(
        self,
    ) -> Gst.FlowReturn:
        """
        end_of_stream(self) -> Gst.FlowReturn
        """
    def do_enough_data(
        self,
    ) -> None:
        """
        enough_data(self)
        """
    def do_need_data(
        self,
        length: int,
    ) -> None:
        """
        need_data(self, length:int)
        """
    def do_push_buffer(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        push_buffer(self, buffer:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_push_buffer_list(
        self,
        buffer_list: Gst.BufferList,
    ) -> Gst.FlowReturn:
        """
        push_buffer_list(self, buffer_list:Gst.BufferList) -> Gst.FlowReturn
        """
    def do_push_sample(
        self,
        sample: Gst.Sample,
    ) -> Gst.FlowReturn:
        """
        push_sample(self, sample:Gst.Sample) -> Gst.FlowReturn
        """
    def do_seek_data(
        self,
        offset: int,
    ) -> bool:
        """
        seek_data(self, offset:int) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["end-of-stream"],
        handler: typing.Callable[..., Gst.FlowReturn],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["enough-data"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["need-data"],
        handler: typing.Callable[[typing_extensions.Self, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["push-buffer"],
        handler: typing.Callable[[typing_extensions.Self, Gst.Buffer], Gst.FlowReturn],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["push-buffer-list"],
        handler: typing.Callable[[typing_extensions.Self, Gst.BufferList], Gst.FlowReturn],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["push-sample"],
        handler: typing.Callable[[typing_extensions.Self, Gst.Sample], Gst.FlowReturn],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["seek-data"],
        handler: typing.Callable[[typing_extensions.Self, int], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::block"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::caps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_level_buffers"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_level_bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_level_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::duration"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::emit_signals"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::format"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::handle_segment_change"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_live"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::leaky_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_buffers"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_latency"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_latency"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_percent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stream_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AppSrcClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def basesrc_class(self) -> GstBase.BaseSrcClass | None: ...
    @builtins.property
    def end_of_stream(self) -> end_of_streamAppSrcClassCB: ...
    @builtins.property
    def enough_data(self) -> enough_dataAppSrcClassCB: ...
    @builtins.property
    def need_data(self) -> need_dataAppSrcClassCB: ...
    @builtins.property
    def push_buffer(self) -> push_bufferAppSrcClassCB: ...
    @builtins.property
    def push_buffer_list(self) -> push_buffer_listAppSrcClassCB: ...
    @builtins.property
    def push_sample(self) -> push_sampleAppSrcClassCB: ...
    @builtins.property
    def seek_data(self) -> seek_dataAppSrcClassCB: ...

class AppSrcPrivate(GObject.GPointer): ...

###############################################################
# Callbacks
###############################################################

class eosAppSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSinkClass.eos
    """
    #  appsink
    def __call__(
        self,
        appsink: AppSink,
    ) -> None: ...

class new_prerollAppSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSinkClass.new_preroll
    """
    #  appsink
    def __call__(
        self,
        appsink: AppSink,
    ) -> Gst.FlowReturn: ...

class new_sampleAppSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSinkClass.new_sample
    """
    #  appsink
    def __call__(
        self,
        appsink: AppSink,
    ) -> Gst.FlowReturn: ...

class pull_prerollAppSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSinkClass.pull_preroll
    """
    #  appsink
    def __call__(
        self,
        appsink: AppSink,
    ) -> Gst.Sample | None: ...

class pull_sampleAppSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSinkClass.pull_sample
    """
    #  appsink
    def __call__(
        self,
        appsink: AppSink,
    ) -> Gst.Sample | None: ...

class try_pull_prerollAppSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSinkClass.try_pull_preroll
    """
    #  appsink
    def __call__(
        self,
        appsink: AppSink,
        timeout: int,
    ) -> Gst.Sample | None: ...

class try_pull_sampleAppSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSinkClass.try_pull_sample
    """
    #  appsink
    def __call__(
        self,
        appsink: AppSink,
        timeout: int,
    ) -> Gst.Sample | None: ...

class try_pull_objectAppSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSinkClass.try_pull_object
    """
    #  appsink
    def __call__(
        self,
        appsink: AppSink,
        timeout: int,
    ) -> Gst.MiniObject | None: ...

class need_dataAppSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSrcClass.need_data
    """
    #  appsrc
    def __call__(
        self,
        appsrc: AppSrc,
        length: int,
    ) -> None: ...

class enough_dataAppSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSrcClass.enough_data
    """
    #  appsrc
    def __call__(
        self,
        appsrc: AppSrc,
    ) -> None: ...

class seek_dataAppSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSrcClass.seek_data
    """
    #  appsrc
    def __call__(
        self,
        appsrc: AppSrc,
        offset: int,
    ) -> bool: ...

class push_bufferAppSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSrcClass.push_buffer
    """
    #  appsrc
    def __call__(
        self,
        appsrc: AppSrc,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class end_of_streamAppSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSrcClass.end_of_stream
    """
    #  appsrc
    def __call__(
        self,
        appsrc: AppSrc,
    ) -> Gst.FlowReturn: ...

class push_sampleAppSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSrcClass.push_sample
    """
    #  appsrc
    def __call__(
        self,
        appsrc: AppSrc,
        sample: Gst.Sample,
    ) -> Gst.FlowReturn: ...

class push_buffer_listAppSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AppSrcClass.push_buffer_list
    """
    #  appsrc
    def __call__(
        self,
        appsrc: AppSrc,
        buffer_list: Gst.BufferList,
    ) -> Gst.FlowReturn: ...

###############################################################
# Aliases
###############################################################

_lock = _thread._lock  # type: ignore
###############################################################
# Constants
###############################################################

_namespace: str = ...
_version: str = ...
###############################################################
# Unknowns/Not Parsed
###############################################################
