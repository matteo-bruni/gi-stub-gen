# pyright: reportIncompatibleMethodOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: GstBase
Date: 2025-12-24
"""
# we disable method override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401
import gi  # noqa: F401

import typing
import enum
import _thread

# gi.repository imports needed by this Stub
from gi.repository import GLib
from gi.repository import Gst
from gi.repository import GObject
###############################################################
# Functions
###############################################################

@staticmethod
def type_find_helper(
    src: Gst.Pad,
    size: int,
) -> Gst.Caps | None:
    """
    Tries to find what type of data is flowing from the given source #GstPad.

    Free-function: gst_caps_unref
    """
    ...

@staticmethod
def type_find_helper_for_buffer(
    obj: Gst.Object | None,
    buf: Gst.Buffer,
) -> tuple[Gst.Caps | None, Gst.TypeFindProbability | None]:
    """
    Tries to find what type of data is contained in the given #GstBuffer, the
    assumption being that the buffer represents the beginning of the stream or
    file.

    All available typefinders will be called on the data in order of rank. If
    a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
    typefinding is stopped immediately and the found caps will be returned
    right away. Otherwise, all available typefind functions will the tried,
    and the caps with the highest probability will be returned, or %NULL if
    the content of the buffer could not be identified.

    Free-function: gst_caps_unref
    """
    ...

@staticmethod
def type_find_helper_for_buffer_with_caps(
    obj: Gst.Object | None,
    buf: Gst.Buffer,
    caps: Gst.Caps,
) -> tuple[Gst.Caps | None, Gst.TypeFindProbability | None]:
    """
    Tries to find if type of media contained in the given #GstBuffer, matches
    @caps specified, assumption being that the buffer represents the beginning
    of the stream or file.

    Tries to find what type of data is contained in the given @data, the
    assumption being that the data represents the beginning of the stream or
    file.

    Only the typefinder matching the given caps will be called, if found. The
    caps with the highest probability will be returned, or %NULL if the content
    of the @data could not be identified.

    Free-function: gst_caps_unref
    """
    ...

@staticmethod
def type_find_helper_for_buffer_with_extension(
    obj: Gst.Object | None,
    buf: Gst.Buffer,
    extension: str | None = None,
) -> tuple[Gst.Caps | None, Gst.TypeFindProbability | None]:
    """
    Tries to find what type of data is contained in the given #GstBuffer, the
    assumption being that the buffer represents the beginning of the stream or
    file.

    All available typefinders will be called on the data in order of rank. If
    a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
    typefinding is stopped immediately and the found caps will be returned
    right away. Otherwise, all available typefind functions will the tried,
    and the caps with the highest probability will be returned, or %NULL if
    the content of the buffer could not be identified.

    When @extension is not %NULL, this function will first try the typefind
    functions for the given extension, which might speed up the typefinding
    in many cases.

    Free-function: gst_caps_unref
    """
    ...

@staticmethod
def type_find_helper_for_data(
    obj: Gst.Object | None,
    data: list,
    size: int,
) -> tuple[Gst.Caps | None, Gst.TypeFindProbability | None]:
    """
    Tries to find what type of data is contained in the given @data, the
    assumption being that the data represents the beginning of the stream or
    file.

    All available typefinders will be called on the data in order of rank. If
    a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
    typefinding is stopped immediately and the found caps will be returned
    right away. Otherwise, all available typefind functions will the tried,
    and the caps with the highest probability will be returned, or %NULL if
    the content of @data could not be identified.

    Free-function: gst_caps_unref
    """
    ...

@staticmethod
def type_find_helper_for_data_with_caps(
    obj: Gst.Object | None,
    data: list,
    size: int,
    caps: Gst.Caps,
) -> tuple[Gst.Caps | None, Gst.TypeFindProbability | None]:
    """
    Tries to find if type of media contained in the given @data, matches the
    @caps specified, assumption being that the data represents the beginning
    of the stream or file.

    Only the typefinder matching the given caps will be called, if found. The
    caps with the highest probability will be returned, or %NULL if the content
    of the @data could not be identified.

    Free-function: gst_caps_unref
    """
    ...

@staticmethod
def type_find_helper_for_data_with_extension(
    obj: Gst.Object | None,
    data: list,
    size: int,
    extension: str | None = None,
) -> tuple[Gst.Caps | None, Gst.TypeFindProbability | None]:
    """
    Tries to find what type of data is contained in the given @data, the
    assumption being that the data represents the beginning of the stream or
    file.

    All available typefinders will be called on the data in order of rank. If
    a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
    typefinding is stopped immediately and the found caps will be returned
    right away. Otherwise, all available typefind functions will the tried,
    and the caps with the highest probability will be returned, or %NULL if
    the content of @data could not be identified.

    When @extension is not %NULL, this function will first try the typefind
    functions for the given extension, which might speed up the typefinding
    in many cases.

    Free-function: gst_caps_unref
    """
    ...

@staticmethod
def type_find_helper_for_extension(
    obj: Gst.Object | None,
    extension: str,
) -> Gst.Caps | None:
    """
    Tries to find the best #GstCaps associated with @extension.

    All available typefinders will be checked against the extension in order
    of rank. The caps of the first typefinder that can handle @extension will be
    returned.

    Free-function: gst_caps_unref
    """
    ...

@staticmethod
def type_find_helper_get_range(
    obj: Gst.Object,
    parent: Gst.Object | None,
    func: TypeFindHelperGetRangeFunction,
    size: int,
    extension: str | None = None,
) -> tuple[Gst.Caps | None, Gst.TypeFindProbability | None]:
    """
    Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
    however, this function will use the specified function @func to obtain the
    data needed by the typefind functions, rather than operating on a given
    source pad. This is useful mostly for elements like tag demuxers which
    strip off data at the beginning and/or end of a file and want to typefind
    the stripped data stream before adding their own source pad (the specified
    callback can then call the upstream peer pad with offsets adjusted for the
    tag size, for example).

    When @extension is not %NULL, this function will first try the typefind
    functions for the given extension, which might speed up the typefinding
    in many cases.

    Free-function: gst_caps_unref
    """
    ...

@staticmethod
def type_find_helper_get_range_full(
    obj: Gst.Object,
    parent: Gst.Object | None,
    func: TypeFindHelperGetRangeFunction,
    size: int,
    extension: str | None = None,
) -> tuple[Gst.FlowReturn, Gst.Caps, Gst.TypeFindProbability | None]:
    """
    Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
    however, this function will use the specified function @func to obtain the
    data needed by the typefind functions, rather than operating on a given
    source pad. This is useful mostly for elements like tag demuxers which
    strip off data at the beginning and/or end of a file and want to typefind
    the stripped data stream before adding their own source pad (the specified
    callback can then call the upstream peer pad with offsets adjusted for the
    tag size, for example).

    When @extension is not %NULL, this function will first try the typefind
    functions for the given extension, which might speed up the typefinding
    in many cases.
    """
    ...

@staticmethod
def type_find_list_factories_for_caps(
    obj: Gst.Object | None,
    caps: Gst.Caps,
) -> list | None:
    """
    Tries to find the best #GstTypeFindFactory associated with @caps.

    The typefinder that can handle @caps will be returned.

    Free-function: g_list_free
    """
    ...

###############################################################
# Enums/Flags
###############################################################

class AggregatorStartTimeSelection(GObject.GEnum):
    ZERO = 0
    """
    Start at running time 0.
    """
    FIRST = 1
    """
    Start at the running time of
    the first buffer that is received.
    """
    SET = 2
    """
    Start at the running time
    selected by the `start-time` property.
    """

class BaseParseFrameFlags(enum.IntFlag):
    """
    Flags to be used in a #GstBaseParseFrame."""

    NONE = 0
    """
    no flag
    """
    NEW_FRAME = 1
    """
    set by baseclass if current frame
      is passed for processing to the subclass for the first time
      (and not set on subsequent calls with same data).
    """
    NO_FRAME = 2
    """
    set to indicate this buffer should not be
      counted as frame, e.g. if this frame is dependent on a previous one.
      As it is not counted as a frame, bitrate increases but frame to time
      conversions are maintained.
    """
    CLIP = 4
    """
    @pre_push_frame can set this to indicate
       that regular segment clipping can still be performed (as opposed to
       any custom one having been done).
    """
    DROP = 8
    """
    indicates to @finish_frame that the
       the frame should be dropped (and might be handled internally by subclass)
    """
    QUEUE = 16
    """
    indicates to @finish_frame that the
       the frame should be queued for now and processed fully later
       when the first non-queued frame is finished
    """

class BaseSrcFlags(enum.IntFlag):
    """
    The #GstElement flags that a basesrc element may have."""

    STARTING = 16384
    """
    has source is starting
    """
    STARTED = 32768
    """
    has source been started
    """
    LAST = 1048576
    """
    offset to define more flags
    """

class CollectPadsStateFlags(enum.IntFlag):
    EOS = 1
    """
    Set if collectdata's pad is EOS.
    """
    FLUSHING = 2
    """
    Set if collectdata's pad is flushing.
    """
    NEW_SEGMENT = 4
    """
    Set if collectdata's pad received a
                                         new_segment event.
    """
    WAITING = 8
    """
    Set if collectdata's pad must be waited
                                         for when collecting.
    """
    LOCKED = 16
    """
    Set collectdata's pad WAITING state must
                                         not be changed.
    #GstCollectPadsStateFlags indicate private state of a collectdata('s pad).
    """

###############################################################
# classes
###############################################################

class Adapter(GObject.Object):
    """
    This class is for elements that receive buffers in an undesired size.
    While for example raw video contains one image per buffer, the same is not
    true for a lot of other formats, especially those that come directly from
    a file. So if you have undefined buffer sizes and require a specific size,
    this object is for you.

    An adapter is created with gst_adapter_new(). It can be freed again with
    g_object_unref().

    The theory of operation is like this: All buffers received are put
    into the adapter using gst_adapter_push() and the data is then read back
    in chunks of the desired size using gst_adapter_map()/gst_adapter_unmap()
    and/or gst_adapter_copy(). After the data has been processed, it is freed
    using gst_adapter_unmap().

    Other methods such as gst_adapter_take() and gst_adapter_take_buffer()
    combine gst_adapter_map() and gst_adapter_unmap() in one method and are
    potentially more convenient for some use cases.

    For example, a sink pad's chain function that needs to pass data to a library
    in 512-byte chunks could be implemented like this:
    |[<!-- language="C" -->
    static GstFlowReturn
    sink_pad_chain (GstPad *pad, GstObject *parent, GstBuffer *buffer)
    {
      MyElement *this;
      GstAdapter *adapter;
      GstFlowReturn ret = GST_FLOW_OK;

      this = MY_ELEMENT (parent);

      adapter = this->adapter;

      // put buffer into adapter
      gst_adapter_push (adapter, buffer);

      // while we can read out 512 bytes, process them
      while (gst_adapter_available (adapter) >= 512 && ret == GST_FLOW_OK) {
        const guint8 *data = gst_adapter_map (adapter, 512);
        // use flowreturn as an error value
        ret = my_library_foo (data);
        gst_adapter_unmap (adapter);
        gst_adapter_flush (adapter, 512);
      }
      return ret;
    }
    ]|

    For another example, a simple element inside GStreamer that uses #GstAdapter
    is the libvisual element.

    An element using #GstAdapter in its sink pad chain function should ensure that
    when the FLUSH_STOP event is received, that any queued data is cleared using
    gst_adapter_clear(). Data should also be cleared or processed on EOS and
    when changing state from %GST_STATE_PAUSED to %GST_STATE_READY.

    Also check the GST_BUFFER_FLAG_DISCONT flag on the buffer. Some elements might
    need to clear the adapter after a discontinuity.

    The adapter will keep track of the timestamps of the buffers
    that were pushed. The last seen timestamp before the current position
    can be queried with gst_adapter_prev_pts(). This function can
    optionally return the number of bytes between the start of the buffer that
    carried the timestamp and the current adapter position. The distance is
    useful when dealing with, for example, raw audio samples because it allows
    you to calculate the timestamp of the current adapter position by using the
    last seen timestamp and the amount of bytes since.  Additionally, the
    gst_adapter_prev_pts_at_offset() can be used to determine the last
    seen timestamp at a particular offset in the adapter.

    The adapter will also keep track of the offset of the buffers
    (#GST_BUFFER_OFFSET) that were pushed. The last seen offset before the
    current position can be queried with gst_adapter_prev_offset(). This function
    can optionally return the number of bytes between the start of the buffer
    that carried the offset and the current adapter position.

    Additionally the adapter also keeps track of the PTS, DTS and buffer offset
    at the last discontinuity, which can be retrieved with
    gst_adapter_pts_at_discont(), gst_adapter_dts_at_discont() and
    gst_adapter_offset_at_discont(). The number of bytes that were consumed
    since then can be queried with gst_adapter_distance_from_discont().

    A last thing to note is that while #GstAdapter is pretty optimized,
    merging buffers still might be an operation that requires a `malloc()` and
    `memcpy()` operation, and these operations are not the fastest. Because of
    this, some functions like gst_adapter_available_fast() are provided to help
    speed up such cases should you want to. To avoid repeated memory allocations,
    gst_adapter_copy() can be used to copy data into a (statically allocated)
    user provided buffer.

    #GstAdapter is not MT safe. All operations on an adapter must be serialized by
    the caller. This is not normally a problem, however, as the normal use case
    of #GstAdapter is inside one pad's chain function, in which case access is
    serialized via the pad's STREAM_LOCK.

    Note that gst_adapter_push() takes ownership of the buffer passed. Use
    gst_buffer_ref() before pushing it into the adapter if you still want to
    access the buffer later. The adapter will never modify the data in the
    buffer pushed in it.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def available(self) -> int: ...
    def available_fast(self) -> int: ...
    def clear(self) -> None: ...
    def copy(self, offset: int, size: int) -> GLib.Bytes: ...
    def distance_from_discont(self) -> int: ...
    def dts_at_discont(self) -> int: ...
    def flush(self, flush: int) -> None: ...
    def get_buffer(self, nbytes: int) -> Gst.Buffer | None: ...
    def get_buffer_fast(self, nbytes: int) -> Gst.Buffer | None: ...
    def get_buffer_list(self, nbytes: int) -> Gst.BufferList | None: ...
    def get_list(self, nbytes: int) -> list | None: ...
    def map(self) -> tuple[list | None, int]: ...
    def masked_scan_uint32(self, mask: int, pattern: int, offset: int, size: int) -> int: ...
    def masked_scan_uint32_peek(self, mask: int, pattern: int, offset: int, size: int) -> tuple[int, int | None]: ...
    @classmethod
    def new(cls) -> Adapter: ...
    def offset_at_discont(self) -> int: ...
    def prev_dts(self) -> tuple[int, int | None]: ...
    def prev_dts_at_offset(self, offset: int) -> tuple[int, int | None]: ...
    def prev_offset(self) -> tuple[int, int | None]: ...
    def prev_pts(self) -> tuple[int, int | None]: ...
    def prev_pts_at_offset(self, offset: int) -> tuple[int, int | None]: ...
    def pts_at_discont(self) -> int: ...
    def push(self, buf: Gst.Buffer) -> None: ...
    def take(self) -> tuple[list | None, int]: ...
    def take_buffer(self, nbytes: int) -> Gst.Buffer | None: ...
    def take_buffer_fast(self, nbytes: int) -> Gst.Buffer | None: ...
    def take_buffer_list(self, nbytes: int) -> Gst.BufferList | None: ...
    def take_list(self, nbytes: int) -> list | None: ...
    def unmap(self) -> None: ...

    ...

class AdapterClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Aggregator(Gst.Element):
    """
    Manages a set of pads with the purpose of aggregating their buffers.
    Control is given to the subclass when all pads have data.

     * Base class for mixers and muxers. Subclasses should at least implement
       the #GstAggregatorClass::aggregate virtual method.

     * Installs a #GstPadChainFunction, a #GstPadEventFullFunction and a
       #GstPadQueryFunction to queue all serialized data packets per sink pad.
       Subclasses should not overwrite those, but instead implement
       #GstAggregatorClass::sink_event and #GstAggregatorClass::sink_query as
       needed.

     * When data is queued on all pads, the aggregate vmethod is called.

     * One can peek at the data on any given GstAggregatorPad with the
       gst_aggregator_pad_peek_buffer() method, and remove it from the pad
       with the gst_aggregator_pad_pop_buffer () method. When a buffer
       has been taken with pop_buffer (), a new buffer can be queued
       on that pad.

     * When gst_aggregator_pad_peek_buffer() or gst_aggregator_pad_has_buffer()
       are called, a reference is taken to the returned buffer, which stays
       valid until either:

         - gst_aggregator_pad_pop_buffer() is called, in which case the caller
           is guaranteed that the buffer they receive is the same as the peeked
           buffer.
         - gst_aggregator_pad_drop_buffer() is called, in which case the caller
           is guaranteed that the dropped buffer is the one that was peeked.
         - the subclass implementation of #GstAggregatorClass.aggregate returns.

       Subsequent calls to gst_aggregator_pad_peek_buffer() or
       gst_aggregator_pad_has_buffer() return / check the same buffer that was
       returned / checked, until one of the conditions listed above is met.

       Subclasses are only allowed to call these methods from the aggregate
       thread.

     * If the subclass wishes to push a buffer downstream in its aggregate
       implementation, it should do so through the
       gst_aggregator_finish_buffer() method. This method will take care
       of sending and ordering mandatory events such as stream start, caps
       and segment. Buffer lists can also be pushed out with
       gst_aggregator_finish_buffer_list().

     * Same goes for EOS events, which should not be pushed directly by the
       subclass, it should instead return GST_FLOW_EOS in its aggregate
       implementation.

     * Note that the aggregator logic regarding gap event handling is to turn
       these into gap buffers with matching PTS and duration. It will also
       flag these buffers with GST_BUFFER_FLAG_GAP and GST_BUFFER_FLAG_DROPPABLE
       to ease their identification and subsequent processing.
       In addition, if the gap event was flagged with GST_GAP_FLAG_MISSING_DATA,
       a custom meta is added to the resulting gap buffer (GstAggregatorMissingDataMeta).

     * Subclasses must use (a subclass of) #GstAggregatorPad for both their
       sink and source pads.
       See gst_element_class_add_static_pad_template_with_gtype().

    This class used to live in gst-plugins-bad and was moved to core.
    """

    class Props(Gst.Element.Props):
        emit_signals: bool  # [emit-signals]: changed because contained invalid characters
        latency: int
        min_upstream_latency: int  # [min-upstream-latency]: changed because contained invalid characters
        start_time: int  # [start-time]: changed because contained invalid characters
        start_time_selection: (
            AggregatorStartTimeSelection  # [start-time-selection]: changed because contained invalid characters
        )

    # gi Fields
    @property
    def srcpad(self) -> Gst.Pad | None: ...

    # gi Methods
    def __init__(
        self,
        emit_signals: bool = ...,
        latency: int = ...,
        min_upstream_latency: int = ...,
        start_time: int = ...,
        start_time_selection: AggregatorStartTimeSelection = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def finish_buffer(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def finish_buffer_list(self, bufferlist: Gst.BufferList) -> Gst.FlowReturn: ...
    def get_allocator(self) -> tuple[Gst.Allocator | None, Gst.AllocationParams | None]: ...
    def get_buffer_pool(self) -> Gst.BufferPool | None: ...
    def get_force_live(self) -> bool: ...
    def get_ignore_inactive_pads(self) -> bool: ...
    @property
    def get_latency(self) -> int: ...
    def negotiate(self) -> bool: ...
    def peek_next_sample(self, pad: AggregatorPad) -> Gst.Sample | None: ...
    def push_src_event(self, event: Gst.Event) -> bool: ...
    def selected_samples(self, pts: int, dts: int, duration: int, info: Gst.Structure | None = None) -> None: ...
    def set_force_live(self, force_live: bool) -> None: ...
    def set_ignore_inactive_pads(self, ignore: bool) -> None: ...
    def set_latency(self, min_latency: int, max_latency: int) -> None: ...
    def set_src_caps(self, caps: Gst.Caps) -> None: ...
    def simple_get_next_time(self) -> int: ...
    def update_segment(self, segment: Gst.Segment) -> None: ...

    # python methods (overrides?)
    def do_aggregate(
        self,
        timeout: bool,
    ) -> Gst.FlowReturn:
        """
        aggregate(self, timeout:bool) -> Gst.FlowReturn
        """
    def do_clip(
        self,
        aggregator_pad: AggregatorPad,
        buf: Gst.Buffer,
    ) -> Gst.Buffer:
        """
        clip(self, aggregator_pad:GstBase.AggregatorPad, buf:Gst.Buffer) -> Gst.Buffer
        """
    def do_decide_allocation(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        decide_allocation(self, query:Gst.Query) -> bool
        """
    def do_finish_buffer(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        finish_buffer(self, buffer:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_finish_buffer_list(
        self,
        bufferlist: Gst.BufferList,
    ) -> Gst.FlowReturn:
        """
        finish_buffer_list(self, bufferlist:Gst.BufferList) -> Gst.FlowReturn
        """
    def do_fixate_src_caps(
        self,
        caps: Gst.Caps,
    ) -> Gst.Caps:
        """
        fixate_src_caps(self, caps:Gst.Caps) -> Gst.Caps
        """
    def do_flush(
        self,
    ) -> Gst.FlowReturn:
        """
        flush(self) -> Gst.FlowReturn
        """
    def do_get_next_time(
        self,
    ) -> int:
        """
        get_next_time(self) -> int
        """
    def do_negotiate(
        self,
    ) -> bool:
        """
        negotiate(self) -> bool
        """
    def do_negotiated_src_caps(
        self,
        caps: Gst.Caps,
    ) -> bool:
        """
        negotiated_src_caps(self, caps:Gst.Caps) -> bool
        """
    def do_peek_next_sample(
        self,
        aggregator_pad: AggregatorPad,
    ) -> Gst.Sample | None:
        """
        peek_next_sample(self, aggregator_pad:GstBase.AggregatorPad) -> Gst.Sample or None
        """
    def do_propose_allocation(
        self,
        pad: AggregatorPad,
        decide_query: Gst.Query,
        query: Gst.Query,
    ) -> bool:
        """
        propose_allocation(self, pad:GstBase.AggregatorPad, decide_query:Gst.Query, query:Gst.Query) -> bool
        """
    def do_sink_event(
        self,
        aggregator_pad: AggregatorPad,
        event: Gst.Event,
    ) -> bool:
        """
        sink_event(self, aggregator_pad:GstBase.AggregatorPad, event:Gst.Event) -> bool
        """
    def do_sink_event_pre_queue(
        self,
        aggregator_pad: AggregatorPad,
        event: Gst.Event,
    ) -> Gst.FlowReturn:
        """
        sink_event_pre_queue(self, aggregator_pad:GstBase.AggregatorPad, event:Gst.Event) -> Gst.FlowReturn
        """
    def do_sink_query(
        self,
        aggregator_pad: AggregatorPad,
        query: Gst.Query,
    ) -> bool:
        """
        sink_query(self, aggregator_pad:GstBase.AggregatorPad, query:Gst.Query) -> bool
        """
    def do_sink_query_pre_queue(
        self,
        aggregator_pad: AggregatorPad,
        query: Gst.Query,
    ) -> bool:
        """
        sink_query_pre_queue(self, aggregator_pad:GstBase.AggregatorPad, query:Gst.Query) -> bool
        """
    def do_src_activate(
        self,
        mode: Gst.PadMode,
        active: bool,
    ) -> bool:
        """
        src_activate(self, mode:Gst.PadMode, active:bool) -> bool
        """
    def do_src_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        src_event(self, event:Gst.Event) -> bool
        """
    def do_src_query(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        src_query(self, query:Gst.Query) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """
    def do_update_src_caps(
        self,
        caps: Gst.Caps,
    ) -> tuple:
        """
        update_src_caps(self, caps:Gst.Caps) -> Gst.FlowReturn, ret:Gst.Caps
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["samples-selected"],
        handler: typing.Callable[[typing_extensions.Self, Gst.Segment, int, int, int, Gst.Structure | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::emit_signals"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::latency"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_upstream_latency"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::start_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::start_time_selection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class AggregatorClass(GObject.GPointer):
    # gi Fields
    @property
    def aggregate(self) -> aggregateAggregatorClassCB: ...
    @property
    def clip(self) -> clipAggregatorClassCB: ...
    @property
    def decide_allocation(self) -> decide_allocationAggregatorClassCB: ...
    @property
    def finish_buffer(self) -> finish_bufferAggregatorClassCB: ...
    @property
    def finish_buffer_list(self) -> finish_buffer_listAggregatorClassCB: ...
    @property
    def fixate_src_caps(self) -> fixate_src_capsAggregatorClassCB: ...
    @property
    def flush(self) -> flushAggregatorClassCB: ...
    @property
    def get_next_time(self) -> get_next_timeAggregatorClassCB: ...
    @property
    def negotiate(self) -> negotiateAggregatorClassCB: ...
    @property
    def negotiated_src_caps(self) -> negotiated_src_capsAggregatorClassCB: ...
    @property
    def parent_class(self) -> Gst.ElementClass | None: ...
    @property
    def peek_next_sample(self) -> peek_next_sampleAggregatorClassCB | None: ...
    @property
    def propose_allocation(self) -> propose_allocationAggregatorClassCB: ...
    @property
    def sink_event(self) -> sink_eventAggregatorClassCB: ...
    @property
    def sink_event_pre_queue(self) -> sink_event_pre_queueAggregatorClassCB: ...
    @property
    def sink_query(self) -> sink_queryAggregatorClassCB: ...
    @property
    def sink_query_pre_queue(self) -> sink_query_pre_queueAggregatorClassCB: ...
    @property
    def src_activate(self) -> src_activateAggregatorClassCB: ...
    @property
    def src_event(self) -> src_eventAggregatorClassCB: ...
    @property
    def src_query(self) -> src_queryAggregatorClassCB: ...
    @property
    def start(self) -> startAggregatorClassCB: ...
    @property
    def stop(self) -> stopAggregatorClassCB: ...
    @property
    def update_src_caps(self) -> update_src_capsAggregatorClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class AggregatorPad(Gst.Pad):
    """
    Pads managed by a #GstAggregator subclass.

    This class used to live in gst-plugins-bad and was moved to core.
    """

    class Props(Gst.Pad.Props):
        emit_signals: bool  # [emit-signals]: changed because contained invalid characters

    # gi Fields
    @property
    def segment(self) -> Gst.Segment | None: ...

    # gi Methods
    def __init__(self, emit_signals: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def drop_buffer(self) -> bool: ...
    def has_buffer(self) -> bool: ...
    def is_eos(self) -> bool: ...
    def is_inactive(self) -> bool: ...
    def peek_buffer(self) -> Gst.Buffer | None: ...
    def pop_buffer(self) -> Gst.Buffer | None: ...

    # python methods (overrides?)
    def do_flush(
        self,
        aggregator: Aggregator,
    ) -> Gst.FlowReturn:
        """
        flush(self, aggregator:GstBase.Aggregator) -> Gst.FlowReturn
        """
    def do_skip_buffer(
        self,
        aggregator: Aggregator,
        buffer: Gst.Buffer,
    ) -> bool:
        """
        skip_buffer(self, aggregator:GstBase.Aggregator, buffer:Gst.Buffer) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["buffer-consumed"],
        handler: typing.Callable[[typing_extensions.Self, Gst.Buffer], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::emit_signals"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class AggregatorPadClass(GObject.GPointer):
    # gi Fields
    @property
    def flush(self) -> flushAggregatorPadClassCB: ...
    @property
    def parent_class(self) -> Gst.PadClass | None: ...
    @property
    def skip_buffer(self) -> skip_bufferAggregatorPadClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class AggregatorPadPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class AggregatorPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BaseParse(Gst.Element):
    """
    This base class is for parser elements that process data and splits it
    into separate audio/video/whatever frames.

    It provides for:

      * provides one sink pad and one source pad
      * handles state changes
      * can operate in pull mode or push mode
      * handles seeking in both modes
      * handles events (SEGMENT/EOS/FLUSH)
      * handles queries (POSITION/DURATION/SEEKING/FORMAT/CONVERT)
      * handles flushing

    The purpose of this base class is to provide the basic functionality of
    a parser and share a lot of rather complex code.

    # Description of the parsing mechanism:

    ## Set-up phase

     * #GstBaseParse calls #GstBaseParseClass::start to inform subclass
       that data processing is about to start now.

     * #GstBaseParse class calls #GstBaseParseClass::set_sink_caps to
       inform the subclass about incoming sinkpad caps. Subclass could
       already set the srcpad caps accordingly, but this might be delayed
       until calling gst_base_parse_finish_frame() with a non-queued frame.

     * At least at this point subclass needs to tell the #GstBaseParse class
       how big data chunks it wants to receive (minimum frame size ). It can
       do this with gst_base_parse_set_min_frame_size().

     * #GstBaseParse class sets up appropriate data passing mode (pull/push)
       and starts to process the data.

    ## Parsing phase

     * #GstBaseParse gathers at least min_frame_size bytes of data either
       by pulling it from upstream or collecting buffers in an internal
       #GstAdapter.

     * A buffer of (at least) min_frame_size bytes is passed to subclass
       with #GstBaseParseClass::handle_frame. Subclass checks the contents
       and can optionally return #GST_FLOW_OK along with an amount of data
       to be skipped to find a valid frame (which will result in a
       subsequent DISCONT).  If, otherwise, the buffer does not hold a
       complete frame, #GstBaseParseClass::handle_frame can merely return
       and will be called again when additional data is available.  In push
       mode this amounts to an additional input buffer (thus minimal
       additional latency), in pull mode this amounts to some arbitrary
       reasonable buffer size increase.

       Of course, gst_base_parse_set_min_frame_size() could also be used if
       a very specific known amount of additional data is required.  If,
       however, the buffer holds a complete valid frame, it can pass the
       size of this frame to gst_base_parse_finish_frame().

       If acting as a converter, it can also merely indicate consumed input
       data while simultaneously providing custom output data.  Note that
       baseclass performs some processing (such as tracking overall consumed
       data rate versus duration) for each finished frame, but other state
       is only updated upon each call to #GstBaseParseClass::handle_frame
       (such as tracking upstream input timestamp).

       Subclass is also responsible for setting the buffer metadata
       (e.g. buffer timestamp and duration, or keyframe if applicable).
       (although the latter can also be done by #GstBaseParse if it is
       appropriately configured, see below).  Frame is provided with
       timestamp derived from upstream (as much as generally possible),
       duration obtained from configuration (see below), and offset
       if meaningful (in pull mode).

       Note that #GstBaseParseClass::handle_frame might receive any small
       amount of input data when leftover data is being drained (e.g. at
       EOS).

     * As part of finish frame processing, just prior to actually pushing
       the buffer in question, it is passed to
       #GstBaseParseClass::pre_push_frame which gives subclass yet one last
       chance to examine buffer metadata, or to send some custom (tag)
       events, or to perform custom (segment) filtering.

     * During the parsing process #GstBaseParseClass will handle both srcpad
       and sinkpad events. They will be passed to subclass if
       #GstBaseParseClass::sink_event or #GstBaseParseClass::src_event
       implementations have been provided.

    ## Shutdown phase

    * #GstBaseParse class calls #GstBaseParseClass::stop to inform the
      subclass that data parsing will be stopped.

    Subclass is responsible for providing pad template caps for source and
    sink pads. The pads need to be named "sink" and "src". It also needs to
    set the fixed caps on srcpad, when the format is ensured (e.g.  when
    base class calls subclass' #GstBaseParseClass::set_sink_caps function).

    This base class uses %GST_FORMAT_DEFAULT as a meaning of frames. So,
    subclass conversion routine needs to know that conversion from
    %GST_FORMAT_TIME to %GST_FORMAT_DEFAULT must return the
    frame number that can be found from the given byte position.

    #GstBaseParse uses subclasses conversion methods also for seeking (or
    otherwise uses its own default one, see also below).

    Subclass @start and @stop functions will be called to inform the beginning
    and end of data processing.

    Things that subclass need to take care of:

    * Provide pad templates
    * Fixate the source pad caps when appropriate
    * Inform base class how big data chunks should be retrieved. This is
      done with gst_base_parse_set_min_frame_size() function.
    * Examine data chunks passed to subclass with
      #GstBaseParseClass::handle_frame and pass proper frame(s) to
      gst_base_parse_finish_frame(), and setting src pad caps and timestamps
      on frame.
    * Provide conversion functions
    * Update the duration information with gst_base_parse_set_duration()
    * Optionally passthrough using gst_base_parse_set_passthrough()
    * Configure various baseparse parameters using
      gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
      and gst_base_parse_set_frame_rate().

    * In particular, if subclass is unable to determine a duration, but
      parsing (or specs) yields a frames per seconds rate, then this can be
      provided to #GstBaseParse to enable it to cater for buffer time
      metadata (which will be taken from upstream as much as
      possible). Internally keeping track of frame durations and respective
      sizes that have been pushed provides #GstBaseParse with an estimated
      bitrate. A default #GstBaseParseClass::convert (used if not
      overridden) will then use these rates to perform obvious conversions.
      These rates are also used to update (estimated) duration at regular
      frame intervals.
    """

    class Props(Gst.Element.Props):
        disable_passthrough: bool  # [disable-passthrough]: changed because contained invalid characters

    # gi Fields
    @property
    def element(self) -> Gst.Element | None: ...
    @property
    def flags(self) -> int: ...
    @property
    def segment(self) -> Gst.Segment | None: ...
    @property
    def sinkpad(self) -> Gst.Pad | None: ...
    @property
    def srcpad(self) -> Gst.Pad | None: ...

    # gi Methods
    def __init__(self, disable_passthrough: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_index_entry(self, offset: int, ts: int, key: bool, force: bool) -> bool: ...
    def convert_default(self, src_format: Gst.Format, src_value: int, dest_format: Gst.Format) -> tuple[bool, int]: ...
    def drain(self) -> None: ...
    def finish_frame(self, frame: BaseParseFrame, size: int) -> Gst.FlowReturn: ...
    def merge_tags(self, tags: Gst.TagList | None, mode: Gst.TagMergeMode) -> None: ...
    def push_frame(self, frame: BaseParseFrame) -> Gst.FlowReturn: ...
    def set_average_bitrate(self, bitrate: int) -> None: ...
    def set_duration(self, fmt: Gst.Format, duration: int, interval: int) -> None: ...
    def set_frame_rate(self, fps_num: int, fps_den: int, lead_in: int, lead_out: int) -> None: ...
    def set_has_timing_info(self, has_timing: bool) -> None: ...
    def set_infer_ts(self, infer_ts: bool) -> None: ...
    def set_latency(self, min_latency: int, max_latency: int) -> None: ...
    def set_min_frame_size(self, min_size: int) -> None: ...
    def set_passthrough(self, passthrough: bool) -> None: ...
    def set_pts_interpolation(self, pts_interpolate: bool) -> None: ...
    def set_syncable(self, syncable: bool) -> None: ...
    def set_ts_at_offset(self, offset: int) -> None: ...

    # python methods (overrides?)
    def do_convert(
        self,
        src_format: Gst.Format,
        src_value: int,
        dest_format: Gst.Format,
        dest_value: int,
    ) -> bool:
        """
        convert(self, src_format:Gst.Format, src_value:int, dest_format:Gst.Format, dest_value:int) -> bool
        """
    def do_detect(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        detect(self, buffer:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_get_sink_caps(
        self,
        filter: Gst.Caps,
    ) -> Gst.Caps:
        """
        get_sink_caps(self, filter:Gst.Caps) -> Gst.Caps
        """
    def do_handle_frame(
        self,
        frame: BaseParseFrame,
    ) -> tuple:
        """
        handle_frame(self, frame:GstBase.BaseParseFrame) -> Gst.FlowReturn, skipsize:int
        """
    def do_pre_push_frame(
        self,
        frame: BaseParseFrame,
    ) -> Gst.FlowReturn:
        """
        pre_push_frame(self, frame:GstBase.BaseParseFrame) -> Gst.FlowReturn
        """
    def do_set_sink_caps(
        self,
        caps: Gst.Caps,
    ) -> bool:
        """
        set_sink_caps(self, caps:Gst.Caps) -> bool
        """
    def do_sink_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        sink_event(self, event:Gst.Event) -> bool
        """
    def do_sink_query(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        sink_query(self, query:Gst.Query) -> bool
        """
    def do_src_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        src_event(self, event:Gst.Event) -> bool
        """
    def do_src_query(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        src_query(self, query:Gst.Query) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::disable_passthrough"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class BaseParseClass(GObject.GPointer):
    # gi Fields
    @property
    def convert(self) -> convertBaseParseClassCB: ...
    @property
    def detect(self) -> detectBaseParseClassCB: ...
    @property
    def get_sink_caps(self) -> get_sink_capsBaseParseClassCB: ...
    @property
    def handle_frame(self) -> handle_frameBaseParseClassCB: ...
    @property
    def parent_class(self) -> Gst.ElementClass | None: ...
    @property
    def pre_push_frame(self) -> pre_push_frameBaseParseClassCB: ...
    @property
    def set_sink_caps(self) -> set_sink_capsBaseParseClassCB: ...
    @property
    def sink_event(self) -> sink_eventBaseParseClassCB: ...
    @property
    def sink_query(self) -> sink_queryBaseParseClassCB: ...
    @property
    def src_event(self) -> src_eventBaseParseClassCB: ...
    @property
    def src_query(self) -> src_queryBaseParseClassCB: ...
    @property
    def start(self) -> startBaseParseClassCB: ...
    @property
    def stop(self) -> stopBaseParseClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BaseParseFrame(GObject.GBoxed):
    # gi Fields
    buffer: Gst.Buffer | None = ...  # type: ignore
    flags: int = ...
    offset: int = ...
    out_buffer: Gst.Buffer | None = ...  # type: ignore
    overhead: int = ...
    @property
    def size(self) -> int: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def copy(self) -> BaseParseFrame: ...
    def free(self) -> None: ...
    def init(self) -> None: ...
    @classmethod
    def new(cls, buffer: Gst.Buffer, flags: BaseParseFrameFlags, overhead: int) -> BaseParseFrame: ...

    ...

class BaseParsePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BaseSink(Gst.Element):
    """
    #GstBaseSink is the base class for sink elements in GStreamer, such as
    xvimagesink or filesink. It is a layer on top of #GstElement that provides a
    simplified interface to plugin writers. #GstBaseSink handles many details
    for you, for example: preroll, clock synchronization, state changes,
    activation in push or pull mode, and queries.

    In most cases, when writing sink elements, there is no need to implement
    class methods from #GstElement or to set functions on pads, because the
    #GstBaseSink infrastructure should be sufficient.

    #GstBaseSink provides support for exactly one sink pad, which should be
    named "sink". A sink implementation (subclass of #GstBaseSink) should
    install a pad template in its class_init function, like so:
    |[<!-- language="C" -->
    static void
    my_element_class_init (GstMyElementClass *klass)
    {
      GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);

      // sinktemplate should be a #GstStaticPadTemplate with direction
      // %GST_PAD_SINK and name "sink"
      gst_element_class_add_static_pad_template (gstelement_class, &sinktemplate);

      gst_element_class_set_static_metadata (gstelement_class,
          "Sink name",
          "Sink",
          "My Sink element",
          "The author <my.sink@my.email>");
    }
    ]|

    #GstBaseSink will handle the prerolling correctly. This means that it will
    return %GST_STATE_CHANGE_ASYNC from a state change to PAUSED until the first
    buffer arrives in this element. The base class will call the
    #GstBaseSinkClass::preroll vmethod with this preroll buffer and will then
    commit the state change to the next asynchronously pending state.

    When the element is set to PLAYING, #GstBaseSink will synchronise on the
    clock using the times returned from #GstBaseSinkClass::get_times. If this
    function returns %GST_CLOCK_TIME_NONE for the start time, no synchronisation
    will be done. Synchronisation can be disabled entirely by setting the object
    #GstBaseSink:sync property to %FALSE.

    After synchronisation the virtual method #GstBaseSinkClass::render will be
    called. Subclasses should minimally implement this method.

    Subclasses that synchronise on the clock in the #GstBaseSinkClass::render
    method are supported as well. These classes typically receive a buffer in
    the render method and can then potentially block on the clock while
    rendering. A typical example is an audiosink.
    These subclasses can use gst_base_sink_wait_preroll() to perform the
    blocking wait.

    Upon receiving the EOS event in the PLAYING state, #GstBaseSink will wait
    for the clock to reach the time indicated by the stop time of the last
    #GstBaseSinkClass::get_times call before posting an EOS message. When the
    element receives EOS in PAUSED, preroll completes, the event is queued and an
    EOS message is posted when going to PLAYING.

    #GstBaseSink will internally use the %GST_EVENT_SEGMENT events to schedule
    synchronisation and clipping of buffers. Buffers that fall completely outside
    of the current segment are dropped. Buffers that fall partially in the
    segment are rendered (and prerolled). Subclasses should do any subbuffer
    clipping themselves when needed.

    #GstBaseSink will by default report the current playback position in
    %GST_FORMAT_TIME based on the current clock time and segment information.
    If no clock has been set on the element, the query will be forwarded
    upstream.

    The #GstBaseSinkClass::set_caps function will be called when the subclass
    should configure itself to process a specific media type.

    The #GstBaseSinkClass::start and #GstBaseSinkClass::stop virtual methods
    will be called when resources should be allocated. Any
    #GstBaseSinkClass::preroll, #GstBaseSinkClass::render and
    #GstBaseSinkClass::set_caps function will be called between the
    #GstBaseSinkClass::start and #GstBaseSinkClass::stop calls.

    The #GstBaseSinkClass::event virtual method will be called when an event is
    received by #GstBaseSink. Normally this method should only be overridden by
    very specific elements (such as file sinks) which need to handle the
    newsegment event specially.

    The #GstBaseSinkClass::unlock method is called when the elements should
    unblock any blocking operations they perform in the
    #GstBaseSinkClass::render method. This is mostly useful when the
    #GstBaseSinkClass::render method performs a blocking write on a file
    descriptor, for example.

    The #GstBaseSink:max-lateness property affects how the sink deals with
    buffers that arrive too late in the sink. A buffer arrives too late in the
    sink when the presentation time (as a combination of the last segment, buffer
    timestamp and element base_time) plus the duration is before the current
    time of the clock.
    If the frame is later than max-lateness, the sink will drop the buffer
    without calling the render method.
    This feature is disabled if sync is disabled, the
    #GstBaseSinkClass::get_times method does not return a valid start time or
    max-lateness is set to -1 (the default).
    Subclasses can use gst_base_sink_set_max_lateness() to configure the
    max-lateness value.

    The #GstBaseSink:qos property will enable the quality-of-service features of
    the basesink which gather statistics about the real-time performance of the
    clock synchronisation. For each buffer received in the sink, statistics are
    gathered and a QOS event is sent upstream with these numbers. This
    information can then be used by upstream elements to reduce their processing
    rate, for example.

    The #GstBaseSink:async property can be used to instruct the sink to never
    perform an ASYNC state change. This feature is mostly usable when dealing
    with non-synchronized streams or sparse streams.
    """

    class Props(Gst.Element.Props):
        async_: bool
        blocksize: int
        enable_last_sample: bool  # [enable-last-sample]: changed because contained invalid characters
        last_sample: Gst.Sample | None  # [last-sample]: changed because contained invalid characters
        max_bitrate: int  # [max-bitrate]: changed because contained invalid characters
        max_lateness: int  # [max-lateness]: changed because contained invalid characters
        processing_deadline: int  # [processing-deadline]: changed because contained invalid characters
        qos: bool
        render_delay: int  # [render-delay]: changed because contained invalid characters
        stats: Gst.Structure | None
        sync: bool
        throttle_time: int  # [throttle-time]: changed because contained invalid characters
        ts_offset: int  # [ts-offset]: changed because contained invalid characters

    # gi Fields
    @property
    def can_activate_pull(self) -> bool: ...
    @property
    def can_activate_push(self) -> bool: ...
    @property
    def element(self) -> Gst.Element | None: ...
    @property
    def eos(self) -> bool: ...
    @property
    def flushing(self) -> bool: ...
    @property
    def have_newsegment(self) -> bool: ...
    @property
    def have_preroll(self) -> bool: ...
    @property
    def max_lateness(self) -> int: ...
    @property
    def need_preroll(self) -> bool: ...
    @property
    def offset(self) -> int: ...
    @property
    def pad_mode(self) -> Gst.PadMode: ...
    @property
    def playing_async(self) -> bool: ...
    @property
    def preroll_cond(self) -> GLib.Cond | None: ...
    @property
    def preroll_lock(self) -> GLib.Mutex | None: ...
    @property
    def running(self) -> bool: ...
    @property
    def segment(self) -> Gst.Segment | None: ...
    @property
    def sinkpad(self) -> Gst.Pad | None: ...
    @property
    def sync(self) -> bool: ...

    # gi Methods
    def __init__(
        self,
        async_: bool = ...,
        blocksize: int = ...,
        enable_last_sample: bool = ...,
        max_bitrate: int = ...,
        max_lateness: int = ...,
        processing_deadline: int = ...,
        qos: bool = ...,
        render_delay: int = ...,
        sync: bool = ...,
        throttle_time: int = ...,
        ts_offset: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def do_preroll(self, obj: Gst.MiniObject) -> Gst.FlowReturn: ...
    @property
    def get_blocksize(self) -> int: ...
    def get_drop_out_of_segment(self) -> bool: ...
    @property
    def get_last_sample(self) -> Gst.Sample | None: ...
    def get_latency(self) -> int: ...
    @property
    def get_max_bitrate(self) -> int: ...
    @property
    def get_max_lateness(self) -> int: ...
    @property
    def get_processing_deadline(self) -> int: ...
    @property
    def get_render_delay(self) -> int: ...
    @property
    def get_stats(self) -> Gst.Structure: ...
    @property
    def get_sync(self) -> bool: ...
    @property
    def get_throttle_time(self) -> int: ...
    @property
    def get_ts_offset(self) -> int: ...
    def is_async_enabled(self) -> bool: ...
    def is_last_sample_enabled(self) -> bool: ...
    def is_qos_enabled(self) -> bool: ...
    def query_latency(self) -> tuple[bool, bool | None, bool | None, int | None, int | None]: ...
    def set_async_enabled(self, enabled: bool) -> None: ...
    def set_blocksize(self, blocksize: int) -> None: ...
    def set_drop_out_of_segment(self, drop_out_of_segment: bool) -> None: ...
    def set_last_sample_enabled(self, enabled: bool) -> None: ...
    def set_max_bitrate(self, max_bitrate: int) -> None: ...
    def set_max_lateness(self, max_lateness: int) -> None: ...
    def set_processing_deadline(self, processing_deadline: int) -> None: ...
    def set_qos_enabled(self, enabled: bool) -> None: ...
    def set_render_delay(self, delay: int) -> None: ...
    def set_sync(self, sync: bool) -> None: ...
    def set_throttle_time(self, throttle: int) -> None: ...
    def set_ts_offset(self, offset: int) -> None: ...
    def wait(self, time: int) -> tuple[Gst.FlowReturn, int | None]: ...
    def wait_clock(self, time: int) -> tuple[Gst.ClockReturn, int | None]: ...
    def wait_preroll(self) -> Gst.FlowReturn: ...

    # python methods (overrides?)
    def do_activate_pull(
        self,
        active: bool,
    ) -> bool:
        """
        activate_pull(self, active:bool) -> bool
        """
    def do_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        event(self, event:Gst.Event) -> bool
        """
    def do_fixate(
        self,
        caps: Gst.Caps,
    ) -> Gst.Caps:
        """
        fixate(self, caps:Gst.Caps) -> Gst.Caps
        """
    def do_get_caps(
        self,
        filter: Gst.Caps | None = None,
    ) -> Gst.Caps:
        """
        get_caps(self, filter:Gst.Caps=None) -> Gst.Caps
        """
    def do_get_times(
        self,
        buffer: Gst.Buffer,
    ) -> tuple:
        """
        get_times(self, buffer:Gst.Buffer) -> start:int, end:int
        """
    def do_prepare(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        prepare(self, buffer:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_prepare_list(
        self,
        buffer_list: Gst.BufferList,
    ) -> Gst.FlowReturn:
        """
        prepare_list(self, buffer_list:Gst.BufferList) -> Gst.FlowReturn
        """
    def do_propose_allocation(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        propose_allocation(self, query:Gst.Query) -> bool
        """
    def do_query(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        query(self, query:Gst.Query) -> bool
        """
    def do_render(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        render(self, buffer:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_render_list(
        self,
        buffer_list: Gst.BufferList,
    ) -> Gst.FlowReturn:
        """
        render_list(self, buffer_list:Gst.BufferList) -> Gst.FlowReturn
        """
    def do_set_caps(
        self,
        caps: Gst.Caps,
    ) -> bool:
        """
        set_caps(self, caps:Gst.Caps) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """
    def do_unlock(
        self,
    ) -> bool:
        """
        unlock(self) -> bool
        """
    def do_unlock_stop(
        self,
    ) -> bool:
        """
        unlock_stop(self) -> bool
        """
    def do_wait_event(
        self,
        event: Gst.Event,
    ) -> Gst.FlowReturn:
        """
        wait_event(self, event:Gst.Event) -> Gst.FlowReturn
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::async_"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::blocksize"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_last_sample"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::last_sample"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_bitrate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_lateness"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::processing_deadline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::qos"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::render_delay"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stats"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sync"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::throttle_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ts_offset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class BaseSinkClass(GObject.GPointer):
    # gi Fields
    @property
    def activate_pull(self) -> activate_pullBaseSinkClassCB: ...
    @property
    def event(self) -> eventBaseSinkClassCB: ...
    @property
    def fixate(self) -> fixateBaseSinkClassCB: ...
    @property
    def get_caps(self) -> get_capsBaseSinkClassCB: ...
    @property
    def get_times(self) -> get_timesBaseSinkClassCB: ...
    @property
    def parent_class(self) -> Gst.ElementClass | None: ...
    @property
    def prepare(self) -> prepareBaseSinkClassCB: ...
    @property
    def prepare_list(self) -> prepare_listBaseSinkClassCB: ...
    @property
    def preroll(self) -> prerollBaseSinkClassCB: ...
    @property
    def propose_allocation(self) -> propose_allocationBaseSinkClassCB: ...
    @property
    def query(self) -> queryBaseSinkClassCB: ...
    @property
    def render(self) -> renderBaseSinkClassCB: ...
    @property
    def render_list(self) -> render_listBaseSinkClassCB: ...
    @property
    def set_caps(self) -> set_capsBaseSinkClassCB: ...
    @property
    def start(self) -> startBaseSinkClassCB: ...
    @property
    def stop(self) -> stopBaseSinkClassCB: ...
    @property
    def unlock(self) -> unlockBaseSinkClassCB: ...
    @property
    def unlock_stop(self) -> unlock_stopBaseSinkClassCB: ...
    @property
    def wait_event(self) -> wait_eventBaseSinkClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BaseSinkPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BaseSrc(Gst.Element):
    """
    This is a generic base class for source elements. The following
    types of sources are supported:

      * random access sources like files
      * seekable sources
      * live sources

    The source can be configured to operate in any #GstFormat with the
    gst_base_src_set_format() method. The currently set format determines
    the format of the internal #GstSegment and any %GST_EVENT_SEGMENT
    events. The default format for #GstBaseSrc is %GST_FORMAT_BYTES.

    #GstBaseSrc always supports push mode scheduling. If the following
    conditions are met, it also supports pull mode scheduling:

      * The format is set to %GST_FORMAT_BYTES (default).
      * #GstBaseSrcClass::is_seekable returns %TRUE.

    If all the conditions are met for operating in pull mode, #GstBaseSrc is
    automatically seekable in push mode as well. The following conditions must
    be met to make the element seekable in push mode when the format is not
    %GST_FORMAT_BYTES:

    * #GstBaseSrcClass::is_seekable returns %TRUE.
    * #GstBaseSrcClass::query can convert all supported seek formats to the
      internal format as set with gst_base_src_set_format().
    * #GstBaseSrcClass::do_seek is implemented, performs the seek and returns
       %TRUE.

    When the element does not meet the requirements to operate in pull mode, the
    offset and length in the #GstBaseSrcClass::create method should be ignored.
    It is recommended to subclass #GstPushSrc instead, in this situation. If the
    element can operate in pull mode but only with specific offsets and
    lengths, it is allowed to generate an error when the wrong values are passed
    to the #GstBaseSrcClass::create function.

    #GstBaseSrc has support for live sources. Live sources are sources that when
    paused discard data, such as audio or video capture devices. A typical live
    source also produces data at a fixed rate and thus provides a clock to publish
    this rate.
    Use gst_base_src_set_live() to activate the live source mode.

    A live source does not produce data in the PAUSED state. This means that the
    #GstBaseSrcClass::create method will not be called in PAUSED but only in
    PLAYING. To signal the pipeline that the element will not produce data, the
    return value from the READY to PAUSED state will be
    %GST_STATE_CHANGE_NO_PREROLL.

    A typical live source will timestamp the buffers it creates with the
    current running time of the pipeline. This is one reason why a live source
    can only produce data in the PLAYING state, when the clock is actually
    distributed and running.

    Live sources that synchronize and block on the clock (an audio source, for
    example) can use gst_base_src_wait_playing() when the
    #GstBaseSrcClass::create function was interrupted by a state change to
    PAUSED.

    The #GstBaseSrcClass::get_times method can be used to implement pseudo-live
    sources. It only makes sense to implement the #GstBaseSrcClass::get_times
    function if the source is a live source. The #GstBaseSrcClass::get_times
    function should return timestamps starting from 0, as if it were a non-live
    source. The base class will make sure that the timestamps are transformed
    into the current running_time. The base source will then wait for the
    calculated running_time before pushing out the buffer.

    For live sources, the base class will by default report a latency of 0.
    For pseudo live sources, the base class will by default measure the difference
    between the first buffer timestamp and the start time of get_times and will
    report this value as the latency.
    Subclasses should override the query function when this behaviour is not
    acceptable.

    There is only support in #GstBaseSrc for exactly one source pad, which
    should be named "src". A source implementation (subclass of #GstBaseSrc)
    should install a pad template in its class_init function, like so:
    |[<!-- language="C" -->
    static void
    my_element_class_init (GstMyElementClass *klass)
    {
      GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
      // srctemplate should be a #GstStaticPadTemplate with direction
      // %GST_PAD_SRC and name "src"
      gst_element_class_add_static_pad_template (gstelement_class, &srctemplate);

      gst_element_class_set_static_metadata (gstelement_class,
         "Source name",
         "Source",
         "My Source element",
         "The author <my.sink@my.email>");
    }
    ]|

    ## Controlled shutdown of live sources in applications

    Applications that record from a live source may want to stop recording
    in a controlled way, so that the recording is stopped, but the data
    already in the pipeline is processed to the end (remember that many live
    sources would go on recording forever otherwise). For that to happen the
    application needs to make the source stop recording and send an EOS
    event down the pipeline. The application would then wait for an
    EOS message posted on the pipeline's bus to know when all data has
    been processed and the pipeline can safely be stopped.

    An application may send an EOS event to a source element to make it
    perform the EOS logic (send EOS event downstream or post a
    %GST_MESSAGE_SEGMENT_DONE on the bus). This can typically be done
    with the gst_element_send_event() function on the element or its parent bin.

    After the EOS has been sent to the element, the application should wait for
    an EOS message to be posted on the pipeline's bus. Once this EOS message is
    received, it may safely shut down the entire pipeline.
    """

    class Props(Gst.Element.Props):
        automatic_eos: bool  # [automatic-eos]: changed because contained invalid characters
        blocksize: int
        do_timestamp: bool  # [do-timestamp]: changed because contained invalid characters
        num_buffers: int  # [num-buffers]: changed because contained invalid characters
        typefind: bool

    # gi Fields
    @property
    def blocksize(self) -> int: ...
    @property
    def can_activate_push(self) -> bool: ...
    @property
    def element(self) -> Gst.Element | None: ...
    @property
    def live_cond(self) -> GLib.Cond | None: ...
    @property
    def live_lock(self) -> GLib.Mutex | None: ...
    @property
    def live_running(self) -> bool: ...
    @property
    def need_newsegment(self) -> bool: ...
    @property
    def num_buffers(self) -> int: ...
    @property
    def num_buffers_left(self) -> int: ...
    @property
    def pending_seek(self) -> Gst.Event | None: ...
    @property
    def random_access(self) -> bool: ...
    @property
    def running(self) -> bool: ...
    @property
    def segment(self) -> Gst.Segment | None: ...
    @property
    def srcpad(self) -> Gst.Pad | None: ...
    @property
    def typefind(self) -> bool: ...

    # gi Methods
    def __init__(
        self,
        automatic_eos: bool = ...,
        blocksize: int = ...,
        do_timestamp: bool = ...,
        num_buffers: int = ...,
        typefind: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_allocator(self) -> tuple[Gst.Allocator | None, Gst.AllocationParams | None]: ...
    @property
    def get_blocksize(self) -> int: ...
    def get_buffer_pool(self) -> Gst.BufferPool | None: ...
    @property
    def get_do_timestamp(self) -> bool: ...
    def is_async(self) -> bool: ...
    def is_live(self) -> bool: ...
    def negotiate(self) -> bool: ...
    @deprecated("deprecated")
    def new_seamless_segment(self, start: int, stop: int, time: int) -> bool: ...
    def new_segment(self, segment: Gst.Segment) -> bool: ...
    def push_segment(self, segment: Gst.Segment) -> bool: ...
    def query_latency(self) -> tuple[bool, bool | None, int | None, int | None]: ...
    def set_async(self, async_: bool) -> None: ...
    def set_automatic_eos(self, automatic_eos: bool) -> None: ...
    def set_blocksize(self, blocksize: int) -> None: ...
    def set_caps(self, caps: Gst.Caps) -> bool: ...
    def set_do_timestamp(self, timestamp: bool) -> None: ...
    def set_dynamic_size(self, dynamic: bool) -> None: ...
    def set_format(self, format: Gst.Format) -> None: ...
    def set_live(self, live: bool) -> None: ...
    def start_complete(self, ret: Gst.FlowReturn) -> None: ...
    def start_wait(self) -> Gst.FlowReturn: ...
    def submit_buffer_list(self, buffer_list: Gst.BufferList) -> None: ...
    def wait_playing(self) -> Gst.FlowReturn: ...

    # python methods (overrides?)
    def do_alloc(
        self,
        offset: int,
        size: int,
    ) -> tuple:
        """
        alloc(self, offset:int, size:int) -> Gst.FlowReturn, buf:Gst.Buffer
        """
    def do_create(
        self,
        offset: int,
        size: int,
        buf: Gst.Buffer | None = None,
    ) -> tuple:
        """
        create(self, offset:int, size:int, buf:Gst.Buffer=None) -> Gst.FlowReturn, buf:Gst.Buffer
        """
    def do_decide_allocation(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        decide_allocation(self, query:Gst.Query) -> bool
        """
    def do_do_seek(
        self,
        segment: Gst.Segment,
    ) -> bool:
        """
        do_seek(self, segment:Gst.Segment) -> bool
        """
    def do_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        event(self, event:Gst.Event) -> bool
        """
    def do_fill(
        self,
        offset: int,
        size: int,
        buf: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        fill(self, offset:int, size:int, buf:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_fixate(
        self,
        caps: Gst.Caps,
    ) -> Gst.Caps:
        """
        fixate(self, caps:Gst.Caps) -> Gst.Caps
        """
    def do_get_caps(
        self,
        filter: Gst.Caps | None = None,
    ) -> Gst.Caps:
        """
        get_caps(self, filter:Gst.Caps=None) -> Gst.Caps
        """
    def do_get_size(
        self,
    ) -> tuple:
        """
        get_size(self) -> bool, size:int
        """
    def do_get_times(
        self,
        buffer: Gst.Buffer,
    ) -> tuple:
        """
        get_times(self, buffer:Gst.Buffer) -> start:int, end:int
        """
    def do_is_seekable(
        self,
    ) -> bool:
        """
        is_seekable(self) -> bool
        """
    def do_negotiate(
        self,
    ) -> bool:
        """
        negotiate(self) -> bool
        """
    def do_prepare_seek_segment(
        self,
        seek: Gst.Event,
        segment: Gst.Segment,
    ) -> bool:
        """
        prepare_seek_segment(self, seek:Gst.Event, segment:Gst.Segment) -> bool
        """
    def do_query(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        query(self, query:Gst.Query) -> bool
        """
    def do_set_caps(
        self,
        caps: Gst.Caps,
    ) -> bool:
        """
        set_caps(self, caps:Gst.Caps) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """
    def do_unlock(
        self,
    ) -> bool:
        """
        unlock(self) -> bool
        """
    def do_unlock_stop(
        self,
    ) -> bool:
        """
        unlock_stop(self) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::automatic_eos"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::blocksize"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::do_timestamp"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::num_buffers"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::typefind"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class BaseSrcClass(GObject.GPointer):
    # gi Fields
    @property
    def alloc(self) -> allocBaseSrcClassCB: ...
    @property
    def create(self) -> createBaseSrcClassCB: ...
    @property
    def decide_allocation(self) -> decide_allocationBaseSrcClassCB: ...
    @property
    def do_seek(self) -> do_seekBaseSrcClassCB: ...
    @property
    def event(self) -> eventBaseSrcClassCB: ...
    @property
    def fill(self) -> fillBaseSrcClassCB: ...
    @property
    def fixate(self) -> fixateBaseSrcClassCB: ...
    @property
    def get_caps(self) -> get_capsBaseSrcClassCB: ...
    @property
    def get_size(self) -> get_sizeBaseSrcClassCB: ...
    @property
    def get_times(self) -> get_timesBaseSrcClassCB: ...
    @property
    def is_seekable(self) -> is_seekableBaseSrcClassCB: ...
    @property
    def negotiate(self) -> negotiateBaseSrcClassCB: ...
    @property
    def parent_class(self) -> Gst.ElementClass | None: ...
    @property
    def prepare_seek_segment(self) -> prepare_seek_segmentBaseSrcClassCB: ...
    @property
    def query(self) -> queryBaseSrcClassCB: ...
    @property
    def set_caps(self) -> set_capsBaseSrcClassCB: ...
    @property
    def start(self) -> startBaseSrcClassCB: ...
    @property
    def stop(self) -> stopBaseSrcClassCB: ...
    @property
    def unlock(self) -> unlockBaseSrcClassCB: ...
    @property
    def unlock_stop(self) -> unlock_stopBaseSrcClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BaseSrcPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BaseTransform(Gst.Element):
    """
    This base class is for filter elements that process data. Elements
    that are suitable for implementation using #GstBaseTransform are ones
    where the size and caps of the output is known entirely from the input
    caps and buffer sizes. These include elements that directly transform
    one buffer into another, modify the contents of a buffer in-place, as
    well as elements that collate multiple input buffers into one output buffer,
    or that expand one input buffer into multiple output buffers. See below
    for more concrete use cases.

    It provides for:

    * one sinkpad and one srcpad
    * Possible formats on sink and source pad implemented
      with custom transform_caps function. By default uses
      same format on sink and source.

    * Handles state changes
    * Does flushing
    * Push mode
    * Pull mode if the sub-class transform can operate on arbitrary data

    # Use Cases

    ## Passthrough mode

      * Element has no interest in modifying the buffer. It may want to inspect it,
        in which case the element should have a transform_ip function. If there
        is no transform_ip function in passthrough mode, the buffer is pushed
        intact.

      * The #GstBaseTransformClass.passthrough_on_same_caps variable
        will automatically set/unset passthrough based on whether the
        element negotiates the same caps on both pads.

      * #GstBaseTransformClass.passthrough_on_same_caps on an element that
        doesn't implement a transform_caps function is useful for elements that
        only inspect data (such as level)

      * Example elements

        * Level
        * Videoscale, audioconvert, videoconvert, audioresample in certain modes.

    ## Modifications in-place - input buffer and output buffer are the same thing.

    * The element must implement a transform_ip function.
    * Output buffer size must <= input buffer size
    * If the always_in_place flag is set, non-writable buffers will be copied
      and passed to the transform_ip function, otherwise a new buffer will be
      created and the transform function called.

    * Incoming writable buffers will be passed to the transform_ip function
      immediately.
    * only implementing transform_ip and not transform implies always_in_place = %TRUE

      * Example elements:
        * Volume
        * Audioconvert in certain modes (signed/unsigned conversion)
        * videoconvert in certain modes (endianness swapping)

    ## Modifications only to the caps/metadata of a buffer

    * The element does not require writable data, but non-writable buffers
      should be subbuffered so that the meta-information can be replaced.

    * Elements wishing to operate in this mode should replace the
      prepare_output_buffer method to create subbuffers of the input buffer
      and set always_in_place to %TRUE

    * Example elements
      * Capsfilter when setting caps on outgoing buffers that have
        none.
      * identity when it is going to re-timestamp buffers by
        datarate.

    ## Normal mode
      * always_in_place flag is not set, or there is no transform_ip function
      * Element will receive an input buffer and output buffer to operate on.
      * Output buffer is allocated by calling the prepare_output_buffer function.
      * Example elements:
        * Videoscale, videoconvert, audioconvert when doing
        scaling/conversions

    ## Special output buffer allocations
      * Elements which need to do special allocation of their output buffers
        beyond allocating output buffers via the negotiated allocator or
        buffer pool should implement the prepare_output_buffer method.

      * Example elements:
        * efence

    # Sub-class settable flags on GstBaseTransform

    * passthrough

      * Implies that in the current configuration, the sub-class is not interested in modifying the buffers.
      * Elements which are always in passthrough mode whenever the same caps has been negotiated on both pads can set the class variable passthrough_on_same_caps to have this behaviour automatically.

    * always_in_place
      * Determines whether a non-writable buffer will be copied before passing
        to the transform_ip function.

      * Implied %TRUE if no transform function is implemented.
      * Implied %FALSE if ONLY transform function is implemented.
    """

    class Props(Gst.Element.Props):
        qos: bool

    # gi Fields
    @property
    def element(self) -> Gst.Element | None: ...
    @property
    def have_segment(self) -> bool: ...
    @property
    def queued_buf(self) -> Gst.Buffer | None: ...
    @property
    def segment(self) -> Gst.Segment | None: ...
    @property
    def sinkpad(self) -> Gst.Pad | None: ...
    @property
    def srcpad(self) -> Gst.Pad | None: ...

    # gi Methods
    def __init__(self, qos: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_allocator(self) -> tuple[Gst.Allocator | None, Gst.AllocationParams | None]: ...
    def get_buffer_pool(self) -> Gst.BufferPool | None: ...
    def is_in_place(self) -> bool: ...
    def is_passthrough(self) -> bool: ...
    def is_qos_enabled(self) -> bool: ...
    def reconfigure(self) -> bool: ...
    def reconfigure_sink(self) -> None: ...
    def reconfigure_src(self) -> None: ...
    def set_gap_aware(self, gap_aware: bool) -> None: ...
    def set_in_place(self, in_place: bool) -> None: ...
    def set_passthrough(self, passthrough: bool) -> None: ...
    def set_prefer_passthrough(self, prefer_passthrough: bool) -> None: ...
    def set_qos_enabled(self, enabled: bool) -> None: ...
    def update_qos(self, proportion: float, diff: int, timestamp: int) -> None: ...
    def update_src_caps(self, updated_caps: Gst.Caps) -> bool: ...

    # python methods (overrides?)
    def do_accept_caps(
        self,
        direction: Gst.PadDirection,
        caps: Gst.Caps,
    ) -> bool:
        """
        accept_caps(self, direction:Gst.PadDirection, caps:Gst.Caps) -> bool
        """
    def do_before_transform(
        self,
        buffer: Gst.Buffer,
    ) -> None:
        """
        before_transform(self, buffer:Gst.Buffer)
        """
    def do_copy_metadata(
        self,
        input: Gst.Buffer,
        outbuf: Gst.Buffer,
    ) -> bool:
        """
        copy_metadata(self, input:Gst.Buffer, outbuf:Gst.Buffer) -> bool
        """
    def do_decide_allocation(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        decide_allocation(self, query:Gst.Query) -> bool
        """
    def do_filter_meta(
        self,
        query: Gst.Query,
        api: GObject.GType,
        params: Gst.Structure,
    ) -> bool:
        """
        filter_meta(self, query:Gst.Query, api:GType, params:Gst.Structure) -> bool
        """
    def do_fixate_caps(
        self,
        direction: Gst.PadDirection,
        caps: Gst.Caps,
        othercaps: Gst.Caps,
    ) -> Gst.Caps:
        """
        fixate_caps(self, direction:Gst.PadDirection, caps:Gst.Caps, othercaps:Gst.Caps) -> Gst.Caps
        """
    def do_generate_output(
        self,
    ) -> tuple:
        """
        generate_output(self) -> Gst.FlowReturn, outbuf:Gst.Buffer
        """
    def do_get_unit_size(
        self,
        caps: Gst.Caps,
    ) -> tuple:
        """
        get_unit_size(self, caps:Gst.Caps) -> bool, size:int
        """
    def do_prepare_output_buffer(
        self,
        input: Gst.Buffer,
    ) -> tuple:
        """
        prepare_output_buffer(self, input:Gst.Buffer) -> Gst.FlowReturn, outbuf:Gst.Buffer
        """
    def do_propose_allocation(
        self,
        decide_query: Gst.Query,
        query: Gst.Query,
    ) -> bool:
        """
        propose_allocation(self, decide_query:Gst.Query, query:Gst.Query) -> bool
        """
    def do_query(
        self,
        direction: Gst.PadDirection,
        query: Gst.Query,
    ) -> bool:
        """
        query(self, direction:Gst.PadDirection, query:Gst.Query) -> bool
        """
    def do_set_caps(
        self,
        incaps: Gst.Caps,
        outcaps: Gst.Caps,
    ) -> bool:
        """
        set_caps(self, incaps:Gst.Caps, outcaps:Gst.Caps) -> bool
        """
    def do_sink_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        sink_event(self, event:Gst.Event) -> bool
        """
    def do_src_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        src_event(self, event:Gst.Event) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """
    def do_submit_input_buffer(
        self,
        is_discont: bool,
        input: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        submit_input_buffer(self, is_discont:bool, input:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_transform(
        self,
        inbuf: Gst.Buffer,
        outbuf: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        transform(self, inbuf:Gst.Buffer, outbuf:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_transform_caps(
        self,
        direction: Gst.PadDirection,
        caps: Gst.Caps,
        filter: Gst.Caps,
    ) -> Gst.Caps:
        """
        transform_caps(self, direction:Gst.PadDirection, caps:Gst.Caps, filter:Gst.Caps) -> Gst.Caps
        """
    def do_transform_ip(
        self,
        buf: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        transform_ip(self, buf:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_transform_meta(
        self,
        outbuf: Gst.Buffer,
        meta: Gst.Meta,
        inbuf: Gst.Buffer,
    ) -> bool:
        """
        transform_meta(self, outbuf:Gst.Buffer, meta:Gst.Meta, inbuf:Gst.Buffer) -> bool
        """
    def do_transform_size(
        self,
        direction: Gst.PadDirection,
        caps: Gst.Caps,
        size: int,
        othercaps: Gst.Caps,
    ) -> tuple:
        """
        transform_size(self, direction:Gst.PadDirection, caps:Gst.Caps, size:int, othercaps:Gst.Caps) -> bool, othersize:int
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::qos"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class BaseTransformClass(GObject.GPointer):
    # gi Fields
    @property
    def accept_caps(self) -> accept_capsBaseTransformClassCB: ...
    @property
    def before_transform(self) -> before_transformBaseTransformClassCB: ...
    @property
    def copy_metadata(self) -> copy_metadataBaseTransformClassCB: ...
    @property
    def decide_allocation(self) -> decide_allocationBaseTransformClassCB: ...
    @property
    def filter_meta(self) -> filter_metaBaseTransformClassCB: ...
    @property
    def fixate_caps(self) -> fixate_capsBaseTransformClassCB: ...
    @property
    def generate_output(self) -> generate_outputBaseTransformClassCB: ...
    @property
    def get_unit_size(self) -> get_unit_sizeBaseTransformClassCB: ...
    @property
    def parent_class(self) -> Gst.ElementClass | None: ...
    @property
    def passthrough_on_same_caps(self) -> bool: ...
    @property
    def prepare_output_buffer(self) -> prepare_output_bufferBaseTransformClassCB: ...
    @property
    def propose_allocation(self) -> propose_allocationBaseTransformClassCB: ...
    @property
    def query(self) -> queryBaseTransformClassCB: ...
    @property
    def set_caps(self) -> set_capsBaseTransformClassCB: ...
    @property
    def sink_event(self) -> sink_eventBaseTransformClassCB: ...
    @property
    def src_event(self) -> src_eventBaseTransformClassCB: ...
    @property
    def start(self) -> startBaseTransformClassCB: ...
    @property
    def stop(self) -> stopBaseTransformClassCB: ...
    @property
    def submit_input_buffer(self) -> submit_input_bufferBaseTransformClassCB: ...
    @property
    def transform(self) -> transformBaseTransformClassCB: ...
    @property
    def transform_caps(self) -> transform_capsBaseTransformClassCB: ...
    @property
    def transform_ip(self) -> transform_ipBaseTransformClassCB: ...
    @property
    def transform_ip_on_passthrough(self) -> bool: ...
    @property
    def transform_meta(self) -> transform_metaBaseTransformClassCB: ...
    @property
    def transform_size(self) -> transform_sizeBaseTransformClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BaseTransformPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BitReader(GObject.GPointer):
    # gi Fields
    bit: int = ...
    byte: int = ...
    data: list | None = ...
    size: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def free(self) -> None: ...
    def get_bits_uint16(self, nbits: int) -> tuple[bool, int]: ...
    def get_bits_uint32(self, nbits: int) -> tuple[bool, int]: ...
    def get_bits_uint64(self, nbits: int) -> tuple[bool, int]: ...
    def get_bits_uint8(self, nbits: int) -> tuple[bool, int]: ...
    def get_pos(self) -> int: ...
    def get_remaining(self) -> int: ...
    def get_size(self) -> int: ...
    def init(self, data: list, size: int) -> None: ...
    def peek_bits_uint16(self, nbits: int) -> tuple[bool, int]: ...
    def peek_bits_uint32(self, nbits: int) -> tuple[bool, int]: ...
    def peek_bits_uint64(self, nbits: int) -> tuple[bool, int]: ...
    def peek_bits_uint8(self, nbits: int) -> tuple[bool, int]: ...
    def set_pos(self, pos: int) -> bool: ...
    def skip(self, nbits: int) -> bool: ...
    def skip_to_byte(self) -> bool: ...

    ...

class BitWriter(GObject.GPointer):
    # gi Fields
    @property
    def auto_grow(self) -> bool: ...
    @property
    def bit_capacity(self) -> int: ...
    bit_size: int = ...
    data: int = ...
    @property
    def owned(self) -> bool: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def align_bytes(self, trailing_bit: int) -> bool: ...
    def free(self) -> None: ...
    def free_and_get_buffer(self) -> Gst.Buffer: ...
    def free_and_get_data(self) -> list: ...
    def get_data(self) -> list: ...
    def get_remaining(self) -> int: ...
    def get_size(self) -> int: ...
    def put_bits_uint16(self, value: int, nbits: int) -> bool: ...
    def put_bits_uint32(self, value: int, nbits: int) -> bool: ...
    def put_bits_uint64(self, value: int, nbits: int) -> bool: ...
    def put_bits_uint8(self, value: int, nbits: int) -> bool: ...
    def put_bytes(self, data: list, nbytes: int) -> bool: ...
    def reset(self) -> None: ...
    def reset_and_get_buffer(self) -> Gst.Buffer: ...
    def reset_and_get_data(self) -> list: ...
    def set_pos(self, pos: int) -> bool: ...

    ...

class ByteReader(GObject.GPointer):
    # gi Fields
    byte: int = ...
    data: list | None = ...
    size: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def dup_data(self) -> tuple[bool, int, list]: ...
    def dup_string_utf16(self) -> tuple[bool, list]: ...
    def dup_string_utf32(self) -> tuple[bool, list]: ...
    def dup_string_utf8(self) -> tuple[bool, list]: ...
    def free(self) -> None: ...
    def get_data(self) -> tuple[bool, int, list]: ...
    def get_float32_be(self) -> tuple[bool, float]: ...
    def get_float32_le(self) -> tuple[bool, float]: ...
    def get_float64_be(self) -> tuple[bool, float]: ...
    def get_float64_le(self) -> tuple[bool, float]: ...
    def get_int16_be(self) -> tuple[bool, int]: ...
    def get_int16_le(self) -> tuple[bool, int]: ...
    def get_int24_be(self) -> tuple[bool, int]: ...
    def get_int24_le(self) -> tuple[bool, int]: ...
    def get_int32_be(self) -> tuple[bool, int]: ...
    def get_int32_le(self) -> tuple[bool, int]: ...
    def get_int64_be(self) -> tuple[bool, int]: ...
    def get_int64_le(self) -> tuple[bool, int]: ...
    def get_int8(self) -> tuple[bool, int]: ...
    def get_pos(self) -> int: ...
    def get_remaining(self) -> int: ...
    def get_size(self) -> int: ...
    def get_string_utf8(self) -> tuple[bool, list]: ...
    def get_uint16_be(self) -> tuple[bool, int]: ...
    def get_uint16_le(self) -> tuple[bool, int]: ...
    def get_uint24_be(self) -> tuple[bool, int]: ...
    def get_uint24_le(self) -> tuple[bool, int]: ...
    def get_uint32_be(self) -> tuple[bool, int]: ...
    def get_uint32_le(self) -> tuple[bool, int]: ...
    def get_uint64_be(self) -> tuple[bool, int]: ...
    def get_uint64_le(self) -> tuple[bool, int]: ...
    def get_uint8(self) -> tuple[bool, int]: ...
    def init(self, data: list, size: int) -> None: ...
    def masked_scan_uint32(self, mask: int, pattern: int, offset: int, size: int) -> int: ...
    def masked_scan_uint32_peek(self, mask: int, pattern: int, offset: int, size: int) -> tuple[int, int]: ...
    def peek_data(self) -> tuple[bool, int, list]: ...
    def peek_float32_be(self) -> tuple[bool, float]: ...
    def peek_float32_le(self) -> tuple[bool, float]: ...
    def peek_float64_be(self) -> tuple[bool, float]: ...
    def peek_float64_le(self) -> tuple[bool, float]: ...
    def peek_int16_be(self) -> tuple[bool, int]: ...
    def peek_int16_le(self) -> tuple[bool, int]: ...
    def peek_int24_be(self) -> tuple[bool, int]: ...
    def peek_int24_le(self) -> tuple[bool, int]: ...
    def peek_int32_be(self) -> tuple[bool, int]: ...
    def peek_int32_le(self) -> tuple[bool, int]: ...
    def peek_int64_be(self) -> tuple[bool, int]: ...
    def peek_int64_le(self) -> tuple[bool, int]: ...
    def peek_int8(self) -> tuple[bool, int]: ...
    def peek_string_utf8(self) -> tuple[bool, list]: ...
    def peek_uint16_be(self) -> tuple[bool, int]: ...
    def peek_uint16_le(self) -> tuple[bool, int]: ...
    def peek_uint24_be(self) -> tuple[bool, int]: ...
    def peek_uint24_le(self) -> tuple[bool, int]: ...
    def peek_uint32_be(self) -> tuple[bool, int]: ...
    def peek_uint32_le(self) -> tuple[bool, int]: ...
    def peek_uint64_be(self) -> tuple[bool, int]: ...
    def peek_uint64_le(self) -> tuple[bool, int]: ...
    def peek_uint8(self) -> tuple[bool, int]: ...
    def set_pos(self, pos: int) -> bool: ...
    def skip(self, nbytes: int) -> bool: ...
    def skip_string_utf16(self) -> bool: ...
    def skip_string_utf32(self) -> bool: ...
    def skip_string_utf8(self) -> bool: ...

    ...

class ByteWriter(GObject.GPointer):
    # gi Fields
    alloc_size: int = ...
    fixed: bool = ...
    owned: bool = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def ensure_free_space(self, size: int) -> bool: ...
    def fill(self, value: int, size: int) -> bool: ...
    def free(self) -> None: ...
    def free_and_get_buffer(self) -> Gst.Buffer: ...
    def free_and_get_data(self) -> int: ...
    def get_remaining(self) -> int: ...
    def init(self) -> None: ...
    def init_with_data(self, data: list, size: int, initialized: bool) -> None: ...
    def init_with_size(self, size: int, fixed: bool) -> None: ...
    def put_buffer(self, buffer: Gst.Buffer, offset: int, size: int) -> bool: ...
    def put_data(self, data: list, size: int) -> bool: ...
    def put_float32_be(self, val: float) -> bool: ...
    def put_float32_le(self, val: float) -> bool: ...
    def put_float64_be(self, val: float) -> bool: ...
    def put_float64_le(self, val: float) -> bool: ...
    def put_int16_be(self, val: int) -> bool: ...
    def put_int16_le(self, val: int) -> bool: ...
    def put_int24_be(self, val: int) -> bool: ...
    def put_int24_le(self, val: int) -> bool: ...
    def put_int32_be(self, val: int) -> bool: ...
    def put_int32_le(self, val: int) -> bool: ...
    def put_int64_be(self, val: int) -> bool: ...
    def put_int64_le(self, val: int) -> bool: ...
    def put_int8(self, val: int) -> bool: ...
    def put_string_utf16(self, data: list) -> bool: ...
    def put_string_utf32(self, data: list) -> bool: ...
    def put_string_utf8(self, data: str) -> bool: ...
    def put_uint16_be(self, val: int) -> bool: ...
    def put_uint16_le(self, val: int) -> bool: ...
    def put_uint24_be(self, val: int) -> bool: ...
    def put_uint24_le(self, val: int) -> bool: ...
    def put_uint32_be(self, val: int) -> bool: ...
    def put_uint32_le(self, val: int) -> bool: ...
    def put_uint64_be(self, val: int) -> bool: ...
    def put_uint64_le(self, val: int) -> bool: ...
    def put_uint8(self, val: int) -> bool: ...
    def reset(self) -> None: ...
    def reset_and_get_buffer(self) -> Gst.Buffer: ...
    def reset_and_get_data(self) -> list: ...

    ...

class CollectData(GObject.GPointer):
    # gi Fields
    buffer: Gst.Buffer | None = ...  # type: ignore
    collect: CollectPads | None = ...
    pad: Gst.Pad | None = ...  # type: ignore
    pos: int = ...
    segment: Gst.Segment | None = ...  # type: ignore
    @property
    def state(self) -> CollectPadsStateFlags: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class CollectDataPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class CollectPads(Gst.Object):
    """
    Manages a set of pads that operate in collect mode. This means that control
    is given to the manager of this object when all pads have data.

      * Collectpads are created with gst_collect_pads_new(). A callback should then
        be installed with gst_collect_pads_set_function ().

      * Pads are added to the collection with gst_collect_pads_add_pad()/
        gst_collect_pads_remove_pad(). The pad has to be a sinkpad. When added,
        the chain, event and query functions of the pad are overridden. The
        element_private of the pad is used to store private information for the
        collectpads.

      * For each pad, data is queued in the _chain function or by
        performing a pull_range.

      * When data is queued on all pads in waiting mode, the callback function is called.

      * Data can be dequeued from the pad with the gst_collect_pads_pop() method.
        One can peek at the data with the gst_collect_pads_peek() function.
        These functions will return %NULL if the pad received an EOS event. When all
        pads return %NULL from a gst_collect_pads_peek(), the element can emit an EOS
        event itself.

      * Data can also be dequeued in byte units using the gst_collect_pads_available(),
        gst_collect_pads_read_buffer() and gst_collect_pads_flush() calls.

      * Elements should call gst_collect_pads_start() and gst_collect_pads_stop() in
        their state change functions to start and stop the processing of the collectpads.
        The gst_collect_pads_stop() call should be called before calling the parent
        element state change function in the PAUSED_TO_READY state change to ensure
        no pad is blocked and the element can finish streaming.

      * gst_collect_pads_set_waiting() sets a pad to waiting or non-waiting mode.
        CollectPads element is not waiting for data to be collected on non-waiting pads.
        Thus these pads may but need not have data when the callback is called.
        All pads are in waiting mode by default.
    """

    # gi Fields
    @property
    def data(self) -> list | None: ...
    @property
    def object(self) -> Gst.Object | None: ...
    @property
    def stream_lock(self) -> GLib.RecMutex | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_pad(
        self, pad: Gst.Pad, size: int, destroy_notify: CollectDataDestroyNotify, lock: bool
    ) -> CollectData | None: ...
    def available(self) -> int: ...
    def clip_running_time(
        self, cdata: CollectData, buf: Gst.Buffer, user_data: object | None = None
    ) -> tuple[Gst.FlowReturn, Gst.Buffer | None]: ...
    def event_default(self, data: CollectData, event: Gst.Event, discard: bool) -> bool: ...
    def flush(self, data: CollectData, size: int) -> int: ...
    @classmethod
    def new(cls) -> CollectPads: ...
    def peek(self, data: CollectData) -> Gst.Buffer | None: ...
    def pop(self, data: CollectData) -> Gst.Buffer | None: ...
    def query_default(self, data: CollectData, query: Gst.Query, discard: bool) -> bool: ...
    def read_buffer(self, data: CollectData, size: int) -> Gst.Buffer | None: ...
    def remove_pad(self, pad: Gst.Pad) -> bool: ...
    def set_buffer_function(self, func: CollectPadsBufferFunction, user_data: object | None = None) -> None: ...
    def set_clip_function(self, clipfunc: CollectPadsClipFunction, user_data: object | None = None) -> None: ...
    def set_compare_function(self, func: CollectPadsCompareFunction, user_data: object | None = None) -> None: ...
    def set_event_function(self, func: CollectPadsEventFunction, user_data: object | None = None) -> None: ...
    def set_flush_function(self, func: CollectPadsFlushFunction, user_data: object | None = None) -> None: ...
    def set_flushing(self, flushing: bool) -> None: ...
    def set_function(self, func: CollectPadsFunction, user_data: object | None = None) -> None: ...
    def set_query_function(self, func: CollectPadsQueryFunction, user_data: object | None = None) -> None: ...
    def set_waiting(self, data: CollectData, waiting: bool) -> None: ...
    def src_event_default(self, pad: Gst.Pad, event: Gst.Event) -> bool: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def take_buffer(self, data: CollectData, size: int) -> Gst.Buffer | None: ...

    ...

class CollectPadsClass(GObject.GPointer):
    # gi Fields
    @property
    def parent_class(self) -> Gst.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class CollectPadsPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DataQueue(GObject.Object):
    """
    #GstDataQueue is an object that handles threadsafe queueing of objects. It
    also provides size-related functionality. This object should be used for
    any #GstElement that wishes to provide some sort of queueing functionality.
    """

    class Props(GObject.Object.Props):
        current_level_bytes: int  # [current-level-bytes]: changed because contained invalid characters
        current_level_time: int  # [current-level-time]: changed because contained invalid characters
        current_level_visible: int  # [current-level-visible]: changed because contained invalid characters

    # gi Fields
    @property
    def object(self) -> GObject.Object | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    # python methods (overrides?)
    def do_empty(
        self,
    ) -> None:
        """
        empty(self)
        """
    def do_full(
        self,
    ) -> None:
        """
        full(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_level_bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_level_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_level_visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class DataQueueClass(GObject.GPointer):
    # gi Fields
    @property
    def empty(self) -> emptyDataQueueClassCB: ...
    @property
    def full(self) -> fullDataQueueClassCB: ...
    @property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DataQueuePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FlowCombiner(GObject.GBoxed):
    # gi Methods
    def add_pad(self, pad: Gst.Pad) -> None: ...
    def clear(self) -> None: ...
    def free(self) -> None: ...
    @classmethod
    def new(cls) -> FlowCombiner: ...
    def ref(self) -> FlowCombiner: ...
    def remove_pad(self, pad: Gst.Pad) -> None: ...
    def reset(self) -> None: ...
    def unref(self) -> None: ...
    def update_flow(self, fret: Gst.FlowReturn) -> Gst.FlowReturn: ...
    def update_pad_flow(self, pad: Gst.Pad, fret: Gst.FlowReturn) -> Gst.FlowReturn: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class PushSrc(BaseSrc):
    """
    This class is mostly useful for elements that cannot do
    random access, or at least very slowly. The source usually
    prefers to push out a fixed size buffer.

    Subclasses usually operate in a format that is different from the
    default GST_FORMAT_BYTES format of #GstBaseSrc.

    Classes extending this base class will usually be scheduled
    in a push based mode. If the peer accepts to operate without
    offsets and within the limits of the allowed block size, this
    class can operate in getrange based mode automatically. To make
    this possible, the subclass should implement and override the
    SCHEDULING query.

    The subclass should extend the methods from the baseclass in
    addition to the ::create method.

    Seeking, flushing, scheduling and sync is all handled by this
    base class.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    # python methods (overrides?)
    def do_alloc(
        self,
    ) -> tuple:
        """
        alloc(self) -> Gst.FlowReturn, buf:Gst.Buffer
        """
    def do_create(
        self,
        buf: Gst.Buffer | None = None,
    ) -> tuple:
        """
        create(self, buf:Gst.Buffer=None) -> Gst.FlowReturn, buf:Gst.Buffer
        """
    def do_fill(
        self,
        buf: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        fill(self, buf:Gst.Buffer) -> Gst.FlowReturn
        """

    ...

class PushSrcClass(GObject.GPointer):
    # gi Fields
    @property
    def alloc(self) -> allocPushSrcClassCB: ...
    @property
    def create(self) -> createPushSrcClassCB: ...
    @property
    def fill(self) -> fillPushSrcClassCB: ...
    @property
    def parent_class(self) -> BaseSrcClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TypeFindData(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

###############################################################
# Callbacks
###############################################################

class flushAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.flush
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
    ) -> Gst.FlowReturn: ...

class clipAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.clip
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        aggregator_pad: AggregatorPad,
        buf: Gst.Buffer,
    ) -> Gst.Buffer: ...

class finish_bufferAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.finish_buffer
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class sink_eventAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.sink_event
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        aggregator_pad: AggregatorPad,
        event: Gst.Event,
    ) -> bool: ...

class sink_queryAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.sink_query
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        aggregator_pad: AggregatorPad,
        query: Gst.Query,
    ) -> bool: ...

class src_eventAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.src_event
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        event: Gst.Event,
    ) -> bool: ...

class src_queryAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.src_query
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        query: Gst.Query,
    ) -> bool: ...

class src_activateAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.src_activate
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        mode: Gst.PadMode,
        active: bool,
    ) -> bool: ...

class aggregateAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.aggregate
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        timeout: bool,
    ) -> Gst.FlowReturn: ...

class stopAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.stop
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
    ) -> bool: ...

class startAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.start
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
    ) -> bool: ...

class get_next_timeAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.get_next_time
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
    ) -> int: ...

class update_src_capsAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.update_src_caps
    """
    #  self
    def __call__(
        self: Aggregator,
        caps: Gst.Caps,
    ) -> tuple[Gst.FlowReturn, Gst.Caps | None]: ...

class fixate_src_capsAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.fixate_src_caps
    """
    #  self
    def __call__(
        self: Aggregator,
        caps: Gst.Caps,
    ) -> Gst.Caps: ...

class negotiated_src_capsAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.negotiated_src_caps
    """
    #  self
    def __call__(
        self: Aggregator,
        caps: Gst.Caps,
    ) -> bool: ...

class decide_allocationAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.decide_allocation
    """
    #  self
    def __call__(
        self: Aggregator,
        query: Gst.Query,
    ) -> bool: ...

class propose_allocationAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.propose_allocation
    """
    #  self
    def __call__(
        self: Aggregator,
        pad: AggregatorPad,
        decide_query: Gst.Query,
        query: Gst.Query,
    ) -> bool: ...

class negotiateAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.negotiate
    """
    #  self
    def __call__(
        self: Aggregator,
    ) -> bool: ...

class sink_event_pre_queueAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.sink_event_pre_queue
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        aggregator_pad: AggregatorPad,
        event: Gst.Event,
    ) -> Gst.FlowReturn: ...

class sink_query_pre_queueAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.sink_query_pre_queue
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        aggregator_pad: AggregatorPad,
        query: Gst.Query,
    ) -> bool: ...

class finish_buffer_listAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.finish_buffer_list
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        bufferlist: Gst.BufferList,
    ) -> Gst.FlowReturn: ...

class peek_next_sampleAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorClass.peek_next_sample
    """
    #  aggregator
    def __call__(
        self,
        aggregator: Aggregator,
        aggregator_pad: AggregatorPad,
    ) -> Gst.Sample | None: ...

class flushAggregatorPadClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorPadClass.flush
    """
    #  aggpad
    def __call__(
        self,
        aggpad: AggregatorPad,
        aggregator: Aggregator,
    ) -> Gst.FlowReturn: ...

class skip_bufferAggregatorPadClassCB(typing.Protocol):
    """
    This callback was used in:
        AggregatorPadClass.skip_buffer
    """
    #  aggpad
    def __call__(
        self,
        aggpad: AggregatorPad,
        aggregator: Aggregator,
        buffer: Gst.Buffer,
    ) -> bool: ...

class startBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.start
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
    ) -> bool: ...

class stopBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.stop
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
    ) -> bool: ...

class set_sink_capsBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.set_sink_caps
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        caps: Gst.Caps,
    ) -> bool: ...

class handle_frameBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.handle_frame
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        frame: BaseParseFrame,
    ) -> tuple[Gst.FlowReturn, int]: ...

class pre_push_frameBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.pre_push_frame
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        frame: BaseParseFrame,
    ) -> Gst.FlowReturn: ...

class convertBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.convert
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        src_format: Gst.Format,
        src_value: int,
        dest_format: Gst.Format,
        dest_value: int,
    ) -> bool: ...

class sink_eventBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.sink_event
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        event: Gst.Event,
    ) -> bool: ...

class src_eventBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.src_event
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        event: Gst.Event,
    ) -> bool: ...

class get_sink_capsBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.get_sink_caps
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        filter: Gst.Caps,
    ) -> Gst.Caps: ...

class detectBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.detect
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class sink_queryBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.sink_query
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        query: Gst.Query,
    ) -> bool: ...

class src_queryBaseParseClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseParseClass.src_query
    """
    #  parse
    def __call__(
        self,
        parse: BaseParse,
        query: Gst.Query,
    ) -> bool: ...

class get_capsBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.get_caps
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        filter: Gst.Caps | None = None,
    ) -> Gst.Caps: ...

class set_capsBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.set_caps
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        caps: Gst.Caps,
    ) -> bool: ...

class fixateBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.fixate
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        caps: Gst.Caps,
    ) -> Gst.Caps: ...

class activate_pullBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.activate_pull
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        active: bool,
    ) -> bool: ...

class get_timesBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.get_times
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        buffer: Gst.Buffer,
    ) -> tuple[int, int]: ...

class propose_allocationBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.propose_allocation
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        query: Gst.Query,
    ) -> bool: ...

class startBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.start
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
    ) -> bool: ...

class stopBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.stop
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
    ) -> bool: ...

class unlockBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.unlock
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
    ) -> bool: ...

class unlock_stopBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.unlock_stop
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
    ) -> bool: ...

class queryBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.query
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        query: Gst.Query,
    ) -> bool: ...

class eventBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.event
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        event: Gst.Event,
    ) -> bool: ...

class wait_eventBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.wait_event
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        event: Gst.Event,
    ) -> Gst.FlowReturn: ...

class prepareBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.prepare
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class prepare_listBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.prepare_list
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        buffer_list: Gst.BufferList,
    ) -> Gst.FlowReturn: ...

class prerollBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.preroll
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class renderBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.render
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class render_listBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSinkClass.render_list
    """
    #  sink
    def __call__(
        self,
        sink: BaseSink,
        buffer_list: Gst.BufferList,
    ) -> Gst.FlowReturn: ...

class get_capsBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.get_caps
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        filter: Gst.Caps | None = None,
    ) -> Gst.Caps: ...

class negotiateBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.negotiate
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
    ) -> bool: ...

class fixateBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.fixate
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        caps: Gst.Caps,
    ) -> Gst.Caps: ...

class set_capsBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.set_caps
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        caps: Gst.Caps,
    ) -> bool: ...

class decide_allocationBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.decide_allocation
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        query: Gst.Query,
    ) -> bool: ...

class startBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.start
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
    ) -> bool: ...

class stopBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.stop
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
    ) -> bool: ...

class get_timesBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.get_times
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        buffer: Gst.Buffer,
    ) -> tuple[int, int]: ...

class get_sizeBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.get_size
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
    ) -> tuple[bool, int]: ...

class is_seekableBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.is_seekable
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
    ) -> bool: ...

class prepare_seek_segmentBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.prepare_seek_segment
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        seek: Gst.Event,
        segment: Gst.Segment,
    ) -> bool: ...

class do_seekBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.do_seek
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        segment: Gst.Segment,
    ) -> bool: ...

class unlockBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.unlock
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
    ) -> bool: ...

class unlock_stopBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.unlock_stop
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
    ) -> bool: ...

class queryBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.query
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        query: Gst.Query,
    ) -> bool: ...

class eventBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.event
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        event: Gst.Event,
    ) -> bool: ...

class createBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.create
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        offset: int,
        size: int,
        buf: Gst.Buffer | None = None,
    ) -> tuple[Gst.FlowReturn, Gst.Buffer | None]: ...

class allocBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.alloc
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        offset: int,
        size: int,
    ) -> tuple[Gst.FlowReturn, Gst.Buffer | None]: ...

class fillBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseSrcClass.fill
    """
    #  src
    def __call__(
        self,
        src: BaseSrc,
        offset: int,
        size: int,
        buf: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class transform_capsBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.transform_caps
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        direction: Gst.PadDirection,
        caps: Gst.Caps,
        filter: Gst.Caps,
    ) -> Gst.Caps: ...

class fixate_capsBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.fixate_caps
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        direction: Gst.PadDirection,
        caps: Gst.Caps,
        othercaps: Gst.Caps,
    ) -> Gst.Caps: ...

class accept_capsBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.accept_caps
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        direction: Gst.PadDirection,
        caps: Gst.Caps,
    ) -> bool: ...

class set_capsBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.set_caps
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        incaps: Gst.Caps,
        outcaps: Gst.Caps,
    ) -> bool: ...

class queryBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.query
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        direction: Gst.PadDirection,
        query: Gst.Query,
    ) -> bool: ...

class decide_allocationBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.decide_allocation
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        query: Gst.Query,
    ) -> bool: ...

class filter_metaBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.filter_meta
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        query: Gst.Query,
        api: GObject.GType,
        params: Gst.Structure,
    ) -> bool: ...

class propose_allocationBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.propose_allocation
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        decide_query: Gst.Query,
        query: Gst.Query,
    ) -> bool: ...

class transform_sizeBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.transform_size
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        direction: Gst.PadDirection,
        caps: Gst.Caps,
        size: int,
        othercaps: Gst.Caps,
    ) -> tuple[bool, int]: ...

class get_unit_sizeBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.get_unit_size
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        caps: Gst.Caps,
    ) -> tuple[bool, int]: ...

class startBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.start
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
    ) -> bool: ...

class stopBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.stop
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
    ) -> bool: ...

class sink_eventBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.sink_event
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        event: Gst.Event,
    ) -> bool: ...

class src_eventBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.src_event
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        event: Gst.Event,
    ) -> bool: ...

class prepare_output_bufferBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.prepare_output_buffer
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        input: Gst.Buffer,
    ) -> tuple[Gst.FlowReturn, Gst.Buffer]: ...

class copy_metadataBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.copy_metadata
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        input: Gst.Buffer,
        outbuf: Gst.Buffer,
    ) -> bool: ...

class transform_metaBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.transform_meta
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        outbuf: Gst.Buffer,
        meta: Gst.Meta,
        inbuf: Gst.Buffer,
    ) -> bool: ...

class before_transformBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.before_transform
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        buffer: Gst.Buffer,
    ) -> None: ...

class transformBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.transform
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        inbuf: Gst.Buffer,
        outbuf: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class transform_ipBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.transform_ip
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        buf: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class submit_input_bufferBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.submit_input_buffer
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
        is_discont: bool,
        input: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class generate_outputBaseTransformClassCB(typing.Protocol):
    """
    This callback was used in:
        BaseTransformClass.generate_output
    """
    #  trans
    def __call__(
        self,
        trans: BaseTransform,
    ) -> tuple[Gst.FlowReturn, Gst.Buffer]: ...

class CollectDataDestroyNotify(typing.Protocol):
    """
    This callback was used in:
        GstBase.add_pad
    """
    #  data
    def __call__(
        self,
        data: CollectData,
    ) -> None: ...

class CollectPadsBufferFunction(typing.Protocol):
    """
    This callback was used in:
        GstBase.set_buffer_function
    """
    #  pads
    def __call__(
        self,
        pads: CollectPads,
        data: CollectData,
        buffer: Gst.Buffer,
        user_data: object | None = None,
    ) -> Gst.FlowReturn: ...

class CollectPadsClipFunction(typing.Protocol):
    """
    This callback was used in:
        GstBase.set_clip_function
    """
    #  pads
    def __call__(
        self,
        pads: CollectPads,
        data: CollectData,
        inbuffer: Gst.Buffer,
        user_data: object | None = None,
    ) -> tuple[Gst.FlowReturn, Gst.Buffer]: ...

class CollectPadsCompareFunction(typing.Protocol):
    """
    This callback was used in:
        GstBase.set_compare_function
    """
    #  pads
    def __call__(
        self,
        pads: CollectPads,
        data1: CollectData,
        timestamp1: int,
        data2: CollectData,
        timestamp2: int,
        user_data: object | None = None,
    ) -> int: ...

class CollectPadsEventFunction(typing.Protocol):
    """
    This callback was used in:
        GstBase.set_event_function
    """
    #  pads
    def __call__(
        self,
        pads: CollectPads,
        pad: CollectData,
        event: Gst.Event,
        user_data: object | None = None,
    ) -> bool: ...

class CollectPadsFlushFunction(typing.Protocol):
    """
    This callback was used in:
        GstBase.set_flush_function
    """
    #  pads
    def __call__(
        self,
        pads: CollectPads,
        user_data: object | None = None,
    ) -> None: ...

class CollectPadsFunction(typing.Protocol):
    """
    This callback was used in:
        GstBase.set_function
    """
    #  pads
    def __call__(
        self,
        pads: CollectPads,
        user_data: object | None = None,
    ) -> Gst.FlowReturn: ...

class CollectPadsQueryFunction(typing.Protocol):
    """
    This callback was used in:
        GstBase.set_query_function
    """
    #  pads
    def __call__(
        self,
        pads: CollectPads,
        pad: CollectData,
        query: Gst.Query,
        user_data: object | None = None,
    ) -> bool: ...

class emptyDataQueueClassCB(typing.Protocol):
    """
    This callback was used in:
        DataQueueClass.empty
    """
    #  queue
    def __call__(
        self,
        queue: DataQueue,
    ) -> None: ...

class fullDataQueueClassCB(typing.Protocol):
    """
    This callback was used in:
        DataQueueClass.full
    """
    #  queue
    def __call__(
        self,
        queue: DataQueue,
    ) -> None: ...

class createPushSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        PushSrcClass.create
    """
    #  src
    def __call__(
        self,
        src: PushSrc,
        buf: Gst.Buffer | None = None,
    ) -> tuple[Gst.FlowReturn, Gst.Buffer | None]: ...

class allocPushSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        PushSrcClass.alloc
    """
    #  src
    def __call__(
        self,
        src: PushSrc,
    ) -> tuple[Gst.FlowReturn, Gst.Buffer | None]: ...

class fillPushSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        PushSrcClass.fill
    """
    #  src
    def __call__(
        self,
        src: PushSrc,
        buf: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class TypeFindHelperGetRangeFunction(typing.Protocol):
    """
    This callback was used in:
        GstBase.type_find_helper_get_range, GstBase.type_find_helper_get_range_full
    """
    #  obj
    def __call__(
        self,
        obj: Gst.Object,
        parent: Gst.Object | None,
        offset: int,
        length: int,
    ) -> tuple[Gst.FlowReturn, Gst.Buffer]: ...

###############################################################
# Aliases
###############################################################

_lock = _thread._lock  # type: ignore
###############################################################
# Constants
###############################################################

BASE_PARSE_FLAG_DRAINING: int = ...
BASE_PARSE_FLAG_LOST_SYNC: int = ...
BASE_TRANSFORM_SINK_NAME: str = ...
BASE_TRANSFORM_SRC_NAME: str = ...
_namespace: str = ...
_version: str = ...
###############################################################
# Unknowns/Not Parsed
###############################################################
