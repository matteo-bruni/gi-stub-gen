# pyright: reportIncompatibleMethodOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: GstAudio
Date: 2025-12-27
"""
# we disable method override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401

import _thread
import builtins
import enum
import typing

# gi.repository imports needed by this Stub
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gst
from gi.repository import GstBase
###############################################################
# Functions
###############################################################

@staticmethod
def audio_buffer_clip(
    buffer: Gst.Buffer,
    segment: Gst.Segment,
    rate: int,
    bpf: int,
) -> Gst.Buffer | None: ...
@staticmethod
def audio_buffer_map(
    info: AudioInfo,
    gstbuffer: Gst.Buffer,
    flags: Gst.MapFlags,
) -> tuple[bool, AudioBuffer]: ...
@staticmethod
def audio_buffer_reorder_channels(
    buffer: Gst.Buffer,
    format: AudioFormat,
    channels: int,
    from_: list,
    to: list,
) -> bool: ...
@staticmethod
def audio_buffer_truncate(
    buffer: Gst.Buffer,
    bpf: int,
    trim: int,
    samples: int,
) -> Gst.Buffer: ...
@staticmethod
def audio_channel_get_fallback_mask(
    channels: int,
) -> int: ...
@staticmethod
def audio_channel_positions_from_mask(
    channels: int,
    channel_mask: int,
    position: list,
) -> bool: ...
@staticmethod
def audio_channel_positions_to_mask(
    position: list,
    channels: int,
    force_order: bool,
) -> tuple[bool, int]: ...
@staticmethod
def audio_channel_positions_to_string(
    position: list,
    channels: int,
) -> str: ...
@staticmethod
def audio_channel_positions_to_valid_order(
    position: list,
    channels: int,
) -> bool: ...
@staticmethod
def audio_check_valid_channel_positions(
    position: list,
    channels: int,
    force_order: bool,
) -> bool: ...
@staticmethod
def audio_clipping_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def audio_clipping_meta_get_info() -> Gst.MetaInfo: ...
@staticmethod
def audio_downmix_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def audio_downmix_meta_get_info() -> Gst.MetaInfo: ...
@staticmethod
def audio_format_build_integer(
    sign: bool,
    endianness: int,
    width: int,
    depth: int,
) -> AudioFormat: ...
@deprecated("deprecated")
@staticmethod
def audio_format_fill_silence(
    info: AudioFormatInfo,
    dest: list,
    length: int,
) -> None: ...
@staticmethod
def audio_format_from_string(
    format: str,
) -> AudioFormat: ...
@staticmethod
def audio_format_get_info(
    format: AudioFormat,
) -> AudioFormatInfo: ...
@staticmethod
def audio_format_to_string(
    format: AudioFormat,
) -> str: ...
@staticmethod
def audio_formats_raw() -> tuple[list, int]: ...
@staticmethod
def audio_get_channel_reorder_map(
    channels: int,
    from_: list,
    to: list,
    reorder_map: list,
) -> bool: ...
@staticmethod
def audio_iec61937_frame_size(
    spec: AudioRingBufferSpec,
) -> int: ...
@staticmethod
def audio_iec61937_payload(
    src: list,
    src_n: int,
    dst: list,
    dst_n: int,
    spec: AudioRingBufferSpec,
    endianness: int,
) -> bool: ...
@staticmethod
def audio_info_from_caps(
    caps: Gst.Caps,
) -> tuple[bool, AudioInfo]: ...
@staticmethod
def audio_info_init() -> AudioInfo: ...
@staticmethod
def audio_level_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def audio_level_meta_get_info() -> Gst.MetaInfo: ...
@staticmethod
def audio_make_raw_caps(
    formats: list | None,
    len: int,
    layout: AudioLayout,
) -> Gst.Caps: ...
@staticmethod
def audio_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def audio_meta_get_info() -> Gst.MetaInfo: ...
@staticmethod
def audio_reorder_channels(
    data: list,
    size: int,
    format: AudioFormat,
    channels: int,
    from_: list,
    to: list,
) -> bool: ...
@staticmethod
def audio_reorder_channels_with_reorder_map(
    data: list,
    size: int,
    bps: int,
    channels: int,
    reorder_map: list,
) -> None: ...
@staticmethod
def audio_resampler_new(
    method: AudioResamplerMethod,
    flags: AudioResamplerFlags,
    format: AudioFormat,
    channels: int,
    in_rate: int,
    out_rate: int,
    options: Gst.Structure,
) -> None: ...
@staticmethod
def audio_resampler_options_set_quality(
    method: AudioResamplerMethod,
    quality: int,
    in_rate: int,
    out_rate: int,
    options: Gst.Structure,
) -> None: ...
@staticmethod
def buffer_add_audio_clipping_meta(
    buffer: Gst.Buffer,
    format: Gst.Format,
    start: int,
    end: int,
) -> AudioClippingMeta: ...
@staticmethod
def buffer_add_audio_downmix_meta(
    buffer: Gst.Buffer,
    from_position: list,
    from_channels: int,
    to_position: list,
    to_channels: int,
    matrix: float,
) -> AudioDownmixMeta: ...
@staticmethod
def buffer_add_audio_level_meta(
    buffer: Gst.Buffer,
    level: int,
    voice_activity: bool,
) -> AudioLevelMeta | None: ...
@staticmethod
def buffer_add_audio_meta(
    buffer: Gst.Buffer,
    info: AudioInfo,
    samples: int,
    offsets: int | None = None,
) -> AudioMeta: ...
@staticmethod
def buffer_add_dsd_plane_offset_meta(
    buffer: Gst.Buffer,
    num_channels: int,
    num_bytes_per_channel: int,
    offsets: int | None = None,
) -> DsdPlaneOffsetMeta: ...
@staticmethod
def buffer_get_audio_downmix_meta_for_channels(
    buffer: Gst.Buffer,
    to_position: list,
    to_channels: int,
) -> AudioDownmixMeta: ...
@staticmethod
def buffer_get_audio_level_meta(
    buffer: Gst.Buffer,
) -> AudioLevelMeta | None: ...
@staticmethod
def dsd_convert(
    input_data: int,
    output_data: int,
    input_format: DsdFormat,
    output_format: DsdFormat,
    input_layout: AudioLayout,
    output_layout: AudioLayout,
    input_plane_offsets: int,
    output_plane_offsets: int,
    num_dsd_bytes: int,
    num_channels: int,
    reverse_byte_bits: bool,
) -> None: ...
@staticmethod
def dsd_format_from_string(
    str: str,
) -> DsdFormat: ...
@staticmethod
def dsd_format_get_width(
    format: DsdFormat,
) -> int: ...
@staticmethod
def dsd_format_to_string(
    format: DsdFormat,
) -> str: ...
@staticmethod
def dsd_info_from_caps(
    caps: Gst.Caps,
) -> tuple[bool, DsdInfo]: ...
@staticmethod
def dsd_info_init() -> DsdInfo: ...
@staticmethod
def dsd_plane_offset_meta_api_get_type() -> GObject.GType: ...
@staticmethod
def dsd_plane_offset_meta_get_info() -> Gst.MetaInfo: ...
@staticmethod
def stream_volume_convert_volume(
    from_: StreamVolumeFormat,
    to: StreamVolumeFormat,
    val: float,
) -> float: ...

###############################################################
# Enums/Flags
###############################################################

class AudioBaseSinkDiscontReason(GObject.GEnum):
    NO_DISCONT = 0
    NEW_CAPS = 1
    FLUSH = 2
    SYNC_LATENCY = 3
    ALIGNMENT = 4
    DEVICE_FAILURE = 5

class AudioBaseSinkSlaveMethod(GObject.GEnum):
    RESAMPLE = 0
    SKEW = 1
    NONE = 2
    CUSTOM = 3

class AudioBaseSrcSlaveMethod(GObject.GEnum):
    RESAMPLE = 0
    RE_TIMESTAMP = 1
    SKEW = 2
    NONE = 3

class AudioCdSrcMode(GObject.GEnum):
    NORMAL = 0
    CONTINUOUS = 1

class AudioChannelMixerFlags(GObject.GFlags):
    NONE = 0
    NON_INTERLEAVED_IN = 1
    NON_INTERLEAVED_OUT = 2
    UNPOSITIONED_IN = 4
    UNPOSITIONED_OUT = 8

class AudioChannelPosition(GObject.GEnum):
    NONE = -3
    MONO = -2
    INVALID = -1
    FRONT_LEFT = 0
    FRONT_RIGHT = 1
    FRONT_CENTER = 2
    LFE1 = 3
    REAR_LEFT = 4
    REAR_RIGHT = 5
    FRONT_LEFT_OF_CENTER = 6
    FRONT_RIGHT_OF_CENTER = 7
    REAR_CENTER = 8
    LFE2 = 9
    SIDE_LEFT = 10
    SIDE_RIGHT = 11
    TOP_FRONT_LEFT = 12
    TOP_FRONT_RIGHT = 13
    TOP_FRONT_CENTER = 14
    TOP_CENTER = 15
    TOP_REAR_LEFT = 16
    TOP_REAR_RIGHT = 17
    TOP_SIDE_LEFT = 18
    TOP_SIDE_RIGHT = 19
    TOP_REAR_CENTER = 20
    BOTTOM_FRONT_CENTER = 21
    BOTTOM_FRONT_LEFT = 22
    BOTTOM_FRONT_RIGHT = 23
    WIDE_LEFT = 24
    WIDE_RIGHT = 25
    SURROUND_LEFT = 26
    SURROUND_RIGHT = 27
    TOP_SURROUND_LEFT = 28
    TOP_SURROUND_RIGHT = 29

class AudioConverterFlags(GObject.GFlags):
    NONE = 0
    IN_WRITABLE = 1
    VARIABLE_RATE = 2

class AudioDitherMethod(GObject.GEnum):
    NONE = 0
    RPDF = 1
    TPDF = 2
    TPDF_HF = 3

class AudioFlags(GObject.GFlags):
    NONE = 0
    UNPOSITIONED = 1

class AudioFormat(GObject.GEnum):
    UNKNOWN = 0
    ENCODED = 1
    S8 = 2
    U8 = 3
    S16LE = 4
    S16BE = 5
    U16LE = 6
    U16BE = 7
    S24_32LE = 8
    S24_32BE = 9
    U24_32LE = 10
    U24_32BE = 11
    S32LE = 12
    S32BE = 13
    U32LE = 14
    U32BE = 15
    S24LE = 16
    S24BE = 17
    U24LE = 18
    U24BE = 19
    S20LE = 20
    S20BE = 21
    U20LE = 22
    U20BE = 23
    S18LE = 24
    S18BE = 25
    U18LE = 26
    U18BE = 27
    F32LE = 28
    F32BE = 29
    F64LE = 30
    F64BE = 31
    S16 = 4
    U16 = 6
    S24_32 = 8
    U24_32 = 10
    S32 = 12
    U32 = 14
    S24 = 16
    U24 = 18
    S20 = 20
    U20 = 22
    S18 = 24
    U18 = 26
    F32 = 28
    F64 = 30

class AudioFormatFlags(GObject.GFlags):
    INTEGER = 1
    FLOAT = 2
    SIGNED = 4
    COMPLEX = 16
    UNPACK = 32

class AudioLayout(GObject.GEnum):
    INTERLEAVED = 0
    NON_INTERLEAVED = 1

class AudioNoiseShapingMethod(GObject.GEnum):
    NONE = 0
    ERROR_FEEDBACK = 1
    SIMPLE = 2
    MEDIUM = 3
    HIGH = 4

class AudioPackFlags(GObject.GFlags):
    NONE = 0
    TRUNCATE_RANGE = 1

class AudioQuantizeFlags(GObject.GFlags):
    NONE = 0
    NON_INTERLEAVED = 1

class AudioResamplerFilterInterpolation(GObject.GEnum):
    NONE = 0
    LINEAR = 1
    CUBIC = 2

class AudioResamplerFilterMode(GObject.GEnum):
    INTERPOLATED = 0
    FULL = 1
    AUTO = 2

class AudioResamplerFlags(GObject.GFlags):
    NONE = 0
    NON_INTERLEAVED_IN = 1
    NON_INTERLEAVED_OUT = 2
    VARIABLE_RATE = 4

class AudioResamplerMethod(GObject.GEnum):
    NEAREST = 0
    LINEAR = 1
    CUBIC = 2
    BLACKMAN_NUTTALL = 3
    KAISER = 4

class AudioRingBufferFormatType(GObject.GEnum):
    RAW = 0
    MU_LAW = 1
    A_LAW = 2
    IMA_ADPCM = 3
    MPEG = 4
    GSM = 5
    IEC958 = 6
    AC3 = 7
    EAC3 = 8
    DTS = 9
    MPEG2_AAC = 10
    MPEG4_AAC = 11
    MPEG2_AAC_RAW = 12
    MPEG4_AAC_RAW = 13
    FLAC = 14
    DSD = 15

class AudioRingBufferState(GObject.GEnum):
    STOPPED = 0
    PAUSED = 1
    STARTED = 2
    ERROR = 3

class DsdFormat(GObject.GEnum):
    DSD_FORMAT_UNKNOWN = 0
    DSD_FORMAT_U8 = 1
    DSD_FORMAT_U16LE = 2
    DSD_FORMAT_U16BE = 3
    DSD_FORMAT_U32LE = 4
    DSD_FORMAT_U32BE = 5
    NUM_DSD_FORMATS = 6
    DSD_FORMAT_U16 = 2
    DSD_FORMAT_U32 = 4

class StreamVolumeFormat(enum.IntEnum):
    LINEAR = 0
    CUBIC = 1
    DB = 2

###############################################################
# classes
###############################################################

class AudioAggregator(GstBase.Aggregator):
    class Props(GstBase.Aggregator.Props):
        alignment_threshold: int  # [alignment-threshold]: changed because contained invalid characters
        discont_wait: int  # [discont-wait]: changed because contained invalid characters
        force_live: bool  # [force-live]: changed because contained invalid characters
        ignore_inactive_pads: bool  # [ignore-inactive-pads]: changed because contained invalid characters
        output_buffer_duration: int  # [output-buffer-duration]: changed because contained invalid characters
        output_buffer_duration_fraction: (
            Gst.Fraction | None
        )  # [output-buffer-duration-fraction]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def current_caps(self) -> Gst.Caps | None: ...
    @builtins.property
    def parent(self) -> GstBase.Aggregator | None: ...
    @builtins.property
    def priv(self) -> AudioAggregatorPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        alignment_threshold: int | None = None,
        discont_wait: int | None = None,
        emit_signals: bool | None = None,
        force_live: bool | None = None,
        ignore_inactive_pads: bool | None = None,
        latency: int | None = None,
        min_upstream_latency: int | None = None,
        name: str | None = None,
        output_buffer_duration: int | None = None,
        output_buffer_duration_fraction: Gst.Fraction | None = Gst.Fraction(num=1.0, denom=100.0),
        parent: Gst.Object | None = None,
        start_time: int | None = None,
        start_time_selection: GstBase.AggregatorStartTimeSelection | None = GstBase.AggregatorStartTimeSelection.ZERO,
    ) -> None:
        """
        Initialize AudioAggregator object with properties.
        """
    def set_sink_caps(self, pad: AudioAggregatorPad, caps: Gst.Caps) -> None: ...

    # python methods (overrides?)
    def do_aggregate_one_buffer(
        self,
        pad: AudioAggregatorPad,
        inbuf: Gst.Buffer,
        in_offset: int,
        outbuf: Gst.Buffer,
        out_offset: int,
        num_frames: int,
    ) -> bool:
        """
        aggregate_one_buffer(self, pad:GstAudio.AudioAggregatorPad, inbuf:Gst.Buffer, in_offset:int, outbuf:Gst.Buffer, out_offset:int, num_frames:int) -> bool
        """
    def do_create_output_buffer(
        self,
        num_frames: int,
    ) -> Gst.Buffer:
        """
        create_output_buffer(self, num_frames:int) -> Gst.Buffer
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::alignment_threshold"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::discont_wait"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::force_live"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ignore_inactive_pads"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::output_buffer_duration"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::output_buffer_duration_fraction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AudioAggregatorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def aggregate_one_buffer(self) -> aggregate_one_bufferAudioAggregatorClassCB: ...
    @builtins.property
    def create_output_buffer(self) -> create_output_bufferAudioAggregatorClassCB: ...
    @builtins.property
    def parent_class(self) -> GstBase.AggregatorClass | None: ...

class AudioAggregatorConvertPad(AudioAggregatorPad):
    class Props(AudioAggregatorPad.Props):
        converter_config: Gst.Structure | None  # [converter-config]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent(self) -> AudioAggregatorPad | None: ...
    @builtins.property
    def priv(self) -> AudioAggregatorConvertPadPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        converter_config: Gst.Structure | None = None,
        direction: Gst.PadDirection | None = Gst.PadDirection.UNKNOWN,
        emit_signals: bool | None = None,
        name: str | None = None,
        offset: int | None = None,
        parent: Gst.Object | None = None,
        qos_messages: bool | None = None,
        template: Gst.PadTemplate | None = None,
    ) -> None:
        """
        Initialize AudioAggregatorConvertPad object with properties.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::converter_config"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AudioAggregatorConvertPadClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> AudioAggregatorPadClass | None: ...

class AudioAggregatorConvertPadPrivate(GObject.GPointer): ...

class AudioAggregatorPad(GstBase.AggregatorPad):
    class Props(GstBase.AggregatorPad.Props):
        qos_messages: bool  # [qos-messages]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def info(self) -> AudioInfo | None: ...
    @builtins.property
    def parent(self) -> GstBase.AggregatorPad | None: ...
    @builtins.property
    def priv(self) -> AudioAggregatorPadPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        direction: Gst.PadDirection | None = Gst.PadDirection.UNKNOWN,
        emit_signals: bool | None = None,
        name: str | None = None,
        offset: int | None = None,
        parent: Gst.Object | None = None,
        qos_messages: bool | None = None,
        template: Gst.PadTemplate | None = None,
    ) -> None:
        """
        Initialize AudioAggregatorPad object with properties.
        """

    # python methods (overrides?)
    def do_convert_buffer(
        self,
        in_info: AudioInfo,
        out_info: AudioInfo,
        buffer: Gst.Buffer,
    ) -> Gst.Buffer:
        """
        convert_buffer(self, in_info:GstAudio.AudioInfo, out_info:GstAudio.AudioInfo, buffer:Gst.Buffer) -> Gst.Buffer
        """
    def do_update_conversion_info(
        self,
    ) -> None:
        """
        update_conversion_info(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::qos_messages"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AudioAggregatorPadClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def convert_buffer(self) -> convert_bufferAudioAggregatorPadClassCB: ...
    @builtins.property
    def parent_class(self) -> GstBase.AggregatorPadClass | None: ...
    @builtins.property
    def update_conversion_info(self) -> update_conversion_infoAudioAggregatorPadClassCB: ...

class AudioAggregatorPadPrivate(GObject.GPointer): ...
class AudioAggregatorPrivate(GObject.GPointer): ...

class AudioBaseSink(GstBase.BaseSink):
    class Props(GstBase.BaseSink.Props):
        alignment_threshold: int  # [alignment-threshold]: changed because contained invalid characters
        buffer_time: int  # [buffer-time]: changed because contained invalid characters
        can_activate_pull: bool  # [can-activate-pull]: changed because contained invalid characters
        discont_wait: int  # [discont-wait]: changed because contained invalid characters
        drift_tolerance: int  # [drift-tolerance]: changed because contained invalid characters
        latency_time: int  # [latency-time]: changed because contained invalid characters
        provide_clock: bool  # [provide-clock]: changed because contained invalid characters
        slave_method: AudioBaseSinkSlaveMethod  # [slave-method]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def buffer_time(self) -> int: ...
    @builtins.property
    def element(self) -> GstBase.BaseSink | None: ...
    @builtins.property
    def eos_rendering(self) -> bool: ...
    @builtins.property
    def latency_time(self) -> int: ...
    @builtins.property
    def next_sample(self) -> int: ...
    @builtins.property
    def priv(self) -> AudioBaseSinkPrivate | None: ...
    @builtins.property
    def provided_clock(self) -> Gst.Clock | None: ...
    @builtins.property
    def ringbuffer(self) -> AudioRingBuffer | None: ...

    # gi Methods
    def __init__(
        self,
        alignment_threshold: int | None = None,
        async_: bool | None = None,
        blocksize: int | None = None,
        buffer_time: int | None = None,
        can_activate_pull: bool | None = None,
        discont_wait: int | None = None,
        drift_tolerance: int | None = None,
        enable_last_sample: bool | None = None,
        latency_time: int | None = None,
        max_bitrate: int | None = None,
        max_lateness: int | None = None,
        name: str | None = None,
        parent: Gst.Object | None = None,
        processing_deadline: int | None = None,
        provide_clock: bool | None = None,
        qos: bool | None = None,
        render_delay: int | None = None,
        slave_method: AudioBaseSinkSlaveMethod | None = AudioBaseSinkSlaveMethod.SKEW,
        sync: bool | None = None,
        throttle_time: int | None = None,
        ts_offset: int | None = None,
    ) -> None:
        """
        Initialize AudioBaseSink object with properties.
        """
    def create_ringbuffer(self) -> AudioRingBuffer | None: ...
    @builtins.property
    def get_alignment_threshold(self) -> int: ...
    @builtins.property
    def get_discont_wait(self) -> int: ...
    @builtins.property
    def get_drift_tolerance(self) -> int: ...
    @builtins.property
    def get_provide_clock(self) -> bool: ...
    @builtins.property
    def get_slave_method(self) -> AudioBaseSinkSlaveMethod: ...
    def report_device_failure(self) -> None: ...
    def set_alignment_threshold(self, alignment_threshold: int) -> None: ...
    def set_custom_slaving_callback(
        self, callback: AudioBaseSinkCustomSlavingCallback, *user_data: object | None
    ) -> None: ...
    def set_discont_wait(self, discont_wait: int) -> None: ...
    def set_drift_tolerance(self, drift_tolerance: int) -> None: ...
    def set_provide_clock(self, provide: bool) -> None: ...
    def set_slave_method(self, method: AudioBaseSinkSlaveMethod) -> None: ...

    # python methods (overrides?)
    def do_create_ringbuffer(
        self,
    ) -> AudioRingBuffer | None:
        """
        create_ringbuffer(self) -> GstAudio.AudioRingBuffer or None
        """
    def do_payload(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.Buffer:
        """
        payload(self, buffer:Gst.Buffer) -> Gst.Buffer
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::alignment_threshold"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_activate_pull"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::discont_wait"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::drift_tolerance"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::latency_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::provide_clock"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::slave_method"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AudioBaseSinkClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def create_ringbuffer(self) -> create_ringbufferAudioBaseSinkClassCB | None: ...
    @builtins.property
    def parent_class(self) -> GstBase.BaseSinkClass | None: ...
    @builtins.property
    def payload(self) -> payloadAudioBaseSinkClassCB: ...

class AudioBaseSinkPrivate(GObject.GPointer): ...

class AudioBaseSrc(GstBase.PushSrc):
    class Props(GstBase.PushSrc.Props):
        actual_buffer_time: int  # [actual-buffer-time]: changed because contained invalid characters
        actual_latency_time: int  # [actual-latency-time]: changed because contained invalid characters
        buffer_time: int  # [buffer-time]: changed because contained invalid characters
        latency_time: int  # [latency-time]: changed because contained invalid characters
        provide_clock: bool  # [provide-clock]: changed because contained invalid characters
        slave_method: AudioBaseSrcSlaveMethod  # [slave-method]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def buffer_time(self) -> int: ...
    @builtins.property
    def clock(self) -> Gst.Clock | None: ...
    @builtins.property
    def element(self) -> GstBase.PushSrc | None: ...
    @builtins.property
    def latency_time(self) -> int: ...
    @builtins.property
    def next_sample(self) -> int: ...
    @builtins.property
    def priv(self) -> AudioBaseSrcPrivate | None: ...
    @builtins.property
    def ringbuffer(self) -> AudioRingBuffer | None: ...

    # gi Methods
    def __init__(
        self,
        automatic_eos: bool | None = None,
        blocksize: int | None = None,
        buffer_time: int | None = None,
        do_timestamp: bool | None = None,
        latency_time: int | None = None,
        name: str | None = None,
        num_buffers: int | None = None,
        parent: Gst.Object | None = None,
        provide_clock: bool | None = None,
        slave_method: AudioBaseSrcSlaveMethod | None = AudioBaseSrcSlaveMethod.SKEW,
        typefind: bool | None = None,
    ) -> None:
        """
        Initialize AudioBaseSrc object with properties.
        """
    def create_ringbuffer(self) -> AudioRingBuffer | None: ...
    @builtins.property
    def get_provide_clock(self) -> bool: ...
    @builtins.property
    def get_slave_method(self) -> AudioBaseSrcSlaveMethod: ...
    def set_provide_clock(self, provide: bool) -> None: ...
    def set_slave_method(self, method: AudioBaseSrcSlaveMethod) -> None: ...

    # python methods (overrides?)
    def do_create_ringbuffer(
        self,
    ) -> AudioRingBuffer | None:
        """
        create_ringbuffer(self) -> GstAudio.AudioRingBuffer or None
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::actual_buffer_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::actual_latency_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::latency_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::provide_clock"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::slave_method"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AudioBaseSrcClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def create_ringbuffer(self) -> create_ringbufferAudioBaseSrcClassCB | None: ...
    @builtins.property
    def parent_class(self) -> GstBase.PushSrcClass | None: ...

class AudioBaseSrcPrivate(GObject.GPointer): ...

class AudioBuffer(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    buffer: Gst.Buffer | None = ...  # type: ignore
    info: AudioInfo | None = ...
    @builtins.property
    def map_infos(self) -> Gst.MapInfo | None: ...
    n_planes: int = ...
    n_samples: int = ...
    planes: object | None = ...
    @builtins.property
    def priv_map_infos_arr(self) -> list | None: ...
    @builtins.property
    def priv_planes_arr(self) -> list | None: ...

    # gi Methods
    @staticmethod
    def clip(buffer: Gst.Buffer, segment: Gst.Segment, rate: int, bpf: int) -> Gst.Buffer | None: ...
    @staticmethod
    def map(info: AudioInfo, gstbuffer: Gst.Buffer, flags: Gst.MapFlags) -> tuple[bool, AudioBuffer]: ...
    @staticmethod
    def reorder_channels(buffer: Gst.Buffer, format: AudioFormat, channels: int, from_: list, to: list) -> bool: ...
    @staticmethod
    def truncate(buffer: Gst.Buffer, bpf: int, trim: int, samples: int) -> Gst.Buffer: ...
    def unmap(self) -> None: ...

class AudioCdSrc(GstBase.PushSrc):
    class Props(GstBase.PushSrc.Props):
        device: str
        mode: AudioCdSrcMode
        track: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved1(self) -> list | None: ...
    @builtins.property
    def _gst_reserved2(self) -> list | None: ...
    @builtins.property
    def priv(self) -> AudioCdSrcPrivate | None: ...
    @builtins.property
    def pushsrc(self) -> GstBase.PushSrc | None: ...
    @builtins.property
    def tags(self) -> Gst.TagList | None: ...

    # gi Methods
    def __init__(
        self,
        automatic_eos: bool | None = None,
        blocksize: int | None = None,
        device: str | None = None,
        do_timestamp: bool | None = None,
        mode: AudioCdSrcMode | None = AudioCdSrcMode.NORMAL,
        name: str | None = None,
        num_buffers: int | None = None,
        parent: Gst.Object | None = None,
        track: int | None = None,
        typefind: bool | None = None,
    ) -> None:
        """
        Initialize AudioCdSrc object with properties.
        """
    def add_track(self, track: AudioCdSrcTrack) -> bool: ...

    # python methods (overrides?)
    def do_close(
        self,
    ) -> None:
        """
        close(self)
        """
    def do_open(
        self,
        device: str,
    ) -> bool:
        """
        open(self, device:str) -> bool
        """
    def do_read_sector(
        self,
        sector: int,
    ) -> Gst.Buffer:
        """
        read_sector(self, sector:int) -> Gst.Buffer
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::device"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::track"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AudioCdSrcClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def close(self) -> closeAudioCdSrcClassCB: ...
    @builtins.property
    def open(self) -> openAudioCdSrcClassCB: ...
    @builtins.property
    def pushsrc_class(self) -> GstBase.PushSrcClass | None: ...
    @builtins.property
    def read_sector(self) -> read_sectorAudioCdSrcClassCB: ...

class AudioCdSrcPrivate(GObject.GPointer): ...

class AudioCdSrcTrack(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved1(self) -> list | None: ...
    @builtins.property
    def _gst_reserved2(self) -> list | None: ...
    end: int = ...
    is_audio: bool = ...
    num: int = ...
    start: int = ...
    tags: Gst.TagList | None = ...  # type: ignore

class AudioChannelMixer(GObject.GPointer):
    # gi Methods
    def free(self) -> None: ...
    def is_passthrough(self) -> bool: ...
    def samples(self, in_: object | None, out: object | None, samples: int) -> None: ...

class AudioClippingMeta(GObject.GPointer):
    # gi Fields
    end: int = ...
    format: Gst.Format = ...  # type: ignore
    meta: Gst.Meta | None = ...  # type: ignore
    start: int = ...

    # gi Methods
    @staticmethod
    def get_info() -> Gst.MetaInfo: ...

class AudioClock(Gst.SystemClock):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def clock(self) -> Gst.SystemClock | None: ...
    @builtins.property
    def destroy_notify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def func(self) -> AudioClockGetTimeFuncAudioClockCB: ...
    @builtins.property
    def last_time(self) -> int: ...
    @builtins.property
    def time_offset(self) -> int: ...
    @builtins.property
    def user_data(self) -> object | None: ...

    # gi Methods
    def __init__(
        self,
        clock_type: Gst.ClockType | None = Gst.ClockType.MONOTONIC,
        name: str | None = None,
        parent: Gst.Object | None = None,
        timeout: int | None = None,
        window_size: int | None = None,
        window_threshold: int | None = None,
    ) -> None:
        """
        Initialize AudioClock object with properties.
        """
    def adjust(self, time: int) -> int: ...
    def get_time(self) -> int: ...
    def invalidate(self) -> None: ...
    def reset(self, time: int) -> None: ...

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        name: str,
        func: typing.Callable,
        user_data: typing.Any = None,
    ) -> Gst.Clock:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(name:str, func:GstAudio.AudioClockGetTimeFunc, user_data=None) -> Gst.Clock
        """

class AudioClockClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> Gst.SystemClockClass | None: ...

class AudioConverter(GObject.GBoxed):
    # gi Methods
    def convert(self, flags: AudioConverterFlags, in_: list, in_size: int) -> tuple[bool, list, int]: ...
    def free(self) -> None: ...
    def get_config(self) -> tuple[Gst.Structure, int, int]: ...
    def get_in_frames(self, out_frames: int) -> int: ...
    def get_max_latency(self) -> int: ...
    def get_out_frames(self, in_frames: int) -> int: ...
    def is_passthrough(self) -> bool: ...
    def reset(self) -> None: ...
    def samples(
        self, flags: AudioConverterFlags, in_: object | None, in_frames: int, out: object | None, out_frames: int
    ) -> bool: ...
    def supports_inplace(self) -> bool: ...
    def update_config(self, in_rate: int, out_rate: int, config: Gst.Structure | None = None) -> bool: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        flags: AudioConverterFlags,
        in_info: AudioInfo,
        out_info: AudioInfo,
        config: Gst.Structure | None = None,
    ) -> AudioConverter | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(flags:GstAudio.AudioConverterFlags, in_info:GstAudio.AudioInfo, out_info:GstAudio.AudioInfo, config:Gst.Structure=None) -> GstAudio.AudioConverter or None
        """

class AudioDecoder(Gst.Element):
    class Props(Gst.Element.Props):
        max_errors: int  # [max-errors]: changed because contained invalid characters
        min_latency: int  # [min-latency]: changed because contained invalid characters
        plc: bool
        tolerance: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def element(self) -> Gst.Element | None: ...
    @builtins.property
    def input_segment(self) -> Gst.Segment | None: ...
    @builtins.property
    def output_segment(self) -> Gst.Segment | None: ...
    @builtins.property
    def priv(self) -> AudioDecoderPrivate | None: ...
    @builtins.property
    def sinkpad(self) -> Gst.Pad | None: ...
    @builtins.property
    def srcpad(self) -> Gst.Pad | None: ...
    @builtins.property
    def stream_lock(self) -> GLib.RecMutex | None: ...

    # gi Methods
    def __init__(
        self,
        max_errors: int | None = None,
        min_latency: int | None = None,
        name: str | None = None,
        parent: Gst.Object | None = None,
        plc: bool | None = None,
        tolerance: int | None = None,
    ) -> None:
        """
        Initialize AudioDecoder object with properties.
        """
    def allocate_output_buffer(self, size: int) -> Gst.Buffer: ...
    def finish_frame(self, buf: Gst.Buffer | None, frames: int) -> Gst.FlowReturn: ...
    def finish_subframe(self, buf: Gst.Buffer | None = None) -> Gst.FlowReturn: ...
    def get_allocator(self) -> tuple[Gst.Allocator | None, Gst.AllocationParams]: ...
    def get_audio_info(self) -> AudioInfo: ...
    def get_delay(self) -> int: ...
    def get_drainable(self) -> bool: ...
    def get_estimate_rate(self) -> int: ...
    def get_latency(self) -> tuple[int, int]: ...
    @builtins.property
    def get_max_errors(self) -> int: ...
    @builtins.property
    def get_min_latency(self) -> int: ...
    def get_needs_format(self) -> bool: ...
    def get_parse_state(self) -> tuple[bool, bool]: ...
    @builtins.property
    def get_plc(self) -> bool: ...
    def get_plc_aware(self) -> int: ...
    @builtins.property
    def get_tolerance(self) -> int: ...
    def merge_tags(self, tags: Gst.TagList | None, mode: Gst.TagMergeMode) -> None: ...
    def negotiate(self) -> bool: ...
    def proxy_getcaps(self, caps: Gst.Caps | None = None, filter: Gst.Caps | None = None) -> Gst.Caps: ...
    def set_allocation_caps(self, allocation_caps: Gst.Caps | None = None) -> None: ...
    def set_drainable(self, enabled: bool) -> None: ...
    def set_estimate_rate(self, enabled: bool) -> None: ...
    def set_latency(self, min: int, max: int) -> None: ...
    def set_max_errors(self, num: int) -> None: ...
    def set_min_latency(self, num: int) -> None: ...
    def set_needs_format(self, enabled: bool) -> None: ...
    def set_output_caps(self, caps: Gst.Caps) -> bool: ...
    def set_output_format(self, info: AudioInfo) -> bool: ...
    def set_plc(self, enabled: bool) -> None: ...
    def set_plc_aware(self, plc: bool) -> None: ...
    def set_tolerance(self, tolerance: int) -> None: ...
    def set_use_default_pad_acceptcaps(self, use: bool) -> None: ...

    # python methods (overrides?)
    def do_close(
        self,
    ) -> bool:
        """
        close(self) -> bool
        """
    def do_decide_allocation(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        decide_allocation(self, query:Gst.Query) -> bool
        """
    def do_flush(
        self,
        hard: bool,
    ) -> None:
        """
        flush(self, hard:bool)
        """
    def do_getcaps(
        self,
        filter: Gst.Caps,
    ) -> Gst.Caps:
        """
        getcaps(self, filter:Gst.Caps) -> Gst.Caps
        """
    def do_handle_frame(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        handle_frame(self, buffer:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_negotiate(
        self,
    ) -> bool:
        """
        negotiate(self) -> bool
        """
    def do_open(
        self,
    ) -> bool:
        """
        open(self) -> bool
        """
    def do_parse(
        self,
        adapter: GstBase.Adapter,
    ) -> tuple:
        """
        parse(self, adapter:GstBase.Adapter) -> Gst.FlowReturn, offset:int, length:int
        """
    def do_pre_push(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        pre_push(self, buffer:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_propose_allocation(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        propose_allocation(self, query:Gst.Query) -> bool
        """
    def do_set_format(
        self,
        caps: Gst.Caps,
    ) -> bool:
        """
        set_format(self, caps:Gst.Caps) -> bool
        """
    def do_sink_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        sink_event(self, event:Gst.Event) -> bool
        """
    def do_sink_query(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        sink_query(self, query:Gst.Query) -> bool
        """
    def do_src_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        src_event(self, event:Gst.Event) -> bool
        """
    def do_src_query(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        src_query(self, query:Gst.Query) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """
    def do_transform_meta(
        self,
        outbuf: Gst.Buffer,
        meta: Gst.Meta,
        inbuf: Gst.Buffer,
    ) -> bool:
        """
        transform_meta(self, outbuf:Gst.Buffer, meta:Gst.Meta, inbuf:Gst.Buffer) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_errors"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_latency"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::plc"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tolerance"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AudioDecoderClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def close(self) -> closeAudioDecoderClassCB: ...
    @builtins.property
    def decide_allocation(self) -> decide_allocationAudioDecoderClassCB: ...
    @builtins.property
    def element_class(self) -> Gst.ElementClass | None: ...
    @builtins.property
    def flush(self) -> flushAudioDecoderClassCB: ...
    @builtins.property
    def getcaps(self) -> getcapsAudioDecoderClassCB: ...
    @builtins.property
    def handle_frame(self) -> handle_frameAudioDecoderClassCB: ...
    @builtins.property
    def negotiate(self) -> negotiateAudioDecoderClassCB: ...
    @builtins.property
    def open(self) -> openAudioDecoderClassCB: ...
    @builtins.property
    def parse(self) -> parseAudioDecoderClassCB: ...
    @builtins.property
    def pre_push(self) -> pre_pushAudioDecoderClassCB: ...
    @builtins.property
    def propose_allocation(self) -> propose_allocationAudioDecoderClassCB: ...
    @builtins.property
    def set_format(self) -> set_formatAudioDecoderClassCB: ...
    @builtins.property
    def sink_event(self) -> sink_eventAudioDecoderClassCB: ...
    @builtins.property
    def sink_query(self) -> sink_queryAudioDecoderClassCB: ...
    @builtins.property
    def src_event(self) -> src_eventAudioDecoderClassCB: ...
    @builtins.property
    def src_query(self) -> src_queryAudioDecoderClassCB: ...
    @builtins.property
    def start(self) -> startAudioDecoderClassCB: ...
    @builtins.property
    def stop(self) -> stopAudioDecoderClassCB: ...
    @builtins.property
    def transform_meta(self) -> transform_metaAudioDecoderClassCB: ...

class AudioDecoderPrivate(GObject.GPointer): ...

class AudioDownmixMeta(GObject.GPointer):
    # gi Fields
    from_channels: int = ...
    from_position: AudioChannelPosition = ...
    matrix: float = ...
    meta: Gst.Meta | None = ...  # type: ignore
    to_channels: int = ...
    to_position: AudioChannelPosition = ...

    # gi Methods
    @staticmethod
    def get_info() -> Gst.MetaInfo: ...

class AudioEncoder(Gst.Element):
    class Props(Gst.Element.Props):
        hard_resync: bool  # [hard-resync]: changed because contained invalid characters
        mark_granule: bool  # [mark-granule]: changed because contained invalid characters
        perfect_timestamp: bool  # [perfect-timestamp]: changed because contained invalid characters
        tolerance: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def element(self) -> Gst.Element | None: ...
    @builtins.property
    def input_segment(self) -> Gst.Segment | None: ...
    @builtins.property
    def output_segment(self) -> Gst.Segment | None: ...
    @builtins.property
    def priv(self) -> AudioEncoderPrivate | None: ...
    @builtins.property
    def sinkpad(self) -> Gst.Pad | None: ...
    @builtins.property
    def srcpad(self) -> Gst.Pad | None: ...
    @builtins.property
    def stream_lock(self) -> GLib.RecMutex | None: ...

    # gi Methods
    def __init__(
        self,
        hard_resync: bool | None = None,
        name: str | None = None,
        parent: Gst.Object | None = None,
        perfect_timestamp: bool | None = None,
        tolerance: int | None = None,
    ) -> None:
        """
        Initialize AudioEncoder object with properties.
        """
    def allocate_output_buffer(self, size: int) -> Gst.Buffer: ...
    def finish_frame(self, buffer: Gst.Buffer | None, samples: int) -> Gst.FlowReturn: ...
    def get_allocator(self) -> tuple[Gst.Allocator | None, Gst.AllocationParams]: ...
    def get_audio_info(self) -> AudioInfo: ...
    def get_drainable(self) -> bool: ...
    def get_frame_max(self) -> int: ...
    def get_frame_samples_max(self) -> int: ...
    def get_frame_samples_min(self) -> int: ...
    def get_hard_min(self) -> bool: ...
    @builtins.property
    def get_hard_resync(self) -> bool: ...
    def get_latency(self) -> tuple[int, int]: ...
    def get_lookahead(self) -> int: ...
    @builtins.property
    def get_mark_granule(self) -> bool: ...
    @builtins.property
    def get_perfect_timestamp(self) -> bool: ...
    @builtins.property
    def get_tolerance(self) -> int: ...
    def merge_tags(self, tags: Gst.TagList | None, mode: Gst.TagMergeMode) -> None: ...
    def negotiate(self) -> bool: ...
    def proxy_getcaps(self, caps: Gst.Caps | None = None, filter: Gst.Caps | None = None) -> Gst.Caps: ...
    def set_allocation_caps(self, allocation_caps: Gst.Caps | None = None) -> None: ...
    def set_drainable(self, enabled: bool) -> None: ...
    def set_frame_max(self, num: int) -> None: ...
    def set_frame_samples_max(self, num: int) -> None: ...
    def set_frame_samples_min(self, num: int) -> None: ...
    def set_hard_min(self, enabled: bool) -> None: ...
    def set_hard_resync(self, enabled: bool) -> None: ...
    def set_headers(self, headers: list) -> None: ...
    def set_latency(self, min: int, max: int) -> None: ...
    def set_lookahead(self, num: int) -> None: ...
    def set_mark_granule(self, enabled: bool) -> None: ...
    def set_output_format(self, caps: Gst.Caps) -> bool: ...
    def set_perfect_timestamp(self, enabled: bool) -> None: ...
    def set_tolerance(self, tolerance: int) -> None: ...

    # python methods (overrides?)
    def do_close(
        self,
    ) -> bool:
        """
        close(self) -> bool
        """
    def do_decide_allocation(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        decide_allocation(self, query:Gst.Query) -> bool
        """
    def do_flush(
        self,
    ) -> None:
        """
        flush(self)
        """
    def do_getcaps(
        self,
        filter: Gst.Caps,
    ) -> Gst.Caps:
        """
        getcaps(self, filter:Gst.Caps) -> Gst.Caps
        """
    def do_handle_frame(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        handle_frame(self, buffer:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_negotiate(
        self,
    ) -> bool:
        """
        negotiate(self) -> bool
        """
    def do_open(
        self,
    ) -> bool:
        """
        open(self) -> bool
        """
    def do_pre_push(
        self,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn:
        """
        pre_push(self, buffer:Gst.Buffer) -> Gst.FlowReturn
        """
    def do_propose_allocation(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        propose_allocation(self, query:Gst.Query) -> bool
        """
    def do_set_format(
        self,
        info: AudioInfo,
    ) -> bool:
        """
        set_format(self, info:GstAudio.AudioInfo) -> bool
        """
    def do_sink_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        sink_event(self, event:Gst.Event) -> bool
        """
    def do_sink_query(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        sink_query(self, query:Gst.Query) -> bool
        """
    def do_src_event(
        self,
        event: Gst.Event,
    ) -> bool:
        """
        src_event(self, event:Gst.Event) -> bool
        """
    def do_src_query(
        self,
        query: Gst.Query,
    ) -> bool:
        """
        src_query(self, query:Gst.Query) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """
    def do_transform_meta(
        self,
        outbuf: Gst.Buffer,
        meta: Gst.Meta,
        inbuf: Gst.Buffer,
    ) -> bool:
        """
        transform_meta(self, outbuf:Gst.Buffer, meta:Gst.Meta, inbuf:Gst.Buffer) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hard_resync"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mark_granule"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::perfect_timestamp"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tolerance"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AudioEncoderClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def close(self) -> closeAudioEncoderClassCB: ...
    @builtins.property
    def decide_allocation(self) -> decide_allocationAudioEncoderClassCB: ...
    @builtins.property
    def element_class(self) -> Gst.ElementClass | None: ...
    @builtins.property
    def flush(self) -> flushAudioEncoderClassCB: ...
    @builtins.property
    def getcaps(self) -> getcapsAudioEncoderClassCB: ...
    @builtins.property
    def handle_frame(self) -> handle_frameAudioEncoderClassCB: ...
    @builtins.property
    def negotiate(self) -> negotiateAudioEncoderClassCB: ...
    @builtins.property
    def open(self) -> openAudioEncoderClassCB: ...
    @builtins.property
    def pre_push(self) -> pre_pushAudioEncoderClassCB: ...
    @builtins.property
    def propose_allocation(self) -> propose_allocationAudioEncoderClassCB: ...
    @builtins.property
    def set_format(self) -> set_formatAudioEncoderClassCB: ...
    @builtins.property
    def sink_event(self) -> sink_eventAudioEncoderClassCB: ...
    @builtins.property
    def sink_query(self) -> sink_queryAudioEncoderClassCB: ...
    @builtins.property
    def src_event(self) -> src_eventAudioEncoderClassCB: ...
    @builtins.property
    def src_query(self) -> src_queryAudioEncoderClassCB: ...
    @builtins.property
    def start(self) -> startAudioEncoderClassCB: ...
    @builtins.property
    def stop(self) -> stopAudioEncoderClassCB: ...
    @builtins.property
    def transform_meta(self) -> transform_metaAudioEncoderClassCB: ...

class AudioEncoderPrivate(GObject.GPointer): ...

class AudioFilter(GstBase.BaseTransform):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def basetransform(self) -> GstBase.BaseTransform | None: ...
    @builtins.property
    def info(self) -> AudioInfo | None: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Gst.Object | None = None, qos: bool | None = None) -> None:
        """
        Initialize AudioFilter object with properties.
        """

    # python methods (overrides?)
    @classmethod
    def add_pad_templates(
        cls,
        allowed_caps: Gst.Caps,
    ) -> None:
        """
        add_pad_templates(self, allowed_caps:Gst.Caps)
        """
    def do_setup(
        self,
        info: AudioInfo,
    ) -> bool:
        """
        setup(self, info:GstAudio.AudioInfo) -> bool
        """

class AudioFilterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def basetransformclass(self) -> GstBase.BaseTransformClass | None: ...
    @builtins.property
    def setup(self) -> setupAudioFilterClassCB: ...

    # gi Methods
    def add_pad_templates(self, allowed_caps: Gst.Caps) -> None: ...

class AudioFormatInfo(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    depth: int = ...
    description: str = ...
    endianness: int = ...
    flags: AudioFormatFlags = ...
    format: AudioFormat = ...
    name: str = ...
    pack_func: AudioFormatPackAudioFormatInfoCB = ...
    silence: list | None = ...
    unpack_format: AudioFormat = ...
    unpack_func: AudioFormatUnpackAudioFormatInfoCB = ...
    width: int = ...

    # gi Methods
    def fill_silence(self, dest: list, length: int) -> None: ...

class AudioInfo(GObject.GBoxed):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    bpf: int = ...
    channels: int = ...
    finfo: AudioFormatInfo | None = ...
    flags: AudioFlags = ...
    layout: AudioLayout = ...
    position: list | None = ...
    rate: int = ...

    # gi Methods
    def convert(self, src_fmt: Gst.Format, src_val: int, dest_fmt: Gst.Format) -> tuple[bool, int]: ...
    def copy(self) -> AudioInfo: ...
    def free(self) -> None: ...
    @staticmethod
    def init() -> AudioInfo: ...
    def is_equal(self, other: AudioInfo) -> bool: ...
    def set_format(self, format: AudioFormat, rate: int, channels: int, position: list | None = None) -> None: ...
    def to_caps(self) -> Gst.Caps: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @staticmethod
    def from_caps(
        *args: typing.Any,
    ) -> typing.Any:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]
        """
    @classmethod
    def new(
        cls,
    ) -> AudioInfo:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> GstAudio.AudioInfo
        """
    @classmethod
    def new_from_caps(
        cls,
        caps: Gst.Caps,
    ) -> AudioInfo | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_caps(caps:Gst.Caps) -> GstAudio.AudioInfo or None
        """

class AudioLevelMeta(GObject.GPointer):
    # gi Fields
    level: int = ...
    meta: Gst.Meta | None = ...  # type: ignore
    voice_activity: bool = ...

    # gi Methods
    @staticmethod
    def get_info() -> Gst.MetaInfo: ...

class AudioMeta(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    info: AudioInfo | None = ...
    meta: Gst.Meta | None = ...  # type: ignore
    offsets: int = ...
    @builtins.property
    def priv_offsets_arr(self) -> list | None: ...
    samples: int = ...

    # gi Methods
    @staticmethod
    def get_info() -> Gst.MetaInfo: ...

class AudioQuantize(GObject.GPointer):
    # gi Methods
    def free(self) -> None: ...
    def reset(self) -> None: ...
    def samples(self, in_: object | None, out: object | None, samples: int) -> None: ...

class AudioResampler(GObject.GPointer):
    # gi Methods
    def free(self) -> None: ...
    def get_in_frames(self, out_frames: int) -> int: ...
    def get_max_latency(self) -> int: ...
    def get_out_frames(self, in_frames: int) -> int: ...
    @staticmethod
    def new(
        method: AudioResamplerMethod,
        flags: AudioResamplerFlags,
        format: AudioFormat,
        channels: int,
        in_rate: int,
        out_rate: int,
        options: Gst.Structure,
    ) -> None: ...
    @staticmethod
    def options_set_quality(
        method: AudioResamplerMethod, quality: int, in_rate: int, out_rate: int, options: Gst.Structure
    ) -> None: ...
    def resample(self, in_: object | None, in_frames: int, out: object | None, out_frames: int) -> None: ...
    def reset(self) -> None: ...
    def update(self, in_rate: int, out_rate: int, options: Gst.Structure) -> bool: ...

class AudioRingBuffer(Gst.Object):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def acquired(self) -> bool: ...
    @builtins.property
    def active(self) -> bool: ...
    @builtins.property
    def callback(self) -> AudioRingBufferCallbackAudioRingBufferCB: ...
    @builtins.property
    def cb_data(self) -> object | None: ...
    @builtins.property
    def cb_data_notify(self) -> GLib.DestroyNotify: ...
    @builtins.property
    def channel_reorder_map(self) -> list | None: ...
    @builtins.property
    def cond(self) -> GLib.Cond | None: ...
    @builtins.property
    def empty_seg(self) -> int: ...
    @builtins.property
    def flushing(self) -> bool: ...
    @builtins.property
    def memory(self) -> int: ...
    @builtins.property
    def need_reorder(self) -> bool: ...
    @builtins.property
    def object(self) -> Gst.Object | None: ...
    @builtins.property
    def open(self) -> bool: ...
    @builtins.property
    def priv(self) -> AudioRingBufferPrivate | None: ...
    @builtins.property
    def samples_per_seg(self) -> int: ...
    @builtins.property
    def segbase(self) -> int: ...
    @builtins.property
    def segdone(self) -> int: ...
    @builtins.property
    def size(self) -> int: ...
    @builtins.property
    def spec(self) -> AudioRingBufferSpec | None: ...
    @builtins.property
    def state(self) -> int: ...
    @builtins.property
    def timestamps(self) -> int: ...
    @builtins.property
    def waiting(self) -> int: ...

    # gi Methods
    def __init__(self, name: str | None = None, parent: Gst.Object | None = None) -> None:
        """
        Initialize AudioRingBuffer object with properties.
        """
    def acquire(self, spec: AudioRingBufferSpec) -> bool: ...
    def activate(self, active: bool) -> bool: ...
    def advance(self, advance: int) -> None: ...
    def clear(self, segment: int) -> None: ...
    def clear_all(self) -> None: ...
    def close_device(self) -> bool: ...
    def commit(
        self, sample: int, data: list, in_samples: int, out_samples: int, accum: int
    ) -> tuple[int, int, int]: ...
    def convert(self, src_fmt: Gst.Format, src_val: int, dest_fmt: Gst.Format) -> tuple[bool, int]: ...
    @staticmethod
    def debug_spec_buff(spec: AudioRingBufferSpec) -> None: ...
    @staticmethod
    def debug_spec_caps(spec: AudioRingBufferSpec) -> None: ...
    def delay(self) -> int: ...
    def device_is_open(self) -> bool: ...
    def get_segbase(self) -> int: ...
    def get_segdone(self) -> int: ...
    def is_acquired(self) -> bool: ...
    def is_active(self) -> bool: ...
    def is_flushing(self) -> bool: ...
    def may_start(self, allowed: bool) -> None: ...
    def open_device(self) -> bool: ...
    @staticmethod
    def parse_caps(spec: AudioRingBufferSpec, caps: Gst.Caps) -> bool: ...
    def pause(self) -> bool: ...
    def prepare_read(self) -> tuple[bool, int, list, int]: ...
    def read(self, sample: int, data: list, len: int) -> tuple[int, int]: ...
    def release(self) -> bool: ...
    def samples_done(self) -> int: ...
    def set_callback(self, cb: AudioRingBufferCallback | None = None, *user_data: object | None) -> None: ...
    def set_channel_positions(self, position: list) -> None: ...
    def set_errored(self) -> None: ...
    def set_flushing(self, flushing: bool) -> None: ...
    def set_sample(self, sample: int) -> None: ...
    def set_segdone(self, segdone: int) -> None: ...
    def set_timestamp(self, readseg: int, timestamp: int) -> None: ...
    def start(self) -> bool: ...
    def stop(self) -> bool: ...

    # python methods (overrides?)
    def do_acquire(
        self,
        spec: AudioRingBufferSpec,
    ) -> bool:
        """
        acquire(self, spec:GstAudio.AudioRingBufferSpec) -> bool
        """
    def do_activate(
        self,
        active: bool,
    ) -> bool:
        """
        activate(self, active:bool) -> bool
        """
    def do_clear_all(
        self,
    ) -> None:
        """
        clear_all(self)
        """
    def do_close_device(
        self,
    ) -> bool:
        """
        close_device(self) -> bool
        """
    def do_commit(
        self,
        sample: int,
        data: list,
        out_samples: int,
        accum: int,
    ) -> tuple:
        """
        commit(self, sample:int, data:list, out_samples:int, accum:int) -> int, sample:int, accum:int
        """
    def do_delay(
        self,
    ) -> int:
        """
        delay(self) -> int
        """
    def do_open_device(
        self,
    ) -> bool:
        """
        open_device(self) -> bool
        """
    def do_pause(
        self,
    ) -> bool:
        """
        pause(self) -> bool
        """
    def do_release(
        self,
    ) -> bool:
        """
        release(self) -> bool
        """
    def do_resume(
        self,
    ) -> bool:
        """
        resume(self) -> bool
        """
    def do_start(
        self,
    ) -> bool:
        """
        start(self) -> bool
        """
    def do_stop(
        self,
    ) -> bool:
        """
        stop(self) -> bool
        """

class AudioRingBufferClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def acquire(self) -> acquireAudioRingBufferClassCB: ...
    @builtins.property
    def activate(self) -> activateAudioRingBufferClassCB: ...
    @builtins.property
    def clear_all(self) -> clear_allAudioRingBufferClassCB: ...
    @builtins.property
    def close_device(self) -> close_deviceAudioRingBufferClassCB: ...
    @builtins.property
    def commit(self) -> commitAudioRingBufferClassCB: ...
    @builtins.property
    def delay(self) -> delayAudioRingBufferClassCB: ...
    @builtins.property
    def open_device(self) -> open_deviceAudioRingBufferClassCB: ...
    @builtins.property
    def parent_class(self) -> Gst.ObjectClass | None: ...
    @builtins.property
    def pause(self) -> pauseAudioRingBufferClassCB: ...
    @builtins.property
    def release(self) -> releaseAudioRingBufferClassCB: ...
    @builtins.property
    def resume(self) -> resumeAudioRingBufferClassCB: ...
    @builtins.property
    def start(self) -> startAudioRingBufferClassCB: ...
    @builtins.property
    def stop(self) -> stopAudioRingBufferClassCB: ...

class AudioRingBufferPrivate(GObject.GPointer): ...

class AudioRingBufferSpec(GObject.GPointer):
    # gi Fields
    buffer_time: int = ...
    caps: Gst.Caps | None = ...  # type: ignore
    info: AudioInfo | None = ...
    latency_time: int = ...
    seglatency: int = ...
    segsize: int = ...
    segtotal: int = ...
    type: AudioRingBufferFormatType = ...

class AudioSink(AudioBaseSink):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def element(self) -> AudioBaseSink | None: ...
    @builtins.property
    def thread(self) -> GLib.Thread | None: ...

    # gi Methods
    def __init__(
        self,
        alignment_threshold: int | None = None,
        async_: bool | None = None,
        blocksize: int | None = None,
        buffer_time: int | None = None,
        can_activate_pull: bool | None = None,
        discont_wait: int | None = None,
        drift_tolerance: int | None = None,
        enable_last_sample: bool | None = None,
        latency_time: int | None = None,
        max_bitrate: int | None = None,
        max_lateness: int | None = None,
        name: str | None = None,
        parent: Gst.Object | None = None,
        processing_deadline: int | None = None,
        provide_clock: bool | None = None,
        qos: bool | None = None,
        render_delay: int | None = None,
        slave_method: AudioBaseSinkSlaveMethod | None = AudioBaseSinkSlaveMethod.SKEW,
        sync: bool | None = None,
        throttle_time: int | None = None,
        ts_offset: int | None = None,
    ) -> None:
        """
        Initialize AudioSink object with properties.
        """

    # python methods (overrides?)
    def do_close(
        self,
    ) -> bool:
        """
        close(self) -> bool
        """
    def do_delay(
        self,
    ) -> int:
        """
        delay(self) -> int
        """
    def do_open(
        self,
    ) -> bool:
        """
        open(self) -> bool
        """
    def do_pause(
        self,
    ) -> None:
        """
        pause(self)
        """
    def do_prepare(
        self,
        spec: AudioRingBufferSpec,
    ) -> bool:
        """
        prepare(self, spec:GstAudio.AudioRingBufferSpec) -> bool
        """
    def do_reset(
        self,
    ) -> None:
        """
        reset(self)
        """
    def do_resume(
        self,
    ) -> None:
        """
        resume(self)
        """
    def do_stop(
        self,
    ) -> None:
        """
        stop(self)
        """
    def do_unprepare(
        self,
    ) -> bool:
        """
        unprepare(self) -> bool
        """
    def do_write(
        self,
        data: list,
    ) -> int:
        """
        write(self, data:list) -> int
        """

class AudioSinkClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def close(self) -> closeAudioSinkClassCB: ...
    @builtins.property
    def delay(self) -> delayAudioSinkClassCB: ...
    @builtins.property
    def extension(self) -> AudioSinkClassExtension | None: ...
    @builtins.property
    def open(self) -> openAudioSinkClassCB: ...
    @builtins.property
    def parent_class(self) -> AudioBaseSinkClass | None: ...
    @builtins.property
    def pause(self) -> pauseAudioSinkClassCB: ...
    @builtins.property
    def prepare(self) -> prepareAudioSinkClassCB: ...
    @builtins.property
    def reset(self) -> resetAudioSinkClassCB: ...
    @builtins.property
    def resume(self) -> resumeAudioSinkClassCB: ...
    @builtins.property
    def stop(self) -> stopAudioSinkClassCB: ...
    @builtins.property
    def unprepare(self) -> unprepareAudioSinkClassCB: ...
    @builtins.property
    def write(self) -> writeAudioSinkClassCB: ...

class AudioSinkClassExtension(GObject.GPointer):
    # gi Fields
    @builtins.property
    def clear_all(self) -> clear_allAudioSinkClassExtensionCB: ...

class AudioSrc(AudioBaseSrc):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def element(self) -> AudioBaseSrc | None: ...
    @builtins.property
    def thread(self) -> GLib.Thread | None: ...

    # gi Methods
    def __init__(
        self,
        automatic_eos: bool | None = None,
        blocksize: int | None = None,
        buffer_time: int | None = None,
        do_timestamp: bool | None = None,
        latency_time: int | None = None,
        name: str | None = None,
        num_buffers: int | None = None,
        parent: Gst.Object | None = None,
        provide_clock: bool | None = None,
        slave_method: AudioBaseSrcSlaveMethod | None = AudioBaseSrcSlaveMethod.SKEW,
        typefind: bool | None = None,
    ) -> None:
        """
        Initialize AudioSrc object with properties.
        """

    # python methods (overrides?)
    def do_close(
        self,
    ) -> bool:
        """
        close(self) -> bool
        """
    def do_delay(
        self,
    ) -> int:
        """
        delay(self) -> int
        """
    def do_open(
        self,
    ) -> bool:
        """
        open(self) -> bool
        """
    def do_prepare(
        self,
        spec: AudioRingBufferSpec,
    ) -> bool:
        """
        prepare(self, spec:GstAudio.AudioRingBufferSpec) -> bool
        """
    def do_read(
        self,
        data: list,
    ) -> tuple:
        """
        read(self, data:list) -> int, timestamp:int
        """
    def do_reset(
        self,
    ) -> None:
        """
        reset(self)
        """
    def do_unprepare(
        self,
    ) -> bool:
        """
        unprepare(self) -> bool
        """

class AudioSrcClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    @builtins.property
    def close(self) -> closeAudioSrcClassCB: ...
    @builtins.property
    def delay(self) -> delayAudioSrcClassCB: ...
    @builtins.property
    def open(self) -> openAudioSrcClassCB: ...
    @builtins.property
    def parent_class(self) -> AudioBaseSrcClass | None: ...
    @builtins.property
    def prepare(self) -> prepareAudioSrcClassCB: ...
    @builtins.property
    def read(self) -> readAudioSrcClassCB: ...
    @builtins.property
    def reset(self) -> resetAudioSrcClassCB: ...
    @builtins.property
    def unprepare(self) -> unprepareAudioSrcClassCB: ...

class AudioStreamAlign(GObject.GBoxed):
    # gi Methods
    def copy(self) -> AudioStreamAlign: ...
    def free(self) -> None: ...
    def get_alignment_threshold(self) -> int: ...
    def get_discont_wait(self) -> int: ...
    def get_rate(self) -> int: ...
    def get_samples_since_discont(self) -> int: ...
    def get_timestamp_at_discont(self) -> int: ...
    def mark_discont(self) -> None: ...
    def process(self, discont: bool, timestamp: int, n_samples: int) -> tuple[bool, int, int, int]: ...
    def set_alignment_threshold(self, alignment_threshold: int) -> None: ...
    def set_discont_wait(self, discont_wait: int) -> None: ...
    def set_rate(self, rate: int) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        rate: int,
        alignment_threshold: int,
        discont_wait: int,
    ) -> AudioStreamAlign:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(rate:int, alignment_threshold:int, discont_wait:int) -> GstAudio.AudioStreamAlign
        """

class DsdInfo(GObject.GBoxed):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    channels: int = ...
    flags: AudioFlags = ...
    format: DsdFormat = ...
    layout: AudioLayout = ...
    positions: list | None = ...
    rate: int = ...
    reversed_bytes: bool = ...

    # gi Methods
    def copy(self) -> DsdInfo: ...
    def free(self) -> None: ...
    @staticmethod
    def from_caps(caps: Gst.Caps) -> tuple[bool, DsdInfo]: ...
    @staticmethod
    def init() -> DsdInfo: ...
    def is_equal(self, other: DsdInfo) -> bool: ...
    def set_format(self, format: DsdFormat, rate: int, channels: int, positions: list | None = None) -> None: ...
    def to_caps(self) -> Gst.Caps: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
    ) -> DsdInfo:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> GstAudio.DsdInfo
        """
    @classmethod
    def new_from_caps(
        cls,
        caps: Gst.Caps,
    ) -> DsdInfo:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_caps(caps:Gst.Caps) -> GstAudio.DsdInfo
        """

class DsdPlaneOffsetMeta(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _gst_reserved(self) -> list | None: ...
    meta: Gst.Meta | None = ...  # type: ignore
    num_bytes_per_channel: int = ...
    num_channels: int = ...
    offsets: int = ...
    @builtins.property
    def priv_offsets_arr(self) -> list | None: ...

    # gi Methods
    @staticmethod
    def get_info() -> Gst.MetaInfo: ...

class StreamVolume(builtins.object):
    class Props:
        mute: bool
        volume: float

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, mute: bool | None = None, volume: float | None = None) -> None:
        """
        Initialize StreamVolume object with properties.
        """
    @staticmethod
    def convert_volume(from_: StreamVolumeFormat, to: StreamVolumeFormat, val: float) -> float: ...
    @builtins.property
    def get_mute(self) -> bool: ...
    def get_volume(self, format: StreamVolumeFormat) -> float: ...
    def set_mute(self, mute: bool) -> None: ...
    def set_volume(self, format: StreamVolumeFormat, val: float) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mute"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::volume"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StreamVolumeInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def iface(self) -> GObject.TypeInterface | None: ...

###############################################################
# Callbacks
###############################################################

class create_output_bufferAudioAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioAggregatorClass.create_output_buffer
    """
    #  aagg
    def __call__(
        self,
        aagg: AudioAggregator,
        num_frames: int,
    ) -> Gst.Buffer: ...

class aggregate_one_bufferAudioAggregatorClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioAggregatorClass.aggregate_one_buffer
    """
    #  aagg
    def __call__(
        self,
        aagg: AudioAggregator,
        pad: AudioAggregatorPad,
        inbuf: Gst.Buffer,
        in_offset: int,
        outbuf: Gst.Buffer,
        out_offset: int,
        num_frames: int,
    ) -> bool: ...

class convert_bufferAudioAggregatorPadClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioAggregatorPadClass.convert_buffer
    """
    #  pad
    def __call__(
        self,
        pad: AudioAggregatorPad,
        in_info: AudioInfo,
        out_info: AudioInfo,
        buffer: Gst.Buffer,
    ) -> Gst.Buffer: ...

class update_conversion_infoAudioAggregatorPadClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioAggregatorPadClass.update_conversion_info
    """
    #  pad
    def __call__(
        self,
        pad: AudioAggregatorPad,
    ) -> None: ...

class AudioBaseSinkCustomSlavingCallback(typing.Protocol):
    """
    This callback was used in:
        GstAudio.set_custom_slaving_callback
    """
    #  sink
    def __call__(
        self,
        sink: AudioBaseSink,
        etime: int,
        itime: int,
        requested_skew: int,
        discont_reason: AudioBaseSinkDiscontReason,
        *user_data: object | None,
    ) -> None: ...

class create_ringbufferAudioBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioBaseSinkClass.create_ringbuffer
    """
    #  sink
    def __call__(
        self,
        sink: AudioBaseSink,
    ) -> AudioRingBuffer | None: ...

class payloadAudioBaseSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioBaseSinkClass.payload
    """
    #  sink
    def __call__(
        self,
        sink: AudioBaseSink,
        buffer: Gst.Buffer,
    ) -> Gst.Buffer: ...

class create_ringbufferAudioBaseSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioBaseSrcClass.create_ringbuffer
    """
    #  src
    def __call__(
        self,
        src: AudioBaseSrc,
    ) -> AudioRingBuffer | None: ...

class openAudioCdSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioCdSrcClass.open
    """
    #  src
    def __call__(
        self,
        src: AudioCdSrc,
        device: str,
    ) -> bool: ...

class closeAudioCdSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioCdSrcClass.close
    """
    #  src
    def __call__(
        self,
        src: AudioCdSrc,
    ) -> None: ...

class read_sectorAudioCdSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioCdSrcClass.read_sector
    """
    #  src
    def __call__(
        self,
        src: AudioCdSrc,
        sector: int,
    ) -> Gst.Buffer: ...

class AudioClockGetTimeFuncAudioClockCB(typing.Protocol):
    """
    This callback was used in:
        AudioClock.func
    """
    #  clock
    def __call__(
        self,
        clock: Gst.Clock,
        *user_data: object | None,
    ) -> int: ...

DestroyNotify = GLib.DestroyNotify  # type: ignore

class AudioClockGetTimeFunc(typing.Protocol):
    """
    This callback was used in:
        GstAudio.new
    """
    #  clock
    def __call__(
        self,
        clock: Gst.Clock,
        *user_data: object | None,
    ) -> int: ...

class startAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.start
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
    ) -> bool: ...

class stopAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.stop
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
    ) -> bool: ...

class set_formatAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.set_format
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        caps: Gst.Caps,
    ) -> bool: ...

class parseAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.parse
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        adapter: GstBase.Adapter,
    ) -> tuple[Gst.FlowReturn, int, int]: ...

class handle_frameAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.handle_frame
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class flushAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.flush
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        hard: bool,
    ) -> None: ...

class pre_pushAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.pre_push
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class sink_eventAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.sink_event
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        event: Gst.Event,
    ) -> bool: ...

class src_eventAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.src_event
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        event: Gst.Event,
    ) -> bool: ...

class openAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.open
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
    ) -> bool: ...

class closeAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.close
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
    ) -> bool: ...

class negotiateAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.negotiate
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
    ) -> bool: ...

class decide_allocationAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.decide_allocation
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        query: Gst.Query,
    ) -> bool: ...

class propose_allocationAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.propose_allocation
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        query: Gst.Query,
    ) -> bool: ...

class sink_queryAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.sink_query
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        query: Gst.Query,
    ) -> bool: ...

class src_queryAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.src_query
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        query: Gst.Query,
    ) -> bool: ...

class getcapsAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.getcaps
    """
    #  dec
    def __call__(
        self,
        dec: AudioDecoder,
        filter: Gst.Caps,
    ) -> Gst.Caps: ...

class transform_metaAudioDecoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioDecoderClass.transform_meta
    """
    #  enc
    def __call__(
        self,
        enc: AudioDecoder,
        outbuf: Gst.Buffer,
        meta: Gst.Meta,
        inbuf: Gst.Buffer,
    ) -> bool: ...

class startAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.start
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
    ) -> bool: ...

class stopAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.stop
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
    ) -> bool: ...

class set_formatAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.set_format
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
        info: AudioInfo,
    ) -> bool: ...

class handle_frameAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.handle_frame
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class flushAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.flush
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
    ) -> None: ...

class pre_pushAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.pre_push
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
        buffer: Gst.Buffer,
    ) -> Gst.FlowReturn: ...

class sink_eventAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.sink_event
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
        event: Gst.Event,
    ) -> bool: ...

class src_eventAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.src_event
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
        event: Gst.Event,
    ) -> bool: ...

class getcapsAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.getcaps
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
        filter: Gst.Caps,
    ) -> Gst.Caps: ...

class openAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.open
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
    ) -> bool: ...

class closeAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.close
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
    ) -> bool: ...

class negotiateAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.negotiate
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
    ) -> bool: ...

class decide_allocationAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.decide_allocation
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
        query: Gst.Query,
    ) -> bool: ...

class propose_allocationAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.propose_allocation
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
        query: Gst.Query,
    ) -> bool: ...

class transform_metaAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.transform_meta
    """
    #  enc
    def __call__(
        self,
        enc: AudioEncoder,
        outbuf: Gst.Buffer,
        meta: Gst.Meta,
        inbuf: Gst.Buffer,
    ) -> bool: ...

class sink_queryAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.sink_query
    """
    #  encoder
    def __call__(
        self,
        encoder: AudioEncoder,
        query: Gst.Query,
    ) -> bool: ...

class src_queryAudioEncoderClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioEncoderClass.src_query
    """
    #  encoder
    def __call__(
        self,
        encoder: AudioEncoder,
        query: Gst.Query,
    ) -> bool: ...

class setupAudioFilterClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioFilterClass.setup
    """
    #  filter
    def __call__(
        self,
        filter: AudioFilter,
        info: AudioInfo,
    ) -> bool: ...

class AudioFormatUnpackAudioFormatInfoCB(typing.Protocol):
    """
    This callback was used in:
        AudioFormatInfo.unpack_func
    """
    #  info
    def __call__(
        self,
        info: AudioFormatInfo,
        flags: AudioPackFlags,
        dest: list,
        data: list,
        length: int,
    ) -> None: ...

class AudioFormatPackAudioFormatInfoCB(typing.Protocol):
    """
    This callback was used in:
        AudioFormatInfo.pack_func
    """
    #  info
    def __call__(
        self,
        info: AudioFormatInfo,
        flags: AudioPackFlags,
        src: list,
        data: list,
        length: int,
    ) -> None: ...

class AudioRingBufferCallbackAudioRingBufferCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBuffer.callback
    """
    #  rbuf
    def __call__(
        self,
        rbuf: AudioRingBuffer,
        data: list,
        len: int,
        *user_data: object | None,
    ) -> None: ...

class AudioRingBufferCallback(typing.Protocol):
    """
    This callback was used in:
        GstAudio.set_callback
    """
    #  rbuf
    def __call__(
        self,
        rbuf: AudioRingBuffer,
        data: list,
        len: int,
        *user_data: object | None,
    ) -> None: ...

class open_deviceAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.open_device
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
    ) -> bool: ...

class acquireAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.acquire
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
        spec: AudioRingBufferSpec,
    ) -> bool: ...

class releaseAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.release
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
    ) -> bool: ...

class close_deviceAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.close_device
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
    ) -> bool: ...

class startAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.start
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
    ) -> bool: ...

class pauseAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.pause
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
    ) -> bool: ...

class resumeAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.resume
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
    ) -> bool: ...

class stopAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.stop
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
    ) -> bool: ...

class delayAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.delay
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
    ) -> int: ...

class activateAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.activate
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
        active: bool,
    ) -> bool: ...

class commitAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.commit
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
        sample: int,
        data: list,
        in_samples: int,
        out_samples: int,
        accum: int,
    ) -> tuple[int, int, int]: ...

class clear_allAudioRingBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioRingBufferClass.clear_all
    """
    #  buf
    def __call__(
        self,
        buf: AudioRingBuffer,
    ) -> None: ...

class openAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.open
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
    ) -> bool: ...

class prepareAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.prepare
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
        spec: AudioRingBufferSpec,
    ) -> bool: ...

class unprepareAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.unprepare
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
    ) -> bool: ...

class closeAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.close
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
    ) -> bool: ...

class writeAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.write
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
        data: list,
        length: int,
    ) -> int: ...

class delayAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.delay
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
    ) -> int: ...

class resetAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.reset
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
    ) -> None: ...

class pauseAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.pause
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
    ) -> None: ...

class resumeAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.resume
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
    ) -> None: ...

class stopAudioSinkClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClass.stop
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
    ) -> None: ...

class clear_allAudioSinkClassExtensionCB(typing.Protocol):
    """
    This callback was used in:
        AudioSinkClassExtension.clear_all
    """
    #  sink
    def __call__(
        self,
        sink: AudioSink,
    ) -> None: ...

class openAudioSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSrcClass.open
    """
    #  src
    def __call__(
        self,
        src: AudioSrc,
    ) -> bool: ...

class prepareAudioSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSrcClass.prepare
    """
    #  src
    def __call__(
        self,
        src: AudioSrc,
        spec: AudioRingBufferSpec,
    ) -> bool: ...

class unprepareAudioSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSrcClass.unprepare
    """
    #  src
    def __call__(
        self,
        src: AudioSrc,
    ) -> bool: ...

class closeAudioSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSrcClass.close
    """
    #  src
    def __call__(
        self,
        src: AudioSrc,
    ) -> bool: ...

class readAudioSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSrcClass.read
    """
    #  src
    def __call__(
        self,
        src: AudioSrc,
        data: list,
        length: int,
    ) -> tuple[int, int]: ...

class delayAudioSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSrcClass.delay
    """
    #  src
    def __call__(
        self,
        src: AudioSrc,
    ) -> int: ...

class resetAudioSrcClassCB(typing.Protocol):
    """
    This callback was used in:
        AudioSrcClass.reset
    """
    #  src
    def __call__(
        self,
        src: AudioSrc,
    ) -> None: ...

###############################################################
# Aliases
###############################################################

_lock = _thread._lock  # type: ignore
_overrides_module = ...  # this very module ...
###############################################################
# Constants
###############################################################

AUDIO_CHANNELS_RANGE: str = ...
AUDIO_CONVERTER_OPT_DITHER_METHOD: str = ...
AUDIO_CONVERTER_OPT_DITHER_THRESHOLD: str = ...
AUDIO_CONVERTER_OPT_MIX_MATRIX: str = ...
AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD: str = ...
AUDIO_CONVERTER_OPT_QUANTIZATION: str = ...
AUDIO_CONVERTER_OPT_RESAMPLER_METHOD: str = ...
AUDIO_DECODER_MAX_ERRORS: int = ...
AUDIO_DECODER_SINK_NAME: str = ...
AUDIO_DECODER_SRC_NAME: str = ...
AUDIO_DEF_CHANNELS: int = ...
AUDIO_DEF_FORMAT: str = ...
AUDIO_DEF_RATE: int = ...
AUDIO_ENCODER_SINK_NAME: str = ...
AUDIO_ENCODER_SRC_NAME: str = ...
AUDIO_FORMATS_ALL: str = ...
AUDIO_FORMAT_LAST: int = ...
AUDIO_RATE_RANGE: str = ...
AUDIO_RESAMPLER_OPT_CUBIC_B: str = ...
AUDIO_RESAMPLER_OPT_CUBIC_C: str = ...
AUDIO_RESAMPLER_OPT_CUTOFF: str = ...
AUDIO_RESAMPLER_OPT_FILTER_INTERPOLATION: str = ...
AUDIO_RESAMPLER_OPT_FILTER_MODE: str = ...
AUDIO_RESAMPLER_OPT_FILTER_MODE_THRESHOLD: str = ...
AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE: str = ...
AUDIO_RESAMPLER_OPT_MAX_PHASE_ERROR: str = ...
AUDIO_RESAMPLER_OPT_N_TAPS: str = ...
AUDIO_RESAMPLER_OPT_STOP_ATTENUATION: str = ...
AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH: str = ...
AUDIO_RESAMPLER_QUALITY_DEFAULT: int = ...
AUDIO_RESAMPLER_QUALITY_MAX: int = ...
AUDIO_RESAMPLER_QUALITY_MIN: int = ...
DSD_FORMATS_ALL: str = ...
DSD_MEDIA_TYPE: str = ...
DSD_SILENCE_PATTERN_BYTE: int = ...
META_TAG_AUDIO_CHANNELS_STR: str = ...
META_TAG_AUDIO_RATE_STR: str = ...
META_TAG_AUDIO_STR: str = ...
META_TAG_DSD_PLANE_OFFSETS_STR: str = ...
_namespace: str = ...
_version: str = ...
