# pyright: reportIncompatibleMethodOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: Gsk
Date: 2025-12-27
"""
# we disable method override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401

import _thread
import builtins
import typing

# gi.repository imports needed by this Stub
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gdk
from gi.repository import Graphene
from gi.repository import Pango
from gi.repository import cairo
###############################################################
# Functions
###############################################################

@staticmethod
def path_parse(
    string: str,
) -> Path | None:
    """
    Constructs a path from a serialized form.

    The string is expected to be in (a superset of)
    [SVG path syntax](https://www.w3.org/TR/SVG11/paths.htmlPathData),
    as e.g. produced by [method`Gsk`.Path.to_string].

    A high-level summary of the syntax:

    - `M x y` Move to `(x, y)`
    - `L x y` Add a line from the current point to `(x, y)`
    - `Q x1 y1 x2 y2` Add a quadratic Bézier from the current point to `(x2, y2)`, with control point `(x1, y1)`
    - `C x1 y1 x2 y2 x3 y3` Add a cubic Bézier from the current point to `(x3, y3)`, with control points `(x1, y1)` and `(x2, y2)`
    - `Z` Close the contour by drawing a line back to the start point
    - `H x` Add a horizontal line from the current point to the given x value
    - `V y` Add a vertical line from the current point to the given y value
    - `T x2 y2` Add a quadratic Bézier, using the reflection of the previous segments' control point as control point
    - `S x2 y2 x3 y3` Add a cubic Bézier, using the reflection of the previous segments' second control point as first control point
    - `A rx ry r l s x y` Add an elliptical arc from the current point to `(x, y)` with radii rx and ry. See the SVG documentation for how the other parameters influence the arc.
    - `O x1 y1 x2 y2 w` Add a rational quadratic Bézier from the current point to `(x2, y2)` with control point `(x1, y1)` and weight `w`.

    All the commands have lowercase variants that interpret coordinates
    relative to the current point.

    The `O` command is an extension that is not supported in SVG.
    """
    ...

@staticmethod
def serialization_error_quark() -> int:
    """
    Registers an error quark for [class`Gsk`.RenderNode] errors.
    """
    ...

@staticmethod
def stroke_equal(
    stroke1: object | None = None,
    stroke2: object | None = None,
) -> bool:
    """
    Checks if two strokes are identical.
    """
    ...

@staticmethod
def transform_parse(
    string: str,
) -> tuple[bool, Transform]:
    """
    Parses a given into a transform.

    Strings printed via [method`Gsk`.Transform.to_string]
    can be read in again successfully using this function.

    If `string` does not describe a valid transform, false
    is returned and `None` is put in `out_transform`.
    """
    ...

@staticmethod
def value_dup_render_node(
    value: GObject.Value,
) -> RenderNode | None:
    """
    Retrieves the render node stored inside a `GValue`,
    and acquires a reference to it.
    """
    ...

@staticmethod
def value_get_render_node(
    value: GObject.Value,
) -> RenderNode | None:
    """
    Retrieves the render node stored inside a `GValue`.
    """
    ...

@staticmethod
def value_set_render_node(
    value: GObject.Value,
    node: RenderNode,
) -> None:
    """
    Stores the given render node inside a `GValue`.

    The [struct`GObject`.Value] will acquire a reference
    to the render node.
    """
    ...

@staticmethod
def value_take_render_node(
    value: GObject.Value,
    node: RenderNode | None = None,
) -> None:
    """
    Stores the given render node inside a `GValue`.

    This function transfers the ownership of the
    render node to the `GValue`.
    """
    ...

###############################################################
# Enums/Flags
###############################################################

class BlendMode(GObject.GEnum):
    """
    The blend modes available for render nodes.

    The implementation of each blend mode is deferred to the
    rendering pipeline.

    See <https://www.w3.org/TR/compositing-1/#blending> for more information
    on blending and blend modes."""

    DEFAULT = 0
    """
    The default blend mode, which specifies no blending
    """
    MULTIPLY = 1
    """
    The source color is multiplied by the destination
      and replaces the destination
    """
    SCREEN = 2
    """
    Multiplies the complements of the destination and source
      color values, then complements the result.
    """
    OVERLAY = 3
    """
    Multiplies or screens the colors, depending on the
      destination color value. This is the inverse of hard-list
    """
    DARKEN = 4
    """
    Selects the darker of the destination and source colors
    """
    LIGHTEN = 5
    """
    Selects the lighter of the destination and source colors
    """
    COLOR_DODGE = 6
    """
    Brightens the destination color to reflect the source color
    """
    COLOR_BURN = 7
    """
    Darkens the destination color to reflect the source color
    """
    HARD_LIGHT = 8
    """
    Multiplies or screens the colors, depending on the source color value
    """
    SOFT_LIGHT = 9
    """
    Darkens or lightens the colors, depending on the source color value
    """
    DIFFERENCE = 10
    """
    Subtracts the darker of the two constituent colors from the lighter color
    """
    EXCLUSION = 11
    """
    Produces an effect similar to that of the difference mode but lower in contrast
    """
    COLOR = 12
    """
    Creates a color with the hue and saturation of the source color and the luminosity of the destination color
    """
    HUE = 13
    """
    Creates a color with the hue of the source color and the saturation and luminosity of the destination color
    """
    SATURATION = 14
    """
    Creates a color with the saturation of the source color and the hue and luminosity of the destination color
    """
    LUMINOSITY = 15
    """
    Creates a color with the luminosity of the source color and the hue and saturation of the destination color
    """

class Corner(GObject.GEnum):
    """
    The corner indices used by `GskRoundedRect`."""

    TOP_LEFT = 0
    """
    The top left corner
    """
    TOP_RIGHT = 1
    """
    The top right corner
    """
    BOTTOM_RIGHT = 2
    """
    The bottom right corner
    """
    BOTTOM_LEFT = 3
    """
    The bottom left corner
    """

class FillRule(GObject.GEnum):
    """
    Specifies how paths are filled.

    Whether or not a point is included in the fill is determined by taking
    a ray from that point to infinity and looking at intersections with the
    path. The ray can be in any direction, as long as it doesn't pass through
    the end point of a segment or have a tricky intersection such as
    intersecting tangent to the path.

    (Note that filling is not actually implemented in this way. This
    is just a description of the rule that is applied.)

    New entries may be added in future versions."""

    WINDING = 0
    """
    If the path crosses the ray from
      left-to-right, counts +1. If the path crosses the ray
      from right to left, counts -1. (Left and right are determined
      from the perspective of looking along the ray from the starting
      point.) If the total count is non-zero, the point will be filled.
    """
    EVEN_ODD = 1
    """
    Counts the total number of
      intersections, without regard to the orientation of the contour. If
      the total number of intersections is odd, the point will be
      filled.
    """

class GLUniformType(GObject.GEnum):
    """
    Defines the types of the uniforms that `GskGLShaders` declare.

    It defines both what the type is called in the GLSL shader
    code, and what the corresponding C type is on the Gtk side."""

    NONE = 0
    """
    No type, used for uninitialized or unspecified values.
    """
    FLOAT = 1
    """
    A float uniform
    """
    INT = 2
    """
    A GLSL int / gint32 uniform
    """
    UINT = 3
    """
    A GLSL uint / guint32 uniform
    """
    BOOL = 4
    """
    A GLSL bool / gboolean uniform
    """
    VEC2 = 5
    """
    A GLSL vec2 / graphene_vec2_t uniform
    """
    VEC3 = 6
    """
    A GLSL vec3 / graphene_vec3_t uniform
    """
    VEC4 = 7
    """
    A GLSL vec4 / graphene_vec4_t uniform
    """

class LineCap(GObject.GEnum):
    """
    Specifies how to render the start and end points of contours or
    dashes when stroking.

    The default line cap style is `GSK_LINE_CAP_BUTT`.

    New entries may be added in future versions.

    <figure>
      <picture>
        <source srcset="caps-dark.png" media="(prefers-color-scheme: dark)">
        <img alt="Line Cap Styles" src="caps-light.png">
      </picture>
      <figcaption>GSK_LINE_CAP_BUTT, GSK_LINE_CAP_ROUND, GSK_LINE_CAP_SQUARE</figcaption>
    </figure>"""

    BUTT = 0
    """
    Start and stop the line exactly at the start
      and end point
    """
    ROUND = 1
    """
    Use a round ending, the center of the circle
      is the start or end point
    """
    SQUARE = 2
    """
    use squared ending, the center of the square
      is the start or end point
    """

class LineJoin(GObject.GEnum):
    """
    Specifies how to render the junction of two lines when stroking.

    The default line join style is `GSK_LINE_JOIN_MITER`.

    New entries may be added in future versions.

    <figure>
      <picture>
        <source srcset="join-dark.png" media="(prefers-color-scheme: dark)">
        <img alt="Line Join Styles" src="join-light.png">
      </picture>
      <figcaption>GSK_LINE_JOINT_MITER, GSK_LINE_JOINT_ROUND, GSK_LINE_JOIN_BEVEL</figcaption>
    </figure>"""

    MITER = 0
    """
    Use a sharp angled corner
    """
    ROUND = 1
    """
    Use a round join, the center of the circle is
      the join point
    """
    BEVEL = 2
    """
    use a cut-off join, the join is cut off at half
      the line width from the joint point
    """

class MaskMode(GObject.GEnum):
    """
    The mask modes available for mask nodes."""

    ALPHA = 0
    """
    Use the alpha channel of the mask
    """
    INVERTED_ALPHA = 1
    """
    Use the inverted alpha channel of the mask
    """
    LUMINANCE = 2
    """
    Use the luminance of the mask,
        multiplied by mask alpha
    """
    INVERTED_LUMINANCE = 3
    """
    Use the inverted luminance of the mask,
        multiplied by mask alpha
    """

class PathDirection(GObject.GEnum):
    """
    Used to pick one of the four tangents at a given point on the path.

    Note that the directions for `GSK_PATH_FROM_START`/`GSK_PATH_TO_END` and
    `GSK_PATH_TO_START`/`GSK_PATH_FROM_END` will coincide for smooth points.
    Only sharp turns will exhibit four different directions.

    <picture>
      <source srcset="directions-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="Path Tangents" src="directions-light.png">
    </picture>"""

    FROM_START = 0
    """
    The tangent in path direction of the incoming side
      of the path
    """
    TO_START = 1
    """
    The tangent against path direction of the incoming side
      of the path
    """
    TO_END = 2
    """
    The tangent in path direction of the outgoing side
      of the path
    """
    FROM_END = 3
    """
    The tangent against path direction of the outgoing
      side of the path
    """

class PathForeachFlags(GObject.GFlags):
    """
    Flags that can be passed to `Gsk.Path.foreach` to influence what
    kinds of operations the path is decomposed into.

    By default, [method`Gsk`.Path.foreach] will only emit a path with all
    operations flattened to straight lines to allow for maximum compatibility.
    The only operations emitted will be `GSK_PATH_MOVE`, `GSK_PATH_LINE` and
    `GSK_PATH_CLOSE`."""

    ONLY_LINES = 0
    """
    The default behavior, only allow lines.
    """
    QUAD = 1
    """
    Allow emission of `GSK_PATH_QUAD` operations
    """
    CUBIC = 2
    """
    Allow emission of `GSK_PATH_CUBIC` operations.
    """
    CONIC = 4
    """
    Allow emission of `GSK_PATH_CONIC` operations.
    """

class PathOperation(GObject.GEnum):
    """
    Describes the segments of a `GskPath`.

    More values may be added in the future."""

    MOVE = 0
    """
    A move-to operation, with 1 point describing the target point.
    """
    CLOSE = 1
    """
    A close operation ending the current contour with a line back
      to the starting point. Two points describe the start and end of the line.
    """
    LINE = 2
    """
    A line-to operation, with 2 points describing the start and
      end point of a straight line.
    """
    QUAD = 3
    """
    A curve-to operation describing a quadratic Bézier curve
      with 3 points describing the start point, the control point and the end
      point of the curve.
    """
    CUBIC = 4
    """
    A curve-to operation describing a cubic Bézier curve with 4
      points describing the start point, the two control points and the end point
      of the curve.
    """
    CONIC = 5
    """
    A rational quadratic Bézier curve with 3 points describing
      the start point, control point and end point of the curve. A weight for the
      curve will be passed, too.
    """

class RenderNodeType(GObject.GEnum):
    """
    The type of a node determines what the node is rendering."""

    NOT_A_RENDER_NODE = 0
    """
    Error type. No node will ever have this type.
    """
    CONTAINER_NODE = 1
    """
    A node containing a stack of children
    """
    CAIRO_NODE = 2
    """
    A node drawing a `cairo_surface_t`
    """
    COLOR_NODE = 3
    """
    A node drawing a single color rectangle
    """
    LINEAR_GRADIENT_NODE = 4
    """
    A node drawing a linear gradient
    """
    REPEATING_LINEAR_GRADIENT_NODE = 5
    """
    A node drawing a repeating linear gradient
    """
    RADIAL_GRADIENT_NODE = 6
    """
    A node drawing a radial gradient
    """
    REPEATING_RADIAL_GRADIENT_NODE = 7
    """
    A node drawing a repeating radial gradient
    """
    CONIC_GRADIENT_NODE = 8
    """
    A node drawing a conic gradient
    """
    BORDER_NODE = 9
    """
    A node stroking a border around an area
    """
    TEXTURE_NODE = 10
    """
    A node drawing a `GdkTexture`
    """
    INSET_SHADOW_NODE = 11
    """
    A node drawing an inset shadow
    """
    OUTSET_SHADOW_NODE = 12
    """
    A node drawing an outset shadow
    """
    TRANSFORM_NODE = 13
    """
    A node that renders its child after applying a matrix transform
    """
    OPACITY_NODE = 14
    """
    A node that changes the opacity of its child
    """
    COLOR_MATRIX_NODE = 15
    """
    A node that applies a color matrix to every pixel
    """
    REPEAT_NODE = 16
    """
    A node that repeats the child's contents
    """
    CLIP_NODE = 17
    """
    A node that clips its child to a rectangular area
    """
    ROUNDED_CLIP_NODE = 18
    """
    A node that clips its child to a rounded rectangle
    """
    SHADOW_NODE = 19
    """
    A node that draws a shadow below its child
    """
    BLEND_NODE = 20
    """
    A node that blends two children together
    """
    CROSS_FADE_NODE = 21
    """
    A node that cross-fades between two children
    """
    TEXT_NODE = 22
    """
    A node containing a glyph string
    """
    BLUR_NODE = 23
    """
    A node that applies a blur
    """
    DEBUG_NODE = 24
    """
    Debug information that does not affect the rendering
    """
    GL_SHADER_NODE = 25
    """
    A node that uses OpenGL fragment shaders to render
    """
    TEXTURE_SCALE_NODE = 26
    """
    A node drawing a `GdkTexture` scaled and filtered.
    """
    MASK_NODE = 27
    """
    A node that masks one child with another.
    """
    FILL_NODE = 28
    """
    A node that fills a path.
    """
    STROKE_NODE = 29
    """
    A node that strokes a path.
    """
    SUBSURFACE_NODE = 30
    """
    A node that possibly redirects part of the scene graph to a subsurface.
    """

class ScalingFilter(GObject.GEnum):
    """
    The filters used when scaling texture data.

    The actual implementation of each filter is deferred to the
    rendering pipeline."""

    LINEAR = 0
    """
    linear interpolation filter
    """
    NEAREST = 1
    """
    nearest neighbor interpolation filter
    """
    TRILINEAR = 2
    """
    linear interpolation along each axis,
      plus mipmap generation, with linear interpolation along the mipmap
      levels
    """

class SerializationError(GObject.GEnum):
    """
    Errors that can happen during (de)serialization."""

    UNSUPPORTED_FORMAT = 0
    """
    The format can not be identified
    """
    UNSUPPORTED_VERSION = 1
    """
    The version of the data is not
      understood
    """
    INVALID_DATA = 2
    """
    The given data may not exist in
      a proper serialization
    """

class TransformCategory(GObject.GEnum):
    """
    The categories of matrices relevant for GSK and GTK.

    Note that any category includes matrices of all later categories.
    So if you want to for example check if a matrix is a 2D matrix,
    `category >= GSK_TRANSFORM_CATEGORY_2D` is the way to do this.

    Also keep in mind that rounding errors may cause matrices to not
    conform to their categories. Otherwise, matrix operations done via
    multiplication will not worsen categories. So for the matrix
    multiplication `C = A * B`, `category(C) = MIN (category(A), category(B))`."""

    UNKNOWN = 0
    """
    The category of the matrix has not been
      determined.
    """
    ANY = 1
    """
    Analyzing the matrix concluded that it does
      not fit in any other category.
    """
    _3D = 2  # [3d]: changed because started with a number
    """
    The matrix is a 3D matrix. This means that
      the w column (the last column) has the values (0, 0, 0, 1).
    """
    _2D = 3  # [2d]: changed because started with a number
    """
    The matrix is a 2D matrix. This is equivalent
      to `graphene_matrix_is_2d` returning True. In particular, this
      means that Cairo can deal with the matrix.
    """
    _2D_AFFINE = 4  # [2d_affine]: changed because started with a number
    """
    The matrix is a combination of 2D scale
      and 2D translation operations. In particular, this means that any
      rectangle can be transformed exactly using this matrix.
    """
    _2D_TRANSLATE = 5  # [2d_translate]: changed because started with a number
    """
    The matrix is a 2D translation.
    """
    IDENTITY = 6
    """
    The matrix is the identity matrix.
    """

###############################################################
# classes
###############################################################

class BlendNode(RenderNode):
    """
    A render node applying a blending function between its two child nodes.
    """

    # gi Methods
    def get_blend_mode(self) -> BlendMode:
        """
        Retrieves the blend mode used by `node`.
        """
    def get_bottom_child(self) -> RenderNode:
        """
        Retrieves the bottom `GskRenderNode` child of the `node`.
        """
    def get_top_child(self) -> RenderNode:
        """
        Retrieves the top `GskRenderNode` child of the `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        bottom: RenderNode,
        top: RenderNode,
        blend_mode: BlendMode,
    ) -> BlendNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(bottom:Gsk.RenderNode, top:Gsk.RenderNode, blend_mode:Gsk.BlendMode) -> Gsk.BlendNode
        """

class BlurNode(RenderNode):
    """
    A render node applying a blur effect to its single child.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Retrieves the child `GskRenderNode` of the blur `node`.
        """
    def get_radius(self) -> float:
        """
        Retrieves the blur radius of the `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        radius: float,
    ) -> BlurNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, radius:float) -> Gsk.BlurNode
        """

class BorderNode(RenderNode):
    """
    A render node for a border.
    """

    # gi Methods
    def get_colors(self) -> list:
        """
        Retrieves the colors of the border.
        """
    def get_outline(self) -> RoundedRect:
        """
        Retrieves the outline of the border.
        """
    def get_widths(self) -> list:
        """
        Retrieves the stroke widths of the border.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        outline: RoundedRect,
        border_width: list,
        border_color: list,
    ) -> BorderNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(outline:Gsk.RoundedRect, border_width:list, border_color:list) -> Gsk.BorderNode
        """

class BroadwayRenderer(Renderer):
    """
    A Broadway based renderer.

    See [class`Gsk`.Renderer].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize BroadwayRenderer object with properties.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
    ) -> Renderer:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gsk.Renderer
        """

class BroadwayRendererClass(GObject.GPointer): ...

class CairoNode(RenderNode):
    """
    A render node for a Cairo surface.
    """

    # gi Methods
    def get_draw_context(self) -> cairo.Context:
        """
            Creates a Cairo context for drawing using the surface associated
        to the render node.

        If no surface exists yet, a surface will be created optimized for
        rendering to `renderer`.
        """
    def get_surface(self) -> cairo.Surface:
        """
        Retrieves the Cairo surface used by the render node.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        bounds: Graphene.Rect,
    ) -> CairoNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(bounds:Graphene.Rect) -> Gsk.CairoNode
        """

class CairoRenderer(Renderer):
    """
    Renders a GSK rendernode tree with cairo.

    Since it is using cairo, this renderer cannot support
    3D transformations.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize CairoRenderer object with properties.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
    ) -> Renderer:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gsk.Renderer
        """

class CairoRendererClass(GObject.GPointer): ...

class ClipNode(RenderNode):
    """
    A render node applying a rectangular clip to its single child node.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Gets the child node that is getting clipped by the given `node`.
        """
    def get_clip(self) -> Graphene.Rect:
        """
        Retrieves the clip rectangle for `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        clip: Graphene.Rect,
    ) -> ClipNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, clip:Graphene.Rect) -> Gsk.ClipNode
        """

class ColorMatrixNode(RenderNode):
    """
    A render node controlling the color matrix of its single child node.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Gets the child node that is getting its colors modified by the given `node`.
        """
    def get_color_matrix(self) -> Graphene.Matrix:
        """
        Retrieves the color matrix used by the `node`.
        """
    def get_color_offset(self) -> Graphene.Vec4:
        """
        Retrieves the color offset used by the `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        color_matrix: Graphene.Matrix,
        color_offset: Graphene.Vec4,
    ) -> ColorMatrixNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, color_matrix:Graphene.Matrix, color_offset:Graphene.Vec4) -> Gsk.ColorMatrixNode
        """

class ColorNode(RenderNode):
    """
    A render node for a solid color.
    """

    # gi Methods
    def get_color(self) -> Gdk.RGBA:
        """
            Retrieves the color of the given `node`.

        The value returned by this function will not be correct
        if the render node was created for a non-sRGB color.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        rgba: Gdk.RGBA,
        bounds: Graphene.Rect,
    ) -> ColorNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(rgba:Gdk.RGBA, bounds:Graphene.Rect) -> Gsk.ColorNode
        """

class ColorStop(GObject.GPointer):
    """
    A color stop in a gradient node.
    """

    # gi Fields
    color: Gdk.RGBA | None = ...  # type: ignore
    """
    the color at the given offset

    """
    offset: float = ...
    """
    the offset of the color stop

    """

class ConicGradientNode(RenderNode):
    """
    A render node for a conic gradient.
    """

    # gi Methods
    def get_angle(self) -> float:
        """
            Retrieves the angle for the gradient in radians, normalized in [0, 2 * PI].

        The angle is starting at the top and going clockwise, as expressed
        in the css specification:

            angle = 90 - `Gsk.ConicGradientNode.get_rotation`
        """
    def get_center(self) -> Graphene.Point:
        """
        Retrieves the center pointer for the gradient.
        """
    def get_color_stops(self) -> tuple[list, int]:
        """
        Retrieves the color stops in the gradient.
        """
    def get_n_color_stops(self) -> int:
        """
        Retrieves the number of color stops in the gradient.
        """
    def get_rotation(self) -> float:
        """
        Retrieves the rotation for the gradient in degrees.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        bounds: Graphene.Rect,
        center: Graphene.Point,
        rotation: float,
        color_stops: list,
    ) -> ConicGradientNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(bounds:Graphene.Rect, center:Graphene.Point, rotation:float, color_stops:list) -> Gsk.ConicGradientNode
        """

class ContainerNode(RenderNode):
    """
    A render node that can contain other render nodes.
    """

    # gi Methods
    def get_child(self, idx: int) -> RenderNode:
        """
        Gets one of the children of `container`.
        """
    def get_n_children(self) -> int:
        """
        Retrieves the number of direct children of `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        children: list,
    ) -> ContainerNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(children:list) -> Gsk.ContainerNode
        """

class CrossFadeNode(RenderNode):
    """
    A render node cross fading between two child nodes.
    """

    # gi Methods
    def get_end_child(self) -> RenderNode:
        """
        Retrieves the child `GskRenderNode` at the end of the cross-fade.
        """
    def get_progress(self) -> float:
        """
        Retrieves the progress value of the cross fade.
        """
    def get_start_child(self) -> RenderNode:
        """
        Retrieves the child `GskRenderNode` at the beginning of the cross-fade.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        start: RenderNode,
        end: RenderNode,
        progress: float,
    ) -> CrossFadeNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(start:Gsk.RenderNode, end:Gsk.RenderNode, progress:float) -> Gsk.CrossFadeNode
        """

class DebugNode(RenderNode):
    """
    A render node that emits a debugging message when drawing its
    child node.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Gets the child node that is getting drawn by the given `node`.
        """
    def get_message(self) -> str:
        """
        Gets the debug message that was set on this node
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        message: str,
    ) -> DebugNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, message:str) -> Gsk.DebugNode
        """

class FillNode(RenderNode):
    """
    A render node filling the area given by [struct`Gsk`.Path]
    and [enum`Gsk`.FillRule] with the child node.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Gets the child node that is getting drawn by the given `node`.
        """
    def get_fill_rule(self) -> FillRule:
        """
        Retrieves the fill rule used to determine how the path is filled.
        """
    def get_path(self) -> Path:
        """
            Retrieves the path used to describe the area filled with the contents of
        the `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        path: Path,
        fill_rule: FillRule,
    ) -> FillNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, path:Gsk.Path, fill_rule:Gsk.FillRule) -> Gsk.FillNode
        """

class GLRenderer(Renderer):
    """
    Renders a GSK rendernode tree with OpenGL.

    See [class`Gsk`.Renderer].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize GLRenderer object with properties.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
    ) -> Renderer:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gsk.Renderer
        """

class GLRendererClass(GObject.GPointer): ...

class GLShader(GObject.Object):
    """
    Implements a fragment shader using GLSL.

    A fragment shader gets the coordinates being rendered as input and
    produces the pixel values for that particular pixel. Additionally,
    the shader can declare a set of other input arguments, called
    uniforms (as they are uniform over all the calls to your shader in
    each instance of use). A shader can also receive up to 4
    textures that it can use as input when producing the pixel data.

    `GskGLShader` is usually used with `gtk_snapshot_push_gl_shader`
    to produce a [class`Gsk`.GLShaderNode] in the rendering hierarchy,
    and then its input textures are constructed by rendering the child
    nodes to textures before rendering the shader node itself. (You can
    pass texture nodes as children if you want to directly use a texture
    as input).

    The actual shader code is GLSL code that gets combined with
    some other code into the fragment shader. Since the exact
    capabilities of the GPU driver differs between different OpenGL
    drivers and hardware, GTK adds some defines that you can use
    to ensure your GLSL code runs on as many drivers as it can.

    If the OpenGL driver is GLES, then the shader language version
    is set to 100, and GSK_GLES will be defined in the shader.

    Otherwise, if the OpenGL driver does not support the 3.2 core profile,
    then the shader will run with language version 110 for GL2 and 130 for GL3,
    and GSK_LEGACY will be defined in the shader.

    If the OpenGL driver supports the 3.2 code profile, it will be used,
    the shader language version is set to 150, and GSK_GL3 will be defined
    in the shader.

    The main function the shader must implement is:

    ```glsl
     void mainImage(out vec4 fragColor,
                    in vec2 fragCoord,
                    in vec2 resolution,
                    in vec2 uv)
    ```

    Where the input `fragCoord` is the coordinate of the pixel we're
    currently rendering, relative to the boundary rectangle that was
    specified in the `GskGLShaderNode`, and `resolution` is the width and
    height of that rectangle. This is in the typical GTK coordinate
    system with the origin in the top left. `uv` contains the u and v
    coordinates that can be used to index a texture at the
    corresponding point. These coordinates are in the [0..1]x[0..1]
    region, with 0, 0 being in the lower left corder (which is typical
    for OpenGL).

    The output `fragColor` should be a RGBA color (with
    premultiplied alpha) that will be used as the output for the
    specified pixel location. Note that this output will be
    automatically clipped to the clip region of the glshader node.

    In addition to the function arguments the shader can define
    up to 4 uniforms for textures which must be called u_textureN
    (i.e. u_texture1 to u_texture4) as well as any custom uniforms
    you want of types int, uint, bool, float, vec2, vec3 or vec4.

    All textures sources contain premultiplied alpha colors, but if some
    there are outer sources of colors there is a `Gsk.premultiply` helper
    to compute premultiplication when needed.

    Note that GTK parses the uniform declarations, so each uniform has to
    be on a line by itself with no other code, like so:

    ```glsl
    uniform float u_time;
    uniform vec3 u_color;
    uniform sampler2D u_texture1;
    uniform sampler2D u_texture2;
    ```

    GTK uses the "gsk" namespace in the symbols it uses in the
    shader, so your code should not use any symbols with the prefix gsk
    or GSK. There are some helper functions declared that you can use:

    ```glsl
    vec4 GskTexture(sampler2D sampler, vec2 texCoords);
    ```

    This samples a texture (e.g. u_texture1) at the specified
    coordinates, and contains some helper ifdefs to ensure that
    it works on all OpenGL versions.

    You can compile the shader yourself using [method`Gsk`.GLShader.compile],
    otherwise the GSK renderer will do it when it handling the glshader
    node. If errors occurs, the returned `error` will include the glsl
    sources, so you can see what GSK was passing to the compiler. You
    can also set GSK_DEBUG=shaders in the environment to see the sources
    and other relevant information about all shaders that GSK is handling.

    # An example shader

    ```glsl
    uniform float position;
    uniform sampler2D u_texture1;
    uniform sampler2D u_texture2;

    void mainImage(out vec4 fragColor,
                   in vec2 fragCoord,
                   in vec2 resolution,
                   in vec2 uv) {
      vec4 source1 = GskTexture(u_texture1, uv);
      vec4 source2 = GskTexture(u_texture2, uv);

      fragColor = position * source1 + (1.0 - position) * source2;
    }
    ```
    """

    class Props(GObject.Object.Props):
        resource: str
        """
        Resource containing the source code for the shader.

        If the shader source is not coming from a resource, this
        will be None.
        """
        source: GLib.Bytes | None
        """
        The source code for the shader, as a `GBytes`.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, resource: str | None = None, source: GLib.Bytes | None = None) -> None:
        """
        Initialize GLShader object with properties.
        """
    @deprecated("deprecated")
    def compile(self, renderer: Renderer) -> bool:
        """
            Tries to compile the `shader` for the given `renderer`.

        If there is a problem, this function returns False and reports
        an error. You should use this function before relying on the shader
        for rendering and use a fallback with a simpler shader or without
        shaders if it fails.

        Note that this will modify the rendering state (for example
        change the current GL context) and requires the renderer to be
        set up. This means that the widget has to be realized. Commonly you
        want to call this from the realize signal of a widget, or during
        widget snapshot.
        """
    @deprecated("deprecated")
    def find_uniform_by_name(self, name: str) -> int:
        """
            Looks for a uniform by the name `name`, and returns the index
        of the uniform, or -1 if it was not found.
        """
    @deprecated("deprecated")
    def get_arg_bool(self, args: GLib.Bytes, idx: int) -> bool:
        """
            Gets the value of the uniform `idx` in the `args` block.

        The uniform must be of bool type.
        """
    @deprecated("deprecated")
    def get_arg_float(self, args: GLib.Bytes, idx: int) -> float:
        """
            Gets the value of the uniform `idx` in the `args` block.

        The uniform must be of float type.
        """
    @deprecated("deprecated")
    def get_arg_int(self, args: GLib.Bytes, idx: int) -> int:
        """
            Gets the value of the uniform `idx` in the `args` block.

        The uniform must be of int type.
        """
    @deprecated("deprecated")
    def get_arg_uint(self, args: GLib.Bytes, idx: int) -> int:
        """
            Gets the value of the uniform `idx` in the `args` block.

        The uniform must be of uint type.
        """
    @deprecated("deprecated")
    def get_arg_vec2(self, args: GLib.Bytes, idx: int, out_value: Graphene.Vec2) -> None:
        """
            Gets the value of the uniform `idx` in the `args` block.

        The uniform must be of vec2 type.
        """
    @deprecated("deprecated")
    def get_arg_vec3(self, args: GLib.Bytes, idx: int, out_value: Graphene.Vec3) -> None:
        """
            Gets the value of the uniform `idx` in the `args` block.

        The uniform must be of vec3 type.
        """
    @deprecated("deprecated")
    def get_arg_vec4(self, args: GLib.Bytes, idx: int, out_value: Graphene.Vec4) -> None:
        """
            Gets the value of the uniform `idx` in the `args` block.

        The uniform must be of vec4 type.
        """
    @deprecated("deprecated")
    def get_args_size(self) -> int:
        """
        Get the size of the data block used to specify arguments for this shader.
        """
    @deprecated("deprecated")
    def get_n_textures(self) -> int:
        """
            Returns the number of textures that the shader requires.

        This can be used to check that the a passed shader works
        in your usecase. It is determined by looking at the highest
        u_textureN value that the shader defines.
        """
    @deprecated("deprecated")
    def get_n_uniforms(self) -> int:
        """
        Get the number of declared uniforms for this shader.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_resource(self) -> str | None:
        """
            Gets the resource path for the GLSL sourcecode being used
        to render this shader.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_source(self) -> GLib.Bytes:
        """
        Gets the GLSL sourcecode being used to render this shader.
        """
    @deprecated("deprecated")
    def get_uniform_name(self, idx: int) -> str:
        """
        Get the name of the declared uniform for this shader at index `idx`.
        """
    @deprecated("deprecated")
    def get_uniform_offset(self, idx: int) -> int:
        """
        Get the offset into the data block where data for this uniforms is stored.
        """
    @deprecated("deprecated")
    def get_uniform_type(self, idx: int) -> GLUniformType:
        """
        Get the type of the declared uniform for this shader at index `idx`.
        """

    # python methods (overrides?)
    @classmethod
    def new_from_bytes(
        cls,
        sourcecode: GLib.Bytes,
    ) -> GLShader:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_bytes(sourcecode:GLib.Bytes) -> Gsk.GLShader
        """
    @classmethod
    def new_from_resource(
        cls,
        resource_path: str,
    ) -> GLShader:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_from_resource(resource_path:str) -> Gsk.GLShader
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resource"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::source"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GLShaderClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

class GLShaderNode(RenderNode):
    """
    A render node using a GL shader when drawing its children nodes.
    """

    # gi Methods
    @deprecated("deprecated")
    def get_args(self) -> GLib.Bytes:
        """
        Gets args for the node.
        """
    @deprecated("deprecated")
    def get_child(self, idx: int) -> RenderNode:
        """
        Gets one of the children.
        """
    @deprecated("deprecated")
    def get_n_children(self) -> int:
        """
        Returns the number of children
        """
    def get_shader(self) -> GLShader:
        """
        Gets shader code for the node.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        shader: GLShader,
        bounds: Graphene.Rect,
        args: GLib.Bytes,
        children: list | None = None,
    ) -> GLShaderNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(shader:Gsk.GLShader, bounds:Graphene.Rect, args:GLib.Bytes, children:list=None) -> Gsk.GLShaderNode
        """

class InsetShadowNode(RenderNode):
    """
    A render node for an inset shadow.
    """

    # gi Methods
    def get_blur_radius(self) -> float:
        """
        Retrieves the blur radius to apply to the shadow.
        """
    def get_color(self) -> Gdk.RGBA:
        """
            Retrieves the color of the inset shadow.

        The value returned by this function will not be correct
        if the render node was created for a non-sRGB color.
        """
    def get_dx(self) -> float:
        """
        Retrieves the horizontal offset of the inset shadow.
        """
    def get_dy(self) -> float:
        """
        Retrieves the vertical offset of the inset shadow.
        """
    def get_outline(self) -> RoundedRect:
        """
        Retrieves the outline rectangle of the inset shadow.
        """
    def get_spread(self) -> float:
        """
        Retrieves how much the shadow spreads inwards.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        outline: RoundedRect,
        color: Gdk.RGBA,
        dx: float,
        dy: float,
        spread: float,
        blur_radius: float,
    ) -> InsetShadowNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(outline:Gsk.RoundedRect, color:Gdk.RGBA, dx:float, dy:float, spread:float, blur_radius:float) -> Gsk.InsetShadowNode
        """

class LinearGradientNode(RenderNode):
    """
    A render node for a linear gradient.
    """

    # gi Methods
    def get_color_stops(self) -> tuple[list, int]:
        """
        Retrieves the color stops in the gradient.
        """
    def get_end(self) -> Graphene.Point:
        """
        Retrieves the final point of the linear gradient.
        """
    def get_n_color_stops(self) -> int:
        """
        Retrieves the number of color stops in the gradient.
        """
    def get_start(self) -> Graphene.Point:
        """
        Retrieves the initial point of the linear gradient.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        bounds: Graphene.Rect,
        start: Graphene.Point,
        end: Graphene.Point,
        color_stops: list,
    ) -> LinearGradientNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(bounds:Graphene.Rect, start:Graphene.Point, end:Graphene.Point, color_stops:list) -> Gsk.LinearGradientNode
        """

class MaskNode(RenderNode):
    """
    A render node masking one child node with another.
    """

    # gi Methods
    def get_mask(self) -> RenderNode:
        """
        Retrieves the mask `GskRenderNode` child of the `node`.
        """
    def get_mask_mode(self) -> MaskMode:
        """
        Retrieves the mask mode used by `node`.
        """
    def get_source(self) -> RenderNode:
        """
        Retrieves the source `GskRenderNode` child of the `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        source: RenderNode,
        mask: RenderNode,
        mask_mode: MaskMode,
    ) -> MaskNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(source:Gsk.RenderNode, mask:Gsk.RenderNode, mask_mode:Gsk.MaskMode) -> Gsk.MaskNode
        """

class NglRenderer(Renderer):
    """
    A GL based renderer.

    See [class`Gsk`.Renderer].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize NglRenderer object with properties.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
    ) -> Renderer:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gsk.Renderer
        """

class OpacityNode(RenderNode):
    """
    A render node controlling the opacity of its single child node.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Gets the child node that is getting opacityed by the given `node`.
        """
    def get_opacity(self) -> float:
        """
        Gets the transparency factor for an opacity node.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        opacity: float,
    ) -> OpacityNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, opacity:float) -> Gsk.OpacityNode
        """

class OutsetShadowNode(RenderNode):
    """
    A render node for an outset shadow.
    """

    # gi Methods
    def get_blur_radius(self) -> float:
        """
        Retrieves the blur radius of the shadow.
        """
    def get_color(self) -> Gdk.RGBA:
        """
            Retrieves the color of the outset shadow.

        The value returned by this function will not be correct
        if the render node was created for a non-sRGB color.
        """
    def get_dx(self) -> float:
        """
        Retrieves the horizontal offset of the outset shadow.
        """
    def get_dy(self) -> float:
        """
        Retrieves the vertical offset of the outset shadow.
        """
    def get_outline(self) -> RoundedRect:
        """
        Retrieves the outline rectangle of the outset shadow.
        """
    def get_spread(self) -> float:
        """
        Retrieves how much the shadow spreads outwards.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        outline: RoundedRect,
        color: Gdk.RGBA,
        dx: float,
        dy: float,
        spread: float,
        blur_radius: float,
    ) -> OutsetShadowNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(outline:Gsk.RoundedRect, color:Gdk.RGBA, dx:float, dy:float, spread:float, blur_radius:float) -> Gsk.OutsetShadowNode
        """

class ParseLocation(GObject.GPointer):
    """
    A location in a parse buffer.
    """

    # gi Fields
    bytes: int = ...
    """
    the offset of the location in the parse buffer, as bytes

    """
    chars: int = ...
    """
    the offset of the location in the parse buffer, as characters

    """
    line_bytes: int = ...
    """
    the position in the line, as bytes

    """
    line_chars: int = ...
    """
    the position in the line, as characters

    """
    lines: int = ...
    """
    the line of the location in the parse buffer

    """

class Path(GObject.GBoxed):
    """
    Describes lines and curves that are more complex than simple rectangles.

    Paths can used for rendering (filling or stroking) and for animations
    (e.g. as trajectories).

    `GskPath` is an immutable, opaque, reference-counted struct.
    After creation, you cannot change the types it represents. Instead,
    new `GskPath` objects have to be created. The [struct`Gsk`.PathBuilder]
    structure is meant to help in this endeavor.

    Conceptually, a path consists of zero or more contours (continuous, connected
    curves), each of which may or may not be closed. Contours are typically
    constructed from Bézier segments.

    <picture>
      <source srcset="path-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="A Path" src="path-light.png">
    </picture>
    """

    # gi Methods
    def foreach(self, flags: PathForeachFlags, func: PathForeachFunc, *user_data: object | None) -> bool:
        """
            Calls `func` for every operation of the path.

        Note that this may only approximate `self`, because paths can contain
        optimizations for various specialized contours, and depending on the
        `flags`, the path may be decomposed into simpler curves than the ones
        that it contained originally.

        This function serves two purposes:

        - When the `flags` allow everything, it provides access to the raw,
          unmodified data of the path.
        - When the `flags` disallow certain operations, it provides
          an approximation of the path using just the allowed operations.
        """
    def get_bounds(self) -> tuple[bool, Graphene.Rect]:
        """
            Computes the bounds of the given path.

        The returned bounds may be larger than necessary, because this
        function aims to be fast, not accurate. The bounds are guaranteed
        to contain the path.

        It is possible that the returned rectangle has 0 width and/or height.
        This can happen when the path only describes a point or an
        axis-aligned line.

        If the path is empty, false is returned and `bounds` are set to
        `graphene_rect_zero`. This is different from the case where the path
        is a single point at the origin, where the `bounds` will also be set to
        the zero rectangle but true will be returned.
        """
    def get_closest_point(self, point: Graphene.Point, threshold: float) -> tuple[bool, PathPoint, float]:
        """
            Computes the closest point on the path to the given point.

        If there is no point closer than the given threshold,
        false is returned.
        """
    def get_end_point(self) -> tuple[bool, PathPoint]:
        """
            Gets the end point of the path.

        An empty path has no points, so false
        is returned in this case.
        """
    def get_start_point(self) -> tuple[bool, PathPoint]:
        """
            Gets the start point of the path.

        An empty path has no points, so false
        is returned in this case.
        """
    def get_stroke_bounds(self, stroke: Stroke) -> tuple[bool, Graphene.Rect]:
        """
            Computes the bounds for stroking the given path with the
        given parameters.

        The returned bounds may be larger than necessary, because this
        function aims to be fast, not accurate. The bounds are guaranteed
        to contain the area affected by the stroke, including protrusions
        like miters.
        """
    def in_fill(self, point: Graphene.Point, fill_rule: FillRule) -> bool:
        """
            Returns whether a point is inside the fill area of a path.

        Note that this function assumes that filling a contour
        implicitly closes it.
        """
    def is_closed(self) -> bool:
        """
        Returns if the path represents a single closed contour.
        """
    def is_empty(self) -> bool:
        """
        Checks if the path is empty, i.e. contains no lines or curves.
        """
    @staticmethod
    def parse(string: str) -> Path | None:
        """
            Constructs a path from a serialized form.

        The string is expected to be in (a superset of)
        [SVG path syntax](https://www.w3.org/TR/SVG11/paths.htmlPathData),
        as e.g. produced by [method`Gsk`.Path.to_string].

        A high-level summary of the syntax:

        - `M x y` Move to `(x, y)`
        - `L x y` Add a line from the current point to `(x, y)`
        - `Q x1 y1 x2 y2` Add a quadratic Bézier from the current point to `(x2, y2)`, with control point `(x1, y1)`
        - `C x1 y1 x2 y2 x3 y3` Add a cubic Bézier from the current point to `(x3, y3)`, with control points `(x1, y1)` and `(x2, y2)`
        - `Z` Close the contour by drawing a line back to the start point
        - `H x` Add a horizontal line from the current point to the given x value
        - `V y` Add a vertical line from the current point to the given y value
        - `T x2 y2` Add a quadratic Bézier, using the reflection of the previous segments' control point as control point
        - `S x2 y2 x3 y3` Add a cubic Bézier, using the reflection of the previous segments' second control point as first control point
        - `A rx ry r l s x y` Add an elliptical arc from the current point to `(x, y)` with radii rx and ry. See the SVG documentation for how the other parameters influence the arc.
        - `O x1 y1 x2 y2 w` Add a rational quadratic Bézier from the current point to `(x2, y2)` with control point `(x1, y1)` and weight `w`.

        All the commands have lowercase variants that interpret coordinates
        relative to the current point.

        The `O` command is an extension that is not supported in SVG.
        """
    def print_(self, string: GLib.String) -> None: ...
    def ref(self) -> Path:
        """
        Increases the reference count of a path by one.
        """
    def to_cairo(self, cr: cairo.Context) -> None:
        """
            Appends the path to a cairo context for drawing with Cairo.

        This may cause some suboptimal conversions to be performed as
        Cairo does not support all features of `GskPath`.

        This function does not clear the existing Cairo path. Call
        `cairo_new_path` if you want this.
        """
    def to_string(self) -> str:
        """
            Converts the path into a human-readable string.

        You can use this function in a debugger to get a quick overview
        of the path.

        This is a wrapper around [method`Gsk`.Path.print], see that function
        for details.
        """
    def unref(self) -> None:
        """
            Decreases the reference count of a path by one.

        If the resulting reference count is zero, frees the path.
        """

class PathBuilder(GObject.GBoxed):
    """
    Constructs `GskPath` objects.

    A path is constructed like this:

    ```c
    GskPath *
    construct_path (void)
    {
      GskPathBuilder *builder;

      builder = gsk_path_builder_new ();

      // add contours to the path here

      return gsk_path_builder_free_to_path (builder);
    ```

    Adding contours to the path can be done in two ways.
    The easiest option is to use the `gsk_path_builder_add_*` group
    of functions that add predefined contours to the current path,
    either common shapes like [method`Gsk`.PathBuilder.add_circle]
    or by adding from other paths like [method`Gsk`.PathBuilder.add_path].

    The `gsk_path_builder_add_*` methods always add complete contours,
    and do not use or modify the current point.

    The other option is to define each line and curve manually with
    the `gsk_path_builder_*_to` group of functions. You start with
    a call to [method`Gsk`.PathBuilder.move_to] to set the starting point
    and then use multiple calls to any of the drawing functions to
    move the pen along the plane. Once you are done, you can call
    [method`Gsk`.PathBuilder.close] to close the path by connecting it
    back with a line to the starting point.

    This is similar to how paths are drawn in Cairo.

    Note that `GskPathBuilder` will reduce the degree of added Bézier
    curves as much as possible, to simplify rendering.
    """

    # gi Methods
    def add_cairo_path(self, path: cairo.Path) -> None:
        """
            Adds a Cairo path to the builder.

        You can use `cairo_copy_path` to access the path
        from a Cairo context.
        """
    def add_circle(self, center: Graphene.Point, radius: float) -> None:
        """
            Adds a circle as a new contour.

        The path is going around the circle in clockwise direction.

        If `radius` is zero, the contour will be a closed point.
        """
    def add_layout(self, layout: Pango.Layout) -> None:
        """
        Adds the outlines for the glyphs in `layout` to the builder.
        """
    def add_path(self, path: Path) -> None:
        """
        Appends all of `path` to the builder.
        """
    def add_rect(self, rect: Graphene.Rect) -> None:
        """
            Adds a rectangle as a new contour.

        The path is going around the rectangle in clockwise direction.

        If the the width or height are 0, the path will be a closed
        horizontal or vertical line. If both are 0, it'll be a closed dot.
        """
    def add_reverse_path(self, path: Path) -> None:
        """
        Appends all of `path` to the builder, in reverse order.
        """
    def add_rounded_rect(self, rect: RoundedRect) -> None:
        """
            Adds a rounded rectangle as a new contour.

        The path is going around the rectangle in clockwise direction.
        """
    def add_segment(self, path: Path, start: PathPoint, end: PathPoint) -> None:
        """
            Adds a segment of a path to the builder.

        If `start` is equal to or after `end`, the path will first add the
        segment from `start` to the end of the path, and then add the segment
        from the beginning to `end`. If the path is closed, these segments
        will be connected.

        Note that this method always adds a path with the given start point
        and end point. To add a closed path, use [method`Gsk`.PathBuilder.add_path].
        """
    def arc_to(self, x1: float, y1: float, x2: float, y2: float) -> None:
        """
            Adds an elliptical arc from the current point to `x2`, `y2`
        with `x1`, `y1` determining the tangent directions.

        After this, `x2`, `y2` will be the new current point.

        Note: Two points and their tangents do not determine
        a unique ellipse, so GSK just picks one. If you need more
        precise control, use [method`Gsk`.PathBuilder.conic_to]
        or [method`Gsk`.PathBuilder.svg_arc_to].

        <picture>
          <source srcset="arc-dark.png" media="(prefers-color-scheme: dark)">
          <img alt="Arc To" src="arc-light.png">
        </picture>
        """
    def close(self) -> None:
        """
            Ends the current contour with a line back to the start point.

        Note that this is different from calling [method`Gsk`.PathBuilder.line_to]
        with the start point in that the contour will be closed. A closed
        contour behaves differently from an open one. When stroking, its
        start and end point are considered connected, so they will be
        joined via the line join, and not ended with line caps.
        """
    def conic_to(self, x1: float, y1: float, x2: float, y2: float, weight: float) -> None:
        """
            Adds a [conic curve](https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline)
        from the current point to `x2`, `y2` with the given `weight` and `x1`, `y1` as the
        control point.

        The weight determines how strongly the curve is pulled towards the control point.
        A conic with weight 1 is identical to a quadratic Bézier curve with the same points.

        Conic curves can be used to draw ellipses and circles. They are also known as
        rational quadratic Bézier curves.

        After this, `x2`, `y2` will be the new current point.

        <picture>
          <source srcset="conic-dark.png" media="(prefers-color-scheme: dark)">
          <img alt="Conic To" src="conic-light.png">
        </picture>
        """
    def cubic_to(self, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> None:
        """
            Adds a [cubic Bézier curve](https://en.wikipedia.org/wiki/BC3A9zier_curve)
        from the current point to `x3`, `y3` with `x1`, `y1` and `x2`, `y2` as the control
        points.

        After this, `x3`, `y3` will be the new current point.

        <picture>
          <source srcset="cubic-dark.png" media="(prefers-color-scheme: dark)">
          <img alt="Cubic To" src="cubic-light.png">
        </picture>
        """
    def get_current_point(self) -> Graphene.Point:
        """
            Gets the current point.

        The current point is used for relative drawing commands and
        updated after every operation.

        When the builder is created, the default current point is set
        to `0, 0`. Note that this is different from cairo, which starts
        out without a current point.
        """
    def html_arc_to(self, x1: float, y1: float, x2: float, y2: float, radius: float) -> None:
        """
            Implements arc-to according to the HTML Canvas spec.

        A convenience function that implements the
        [HTML arc_to](https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-arcto-dev)
        functionality.

        After this, the current point will be the point where
        the circle with the given radius touches the line from
        `x1`, `y1` to `x2`, `y2`.
        """
    def line_to(self, x: float, y: float) -> None:
        """
            Draws a line from the current point to `x`, `y` and makes it
        the new current point.

        <picture>
          <source srcset="line-dark.png" media="(prefers-color-scheme: dark)">
          <img alt="Line To" src="line-light.png">
        </picture>
        """
    def move_to(self, x: float, y: float) -> None:
        """
            Starts a new contour by placing the pen at `x`, `y`.

        If this function is called twice in succession, the first
        call will result in a contour made up of a single point.
        The second call will start a new contour.
        """
    def quad_to(self, x1: float, y1: float, x2: float, y2: float) -> None:
        """
            Adds a [quadratic Bézier curve](https://en.wikipedia.org/wiki/BC3A9zier_curve)
        from the current point to `x2`, `y2` with `x1`, `y1` as the control point.

        After this, `x2`, `y2` will be the new current point.

        <picture>
          <source srcset="quad-dark.png" media="(prefers-color-scheme: dark)">
          <img alt="Quad To" src="quad-light.png">
        </picture>
        """
    def ref(self) -> PathBuilder:
        """
            Acquires a reference on the given builder.

        This function is intended primarily for language bindings.
        `GskPathBuilder` objects should not be kept around.
        """
    def rel_arc_to(self, x1: float, y1: float, x2: float, y2: float) -> None:
        """
            Adds an elliptical arc from the current point to `x2`, `y2`
        with `x1`, `y1` determining the tangent directions.

        All coordinates are given relative to the current point.

        This is the relative version of [method`Gsk`.PathBuilder.arc_to].
        """
    def rel_conic_to(self, x1: float, y1: float, x2: float, y2: float, weight: float) -> None:
        """
            Adds a [conic curve](https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline)
        from the current point to `x2`, `y2` with the given `weight` and `x1`, `y1` as the
        control point.

        All coordinates are given relative to the current point.

        This is the relative version of [method`Gsk`.PathBuilder.conic_to].
        """
    def rel_cubic_to(self, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> None:
        """
            Adds a [cubic Bézier curve](https://en.wikipedia.org/wiki/BC3A9zier_curve)
        from the current point to `x3`, `y3` with `x1`, `y1` and `x2`, `y2` as the control
        points.

        All coordinates are given relative to the current point.

        This is the relative version of [method`Gsk`.PathBuilder.cubic_to].
        """
    def rel_html_arc_to(self, x1: float, y1: float, x2: float, y2: float, radius: float) -> None:
        """
            Implements arc-to according to the HTML Canvas spec.

        All coordinates are given relative to the current point.

        This is the relative version of [method`Gsk`.PathBuilder.html_arc_to].
        """
    def rel_line_to(self, x: float, y: float) -> None:
        """
            Draws a line from the current point to a point offset from it
        by `x`, `y` and makes it the new current point.

        This is the relative version of [method`Gsk`.PathBuilder.line_to].
        """
    def rel_move_to(self, x: float, y: float) -> None:
        """
            Starts a new contour by placing the pen at `x`, `y`
        relative to the current point.

        This is the relative version of [method`Gsk`.PathBuilder.move_to].
        """
    def rel_quad_to(self, x1: float, y1: float, x2: float, y2: float) -> None:
        """
            Adds a [quadratic Bézier curve](https://en.wikipedia.org/wiki/BC3A9zier_curve)
        from the current point to `x2`, `y2` with `x1`, `y1` the control point.

        All coordinates are given relative to the current point.

        This is the relative version of [method`Gsk`.PathBuilder.quad_to].
        """
    def rel_svg_arc_to(
        self, rx: float, ry: float, x_axis_rotation: float, large_arc: bool, positive_sweep: bool, x: float, y: float
    ) -> None:
        """
            Implements arc-to according to the SVG spec.

        All coordinates are given relative to the current point.

        This is the relative version of [method`Gsk`.PathBuilder.svg_arc_to].
        """
    def svg_arc_to(
        self, rx: float, ry: float, x_axis_rotation: float, large_arc: bool, positive_sweep: bool, x: float, y: float
    ) -> None:
        """
            Implements arc-to according to the SVG spec.

        A convenience function that implements the
        [SVG arc_to](https://www.w3.org/TR/SVG11/paths.htmlPathDataEllipticalArcCommands)
        functionality.

        After this, `x`, `y` will be the new current point.
        """
    def to_path(self) -> Path:
        """
            Creates a new path from the given builder.

        The given `GskPathBuilder` is reset once this function returns;
        you cannot call this function multiple times on the same builder
        instance.

        This function is intended primarily for language bindings.
        C code should use [method`Gsk`.PathBuilder.free_to_path].
        """
    def unref(self) -> None:
        """
        Releases a reference on the given builder.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
    ) -> PathBuilder:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gsk.PathBuilder
        """

class PathMeasure(GObject.GBoxed):
    """
    Performs measurements on paths such as determining the length of the path.

    Many measuring operations require sampling the path length
    at intermediate points. Therefore, a `GskPathMeasure` has
    a tolerance that determines what precision is required
    for such approximations.

    A `GskPathMeasure` struct is a reference counted struct
    and should be treated as opaque.
    """

    # gi Methods
    def get_length(self) -> float:
        """
            Gets the length of the path being measured.

        The length is cached, so this function does not do any work.
        """
    def get_path(self) -> Path:
        """
        Returns the path that the measure was created for.
        """
    def get_point(self, distance: float) -> tuple[bool, PathPoint]:
        """
            Gets the point at the given distance into the path.

        An empty path has no points, so false is returned in that case.
        """
    def get_tolerance(self) -> float:
        """
        Returns the tolerance that the measure was created with.
        """
    def ref(self) -> PathMeasure:
        """
        Increases the reference count of a `GskPathMeasure` by one.
        """
    def unref(self) -> None:
        """
            Decreases the reference count of a `GskPathMeasure` by one.

        If the resulting reference count is zero, frees the object.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        path: Path,
    ) -> PathMeasure:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(path:Gsk.Path) -> Gsk.PathMeasure
        """
    @classmethod
    def new_with_tolerance(
        cls,
        path: Path,
        tolerance: float,
    ) -> PathMeasure:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_with_tolerance(path:Gsk.Path, tolerance:float) -> Gsk.PathMeasure
        """

class PathPoint(GObject.GBoxed):
    """
    Represents a point on a path.

    It can be queried for properties of the path at that point,
    such as its tangent or its curvature.

    To obtain a `GskPathPoint`, use [method`Gsk`.Path.get_closest_point],
    [method`Gsk`.Path.get_start_point], [method`Gsk`.Path.get_end_point]
    or [method`Gsk`.PathMeasure.get_point].

    Note that `GskPathPoint` structs are meant to be stack-allocated,
    and don't hold a reference to the path object they are obtained from.
    It is the callers responsibility to keep a reference to the path
    as long as the `GskPathPoint` is used.
    """

    # gi Methods
    def compare(self, point2: PathPoint) -> int:
        """
        Returns whether `point1` is before or after `point2`.
        """
    def copy(self) -> PathPoint:
        """
        Copies a path point.
        """
    def equal(self, point2: PathPoint) -> bool:
        """
            Returns whether the two path points refer to the same
        location on all paths.

        Note that the start- and endpoint of a closed contour
        will compare nonequal according to this definition.
        Use [method`Gsk`.Path.is_closed] to find out if the
        start- and endpoint of a concrete path refer to the
        same location.
        """
    def free(self) -> None:
        """
        Frees a path point copied by [method`Gsk`.PathPoint.copy].
        """
    def get_curvature(self, path: Path, direction: PathDirection) -> tuple[float, Graphene.Point | None]:
        """
            Calculates the curvature of the path at the point.

        Optionally, returns the center of the osculating circle as well.
        The curvature is the inverse of the radius of the osculating circle.

        Lines have a curvature of zero (indicating an osculating circle of
        infinite radius). In this case, the `center` is not modified.

        Circles with a radius of zero have `INFINITY` as curvature

        Note that certain points on a path may not have a single curvature,
        such as sharp turns. At such points, there are two curvatures — the
        (limit of) the curvature of the path going into the point, and the
        (limit of) the curvature of the path coming out of it. The `direction`
        argument lets you choose which one to get.

        <picture>
          <source srcset="curvature-dark.png" media="(prefers-color-scheme: dark)">
          <img alt="Osculating circle" src="curvature-light.png">
        </picture>
        """
    def get_distance(self, measure: PathMeasure) -> float:
        """
            Returns the distance from the beginning of the path
        to the point.
        """
    def get_position(self, path: Path) -> Graphene.Point:
        """
        Gets the position of the point.
        """
    def get_rotation(self, path: Path, direction: PathDirection) -> float:
        """
            Gets the direction of the tangent at a given point.

        This is a convenience variant of [method`Gsk`.PathPoint.get_tangent]
        that returns the angle between the tangent and the X axis. The angle
        can e.g. be used in
        [`gtk_snapshot_rotate`](../gtk4/method.Snapshot.rotate.html).
        """
    def get_tangent(self, path: Path, direction: PathDirection) -> Graphene.Vec2:
        """
            Gets the tangent of the path at the point.

        Note that certain points on a path may not have a single
        tangent, such as sharp turns. At such points, there are
        two tangents — the direction of the path going into the
        point, and the direction coming out of it. The `direction`
        argument lets you choose which one to get.

        If the path is just a single point (e.g. a circle with
        radius zero), then the tangent is set to `0, 0`.

        If you want to orient something in the direction of the
        path, [method`Gsk`.PathPoint.get_rotation] may be more
        convenient to use.
        """

class RadialGradientNode(RenderNode):
    """
    A render node for a radial gradient.
    """

    # gi Methods
    def get_center(self) -> Graphene.Point:
        """
        Retrieves the center pointer for the gradient.
        """
    def get_color_stops(self) -> tuple[list, int]:
        """
        Retrieves the color stops in the gradient.
        """
    def get_end(self) -> float:
        """
        Retrieves the end value for the gradient.
        """
    def get_hradius(self) -> float:
        """
        Retrieves the horizontal radius for the gradient.
        """
    def get_n_color_stops(self) -> int:
        """
        Retrieves the number of color stops in the gradient.
        """
    def get_start(self) -> float:
        """
        Retrieves the start value for the gradient.
        """
    def get_vradius(self) -> float:
        """
        Retrieves the vertical radius for the gradient.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        bounds: Graphene.Rect,
        center: Graphene.Point,
        hradius: float,
        vradius: float,
        start: float,
        end: float,
        color_stops: list,
    ) -> RadialGradientNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(bounds:Graphene.Rect, center:Graphene.Point, hradius:float, vradius:float, start:float, end:float, color_stops:list) -> Gsk.RadialGradientNode
        """

class RenderNode(object):
    """
    The basic block in a scene graph to be rendered using [class`Gsk`.Renderer].

    Each node has a parent, except the top-level node; each node may have
    children nodes.

    Each node has an associated drawing surface, which has the size of
    the rectangle set when creating it.

    Render nodes are meant to be transient; once they have been associated
    to a [class`Gsk`.Renderer] it's safe to release any reference you have on
    them. All [class`Gsk`.RenderNode]s are immutable, you can only specify their
    properties during construction.
    """

    # gi Methods
    @staticmethod
    def deserialize(
        bytes: GLib.Bytes, error_func: ParseErrorFunc | None = None, *user_data: object | None
    ) -> RenderNode | None:
        """
            Loads data previously created via [method`Gsk`.RenderNode.serialize].

        For a discussion of the supported format, see that function.
        """
    def draw(self, cr: cairo.Context) -> None:
        """
            Draws the contents of a render node on a cairo context.

        Typically, you'll use this function to implement fallback rendering
        of render nodes on an intermediate Cairo context, instead of using
        the drawing context associated to a [class`Gdk`.Surface]'s rendering buffer.

        For advanced nodes that cannot be supported using Cairo, in particular
        for nodes doing 3D operations, this function may fail.
        """
    def get_bounds(self) -> Graphene.Rect:
        """
            Retrieves the boundaries of the `node`.

        The node will not draw outside of its boundaries.
        """
    def get_node_type(self) -> RenderNodeType:
        """
        Returns the type of the render node.
        """
    def get_opaque_rect(self) -> tuple[bool, Graphene.Rect]:
        """
            Gets an opaque rectangle inside the node that GTK can determine to
        be fully opaque.

        There is no guarantee that this is indeed the largest opaque rectangle or
        that regions outside the rectangle are not opaque. This function is a best
        effort with that goal.

        The rectangle will be fully contained in the bounds of the node.
        """
    def ref(self) -> RenderNode:
        """
        Acquires a reference on the given `GskRenderNode`.
        """
    def serialize(self) -> GLib.Bytes:
        """
            Serializes the `node` for later deserialization via
        `Gsk.RenderNode.deserialize`. No guarantees are made about the format
        used other than that the same version of GTK will be able to deserialize
        the result of a call to `Gsk.RenderNode.serialize` and
        `Gsk.RenderNode.deserialize` will correctly reject files it cannot open
        that were created with previous versions of GTK.

        The intended use of this functions is testing, benchmarking and debugging.
        The format is not meant as a permanent storage format.
        """
    def unref(self) -> None:
        """
            Releases a reference on the given `GskRenderNode`.

        If the reference was the last, the resources associated to the `node` are
        freed.
        """
    def write_to_file(self, filename: str) -> bool:
        """
            This function is equivalent to calling [method`Gsk`.RenderNode.serialize]
        followed by [func`GLib`.file_set_contents].

        See those two functions for details on the arguments.

        It is mostly intended for use inside a debugger to quickly dump a render
        node to a file for later inspection.
        """

class Renderer(GObject.Object):
    """
    Renders a scene graph defined via a tree of [class`Gsk`.RenderNode] instances.

    Typically you will use a `GskRenderer` instance to repeatedly call
    [method`Gsk`.Renderer.render] to update the contents of its associated
    [class`Gdk`.Surface].

    It is necessary to realize a `GskRenderer` instance using
    [method`Gsk`.Renderer.realize] before calling [method`Gsk`.Renderer.render],
    in order to create the appropriate windowing system resources needed
    to render the scene.
    """

    class Props(GObject.Object.Props):
        realized: bool
        """
        Whether the renderer has been associated with a surface or draw context.
        """
        surface: Gdk.Surface | None
        """
        The surface associated with renderer.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize Renderer object with properties.
        """
    @builtins.property
    def get_surface(self) -> Gdk.Surface | None:
        """
            Retrieves the surface that the renderer is associated with.

        If the renderer has not been realized yet, `None` will be returned.
        """
    @builtins.property
    def is_realized(self) -> bool:
        """
        Checks whether the renderer is realized or not.
        """
    def realize(self, surface: Gdk.Surface | None = None) -> bool:
        """
            Creates the resources needed by the renderer.

        Since GTK 4.6, the surface may be `None`, which allows using
        renderers without having to create a surface. Since GTK 4.14,
        it is recommended to use [method`Gsk`.Renderer.realize_for_display]
        for this case.

        Note that it is mandatory to call [method`Gsk`.Renderer.unrealize]
        before destroying the renderer.
        """
    def realize_for_display(self, display: Gdk.Display) -> bool:
        """
            Creates the resources needed by the renderer.

        Note that it is mandatory to call [method`Gsk`.Renderer.unrealize]
        before destroying the renderer.
        """
    def render(self, root: RenderNode, region: cairo.Region | None = None) -> None:
        """
            Renders the scene graph, described by a tree of `GskRenderNode` instances
        to the renderer's surface, ensuring that the given region gets redrawn.

        If the renderer has no associated surface, this function does nothing.

        Renderers must ensure that changes of the contents given by the `root`
        node as well as the area given by `region` are redrawn. They are however
        free to not redraw any pixel outside of `region` if they can guarantee that
        it didn't change.

        The renderer will acquire a reference on the `GskRenderNode` tree while
        the rendering is in progress.
        """
    def render_texture(self, root: RenderNode, viewport: Graphene.Rect | None = None) -> Gdk.Texture:
        """
            Renders a scene graph, described by a tree of `GskRenderNode` instances,
        to a texture.

        The renderer will acquire a reference on the `GskRenderNode` tree while
        the rendering is in progress.

        If you want to apply any transformations to `root`, you should put it into a
        transform node and pass that node instead.
        """
    def unrealize(self) -> None:
        """
        Releases all the resources created by [method`Gsk`.Renderer.realize].
        """

    # python methods (overrides?)
    @classmethod
    def new_for_surface(
        cls,
        surface: Gdk.Surface,
    ) -> Renderer | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new_for_surface(surface:Gdk.Surface) -> Gsk.Renderer or None
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::realized"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::surface"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class RendererClass(GObject.GPointer): ...

class RepeatNode(RenderNode):
    """
    A render node repeating its single child node.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Retrieves the child of `node`.
        """
    def get_child_bounds(self) -> Graphene.Rect:
        """
        Retrieves the bounding rectangle of the child of `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        bounds: Graphene.Rect,
        child: RenderNode,
        child_bounds: Graphene.Rect | None = None,
    ) -> RepeatNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(bounds:Graphene.Rect, child:Gsk.RenderNode, child_bounds:Graphene.Rect=None) -> Gsk.RepeatNode
        """

class RepeatingLinearGradientNode(RenderNode):
    """
    A render node for a repeating linear gradient.
    """

    # gi Methods

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        bounds: Graphene.Rect,
        start: Graphene.Point,
        end: Graphene.Point,
        color_stops: list,
    ) -> RepeatingLinearGradientNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(bounds:Graphene.Rect, start:Graphene.Point, end:Graphene.Point, color_stops:list) -> Gsk.RepeatingLinearGradientNode
        """

class RepeatingRadialGradientNode(RenderNode):
    """
    A render node for a repeating radial gradient.
    """

    # gi Methods

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        bounds: Graphene.Rect,
        center: Graphene.Point,
        hradius: float,
        vradius: float,
        start: float,
        end: float,
        color_stops: list,
    ) -> RepeatingRadialGradientNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(bounds:Graphene.Rect, center:Graphene.Point, hradius:float, vradius:float, start:float, end:float, color_stops:list) -> Gsk.RepeatingRadialGradientNode
        """

class RoundedClipNode(RenderNode):
    """
    A render node applying a rounded rectangle clip to its single child.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Gets the child node that is getting clipped by the given `node`.
        """
    def get_clip(self) -> RoundedRect:
        """
        Retrieves the rounded rectangle used to clip the contents of the `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        clip: RoundedRect,
    ) -> RoundedClipNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, clip:Gsk.RoundedRect) -> Gsk.RoundedClipNode
        """

class RoundedRect(GObject.GPointer):
    """
    A rectangular region with rounded corners.

    Application code should normalize rectangles using
    [method`Gsk`.RoundedRect.normalize]; this function will ensure that
    the bounds of the rectangle are normalized and ensure that the corner
    values are positive and the corners do not overlap.

    All functions taking a `GskRoundedRect` as an argument will internally
    operate on a normalized copy; all functions returning a `GskRoundedRect`
    will always return a normalized one.

    The algorithm used for normalizing corner sizes is described in
    [the CSS specification](https://drafts.csswg.org/css-backgrounds-3/#border-radius).
    """

    # gi Fields
    bounds: Graphene.Rect | None = ...  # type: ignore
    """
    the bounds of the rectangle

    """
    corner: list | None = ...
    """
    the size of the 4 rounded corners

    """

    # gi Methods
    def contains_point(self, point: Graphene.Point) -> bool:
        """
        Checks if the given point is inside the rounded rectangle.
        """
    def contains_rect(self, rect: Graphene.Rect) -> bool:
        """
        Checks if the given rectangle is contained inside the rounded rectangle.
        """
    def init(
        self,
        bounds: Graphene.Rect,
        top_left: Graphene.Size,
        top_right: Graphene.Size,
        bottom_right: Graphene.Size,
        bottom_left: Graphene.Size,
    ) -> RoundedRect:
        """
            Initializes a rounded rectangle with the given values.

        This function will implicitly normalize the rounded rectangle
        before returning.
        """
    def init_copy(self, src: RoundedRect) -> RoundedRect:
        """
            Initializes a rounded rectangle with a copy.

        This function will not normalize the rounded rectangle,
        so make sure the source is normalized.
        """
    def init_from_rect(self, bounds: Graphene.Rect, radius: float) -> RoundedRect:
        """
            Initializes a rounded rectangle to the given bounds
        and sets the radius of all four corners equally.
        """
    def intersects_rect(self, rect: Graphene.Rect) -> bool:
        """
            Checks if part a rectangle is contained
        inside the rounded rectangle.
        """
    def is_rectilinear(self) -> bool:
        """
            Checks if all corners of a rounded rectangle are right angles
        and the rectangle covers all of its bounds.

        This information can be used to decide if [ctor`Gsk`.ClipNode.new]
        or [ctor`Gsk`.RoundedClipNode.new] should be called.
        """
    def normalize(self) -> RoundedRect:
        """
            Normalizes a rounded rectangle.

        This function will ensure that the bounds of the rounded rectangle
        are normalized and ensure that the corner values are positive
        and the corners do not overlap.
        """
    def offset(self, dx: float, dy: float) -> RoundedRect:
        """
            Offsets the rounded rectangle's origin by `dx` and `dy`.

        The size and corners of the rounded rectangle are unchanged.
        """
    def shrink(self, top: float, right: float, bottom: float, left: float) -> RoundedRect:
        """
            Shrinks (or grows) a rounded rectangle by moving the 4 sides
        according to the offsets given.

        The corner radii will be changed in a way that tries to keep
        the center of the corner circle intact. This emulates CSS behavior.

        This function also works for growing rounded rectangles
        if you pass negative values for the `top`, `right`, `bottom` or `left`.
        """

class ShaderArgsBuilder(GObject.GBoxed):
    """
    Builds the uniforms data for a `GskGLShader`.
    """

    # gi Methods
    @deprecated("deprecated")
    def ref(self) -> ShaderArgsBuilder:
        """
        Increases the reference count of a `GskShaderArgsBuilder` by one.
        """
    @deprecated("deprecated")
    def set_bool(self, idx: int, value: bool) -> None:
        """
            Sets the value of the uniform `idx`.

        The uniform must be of bool type.
        """
    def set_float(self, idx: int, value: float) -> None:
        """
            Sets the value of the uniform `idx`.

        The uniform must be of float type.
        """
    @deprecated("deprecated")
    def set_int(self, idx: int, value: int) -> None:
        """
            Sets the value of the uniform `idx`.

        The uniform must be of int type.
        """
    @deprecated("deprecated")
    def set_uint(self, idx: int, value: int) -> None:
        """
            Sets the value of the uniform `idx`.

        The uniform must be of uint type.
        """
    @deprecated("deprecated")
    def set_vec2(self, idx: int, value: Graphene.Vec2) -> None:
        """
            Sets the value of the uniform `idx`.

        The uniform must be of vec2 type.
        """
    @deprecated("deprecated")
    def set_vec3(self, idx: int, value: Graphene.Vec3) -> None:
        """
            Sets the value of the uniform `idx`.

        The uniform must be of vec3 type.
        """
    @deprecated("deprecated")
    def set_vec4(self, idx: int, value: Graphene.Vec4) -> None:
        """
            Sets the value of the uniform `idx`.

        The uniform must be of vec4 type.
        """
    @deprecated("deprecated")
    def to_args(self) -> GLib.Bytes:
        """
            Creates a new `GBytes` args from the current state of the
        given `builder`.

        Any uniforms of the shader that have not been explicitly set on
        the `builder` are zero-initialized.

        The given `GskShaderArgsBuilder` is reset once this function returns;
        you cannot call this function multiple times on the same `builder` instance.

        This function is intended primarily for bindings. C code should use
        [method`Gsk`.ShaderArgsBuilder.free_to_args].
        """
    @deprecated("deprecated")
    def unref(self) -> None:
        """
            Decreases the reference count of a `GskShaderArgBuilder` by one.

        If the resulting reference count is zero, frees the builder.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        shader: GLShader,
        initial_values: GLib.Bytes | None = None,
    ) -> ShaderArgsBuilder:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(shader:Gsk.GLShader, initial_values:GLib.Bytes=None) -> Gsk.ShaderArgsBuilder
        """

class Shadow(GObject.GPointer):
    """
    The shadow parameters in a shadow node.
    """

    # gi Fields
    color: Gdk.RGBA | None = ...  # type: ignore
    """
    the color of the shadow

    """
    dx: float = ...
    """
    the horizontal offset of the shadow

    """
    dy: float = ...
    """
    the vertical offset of the shadow

    """
    radius: float = ...
    """
    the radius of the shadow

    """

class ShadowNode(RenderNode):
    """
    A render node drawing one or more shadows behind its single child node.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Retrieves the child `GskRenderNode` of the shadow `node`.
        """
    def get_n_shadows(self) -> int:
        """
        Retrieves the number of shadows in the `node`.
        """
    def get_shadow(self, i: int) -> Shadow:
        """
        Retrieves the shadow data at the given index `i`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        shadows: list,
    ) -> ShadowNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, shadows:list) -> Gsk.ShadowNode
        """

class Stroke(GObject.GBoxed):
    """
    Collects the parameters that are needed when stroking a path.
    """

    # gi Methods
    def copy(self) -> Stroke:
        """
        Creates a copy of a `GskStroke`.
        """
    @staticmethod
    def equal(stroke1: object | None = None, stroke2: object | None = None) -> bool:
        """
        Checks if two strokes are identical.
        """
    def free(self) -> None:
        """
        Frees a `GskStroke`.
        """
    def get_dash(self) -> tuple[list | None, int]:
        """
        Gets the dash array in use.
        """
    def get_dash_offset(self) -> float:
        """
        Gets the dash offset.
        """
    def get_line_cap(self) -> LineCap:
        """
            Gets the line cap used.

        See [enum`Gsk`.LineCap] for details.
        """
    def get_line_join(self) -> LineJoin:
        """
            Gets the line join used.

        See [enum`Gsk`.LineJoin] for details.
        """
    def get_line_width(self) -> float:
        """
        Gets the line width used.
        """
    def get_miter_limit(self) -> float:
        """
        Gets the miter limit.
        """
    def set_dash(self, dash: list | None, n_dash: int) -> None:
        """
            Sets the dash pattern to use.

        A dash pattern is specified by an array of alternating non-negative
        values. Each value provides the length of alternate "on" and "off"
        portions of the stroke.

        Each "on" segment will have caps applied as if the segment were a
        separate contour. In particular, it is valid to use an "on" length
        of 0 with [enum`Gsk`.LineCap.round] or [enum`Gsk`.LineCap.square]
        to draw dots or squares along a path.

        If `n_dash` is 0, if all elements in `dash` are 0, or if there are
        negative values in `dash`, then dashing is disabled.

        If `n_dash` is 1, an alternating "on" and "off" pattern with the
        single dash length provided is assumed.

        If `n_dash` is uneven, the dash array will be used with the first
        element in `dash` defining an "on" or "off" in alternating passes
        through the array.

        You can specify a starting offset into the dash with
        [method`Gsk`.Stroke.set_dash_offset].
        """
    def set_dash_offset(self, offset: float) -> None:
        """
            Sets the offset into the dash pattern where dashing should begin.

        This is an offset into the length of the path, not an index into
        the array values of the dash array.

        See [method`Gsk`.Stroke.set_dash] for more details on dashing.
        """
    def set_line_cap(self, line_cap: LineCap) -> None:
        """
            Sets the line cap to be used when stroking.

        See [enum`Gsk`.LineCap] for details.
        """
    def set_line_join(self, line_join: LineJoin) -> None:
        """
            Sets the line join to be used when stroking.

        See [enum`Gsk`.LineJoin] for details.
        """
    def set_line_width(self, line_width: float) -> None:
        """
            Sets the line width to be used when stroking.

        The line width must be > 0.
        """
    def set_miter_limit(self, limit: float) -> None:
        """
            Sets the miter limit to be used when stroking.

        The miter limit is the distance from the corner where sharp
        turns of joins get cut off.

        The limit is specfied in units of line width and must be non-negative.

        For joins of type [enum`Gsk`.LineJoin.miter] that exceed the miter limit,
        the join gets rendered as if it was of type [enum`Gsk`.LineJoin.bevel].
        """
    def to_cairo(self, cr: cairo.Context) -> None:
        """
            A helper function that sets the stroke parameters
        of a cairo context from a `GskStroke`.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        line_width: float,
    ) -> Stroke:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(line_width:float) -> Gsk.Stroke
        """

class StrokeNode(RenderNode):
    """
    A render node that will fill the area determined by stroking the the given
    [struct`Gsk`.Path] using the [struct`Gsk`.Stroke] attributes.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Gets the child node that is getting drawn by the given `node`.
        """
    def get_path(self) -> Path:
        """
            Retrieves the path that will be stroked with the contents of
        the `node`.
        """
    def get_stroke(self) -> Stroke:
        """
        Retrieves the stroke attributes used in this `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        path: Path,
        stroke: Stroke,
    ) -> StrokeNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, path:Gsk.Path, stroke:Gsk.Stroke) -> Gsk.StrokeNode
        """

class SubsurfaceNode(RenderNode):
    """
    A render node that potentially diverts a part of the scene graph to a subsurface.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Gets the child node that is getting drawn by the given `node`.
        """

class TextNode(RenderNode):
    """
    A render node drawing a set of glyphs.
    """

    # gi Methods
    def get_color(self) -> Gdk.RGBA:
        """
            Retrieves the color used by the text `node`.

        The value returned by this function will not be correct
        if the render node was created for a non-sRGB color.
        """
    def get_font(self) -> Pango.Font:
        """
        Returns the font used by the text `node`.
        """
    def get_glyphs(self) -> tuple[list, int]:
        """
        Retrieves the glyph information in the `node`.
        """
    def get_num_glyphs(self) -> int:
        """
        Retrieves the number of glyphs in the text node.
        """
    def get_offset(self) -> Graphene.Point:
        """
        Retrieves the offset applied to the text.
        """
    def has_color_glyphs(self) -> bool:
        """
        Checks whether the text `node` has color glyphs.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        font: Pango.Font,
        glyphs: Pango.GlyphString,
        color: Gdk.RGBA,
        offset: Graphene.Point,
    ) -> TextNode | None:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(font:Pango.Font, glyphs:Pango.GlyphString, color:Gdk.RGBA, offset:Graphene.Point) -> Gsk.TextNode or None
        """

class TextureNode(RenderNode):
    """
    A render node for a `GdkTexture`.
    """

    # gi Methods
    def get_texture(self) -> Gdk.Texture:
        """
        Retrieves the `GdkTexture` used when creating this `GskRenderNode`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        texture: Gdk.Texture,
        bounds: Graphene.Rect,
    ) -> TextureNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(texture:Gdk.Texture, bounds:Graphene.Rect) -> Gsk.TextureNode
        """

class TextureScaleNode(RenderNode):
    """
    A render node for a `GdkTexture`, with control over scaling.
    """

    # gi Methods
    def get_filter(self) -> ScalingFilter:
        """
        Retrieves the `GskScalingFilter` used when creating this `GskRenderNode`.
        """
    def get_texture(self) -> Gdk.Texture:
        """
        Retrieves the `GdkTexture` used when creating this `GskRenderNode`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        texture: Gdk.Texture,
        bounds: Graphene.Rect,
        filter: ScalingFilter,
    ) -> TextureScaleNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(texture:Gdk.Texture, bounds:Graphene.Rect, filter:Gsk.ScalingFilter) -> Gsk.TextureScaleNode
        """

class Transform(GObject.GBoxed):
    """
    Describes a 3D transform.

    Unlike `graphene_matrix_t`, `GskTransform` retains the steps in how
    a transform was constructed, and allows inspecting them. It is modeled
    after the way CSS describes transforms.

    `GskTransform` objects are immutable and cannot be changed after creation.
    This means code can safely expose them as properties of objects without
    having to worry about others changing them.
    """

    # gi Methods
    def equal(self, second: Transform | None = None) -> bool:
        """
        Checks two transforms for equality.
        """
    def get_category(self) -> TransformCategory:
        """
        Returns the category this transform belongs to.
        """
    def invert(self) -> Transform | None:
        """
            Inverts the given transform.

        If `self` is not invertible, `None` is returned.
        Note that inverting `None` also returns `None`, which is
        the correct inverse of `None`. If you need to differentiate
        between those cases, you should check `self` is not `None`
        before calling this function.

        This function consumes `self`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def matrix(self, matrix: Graphene.Matrix) -> Transform:
        """
            Multiplies `next` with the given `matrix`.

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    @staticmethod
    def parse(string: str) -> tuple[bool, Transform]:
        """
            Parses a given into a transform.

        Strings printed via [method`Gsk`.Transform.to_string]
        can be read in again successfully using this function.

        If `string` does not describe a valid transform, false
        is returned and `None` is put in `out_transform`.
        """
    def perspective(self, depth: float) -> Transform:
        """
            Applies a perspective projection transform.

        This transform scales points in X and Y based on their Z value,
        scaling points with positive Z values away from the origin, and
        those with negative Z values towards the origin. Points
        on the z=0 plane are unchanged.

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def print_(self, string: GLib.String) -> None: ...
    def ref(self) -> Transform | None:
        """
        Acquires a reference on the given transform.
        """
    def rotate(self, angle: float) -> Transform | None:
        """
            Rotates `next` by an angle around the Z axis.

        The rotation happens around the origin point of (0, 0).

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def rotate_3d(self, angle: float, axis: Graphene.Vec3) -> Transform | None:
        """
            Rotates `next` `angle` degrees around `axis`.

        For a rotation in 2D space, use [method`Gsk`.Transform.rotate]

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def scale(self, factor_x: float, factor_y: float) -> Transform | None:
        """
            Scales `next` in 2-dimensional space by the given factors.

        Use [method`Gsk`.Transform.scale_3d] to scale in all 3 dimensions.

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def scale_3d(self, factor_x: float, factor_y: float, factor_z: float) -> Transform | None:
        """
            Scales `next` by the given factors.

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def skew(self, skew_x: float, skew_y: float) -> Transform | None:
        """
            Applies a skew transform.

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def to_2d(self) -> tuple[float, float, float, float, float, float]:
        """
            Converts a transform to a 2D transformation matrix.

        `self` must be a 2D transformation. If you are not
        sure, use

            `Gsk.Transform.get_category` >= GSK_TRANSFORM_CATEGORY_2D

        to check.

        The returned values are a subset of the full 4x4 matrix that
        is computed by [method`Gsk`.Transform.to_matrix] and have the
        following layout:

        ```
          | xx yx |   |  a  b  0 |
          | xy yy | = |  c  d  0 |
          | dx dy |   | tx ty  1 |
        ```

        This function can be used to convert between a `GskTransform`
        and a matrix type from other 2D drawing libraries, in particular
        Cairo.
        """
    def to_2d_components(self) -> tuple[float, float, float, float, float, float, float]:
        """
            Converts a transform to 2D transformation factors.

        To recreate an equivalent transform from the factors returned
        by this function, use

            gsk_transform_skew (
                gsk_transform_scale (
                    gsk_transform_rotate (
                        gsk_transform_translate (None, &GRAPHENE_POINT_T (dx, dy)),
                        angle),
                    scale_x, scale_y),
                skew_x, skew_y)

        `self` must be a 2D transformation. If you are not sure, use

            `Gsk.Transform.get_category` >= GSK_TRANSFORM_CATEGORY_2D

        to check.
        """
    def to_affine(self) -> tuple[float, float, float, float]:
        """
            Converts a transform to 2D affine transformation factors.

        To recreate an equivalent transform from the factors returned
        by this function, use

            gsk_transform_scale (
                gsk_transform_translate (
                    None,
                    &GRAPHENE_POINT_T (dx, dy)),
                sx, sy)

        `self` must be a 2D affine transformation. If you are not
        sure, use

            `Gsk.Transform.get_category` >= GSK_TRANSFORM_CATEGORY_2D_AFFINE

        to check.
        """
    def to_matrix(self) -> Graphene.Matrix:
        """
            Computes the 4x4 matrix for the transform.

        The previous value of `out_matrix` will be ignored.
        """
    def to_string(self) -> str:
        """
            Converts the transform into a human-readable string.

        The resulting string can be parsed with [func`Gsk`.Transform.parse].

        This is a wrapper around [method`Gsk`.Transform.print].
        """
    def to_translate(self) -> tuple[float, float]:
        """
            Converts a transform to a translation operation.

        `self` must be a 2D transformation. If you are not
        sure, use

            `Gsk.Transform.get_category` >= GSK_TRANSFORM_CATEGORY_2D_TRANSLATE

        to check.
        """
    def transform(self, other: Transform | None = None) -> Transform | None:
        """
            Applies all the operations from `other` to `next`.

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def transform_bounds(self, rect: Graphene.Rect) -> Graphene.Rect:
        """
            Transforms a rectangle using the given transform.

        The result is the bounding box containing the coplanar quad.
        """
    def transform_point(self, point: Graphene.Point) -> Graphene.Point:
        """
        Transforms a point using the given transform.
        """
    def translate(self, point: Graphene.Point) -> Transform | None:
        """
            Translates `next` in 2-dimensional space by `point`.

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def translate_3d(self, point: Graphene.Point3D) -> Transform | None:
        """
            Translates `next` by `point`.

        This function consumes `next`. Use [method`Gsk`.Transform.ref] first
        if you want to keep it around.
        """
    def unref(self) -> None:
        """
            Releases a reference on the given transform.

        If the reference was the last, the resources associated to the `self` are
        freed.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...
    @classmethod
    def new(
        cls,
    ) -> Transform:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gsk.Transform
        """

class TransformNode(RenderNode):
    """
    A render node applying a `GskTransform` to its single child node.
    """

    # gi Methods
    def get_child(self) -> RenderNode:
        """
        Gets the child node that is getting transformed by the given `node`.
        """
    def get_transform(self) -> Transform:
        """
        Retrieves the `GskTransform` used by the `node`.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
        child: RenderNode,
        transform: Transform,
    ) -> TransformNode:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new(child:Gsk.RenderNode, transform:Gsk.Transform) -> Gsk.TransformNode
        """

class VulkanRenderer(Renderer):
    """
    Renders a GSK rendernode tree with Vulkan.

    This renderer will fail to realize if Vulkan is not supported.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Initialize VulkanRenderer object with properties.
        """

    # python methods (overrides?)
    @classmethod
    def new(
        cls,
    ) -> Renderer:
        """
        [is-override: Note this method is an override in Python of the original gi implementation.]

        new() -> Gsk.Renderer
        """

class VulkanRendererClass(GObject.GPointer): ...

###############################################################
# Callbacks
###############################################################

class PathForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gsk.foreach
    """
    #  op
    def __call__(
        self,
        op: PathOperation,
        pts: Graphene.Point,
        n_pts: int,
        weight: float,
        *user_data: object | None,
    ) -> bool: ...

class ParseErrorFunc(typing.Protocol):
    """
    This callback was used in:
        Gsk.deserialize
    """
    #  start
    def __call__(
        self,
        start: ParseLocation,
        end: ParseLocation,
        error: GLib.Error,
        *user_data: object | None,
    ) -> None: ...

###############################################################
# Aliases
###############################################################

_lock = _thread._lock  # type: ignore
###############################################################
# Constants
###############################################################

_namespace: str = ...
_version: str = ...
###############################################################
# Unknowns/Not Parsed
###############################################################
