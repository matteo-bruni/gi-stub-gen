# pyright: reportIncompatibleMethodOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: Gtk
Date: 2025-12-24
"""
# we disable method override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401
import builtins  # noqa: F401

import _thread
import enum
import gi
import typing

# gi.repository imports needed by this Stub
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gdk
from gi.repository import GdkPixbuf
from gi.repository import Gio
from gi.repository import Graphene
from gi.repository import Gsk
from gi.repository import Pango
from gi.repository import cairo
###############################################################
# Functions
###############################################################

@staticmethod
def accelerator_get_default_mod_mask() -> Gdk.ModifierType:
    """
    Gets the modifier mask.

    The modifier mask determines which modifiers are considered significant
    for keyboard accelerators. This includes all keyboard modifiers except
    for `GDK_LOCK_MASK`.
    """
    ...

@staticmethod
def accelerator_get_label(
    accelerator_key: int,
    accelerator_mods: Gdk.ModifierType,
) -> str:
    """
    Converts an accelerator keyval and modifier mask into a string
    which can be used to represent the accelerator to the user.
    """
    ...

@staticmethod
def accelerator_get_label_with_keycode(
    display: Gdk.Display | None,
    accelerator_key: int,
    keycode: int,
    accelerator_mods: Gdk.ModifierType,
) -> str:
    """
    Converts an accelerator keyval and modifier mask
    into a string that can be displayed to the user.

    The string may be translated.

    This function is similar to [func@Gtk.accelerator_get_label],
    but handling keycodes. This is only useful for system-level
    components, applications should use [func@Gtk.accelerator_get_label]
    instead.
    """
    ...

@staticmethod
def accelerator_name(
    accelerator_key: int,
    accelerator_mods: Gdk.ModifierType,
) -> str:
    """
    Converts an accelerator keyval and modifier mask into a string
    that can be parsed by [func@Gtk.accelerator_parse].

    For example, if you pass in `GDK_KEY_q` and `GDK_CONTROL_MASK`,
    this function returns `<Control>q`.

    If you need to display accelerators in the user interface,
    see [func@Gtk.accelerator_get_label].
    """
    ...

@staticmethod
def accelerator_name_with_keycode(
    display: Gdk.Display | None,
    accelerator_key: int,
    keycode: int,
    accelerator_mods: Gdk.ModifierType,
) -> str:
    """
    Converts an accelerator keyval and modifier mask
    into a string that can be parsed by [func@Gtk.accelerator_parse_with_keycode].

    This is similar to [func@Gtk.accelerator_name] but handling keycodes.
    This is only useful for system-level components, applications
    should use [func@Gtk.accelerator_name] instead.
    """
    ...

@staticmethod
def accelerator_parse(
    accelerator: str,
) -> tuple[bool, int | None, Gdk.ModifierType | None]:
    """
    Parses a string representing an accelerator.

    The format looks like “`<Control>a`” or “`<Shift><Alt>F1`”.

    The parser is fairly liberal and allows lower or upper case, and also
    abbreviations such as “`<Ctl>`” and “`<Ctrl>`”.

    Key names are parsed using [func@Gdk.keyval_from_name]. For character keys
    the name is not the symbol, but the lowercase name, e.g. one would use
    “`<Ctrl>minus`” instead of “`<Ctrl>-`”.

    Modifiers are enclosed in angular brackets `<>`, and match the
    [flags@Gdk.ModifierType] mask:

    - `<Shift>` for `GDK_SHIFT_MASK`
    - `<Ctrl>` for `GDK_CONTROL_MASK`
    - `<Alt>` for `GDK_ALT_MASK`
    - `<Meta>` for `GDK_META_MASK`
    - `<Super>` for `GDK_SUPER_MASK`
    - `<Hyper>` for `GDK_HYPER_MASK`

    If the parse operation fails, @accelerator_key and @accelerator_mods will
    be set to 0 (zero).
    """
    ...

@staticmethod
def accelerator_parse_with_keycode(
    accelerator: str,
    display: Gdk.Display | None = None,
) -> tuple[bool, int | None, list | None, Gdk.ModifierType | None]:
    """
    Parses a string representing an accelerator.

    This is similar to [func@Gtk.accelerator_parse] but handles keycodes as
    well. This is only useful for system-level components, applications should
    use [func@Gtk.accelerator_parse] instead.

    If @accelerator_codes is given and the result stored in it is non-%NULL,
    the result must be freed with g_free().

    If a keycode is present in the accelerator and no @accelerator_codes
    is given, the parse will fail.

    If the parse fails, @accelerator_key, @accelerator_mods and
    @accelerator_codes will be set to 0 (zero).
    """
    ...

@staticmethod
def accelerator_valid(
    keyval: int,
    modifiers: Gdk.ModifierType,
) -> bool:
    """
    Determines whether a given keyval and modifier mask constitute
    a valid keyboard accelerator.

    For example, the `GDK_KEY_a` keyval plus `GDK_CONTROL_MASK` mask is valid,
    and matches the “Ctrl+a” accelerator. But, you can't, for instance, use
    the `GDK_KEY_Control_L` keyval as an accelerator.
    """
    ...

@staticmethod
def accessible_property_init_value(
    property: AccessibleProperty,
    value: GObject.Value,
) -> None:
    """
    Initializes @value with the appropriate type for the @property.

    This function is mostly meant for language bindings, in conjunction
    with gtk_accessible_update_property_value().
    """
    ...

@staticmethod
def accessible_relation_init_value(
    relation: AccessibleRelation,
    value: GObject.Value,
) -> None:
    """
    Initializes @value with the appropriate type for the @relation.

    This function is mostly meant for language bindings, in conjunction
    with gtk_accessible_update_relation_value().
    """
    ...

@staticmethod
def accessible_state_init_value(
    state: AccessibleState,
    value: GObject.Value,
) -> None:
    """
    Initializes @value with the appropriate type for the @state.

    This function is mostly meant for language bindings, in conjunction
    with gtk_accessible_update_relation_state().
    """
    ...

@staticmethod
def bitset_iter_init_at(
    set: Bitset,
    target: int,
) -> tuple[bool, BitsetIter, int | None]:
    """
    Initializes @iter to point to @target.

    If @target is not found, finds the next value after it.
    If no value >= @target exists in @set, this function returns %FALSE.
    """
    ...

@staticmethod
def bitset_iter_init_first(
    set: Bitset,
) -> tuple[bool, BitsetIter, int | None]:
    """
    Initializes an iterator for @set and points it to the first
    value in @set.

    If @set is empty, %FALSE is returned and @value is set to %G_MAXUINT.
    """
    ...

@staticmethod
def bitset_iter_init_last(
    set: Bitset,
) -> tuple[bool, BitsetIter, int | None]:
    """
    Initializes an iterator for @set and points it to the last
    value in @set.

    If @set is empty, %FALSE is returned.
    """
    ...

@staticmethod
def builder_error_quark() -> int:
    """
    Registers an error quark for [class@Gtk.Builder] errors.
    """
    ...

@staticmethod
def check_version(
    required_major: int,
    required_minor: int,
    required_micro: int,
) -> str | None:
    """
    Checks that the GTK library in use is compatible with the
    given version.

    Generally you would pass in the constants %GTK_MAJOR_VERSION,
    %GTK_MINOR_VERSION, %GTK_MICRO_VERSION as the three arguments
    to this function; that produces a check that the library in
    use is compatible with the version of GTK the application or
    module was compiled against.

    Compatibility is defined by two things: first the version
    of the running library is newer than the version
    @required_major.required_minor.@required_micro. Second
    the running library must be binary compatible with the
    version @required_major.required_minor.@required_micro
    (same major version.)

    This function is primarily for GTK modules; the module
    can call this function to check that it wasn’t loaded
    into an incompatible version of GTK. However, such a
    check isn’t completely reliable, since the module may be
    linked against an old version of GTK and calling the
    old version of gtk_check_version(), but still get loaded
    into an application using a newer version of GTK.
    """
    ...

@staticmethod
def constraint_vfl_parser_error_quark() -> int:
    """
    Registers an error quark for VFL error parsing.
    """
    ...

@staticmethod
def css_parser_error_quark() -> int:
    """
    Registers an error quark for CSS parsing errors.
    """
    ...

@staticmethod
def css_parser_warning_quark() -> int:
    """
    Registers an error quark for CSS parsing warnings.
    """
    ...

@staticmethod
def dialog_error_quark() -> int:
    """
    Registers an error quark for an operation that requires a dialog if
    necessary.
    """
    ...

@staticmethod
def disable_portals() -> None:
    """
    Prevents GTK from using portals.

    This is equivalent to setting `GDK_DEBUG=no-portals` in the environment.

    This should only be used in portal implementations, apps must not call it.
    """
    ...

@staticmethod
def disable_setlocale() -> None:
    """
    Prevents [func@Gtk.init] and [func@Gtk.init_check] from calling `setlocale()`.

    You would want to use this function if you wanted to set the locale for
    your program to something other than the user’s locale, or if you wanted
    to set different values for different locale categories.

    Most programs should not need to call this function.
    """
    ...

@staticmethod
def distribute_natural_allocation(
    extra_space: int,
    n_requested_sizes: int,
    sizes: list,
) -> int:
    """
    Distributes @extra_space to child @sizes by bringing smaller
    children up to natural size first.

    The remaining space will be added to the @minimum_size member of the
    `GtkRequestedSize` struct. If all sizes reach their natural size then
    the remaining space is returned.
    """
    ...

@staticmethod
def editable_delegate_get_property(
    object: GObject.Object,
    prop_id: int,
    value: GObject.Value,
    pspec: GObject.ParamSpec,
) -> bool:
    """
    Gets a property of the `GtkEditable` delegate for @object.

    This is helper function that should be called in the `get_property`
    function of your `GtkEditable` implementation, before handling your
    own properties.
    """
    ...

@staticmethod
def editable_delegate_set_property(
    object: GObject.Object,
    prop_id: int,
    value: GObject.Value,
    pspec: GObject.ParamSpec,
) -> bool:
    """
    Sets a property on the `GtkEditable` delegate for @object.

    This is a helper function that should be called in the `set_property`
    function of your `GtkEditable` implementation, before handling your
    own properties.
    """
    ...

@staticmethod
def editable_install_properties(
    object_class: GObject.ObjectClass,
    first_prop: int,
) -> int:
    """
    Overrides the `GtkEditable` properties for @class.

    This is a helper function that should be called in class_init,
    after installing your own properties.

    Note that your class must have "text", "cursor-position",
    "selection-bound", "editable", "width-chars", "max-width-chars",
    "xalign" and "enable-undo" properties for this function to work.

    To handle the properties in your set_property and get_property
    functions, you can either use [func@Gtk.Editable.delegate_set_property]
    and [func@Gtk.Editable.delegate_get_property] (if you are using
    a delegate), or remember the @first_prop offset and add it to the
    values in the [enum@Gtk.EditableProperties] enumeration to get the
    property IDs for these properties.
    """
    ...

@staticmethod
def enumerate_printers(
    func: PrinterFunc,
    data: object | None,
    destroy: GLib.DestroyNotify,  # type: ignore
    wait: bool,
) -> None:
    """
    Calls a function for all printers that are known to GTK.

    If @func returns true, the enumeration is stopped.
    """
    ...

@staticmethod
def file_chooser_error_quark() -> int:
    """
    Registers an error quark for `GtkFileChooser` errors.
    """
    ...

@staticmethod
def get_binary_age() -> int:
    """
    Returns the binary age as passed to `libtool`.

    If `libtool` means nothing to you, don't worry about it.
    """
    ...

@staticmethod
def get_debug_flags() -> DebugFlags:
    """
    Returns the GTK debug flags that are currently active.

    This function is intended for GTK modules that want
    to adjust their debug output based on GTK debug flags.
    """
    ...

@staticmethod
def get_default_language() -> Pango.Language:
    """
    Returns the `PangoLanguage` for the default language
    currently in effect.

    Note that this can change over the life of an
    application.

    The default language is derived from the current
    locale. It determines, for example, whether GTK uses
    the right-to-left or left-to-right text direction.

    This function is equivalent to [func@Pango.Language.get_default].
    See that function for details.
    """
    ...

@staticmethod
def get_interface_age() -> int:
    """
    Returns the interface age as passed to `libtool`.

    If `libtool` means nothing to you, don't worry about it.
    """
    ...

@staticmethod
def get_locale_direction() -> TextDirection:
    """
    Gets the direction of the current locale.

    This is the expected reading direction for text and UI.

    This function depends on the current locale being set with
    `setlocale()` and will default to setting the `GTK_TEXT_DIR_LTR`
    direction otherwise. `GTK_TEXT_DIR_NONE` will never be returned.

    GTK sets the default text direction according to the locale during
    [func@Gtk.init], and you should normally use [method@Gtk.Widget.get_direction]
    or [func@Gtk.Widget.get_default_direction] to obtain the current direction.

    This function is only needed rare cases when the locale is
    changed after GTK has already been initialized. In this case,
    you can use it to update the default text direction as follows:

    ```c
    #include <locale.h>

    static void
    update_locale (const char *new_locale)
    {
      setlocale (LC_ALL, new_locale);
      gtk_widget_set_default_direction (gtk_get_locale_direction ());
    }
    ```
    """
    ...

@staticmethod
def get_major_version() -> int:
    """
    Returns the major version number of the GTK library.

    For example, in GTK version 3.1.5 this is 3.

    This function is in the library, so it represents the GTK library
    your code is running against. Contrast with the %GTK_MAJOR_VERSION
    macro, which represents the major version of the GTK headers you
    have included when compiling your code.
    """
    ...

@staticmethod
def get_micro_version() -> int:
    """
    Returns the micro version number of the GTK library.

    For example, in GTK version 3.1.5 this is 5.

    This function is in the library, so it represents the GTK library
    your code is are running against. Contrast with the
    %GTK_MICRO_VERSION macro, which represents the micro version of the
    GTK headers you have included when compiling your code.
    """
    ...

@staticmethod
def get_minor_version() -> int:
    """
    Returns the minor version number of the GTK library.

    For example, in GTK version 3.1.5 this is 1.

    This function is in the library, so it represents the GTK library
    your code is are running against. Contrast with the
    %GTK_MINOR_VERSION macro, which represents the minor version of the
    GTK headers you have included when compiling your code.
    """
    ...

@staticmethod
def hsv_to_rgb(
    h: float,
    s: float,
    v: float,
) -> tuple[float, float, float]:
    """
    Converts a color from HSV space to RGB.

    Input values must be in the [0.0, 1.0] range;
    output values will be in the same range.
    """
    ...

@staticmethod
def icon_theme_error_quark() -> int:
    """
    Registers an error quark for [class@Gtk.IconTheme] errors.
    """
    ...

@staticmethod
def init() -> None:
    """
    Initializes GTK.

    This function must be called before using any other GTK functions
    in your GUI applications.

    It will initialize everything needed to operate the toolkit. In particular,
    it will open the default display (see [func@Gdk.Display.get_default]).

    If you are using [class@Gtk.Application], you usually don't have to call this
    function; the [vfunc@Gio.Application.startup] handler does it for you. Though,
    if you are using `GApplication` methods that will be invoked before `startup`,
    such as `local_command_line`, you may need to initialize GTK explicitly.

    This function will terminate your program if it was unable to initialize
    the windowing system for some reason. If you want your program to fall back
    to a textual interface, call [func@Gtk.init_check] instead.

    GTK calls `signal (SIGPIPE, SIG_IGN)` during initialization, to ignore
    SIGPIPE signals, since these are almost never wanted in graphical
    applications. If you do need to handle SIGPIPE for some reason, reset
    the handler after gtk_init(), but notice that other libraries (e.g.
    libdbus or gvfs) might do similar things.
    """
    ...

@staticmethod
def init_check() -> bool:
    """
    Initializes GTK.

    This function does the same work as [func@Gtk.init] with only a
    single change: It does not terminate the program if the windowing
    system can’t be initialized. Instead it returns false on failure.

    This way the application can fall back to some other means of
    communication with the user - for example a curses or command line
    interface.
    """
    ...

@staticmethod
def is_initialized() -> bool:
    """
    Returns whether GTK has been initialized.

    See [func@Gtk.init].
    """
    ...

@staticmethod
def native_get_for_surface(
    surface: Gdk.Surface,
) -> Native | None:
    """
    Finds the `GtkNative` associated with the surface.
    """
    ...

@staticmethod
def paper_size_get_default() -> str:
    """
    Returns the name of the default paper size, which
    depends on the current locale.
    """
    ...

@staticmethod
def paper_size_get_paper_sizes(
    include_custom: bool,
) -> list:
    """
    Creates a list of known paper sizes.
    """
    ...

@staticmethod
def param_spec_expression(
    name: str,
    nick: str,
    blurb: str,
    flags: GObject.ParamFlags,
) -> GObject.ParamSpec:
    """
    Creates a new `GParamSpec` instance for a property holding a `GtkExpression`.

    See `g_param_spec_internal()` for details on the property strings.
    """
    ...

@staticmethod
def print_error_quark() -> int:
    """
    Registers an error quark for `GtkPrintOperation` if necessary.
    """
    ...

@staticmethod
def print_run_page_setup_dialog(
    parent: Window | None,
    page_setup: PageSetup | None,
    settings: PrintSettings,
) -> PageSetup:
    """
    Runs a page setup dialog, letting the user modify the values from @page_setup.

    If the user cancels the dialog, the returned `GtkPageSetup` is identical
    to the passed in @page_setup, otherwise it contains the modifications
    done in the dialog.

    Note that this function may use a recursive mainloop to show the page
    setup dialog. See [func@Gtk.print_run_page_setup_dialog_async] if this is
    a problem.
    """
    ...

@staticmethod
def print_run_page_setup_dialog_async(
    parent: Window | None,
    page_setup: PageSetup | None,
    settings: PrintSettings,
    done_cb: PageSetupDoneFunc,
    data: object | None = None,
) -> None:
    """
    Runs a page setup dialog, letting the user modify the values from @page_setup.

    In contrast to [func@Gtk.print_run_page_setup_dialog], this function  returns
    after showing the page setup dialog on platforms that support this, and calls
    @done_cb from a signal handler for the ::response signal of the dialog.
    """
    ...

@staticmethod
def recent_manager_error_quark() -> int:
    """
    Registers an error quark for [class@RecentManager] errors.
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_activity(
    context: StyleContext,
    cr: cairo.Context,
    x: float,
    y: float,
    width: float,
    height: float,
) -> None:
    """
    Renders an activity indicator (such as in `GtkSpinner`).
    The state %GTK_STATE_FLAG_CHECKED determines whether there is
    activity going on.
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_arrow(
    context: StyleContext,
    cr: cairo.Context,
    angle: float,
    x: float,
    y: float,
    size: float,
) -> None:
    """
    Renders an arrow pointing to @angle.

    Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:

    ![](arrows.png)
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_background(
    context: StyleContext,
    cr: cairo.Context,
    x: float,
    y: float,
    width: float,
    height: float,
) -> None:
    """
    Renders the background of an element.

    Typical background rendering, showing the effect of
    `background-image`, `border-width` and `border-radius`:

    ![](background.png)
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_check(
    context: StyleContext,
    cr: cairo.Context,
    x: float,
    y: float,
    width: float,
    height: float,
) -> None:
    """
    Renders a checkmark (as in a `GtkCheckButton`).

    The %GTK_STATE_FLAG_CHECKED state determines whether the check is
    on or off, and %GTK_STATE_FLAG_INCONSISTENT determines whether it
    should be marked as undefined.

    Typical checkmark rendering:

    ![](checks.png)
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_expander(
    context: StyleContext,
    cr: cairo.Context,
    x: float,
    y: float,
    width: float,
    height: float,
) -> None:
    """
    Renders an expander (as used in `GtkTreeView` and `GtkExpander`) in the area
    defined by @x, @y, @width, @height. The state %GTK_STATE_FLAG_CHECKED
    determines whether the expander is collapsed or expanded.

    Typical expander rendering:

    ![](expanders.png)
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_focus(
    context: StyleContext,
    cr: cairo.Context,
    x: float,
    y: float,
    width: float,
    height: float,
) -> None:
    """
    Renders a focus indicator on the rectangle determined by @x, @y, @width, @height.

    Typical focus rendering:

    ![](focus.png)
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_frame(
    context: StyleContext,
    cr: cairo.Context,
    x: float,
    y: float,
    width: float,
    height: float,
) -> None:
    """
    Renders a frame around the rectangle defined by @x, @y, @width, @height.

    Examples of frame rendering, showing the effect of `border-image`,
    `border-color`, `border-width`, `border-radius` and junctions:

    ![](frames.png)
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_handle(
    context: StyleContext,
    cr: cairo.Context,
    x: float,
    y: float,
    width: float,
    height: float,
) -> None:
    """
    Renders a handle (as in `GtkPaned` and `GtkWindow`’s resize grip),
    in the rectangle determined by @x, @y, @width, @height.

    Handles rendered for the paned and grip classes:

    ![](handles.png)
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_icon(
    context: StyleContext,
    cr: cairo.Context,
    texture: Gdk.Texture,
    x: float,
    y: float,
) -> None:
    """
    Renders the icon in @texture at the specified @x and @y coordinates.

    This function will render the icon in @texture at exactly its size,
    regardless of scaling factors, which may not be appropriate when
    drawing on displays with high pixel densities.
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_layout(
    context: StyleContext,
    cr: cairo.Context,
    x: float,
    y: float,
    layout: Pango.Layout,
) -> None:
    """
    Renders @layout on the coordinates @x, @y
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_line(
    context: StyleContext,
    cr: cairo.Context,
    x0: float,
    y0: float,
    x1: float,
    y1: float,
) -> None:
    """
    Renders a line from (x0, y0) to (x1, y1).
    """
    ...

@deprecated("deprecated")
@staticmethod
def render_option(
    context: StyleContext,
    cr: cairo.Context,
    x: float,
    y: float,
    width: float,
    height: float,
) -> None:
    """
    Renders an option mark (as in a radio button), the %GTK_STATE_FLAG_CHECKED
    state will determine whether the option is on or off, and
    %GTK_STATE_FLAG_INCONSISTENT whether it should be marked as undefined.

    Typical option mark rendering:

    ![](options.png)
    """
    ...

@staticmethod
def rgb_to_hsv(
    r: float,
    g: float,
    b: float,
) -> tuple[float, float, float]:
    """
    Converts a color from RGB space to HSV.

    Input values must be in the [0.0, 1.0] range;
    output values will be in the same range.
    """
    ...

@staticmethod
def set_debug_flags(
    flags: DebugFlags,
) -> None:
    """
    Sets the GTK debug flags.
    """
    ...

@deprecated("deprecated")
@staticmethod
def show_uri(
    parent: Window | None,
    uri: str,
    timestamp: int,
) -> None:
    """
    This function launches the default application for showing
    a given uri, or shows an error dialog if that fails.
    """
    ...

@deprecated("deprecated")
@staticmethod
def show_uri_full(
    parent: Window | None,
    uri: str,
    timestamp: int,
    cancellable: Gio.Cancellable | None = None,
    callback: Gio.AsyncReadyCallback | None = None,  # type: ignore
    user_data: object | None = None,
) -> None:
    """
    This function launches the default application for showing
    a given uri.

    The @callback will be called when the launch is completed.

    This is the recommended call to be used as it passes information
    necessary for sandbox helpers to parent their dialogs properly.
    """
    ...

@deprecated("deprecated")
@staticmethod
def show_uri_full_finish(
    parent: Window,
    result: Gio.AsyncResult,
) -> bool:
    """
    Finishes the gtk_show_uri() call and returns the result
    of the operation.
    """
    ...

@staticmethod
def test_accessible_assertion_message_role(
    domain: str,
    file: str,
    line: int,
    func: str,
    expr: str,
    accessible: Accessible,
    expected_role: AccessibleRole,
    actual_role: AccessibleRole,
) -> None:
    """
    Prints an assertion message for gtk_test_accessible_assert_role().
    """
    ...

@staticmethod
def test_accessible_has_property(
    accessible: Accessible,
    property: AccessibleProperty,
) -> bool:
    """
    Checks whether the `GtkAccessible` has @property set.
    """
    ...

@staticmethod
def test_accessible_has_relation(
    accessible: Accessible,
    relation: AccessibleRelation,
) -> bool:
    """
    Checks whether the `GtkAccessible` has @relation set.
    """
    ...

@staticmethod
def test_accessible_has_role(
    accessible: Accessible,
    role: AccessibleRole,
) -> bool:
    """
    Checks whether the `GtkAccessible:accessible-role` of the accessible
    is @role.
    """
    ...

@staticmethod
def test_accessible_has_state(
    accessible: Accessible,
    state: AccessibleState,
) -> bool:
    """
    Checks whether the `GtkAccessible` has @state set.
    """
    ...

@staticmethod
def test_list_all_types() -> tuple[list, int]:
    """
    Return the type ids that have been registered after
    calling gtk_test_register_all_types().
    """
    ...

@staticmethod
def test_register_all_types() -> None:
    """
    Force registration of all core GTK object types.

    This allows to refer to any of those object types via
    g_type_from_name() after calling this function.
    """
    ...

@staticmethod
def test_widget_wait_for_draw(
    widget: Widget,
) -> None:
    """
    Enters the main loop and waits for @widget to be “drawn”.

    In this context that means it waits for the frame clock of
    @widget to have run a full styling, layout and drawing cycle.

    This function is intended to be used for syncing with actions that
    depend on @widget relayouting or on interaction with the display
    server.
    """
    ...

@deprecated("deprecated")
@staticmethod
def tree_create_row_drag_content(
    tree_model: TreeModel,
    path: TreePath,
) -> Gdk.ContentProvider:
    """
    Creates a content provider for dragging @path from @tree_model.
    """
    ...

@deprecated("deprecated")
@staticmethod
def tree_get_row_drag_data(
    value: GObject.Value,
) -> tuple[bool, TreeModel | None, TreePath | None]:
    """
    Obtains a @tree_model and @path from value of target type
    %GTK_TYPE_TREE_ROW_DATA.

    The returned path must be freed with gtk_tree_path_free().
    """
    ...

@deprecated("deprecated")
@staticmethod
def tree_row_reference_deleted(
    proxy: GObject.Object,
    path: TreePath,
) -> None:
    """
    Lets a set of row reference created by
    gtk_tree_row_reference_new_proxy() know that the
    model emitted the ::row-deleted signal.
    """
    ...

@deprecated("deprecated")
@staticmethod
def tree_row_reference_inserted(
    proxy: GObject.Object,
    path: TreePath,
) -> None:
    """
    Lets a set of row reference created by
    gtk_tree_row_reference_new_proxy() know that the
    model emitted the ::row-inserted signal.
    """
    ...

@staticmethod
def value_dup_expression(
    value: GObject.Value,
) -> Expression | None:
    """
    Retrieves the `GtkExpression` stored inside the given `value`, and acquires
    a reference to it.
    """
    ...

@staticmethod
def value_get_expression(
    value: GObject.Value,
) -> Expression | None:
    """
    Retrieves the `GtkExpression` stored inside the given `value`.
    """
    ...

@staticmethod
def value_set_expression(
    value: GObject.Value,
    expression: Expression,
) -> None:
    """
    Stores the given `GtkExpression` inside `value`.

    The `GValue` will acquire a reference to the `expression`.
    """
    ...

@staticmethod
def value_take_expression(
    value: GObject.Value,
    expression: Expression | None = None,
) -> None:
    """
    Stores the given `GtkExpression` inside `value`.

    This function transfers the ownership of the `expression` to the `GValue`.
    """
    ...

###############################################################
# Enums/Flags
###############################################################

class AccessibleAnnouncementPriority(GObject.GEnum):
    """
    The priority of an accessibility announcement."""

    LOW = 0
    """
    The announcement is low priority,
      and might be read only on the user's request.
    """
    MEDIUM = 1
    """
    The announcement is of medium
      priority, and is usually spoken at the next opportunity, such as at the
      end of speaking the current sentence or when the user pauses typing.
    """
    HIGH = 2
    """
    The announcement is of high
      priority, and is usually spoken immediately. Because an interruption
      might disorient users or cause them to not complete their current task,
      authors SHOULD NOT use high priority announcements unless the
      interruption is imperative. An example would be a notification about a
      critical battery power level.
    """

class AccessibleAutocomplete(GObject.GEnum):
    """
    The possible values for the %GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE
    accessible property."""

    NONE = 0
    """
    Automatic suggestions are not displayed.
    """
    INLINE = 1
    """
    When a user is providing input, text
       suggesting one way to complete the provided input may be dynamically
       inserted after the caret.
    """
    LIST = 2
    """
    When a user is providing input, an element
       containing a collection of values that could complete the provided input
       may be displayed.
    """
    BOTH = 3
    """
    When a user is providing input, an element
       containing a collection of values that could complete the provided input
       may be displayed. If displayed, one value in the collection is automatically
       selected, and the text needed to complete the automatically selected value
       appears after the caret in the input.
    """

class AccessibleInvalidState(GObject.GEnum):
    """
    The possible values for the %GTK_ACCESSIBLE_STATE_INVALID
    accessible state.

    Note that the %GTK_ACCESSIBLE_INVALID_FALSE and
    %GTK_ACCESSIBLE_INVALID_TRUE have the same values
    as %FALSE and %TRUE."""

    FALSE = 0
    """
    There are no detected errors in the value
    """
    TRUE = 1
    """
    The value entered by the user has failed validation
    """
    GRAMMAR = 2
    """
    A grammatical error was detected
    """
    SPELLING = 3
    """
    A spelling error was detected
    """

class AccessiblePlatformState(GObject.GEnum):
    """
    The various platform states which can be queried
    using [method@Gtk.Accessible.get_platform_state]."""

    FOCUSABLE = 0
    """
    whether the accessible can be focused
    """
    FOCUSED = 1
    """
    whether the accessible has focus
    """
    ACTIVE = 2
    """
    whether the accessible is active
    """

class AccessibleProperty(GObject.GEnum):
    """
    The possible accessible properties of a [iface@Accessible]."""

    AUTOCOMPLETE = 0
    """
    Indicates whether inputting text
       could trigger display of one or more predictions of the user's intended
       value for a combobox, searchbox, or textbox and specifies how predictions
       would be presented if they were made. Value type: [enum@AccessibleAutocomplete]
    """
    DESCRIPTION = 1
    """
    Defines a string value that describes
       or annotates the current element. Value type: string
    """
    HAS_POPUP = 2
    """
    Indicates the availability and type of
       interactive popup element, such as menu or dialog, that can be triggered
       by an element.
    """
    KEY_SHORTCUTS = 3
    """
    Indicates keyboard shortcuts that an
       author has implemented to activate or give focus to an element. Value type:
       string. The format of the value is a space-separated list of shortcuts, with
       each shortcut consisting of one or more modifiers (`Control`, `Alt` or `Shift`),
       followed by a non-modifier key, all separated by `+`.
       Examples: `F2`, `Alt-F`, `Control+Shift+N`
    """
    LABEL = 4
    """
    Defines a string value that labels the current
       element. Value type: string
    """
    LEVEL = 5
    """
    Defines the hierarchical level of an element
       within a structure. Value type: integer
    """
    MODAL = 6
    """
    Indicates whether an element is modal when
       displayed. Value type: boolean
    """
    MULTI_LINE = 7
    """
    Indicates whether a text box accepts
       multiple lines of input or only a single line. Value type: boolean
    """
    MULTI_SELECTABLE = 8
    """
    Indicates that the user may select
       more than one item from the current selectable descendants. Value type:
       boolean
    """
    ORIENTATION = 9
    """
    Indicates whether the element's
       orientation is horizontal, vertical, or unknown/ambiguous. Value type:
       [enum@Orientation]
    """
    PLACEHOLDER = 10
    """
    Defines a short hint (a word or short
       phrase) intended to aid the user with data entry when the control has no
       value. A hint could be a sample value or a brief description of the expected
       format. Value type: string
    """
    READ_ONLY = 11
    """
    Indicates that the element is not editable,
       but is otherwise operable. Value type: boolean
    """
    REQUIRED = 12
    """
    Indicates that user input is required on
       the element before a form may be submitted. Value type: boolean
    """
    ROLE_DESCRIPTION = 13
    """
    Defines a human-readable,
       author-localized description for the role of an element. Value type: string
    """
    SORT = 14
    """
    Indicates if items in a table or grid are
       sorted in ascending or descending order. Value type: [enum@AccessibleSort]
    """
    VALUE_MAX = 15
    """
    Defines the maximum allowed value for a
       range widget. Value type: double
    """
    VALUE_MIN = 16
    """
    Defines the minimum allowed value for a
       range widget. Value type: double
    """
    VALUE_NOW = 17
    """
    Defines the current value for a range widget.
       Value type: double
    """
    VALUE_TEXT = 18
    """
    Defines the human readable text alternative
       of aria-valuenow for a range widget. Value type: string
    """
    HELP_TEXT = 19
    """
    Defines a string value that provides a description of non-standard keyboard
    interactions of the current element. Value type: string
    """

class AccessibleRelation(GObject.GEnum):
    """
    The possible accessible relations of a [iface@Accessible].

    Accessible relations can be references to other widgets,
    integers or strings."""

    ACTIVE_DESCENDANT = 0
    """
    Identifies the currently active
       element when focus is on a composite widget, combobox, textbox, group,
       or application. Value type: reference
    """
    COL_COUNT = 1
    """
    Defines the total number of columns
       in a table, grid, or treegrid. Value type: integer
    """
    COL_INDEX = 2
    """
    Defines an element's column index or
       position with respect to the total number of columns within a table,
       grid, or treegrid. Value type: integer
    """
    COL_INDEX_TEXT = 3
    """
    Defines a human readable text
      alternative of %GTK_ACCESSIBLE_RELATION_COL_INDEX. Value type: string
    """
    COL_SPAN = 4
    """
    Defines the number of columns spanned
      by a cell or gridcell within a table, grid, or treegrid. Value type: integer
    """
    CONTROLS = 5
    """
    Identifies the element (or elements) whose
       contents or presence are controlled by the current element. Value type: reference
    """
    DESCRIBED_BY = 6
    """
    Identifies the element (or elements)
       that describes the object. Value type: reference
    """
    DETAILS = 7
    """
    Identifies the element (or elements) that
       provide additional information related to the object. Value type: reference
    """
    ERROR_MESSAGE = 8
    """
    Identifies the element (or elements) that
       provide an error message for an object. Value type: reference
    """
    FLOW_TO = 9
    """
    Identifies the next element (or elements)
       in an alternate reading order of content which, at the user's discretion,
       allows assistive technology to override the general default of reading in
       document source order. Value type: reference
    """
    LABELLED_BY = 10
    """
    Identifies the element (or elements)
       that labels the current element. Value type: reference
    """
    OWNS = 11
    """
    Identifies an element (or elements) in order
       to define a visual, functional, or contextual parent/child relationship
       between elements where the widget hierarchy cannot be used to represent
       the relationship. Value type: reference
    """
    POS_IN_SET = 12
    """
    Defines an element's number or position
       in the current set of listitems or treeitems. Value type: integer
    """
    ROW_COUNT = 13
    """
    Defines the total number of rows in a table,
       grid, or treegrid. Value type: integer
    """
    ROW_INDEX = 14
    """
    Defines an element's row index or position
       with respect to the total number of rows within a table, grid, or treegrid.
       Value type: integer
    """
    ROW_INDEX_TEXT = 15
    """
    Defines a human readable text
       alternative of aria-rowindex. Value type: string
    """
    ROW_SPAN = 16
    """
    Defines the number of rows spanned by a
       cell or gridcell within a table, grid, or treegrid. Value type: integer
    """
    SET_SIZE = 17
    """
    Defines the number of items in the current
       set of listitems or treeitems. Value type: integer
    """
    LABEL_FOR = 18
    """
    Identifies the element (or elements) that are labeled by the
    current element. Value type: reference
    
    This relation is managed by GTK and should not be set from application code.
    """
    DESCRIPTION_FOR = 19
    """
    Identifies the element (or elements) that are described by
    the current element. Value type: reference
    
    This relation is managed by GTK and should not be set from application code.
    """
    CONTROLLED_BY = 20
    """
    Identifies the element (or elements) that the current
    element is controlled by. Value type: reference
    
    This relation is managed by GTK and should not be set from application code.
    """
    DETAILS_FOR = 21
    """
    Identifies the element (or elements) for which the current
    element provides additional information. Value type: reference
    
    This relation is managed by GTK and should not be set from application code.
    """
    ERROR_MESSAGE_FOR = 22
    """
    Identifies the element (or elements) for which the current
    element provides an error message. Value type: reference
    
    This relation is managed by GTK and should not be set from application code.
    """
    FLOW_FROM = 23
    """
    Identifies the previous element (or elements) in an alternate
    reading order of content which, at the user's discretion, allows
    assistive technology to override the general default of reading in
    document source order. Value type: reference
    
    This relation is managed by GTK and should not be set from application code.
    """

class AccessibleRole(GObject.GEnum):
    """
    The accessible role for a [iface@Accessible] implementation.

    Abstract roles are only used as part of the ontology; application
    developers must not use abstract roles in their code."""

    ALERT = 0
    """
    An element with important, and usually
      time-sensitive, information
    """
    ALERT_DIALOG = 1
    """
    A type of dialog that contains an
      alert message
    """
    BANNER = 2
    """
    Unused
    """
    BUTTON = 3
    """
    An input element that allows for
      user-triggered actions when clicked or pressed
    """
    CAPTION = 4
    """
    Unused
    """
    CELL = 5
    """
    Unused
    """
    CHECKBOX = 6
    """
    A checkable input element that has
      three possible values: `true`, `false`, or `mixed`
    """
    COLUMN_HEADER = 7
    """
    A header in a columned list.
    """
    COMBO_BOX = 8
    """
    An input that controls another element,
      such as a list or a grid, that can dynamically pop up to help the user
      set the value of the input
    """
    COMMAND = 9
    """
    Abstract role.
    """
    COMPOSITE = 10
    """
    Abstract role.
    """
    DIALOG = 11
    """
    A dialog is a window that is designed to interrupt
      the current processing of an application in order to prompt the user to enter
      information or require a response.
    """
    DOCUMENT = 12
    """
    Content that assistive technology users may want to
      browse in a reading mode.
    """
    FEED = 13
    """
    Unused
    """
    FORM = 14
    """
    Unused
    """
    GENERIC = 15
    """
    A nameless container that has no semantic meaning
      of its own. This is the role that GTK uses by default for widgets.
    """
    GRID = 16
    """
    A grid of items.
    """
    GRID_CELL = 17
    """
    An item in a grid or tree grid.
    """
    GROUP = 18
    """
    An element that groups multiple related widgets. GTK uses
      this role for various containers, like [class@Gtk.HeaderBar] or [class@Gtk.Notebook].
    """
    HEADING = 19
    """
    Unused
    """
    IMG = 20
    """
    An image.
    """
    INPUT = 21
    """
    Abstract role.
    """
    LABEL = 22
    """
    A visible name or caption for a user interface component.
    """
    LANDMARK = 23
    """
    Abstract role.
    """
    LEGEND = 24
    """
    Unused
    """
    LINK = 25
    """
    A clickable link.
    """
    LIST = 26
    """
    A list of items.
    """
    LIST_BOX = 27
    """
    Unused.
    """
    LIST_ITEM = 28
    """
    An item in a list.
    """
    LOG = 29
    """
    Unused
    """
    MAIN = 30
    """
    Unused
    """
    MARQUEE = 31
    """
    Unused
    """
    MATH = 32
    """
    Unused
    """
    METER = 33
    """
    An element that represents a value within a known range.
    """
    MENU = 34
    """
    A menu.
    """
    MENU_BAR = 35
    """
    A menubar.
    """
    MENU_ITEM = 36
    """
    An item in a menu.
    """
    MENU_ITEM_CHECKBOX = 37
    """
    A check item in a menu.
    """
    MENU_ITEM_RADIO = 38
    """
    A radio item in a menu.
    """
    NAVIGATION = 39
    """
    Unused
    """
    NONE = 40
    """
    An element that is not represented to accessibility technologies.
      This role is synonymous to @GTK_ACCESSIBLE_ROLE_PRESENTATION.
    """
    NOTE = 41
    """
    Unused
    """
    OPTION = 42
    """
    Unused
    """
    PRESENTATION = 43
    """
    An element that is not represented to accessibility technologies.
      This role is synonymous to @GTK_ACCESSIBLE_ROLE_NONE.
    """
    PROGRESS_BAR = 44
    """
    An element that displays the progress
      status for tasks that take a long time.
    """
    RADIO = 45
    """
    A checkable input in a group of radio roles,
      only one of which can be checked at a time.
    """
    RADIO_GROUP = 46
    """
    Unused
    """
    RANGE = 47
    """
    Abstract role.
    """
    REGION = 48
    """
    Unused
    """
    ROW = 49
    """
    A row in a columned list.
    """
    ROW_GROUP = 50
    """
    Unused
    """
    ROW_HEADER = 51
    """
    Unused
    """
    SCROLLBAR = 52
    """
    A graphical object that controls the scrolling
      of content within a viewing area, regardless of whether the content is fully
      displayed within the viewing area.
    """
    SEARCH = 53
    """
    Unused
    """
    SEARCH_BOX = 54
    """
    A type of textbox intended for specifying
      search criteria.
    """
    SECTION = 55
    """
    Abstract role.
    """
    SECTION_HEAD = 56
    """
    Abstract role.
    """
    SELECT = 57
    """
    Abstract role.
    """
    SEPARATOR = 58
    """
    A divider that separates and distinguishes
      sections of content or groups of menuitems.
    """
    SLIDER = 59
    """
    A user input where the user selects a value
      from within a given range.
    """
    SPIN_BUTTON = 60
    """
    A form of range that expects the user to
      select from among discrete choices.
    """
    STATUS = 61
    """
    Unused
    """
    STRUCTURE = 62
    """
    Abstract role.
    """
    SWITCH = 63
    """
    A type of checkbox that represents on/off values,
      as opposed to checked/unchecked values.
    """
    TAB = 64
    """
    An item in a list of tab used for switching pages.
    """
    TABLE = 65
    """
    Unused
    """
    TAB_LIST = 66
    """
    A list of tabs for switching pages.
    """
    TAB_PANEL = 67
    """
    A page in a notebook or stack.
    """
    TEXT_BOX = 68
    """
    A type of input that allows free-form text
      as its value.
    """
    TIME = 69
    """
    Unused
    """
    TIMER = 70
    """
    Unused
    """
    TOOLBAR = 71
    """
    Unused
    """
    TOOLTIP = 72
    """
    Unused
    """
    TREE = 73
    """
    Unused
    """
    TREE_GRID = 74
    """
    A treeview-like, columned list.
    """
    TREE_ITEM = 75
    """
    Unused
    """
    WIDGET = 76
    """
    Abstract role for interactive components of a
      graphical user interface
    """
    WINDOW = 77
    """
    Abstract role for windows.
    """
    TOGGLE_BUTTON = 78
    """
    A type of push button which stays pressed until depressed by a second
    activation.
    """
    APPLICATION = 79
    """
    A toplevel element of a graphical user interface.
    
    This is the role that GTK uses by default for windows.
    """
    PARAGRAPH = 80
    """
    A paragraph of content.
    """
    BLOCK_QUOTE = 81
    """
    A section of content that is quoted from another source.
    """
    ARTICLE = 82
    """
    A section of a page that consists of a composition that forms an independent
    part of a document, page, or site.
    """
    COMMENT = 83
    """
    A comment contains content expressing reaction to other content.
    """
    TERMINAL = 84
    """
    A virtual terminal.
    """

class AccessibleSort(GObject.GEnum):
    """
    The possible values for the %GTK_ACCESSIBLE_PROPERTY_SORT
    accessible property."""

    NONE = 0
    """
    There is no defined sort applied to the column.
    """
    ASCENDING = 1
    """
    Items are sorted in ascending order by this column.
    """
    DESCENDING = 2
    """
    Items are sorted in descending order by this column.
    """
    OTHER = 3
    """
    A sort algorithm other than ascending or
       descending has been applied.
    """

class AccessibleState(GObject.GEnum):
    """
    The possible accessible states of a [iface@Accessible]."""

    BUSY = 0
    """
    A “busy” state. This state has boolean values
    """
    CHECKED = 1
    """
    A “checked” state; indicates the current
      state of a [class@CheckButton]. Value type: [enum@AccessibleTristate]
    """
    DISABLED = 2
    """
    A “disabled” state; corresponds to the
      [property@Widget:sensitive] property. It indicates a UI element
      that is perceivable, but not editable or operable. Value type: boolean
    """
    EXPANDED = 3
    """
    An “expanded” state; corresponds to the
      [property@Expander:expanded] property. Value type: boolean
      or undefined
    """
    HIDDEN = 4
    """
    A “hidden” state; corresponds to the
      [property@Widget:visible] property. You can use this state
      explicitly on UI elements that should not be exposed to an assistive
      technology. Value type: boolean
      See also: %GTK_ACCESSIBLE_STATE_DISABLED
    """
    INVALID = 5
    """
    An “invalid” state; set when a widget
      is showing an error. Value type: [enum@AccessibleInvalidState]
    """
    PRESSED = 6
    """
    A “pressed” state; indicates the current
      state of a [class@ToggleButton]. Value type: [enum@AccessibleTristate]
      enumeration
    """
    SELECTED = 7
    """
    A “selected” state; set when a widget
      is selected. Value type: boolean or undefined
    """
    VISITED = 8
    """
    Indicates that a widget with the GTK_ACCESSIBLE_ROLE_LINK has been visited.
    Value type: boolean.
    """

class AccessibleTextContentChange(GObject.GEnum):
    """
    The type of contents change operation."""

    INSERT = 0
    """
    contents change as the result of
      an insert operation
    """
    REMOVE = 1
    """
    contents change as the result of
      a remove operation
    """

class AccessibleTextGranularity(GObject.GEnum):
    """
    The granularity for queries about the text contents of a [iface@Gtk.AccessibleText]
    implementation."""

    CHARACTER = 0
    """
    Use the boundary between
      characters (including non-printing characters)
    """
    WORD = 1
    """
    Use the boundary between words,
      starting from the beginning of the current word and ending at the
      beginning of the next word
    """
    SENTENCE = 2
    """
    Use the boundary between
      sentences, starting from the beginning of the current sentence and
      ending at the beginning of the next sentence
    """
    LINE = 3
    """
    Use the boundary between lines,
      starting from the beginning of the current line and ending at the
      beginning of the next line
    """
    PARAGRAPH = 4
    """
    Use the boundary between
      paragraphs, starting from the beginning of the current paragraph and
      ending at the beginning of the next paragraph
    """

class AccessibleTristate(GObject.GEnum):
    """
    The possible values for the %GTK_ACCESSIBLE_STATE_PRESSED
    accessible state.

    Note that the %GTK_ACCESSIBLE_TRISTATE_FALSE and
    %GTK_ACCESSIBLE_TRISTATE_TRUE have the same values
    as %FALSE and %TRUE."""

    FALSE = 0
    """
    The state is `false`
    """
    TRUE = 1
    """
    The state is `true`
    """
    MIXED = 2
    """
    The state is `mixed`
    """

class Align(GObject.GEnum):
    """
    Controls how a widget deals with extra space in a single dimension.

    Alignment only matters if the widget receives a “too large” allocation,
    for example if you packed the widget with the [property@Gtk.Widget:hexpand]
    property inside a [class@Box], then the widget might get extra space.
    If you have for example a 16x16 icon inside a 32x32 space, the icon
    could be scaled and stretched, it could be centered, or it could be
    positioned to one side of the space.

    Note that in horizontal context `GTK_ALIGN_START` and `GTK_ALIGN_END`
    are interpreted relative to text direction.

    Baseline support is optional for containers and widgets, and is only available
    for vertical alignment. `GTK_ALIGN_BASELINE_CENTER` and `GTK_ALIGN_BASELINE_FILL`
    are treated similar to `GTK_ALIGN_CENTER` and `GTK_ALIGN_FILL`, except that it
    positions the widget to line up the baselines, where that is supported."""

    FILL = 0
    """
    stretch to fill all space if possible, center if
      no meaningful way to stretch
    """
    START = 1
    """
    snap to left or top side, leaving space on right or bottom
    """
    END = 2
    """
    snap to right or bottom side, leaving space on left or top
    """
    CENTER = 3
    """
    center natural width of widget inside the allocation
    """
    BASELINE_FILL = 4
    """
    a different name for `GTK_ALIGN_BASELINE`.
    """
    BASELINE = 4
    """
    align the widget according to the baseline.
    """
    BASELINE_CENTER = 5
    """
    stretch to fill all space, but align the baseline.
    """

class ApplicationInhibitFlags(GObject.GFlags):
    """
    Types of user actions that may be blocked by `GtkApplication`.

    See [method@Gtk.Application.inhibit]."""

    LOGOUT = 1
    """
    Inhibit ending the user session
      by logging out or by shutting down the computer
    """
    SWITCH = 2
    """
    Inhibit user switching
    """
    SUSPEND = 4
    """
    Inhibit suspending the
      session or computer
    """
    IDLE = 8
    """
    Inhibit the session being
      marked as idle (and possibly locked)
    """

class ArrowType(GObject.GEnum):
    """
    Indicates the direction in which an arrow should point."""

    UP = 0
    """
    Represents an upward pointing arrow.
    """
    DOWN = 1
    """
    Represents a downward pointing arrow.
    """
    LEFT = 2
    """
    Represents a left pointing arrow.
    """
    RIGHT = 3
    """
    Represents a right pointing arrow.
    """
    NONE = 4
    """
    No arrow.
    """

class AssistantPageType(GObject.GEnum):
    """
    Determines the role of a page inside a `GtkAssistant`.

    The role is used to handle buttons sensitivity and visibility.

    Note that an assistant needs to end its page flow with a page of type
    %GTK_ASSISTANT_PAGE_CONFIRM, %GTK_ASSISTANT_PAGE_SUMMARY or
    %GTK_ASSISTANT_PAGE_PROGRESS to be correct.

    The Cancel button will only be shown if the page isn’t “committed”.
    See gtk_assistant_commit() for details."""

    CONTENT = 0
    """
    The page has regular contents. Both the
     Back and forward buttons will be shown.
    """
    INTRO = 1
    """
    The page contains an introduction to the
     assistant task. Only the Forward button will be shown if there is a
      next page.
    """
    CONFIRM = 2
    """
    The page lets the user confirm or deny the
     changes. The Back and Apply buttons will be shown.
    """
    SUMMARY = 3
    """
    The page informs the user of the changes
     done. Only the Close button will be shown.
    """
    PROGRESS = 4
    """
    Used for tasks that take a long time to
     complete, blocks the assistant until the page is marked as complete.
      Only the back button will be shown.
    """
    CUSTOM = 5
    """
    Used for when other page types are not
     appropriate. No buttons will be shown, and the application must
     add its own buttons through gtk_assistant_add_action_widget().
    """

class BaselinePosition(GObject.GEnum):
    """
    Baseline position in a row of widgets.

    Whenever a container has some form of natural row it may align
    children in that row along a common typographical baseline. If
    the amount of vertical space in the row is taller than the total
    requested height of the baseline-aligned children then it can use a
    `GtkBaselinePosition` to select where to put the baseline inside the
    extra available space."""

    TOP = 0
    """
    Align the baseline at the top
    """
    CENTER = 1
    """
    Center the baseline
    """
    BOTTOM = 2
    """
    Align the baseline at the bottom
    """

class BorderStyle(GObject.GEnum):
    """
    Describes how the border of a UI element should be rendered."""

    NONE = 0
    """
    No visible border
    """
    HIDDEN = 1
    """
    Same as %GTK_BORDER_STYLE_NONE
    """
    SOLID = 2
    """
    A single line segment
    """
    INSET = 3
    """
    Looks as if the content is sunken into the canvas
    """
    OUTSET = 4
    """
    Looks as if the content is coming out of the canvas
    """
    DOTTED = 5
    """
    A series of round dots
    """
    DASHED = 6
    """
    A series of square-ended dashes
    """
    DOUBLE = 7
    """
    Two parallel lines with some space between them
    """
    GROOVE = 8
    """
    Looks as if it were carved in the canvas
    """
    RIDGE = 9
    """
    Looks as if it were coming out of the canvas
    """

class BuilderClosureFlags(GObject.GFlags):
    """
    The list of flags that can be passed to gtk_builder_create_closure().

    New values may be added in the future for new features, so external
    implementations of [iface@Gtk.BuilderScope] should test the flags
    for unknown values and raise a %GTK_BUILDER_ERROR_INVALID_ATTRIBUTE error
    when they encounter one."""

    SWAPPED = 1
    """
    The closure should be created swapped. See
      g_cclosure_new_swap() for details.
    """

class BuilderError(GObject.GEnum):
    """
    Error codes that identify various errors that can occur while using
    `GtkBuilder`."""

    INVALID_TYPE_FUNCTION = 0
    """
    A type-func attribute didn’t name
     a function that returns a `GType`.
    """
    UNHANDLED_TAG = 1
    """
    The input contained a tag that `GtkBuilder`
     can’t handle.
    """
    MISSING_ATTRIBUTE = 2
    """
    An attribute that is required by
     `GtkBuilder` was missing.
    """
    INVALID_ATTRIBUTE = 3
    """
    `GtkBuilder` found an attribute that
     it doesn’t understand.
    """
    INVALID_TAG = 4
    """
    `GtkBuilder` found a tag that
     it doesn’t understand.
    """
    MISSING_PROPERTY_VALUE = 5
    """
    A required property value was
     missing.
    """
    INVALID_VALUE = 6
    """
    `GtkBuilder` couldn’t parse
     some attribute value.
    """
    VERSION_MISMATCH = 7
    """
    The input file requires a newer version
     of GTK.
    """
    DUPLICATE_ID = 8
    """
    An object id occurred twice.
    """
    OBJECT_TYPE_REFUSED = 9
    """
    A specified object type is of the same type or
     derived from the type of the composite class being extended with builder XML.
    """
    TEMPLATE_MISMATCH = 10
    """
    The wrong type was specified in a composite class’s template XML
    """
    INVALID_PROPERTY = 11
    """
    The specified property is unknown for the object class.
    """
    INVALID_SIGNAL = 12
    """
    The specified signal is unknown for the object class.
    """
    INVALID_ID = 13
    """
    An object id is unknown.
    """
    INVALID_FUNCTION = 14
    """
    A function could not be found. This often happens
      when symbols are set to be kept private. Compiling code with -rdynamic or using the
      `gmodule-export-2.0` pkgconfig module can fix this problem.
    """

class ButtonsType(GObject.GEnum):
    """
    Prebuilt sets of buttons for `GtkDialog`.

    If none of these choices are appropriate, simply use
    %GTK_BUTTONS_NONE and call [method@Gtk.Dialog.add_buttons].

    > Please note that %GTK_BUTTONS_OK, %GTK_BUTTONS_YES_NO
    > and %GTK_BUTTONS_OK_CANCEL are discouraged by the
    > [GNOME Human Interface Guidelines](https://developer.gnome.org/hig/)."""

    NONE = 0
    """
    no buttons at all
    """
    OK = 1
    """
    an OK button
    """
    CLOSE = 2
    """
    a Close button
    """
    CANCEL = 3
    """
    a Cancel button
    """
    YES_NO = 4
    """
    Yes and No buttons
    """
    OK_CANCEL = 5
    """
    OK and Cancel buttons
    """

class CellRendererAccelMode(GObject.GEnum):
    """
    The available modes for [property@Gtk.CellRendererAccel:accel-mode]."""

    GTK = 0
    """
    GTK accelerators mode
    """
    OTHER = 1
    """
    Other accelerator mode
    """

class CellRendererMode(GObject.GEnum):
    """
    Identifies how the user can interact with a particular cell."""

    INERT = 0
    """
    The cell is just for display
     and cannot be interacted with.  Note that this doesn’t mean that eg. the
     row being drawn can’t be selected -- just that a particular element of
     it cannot be individually modified.
    """
    ACTIVATABLE = 1
    """
    The cell can be clicked.
    """
    EDITABLE = 2
    """
    The cell can be edited or otherwise modified.
    """

class CellRendererState(GObject.GFlags):
    """
    Tells how a cell is to be rendered."""

    SELECTED = 1
    """
    The cell is currently selected, and
     probably has a selection colored background to render to.
    """
    PRELIT = 2
    """
    The mouse is hovering over the cell.
    """
    INSENSITIVE = 4
    """
    The cell is drawn in an insensitive manner
    """
    SORTED = 8
    """
    The cell is in a sorted row
    """
    FOCUSED = 16
    """
    The cell is in the focus row.
    """
    EXPANDABLE = 32
    """
    The cell is in a row that can be expanded
    """
    EXPANDED = 64
    """
    The cell is in a row that is expanded
    """

class Collation(GObject.GEnum):
    """
    Describes how a [class@Gtk.StringSorter] turns strings into sort keys to
    compare them.

    Note that the result of sorting will in general depend on the current locale
    unless the mode is @GTK_COLLATION_NONE."""

    NONE = 0
    """
    Don't do any collation
    """
    UNICODE = 1
    """
    Use [func@GLib.utf8_collate_key]
    """
    FILENAME = 2
    """
    Use [func@GLib.utf8_collate_key_for_filename]
    """

class ConstraintAttribute(GObject.GEnum):
    """
    The widget attributes that can be used when creating a [class@Constraint]."""

    NONE = 0
    """
    No attribute, used for constant
      relations
    """
    LEFT = 1
    """
    The left edge of a widget, regardless of
      text direction
    """
    RIGHT = 2
    """
    The right edge of a widget, regardless
      of text direction
    """
    TOP = 3
    """
    The top edge of a widget
    """
    BOTTOM = 4
    """
    The bottom edge of a widget
    """
    START = 5
    """
    The leading edge of a widget, depending
      on text direction; equivalent to %GTK_CONSTRAINT_ATTRIBUTE_LEFT for LTR
      languages, and %GTK_CONSTRAINT_ATTRIBUTE_RIGHT for RTL ones
    """
    END = 6
    """
    The trailing edge of a widget, depending
      on text direction; equivalent to %GTK_CONSTRAINT_ATTRIBUTE_RIGHT for LTR
      languages, and %GTK_CONSTRAINT_ATTRIBUTE_LEFT for RTL ones
    """
    WIDTH = 7
    """
    The width of a widget
    """
    HEIGHT = 8
    """
    The height of a widget
    """
    CENTER_X = 9
    """
    The center of a widget, on the
      horizontal axis
    """
    CENTER_Y = 10
    """
    The center of a widget, on the
      vertical axis
    """
    BASELINE = 11
    """
    The baseline of a widget
    """

class ConstraintRelation(GObject.GEnum):
    """
    The relation between two terms of a constraint."""

    LE = -1
    """
    Less than, or equal
    """
    EQ = 0
    """
    Equal
    """
    GE = 1
    """
    Greater than, or equal
    """

class ConstraintStrength(GObject.GEnum):
    """
    The strength of a constraint, expressed as a symbolic constant.

    The strength of a [class@Constraint] can be expressed with any positive
    integer; the values of this enumeration can be used for readability."""

    REQUIRED = 1001001000
    """
    The constraint is required towards solving the layout
    """
    STRONG = 1000000000
    """
    A strong constraint
    """
    MEDIUM = 1000
    """
    A medium constraint
    """
    WEAK = 1
    """
    A weak constraint
    """

class ConstraintVflParserError(GObject.GEnum):
    """
    Domain for VFL parsing errors."""

    SYMBOL = 0
    """
    Invalid or unknown symbol
    """
    ATTRIBUTE = 1
    """
    Invalid or unknown attribute
    """
    VIEW = 2
    """
    Invalid or unknown view
    """
    METRIC = 3
    """
    Invalid or unknown metric
    """
    PRIORITY = 4
    """
    Invalid or unknown priority
    """
    RELATION = 5
    """
    Invalid or unknown relation
    """

class ContentFit(GObject.GEnum):
    """
    Controls how a content should be made to fit inside an allocation."""

    FILL = 0
    """
    Make the content fill the entire allocation,
      without taking its aspect ratio in consideration. The resulting
      content will appear as stretched if its aspect ratio is different
      from the allocation aspect ratio.
    """
    CONTAIN = 1
    """
    Scale the content to fit the allocation,
      while taking its aspect ratio in consideration. The resulting
      content will appear as letterboxed if its aspect ratio is different
      from the allocation aspect ratio.
    """
    COVER = 2
    """
    Cover the entire allocation, while taking
      the content aspect ratio in consideration. The resulting content
      will appear as clipped if its aspect ratio is different from the
      allocation aspect ratio.
    """
    SCALE_DOWN = 3
    """
    The content is scaled down to fit the
      allocation, if needed, otherwise its original size is used.
    """

class CornerType(GObject.GEnum):
    """
    Specifies which corner a child widget should be placed in when packed into
    a `GtkScrolledWindow.`

    This is effectively the opposite of where the scroll bars are placed."""

    TOP_LEFT = 0
    """
    Place the scrollbars on the right and bottom of the
      widget (default behaviour).
    """
    BOTTOM_LEFT = 1
    """
    Place the scrollbars on the top and right of the
      widget.
    """
    TOP_RIGHT = 2
    """
    Place the scrollbars on the left and bottom of the
      widget.
    """
    BOTTOM_RIGHT = 3
    """
    Place the scrollbars on the top and left of the
      widget.
    """

class CssParserError(enum.IntEnum):
    """
    Errors that can occur while parsing CSS.

    These errors are unexpected and will cause parts of the given CSS
    to be ignored."""

    FAILED = 0
    """
    Unknown failure.
    """
    SYNTAX = 1
    """
    The given text does not form valid syntax
    """
    IMPORT = 2
    NAME = 3
    """
    The given name has not been defined
    """
    UNKNOWN_VALUE = 4
    """
    The given value is not correct
    """

class CssParserWarning(enum.IntEnum):
    """
    Warnings that can occur while parsing CSS.

    Unlike `GtkCssParserError`s, warnings do not cause the parser to
    skip any input, but they indicate issues that should be fixed."""

    DEPRECATED = 0
    """
    The given construct is
      deprecated and will be removed in a future version
    """
    SYNTAX = 1
    """
    A syntax construct was used
      that should be avoided
    """
    UNIMPLEMENTED = 2
    """
    A feature is not implemented
    """

class DebugFlags(GObject.GFlags):
    """
    Flags to use with gtk_set_debug_flags().

    Settings these flags causes GTK to print out different
    types of debugging information. Some of these flags are
    only available when GTK has been configured with `-Ddebug=true`."""

    TEXT = 1
    """
    Information about GtkTextView
    """
    TREE = 2
    """
    Information about GtkTreeView
    """
    KEYBINDINGS = 4
    """
    Information about keyboard shortcuts
    """
    MODULES = 8
    """
    Information about modules and extensions
    """
    GEOMETRY = 16
    """
    Information about size allocation
    """
    ICONTHEME = 32
    """
    Information about icon themes
    """
    PRINTING = 64
    """
    Information about printing
    """
    BUILDER_TRACE = 128
    SIZE_REQUEST = 256
    """
    Information about size requests
    """
    NO_CSS_CACHE = 512
    """
    Disable the style property cache
    """
    INTERACTIVE = 1024
    """
    Open the GTK inspector
    """
    ACTIONS = 4096
    """
    Information about actions and menu models
    """
    LAYOUT = 8192
    """
    Information from layout managers
    """
    SNAPSHOT = 16384
    """
    Include debug render nodes in the generated snapshots
    """
    CONSTRAINTS = 32768
    """
    Information from the constraints solver
    """
    BUILDER_OBJECTS = 65536
    """
    Log unused GtkBuilder objects
    """
    A11Y = 131072
    """
    Information about accessibility state changes
    """
    ICONFALLBACK = 262144
    """
    Information about icon fallback.
    """
    INVERT_TEXT_DIR = 524288
    """
    Inverts the default text-direction.
    """
    CSS = 1048576
    """
    Information about deprecated CSS features.
    """
    BUILDER = 2097152
    """
    Trace GtkBuilder operation
    """

class DeleteType(GObject.GEnum):
    """
    Passed to various keybinding signals for deleting text."""

    CHARS = 0
    """
    Delete characters.
    """
    WORD_ENDS = 1
    """
    Delete only the portion of the word to the
      left/right of cursor if we’re in the middle of a word.
    """
    WORDS = 2
    """
    Delete words.
    """
    DISPLAY_LINES = 3
    """
    Delete display-lines. Display-lines
      refers to the visible lines, with respect to the current line
      breaks. As opposed to paragraphs, which are defined by line
      breaks in the input.
    """
    DISPLAY_LINE_ENDS = 4
    """
    Delete only the portion of the
      display-line to the left/right of cursor.
    """
    PARAGRAPH_ENDS = 5
    """
    Delete to the end of the
      paragraph. Like C-k in Emacs (or its reverse).
    """
    PARAGRAPHS = 6
    """
    Delete entire line. Like C-k in pico.
    """
    WHITESPACE = 7
    """
    Delete only whitespace. Like M- in Emacs.
    """

class DialogError(GObject.GEnum):
    """
    Error codes in the `GTK_DIALOG_ERROR` domain that can be returned
    by async dialog functions."""

    FAILED = 0
    """
    Generic error condition for when
      an operation fails and no more specific code is applicable
    """
    CANCELLED = 1
    """
    The async function call was cancelled
      via its `GCancellable`
    """
    DISMISSED = 2
    """
    The operation was cancelled
      by the user (via a Cancel or Close button)
    """

class DialogFlags(GObject.GFlags):
    """
    Flags used to influence dialog construction."""

    MODAL = 1
    """
    Make the constructed dialog modal
    """
    DESTROY_WITH_PARENT = 2
    """
    Destroy the dialog when its parent is destroyed
    """
    USE_HEADER_BAR = 4
    """
    Create dialog with actions in header
      bar instead of action area
    """

class DirectionType(GObject.GEnum):
    """
    Focus movement types."""

    TAB_FORWARD = 0
    """
    Move forward.
    """
    TAB_BACKWARD = 1
    """
    Move backward.
    """
    UP = 2
    """
    Move up.
    """
    DOWN = 3
    """
    Move down.
    """
    LEFT = 4
    """
    Move left.
    """
    RIGHT = 5
    """
    Move right.
    """

class EditableProperties(GObject.GEnum):
    """
    The identifiers for [iface@Gtk.Editable] properties.

    See [func@Gtk.Editable.install_properties] for details on how to
    implement the `GtkEditable` interface."""

    PROP_TEXT = 0
    """
    the property id for [property@Gtk.Editable:text]
    """
    PROP_CURSOR_POSITION = 1
    """
    the property id for [property@Gtk.Editable:cursor-position]
    """
    PROP_SELECTION_BOUND = 2
    """
    the property id for [property@Gtk.Editable:selection-bound]
    """
    PROP_EDITABLE = 3
    """
    the property id for [property@Gtk.Editable:editable]
    """
    PROP_WIDTH_CHARS = 4
    """
    the property id for [property@Gtk.Editable:width-chars]
    """
    PROP_MAX_WIDTH_CHARS = 5
    """
    the property id for [property@Gtk.Editable:max-width-chars]
    """
    PROP_XALIGN = 6
    """
    the property id for [property@Gtk.Editable:xalign]
    """
    PROP_ENABLE_UNDO = 7
    """
    the property id for [property@Gtk.Editable:enable-undo]
    """
    NUM_PROPERTIES = 8
    """
    the number of properties
    """

class EntryIconPosition(GObject.GEnum):
    """
    Specifies the side of the entry at which an icon is placed."""

    PRIMARY = 0
    """
    At the beginning of the entry (depending on the text direction).
    """
    SECONDARY = 1
    """
    At the end of the entry (depending on the text direction).
    """

class EventControllerScrollFlags(GObject.GFlags):
    """
    Describes the behavior of a `GtkEventControllerScroll`."""

    NONE = 0
    """
    Don't emit scroll.
    """
    VERTICAL = 1
    """
    Emit scroll with vertical deltas.
    """
    HORIZONTAL = 2
    """
    Emit scroll with horizontal deltas.
    """
    DISCRETE = 4
    """
    Only emit deltas that are multiples of 1.
    """
    KINETIC = 8
    """
    Emit ::decelerate after continuous scroll finishes.
    """
    BOTH_AXES = 3
    """
    Emit scroll on both axes.
    """

class EventSequenceState(GObject.GEnum):
    """
    Describes the state of a [struct@Gdk.EventSequence] in a [class@Gesture]."""

    NONE = 0
    """
    The sequence is handled, but not grabbed.
    """
    CLAIMED = 1
    """
    The sequence is handled and grabbed.
    """
    DENIED = 2
    """
    The sequence is denied.
    """

class FileChooserAction(GObject.GEnum):
    """
    Describes whether a `GtkFileChooser` is being used to open existing files
    or to save to a possibly new file."""

    OPEN = 0
    """
    Indicates open mode.  The file chooser
     will only let the user pick an existing file.
    """
    SAVE = 1
    """
    Indicates save mode.  The file chooser
     will let the user pick an existing file, or type in a new
     filename.
    """
    SELECT_FOLDER = 2
    """
    Indicates an Open mode for
     selecting folders.  The file chooser will let the user pick an
     existing folder.
    """

class FileChooserError(GObject.GEnum):
    """
    These identify the various errors that can occur while calling
    `GtkFileChooser` functions."""

    NONEXISTENT = 0
    """
    Indicates that a file does not exist.
    """
    BAD_FILENAME = 1
    """
    Indicates a malformed filename.
    """
    ALREADY_EXISTS = 2
    """
    Indicates a duplicate path (e.g. when
     adding a bookmark).
    """
    INCOMPLETE_HOSTNAME = 3
    """
    Indicates an incomplete hostname
     (e.g. "http://foo" without a slash after that).
    """

class FilterChange(GObject.GEnum):
    """
    Describes changes in a filter in more detail and allows objects
    using the filter to optimize refiltering items.

    If you are writing an implementation and are not sure which
    value to pass, `GTK_FILTER_CHANGE_DIFFERENT` is always a correct
    choice."""

    DIFFERENT = 0
    """
    The filter change cannot be
      described with any of the other enumeration values
    """
    LESS_STRICT = 1
    """
    The filter is less strict than
      it was before: All items that it used to return true
      still return true, others now may, too.
    """
    MORE_STRICT = 2
    """
    The filter is more strict than
      it was before: All items that it used to return false
      still return false, others now may, too.
    """

class FilterMatch(GObject.GEnum):
    """
    Describes the known strictness of a filter.

    Note that for filters where the strictness is not known,
    `GTK_FILTER_MATCH_SOME` is always an acceptable value,
    even if a filter does match all or no items."""

    SOME = 0
    """
    The filter matches some items,
      [method@Gtk.Filter.match] may return true or false
    """
    NONE = 1
    """
    The filter does not match any item,
      [method@Gtk.Filter.match] will always return false
    """
    ALL = 2
    """
    The filter matches all items,
      [method@Gtk.Filter.match] will alays return true
    """

class FontChooserLevel(GObject.GFlags):
    """
    Specifies the granularity of font selection
    that is desired in a `GtkFontChooser`.

    This enumeration may be extended in the future; applications should
    ignore unknown values."""

    FAMILY = 0
    """
    Allow selecting a font family
    """
    STYLE = 1
    """
    Allow selecting a specific font face
    """
    SIZE = 2
    """
    Allow selecting a specific font size
    """
    VARIATIONS = 4
    """
    Allow changing OpenType font variation axes
    """
    FEATURES = 8
    """
    Allow selecting specific OpenType font features
    """

class FontLevel(GObject.GEnum):
    """
    The level of granularity for the font selection.

    Depending on this value, the `PangoFontDescription` that
    is returned by [method@Gtk.FontDialogButton.get_font_desc]
    will have more or less fields set."""

    FAMILY = 0
    """
    Select a font family
    """
    FACE = 1
    """
    Select a font face (i.e. a family and a style)
    """
    FONT = 2
    """
    Select a font (i.e. a face with a size, and possibly font variations)
    """
    FEATURES = 3
    """
    Select a font and font features
    """

class FontRendering(GObject.GEnum):
    """
    Values for the [property@Gtk.Settings:gtk-font-rendering] setting
    that influence how GTK renders fonts."""

    AUTOMATIC = 0
    """
    Set up font rendering automatically,
      taking factors like screen resolution and scale into account
    """
    MANUAL = 1
    """
    Follow low-level font-related settings
      when configuring font rendering
    """

class GraphicsOffloadEnabled(GObject.GEnum):
    """
    Represents the state of graphics offloading."""

    ENABLED = 0
    """
    Graphics offloading is enabled.
    """
    DISABLED = 1
    """
    Graphics offloading is disabled.
    """

class IconLookupFlags(GObject.GFlags):
    """
    Used to specify options for gtk_icon_theme_lookup_icon()."""

    NONE = 0
    """
    Perform a regular lookup.
    """
    FORCE_REGULAR = 1
    """
    Try to always load regular icons, even
      when symbolic icon names are given
    """
    FORCE_SYMBOLIC = 2
    """
    Try to always load symbolic icons, even
      when regular icon names are given
    """
    PRELOAD = 4
    """
    Starts loading the texture in the background
      so it is ready when later needed.
    """

class IconSize(GObject.GEnum):
    """
    Built-in icon sizes.

    Icon sizes default to being inherited. Where they cannot be
    inherited, text size is the default.

    All widgets which use `GtkIconSize` set the normal-icons or
    large-icons style classes correspondingly, and let themes
    determine the actual size to be used with the
    `-gtk-icon-size` CSS property."""

    INHERIT = 0
    """
    Keep the size of the parent element
    """
    NORMAL = 1
    """
    Size similar to text size
    """
    LARGE = 2
    """
    Large size, for example in an icon view
    """

class IconThemeError(GObject.GEnum):
    """
    Error codes for `GtkIconTheme` operations."""

    NOT_FOUND = 0
    """
    The icon specified does not exist in the theme
    """
    FAILED = 1
    """
    An unspecified error occurred.
    """

class IconViewDropPosition(GObject.GEnum):
    """
    An enum for determining where a dropped item goes."""

    NO_DROP = 0
    """
    no drop possible
    """
    DROP_INTO = 1
    """
    dropped item replaces the item
    """
    DROP_LEFT = 2
    """
    dropped item is inserted to the left
    """
    DROP_RIGHT = 3
    """
    dropped item is inserted to the right
    """
    DROP_ABOVE = 4
    """
    dropped item is inserted above
    """
    DROP_BELOW = 5
    """
    dropped item is inserted below
    """

class ImageType(GObject.GEnum):
    """
    Describes the image data representation used by a [class@Gtk.Image].

    If you want to get the image from the widget, you can only get the
    currently-stored representation; for instance, if the gtk_image_get_storage_type()
    returns %GTK_IMAGE_PAINTABLE, then you can call gtk_image_get_paintable().

    For empty images, you can request any storage type (call any of the "get"
    functions), but they will all return %NULL values."""

    EMPTY = 0
    """
    there is no image displayed by the widget
    """
    ICON_NAME = 1
    """
    the widget contains a named icon
    """
    GICON = 2
    """
    the widget contains a `GIcon`
    """
    PAINTABLE = 3
    """
    the widget contains a `GdkPaintable`
    """

class InputHints(GObject.GFlags):
    """
    Describes hints that might be taken into account by input methods
    or applications.

    Note that input methods may already tailor their behaviour according
    to the [enum@InputPurpose] of the entry.

    Some common sense is expected when using these flags - mixing
    %GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.

    This enumeration may be extended in the future; input methods should
    ignore unknown values."""

    NONE = 0
    """
    No special behaviour suggested
    """
    SPELLCHECK = 1
    """
    Suggest checking for typos
    """
    NO_SPELLCHECK = 2
    """
    Suggest not checking for typos
    """
    WORD_COMPLETION = 4
    """
    Suggest word completion
    """
    LOWERCASE = 8
    """
    Suggest to convert all text to lowercase
    """
    UPPERCASE_CHARS = 16
    """
    Suggest to capitalize all text
    """
    UPPERCASE_WORDS = 32
    """
    Suggest to capitalize the first
      character of each word
    """
    UPPERCASE_SENTENCES = 64
    """
    Suggest to capitalize the
      first word of each sentence
    """
    INHIBIT_OSK = 128
    """
    Suggest to not show an onscreen keyboard
      (e.g for a calculator that already has all the keys).
    """
    VERTICAL_WRITING = 256
    """
    The text is vertical
    """
    EMOJI = 512
    """
    Suggest offering Emoji support
    """
    NO_EMOJI = 1024
    """
    Suggest not offering Emoji support
    """
    PRIVATE = 2048
    """
    Request that the input method should not
       update personalized data (like typing history)
    """

class InputPurpose(GObject.GEnum):
    """
    Describes primary purpose of the input widget.

    This information is useful for on-screen keyboards and similar input
    methods to decide which keys should be presented to the user.

    Note that the purpose is not meant to impose a totally strict rule
    about allowed characters, and does not replace input validation.
    It is fine for an on-screen keyboard to let the user override the
    character set restriction that is expressed by the purpose. The
    application is expected to validate the entry contents, even if
    it specified a purpose.

    The difference between %GTK_INPUT_PURPOSE_DIGITS and
    %GTK_INPUT_PURPOSE_NUMBER is that the former accepts only digits
    while the latter also some punctuation (like commas or points, plus,
    minus) and “e” or “E” as in 3.14E+000.

    This enumeration may be extended in the future; input methods should
    interpret unknown values as “free form”."""

    FREE_FORM = 0
    """
    Allow any character
    """
    ALPHA = 1
    """
    Allow only alphabetic characters
    """
    DIGITS = 2
    """
    Allow only digits
    """
    NUMBER = 3
    """
    Edited field expects numbers
    """
    PHONE = 4
    """
    Edited field expects phone number
    """
    URL = 5
    """
    Edited field expects URL
    """
    EMAIL = 6
    """
    Edited field expects email address
    """
    NAME = 7
    """
    Edited field expects the name of a person
    """
    PASSWORD = 8
    """
    Like %GTK_INPUT_PURPOSE_FREE_FORM, but characters are hidden
    """
    PIN = 9
    """
    Like %GTK_INPUT_PURPOSE_DIGITS, but characters are hidden
    """
    TERMINAL = 10
    """
    Allow any character, in addition to control codes
    """

class InscriptionOverflow(GObject.GEnum):
    """
    The different methods to handle text in #GtkInscription when it doesn't
    fit the available space."""

    CLIP = 0
    """
    Clip the remaining text
    """
    ELLIPSIZE_START = 1
    """
    Omit characters at the start of the text
    """
    ELLIPSIZE_MIDDLE = 2
    """
    Omit characters at the middle of the text
    """
    ELLIPSIZE_END = 3
    """
    Omit characters at the end of the text
    """

class Justification(GObject.GEnum):
    """
    Used for justifying the text inside a [class@Label] widget."""

    LEFT = 0
    """
    The text is placed at the left edge of the label.
    """
    RIGHT = 1
    """
    The text is placed at the right edge of the label.
    """
    CENTER = 2
    """
    The text is placed in the center of the label.
    """
    FILL = 3
    """
    The text is placed is distributed across the label.
    """

class LevelBarMode(GObject.GEnum):
    """
    Describes how [class@LevelBar] contents should be rendered.

    Note that this enumeration could be extended with additional modes
    in the future."""

    CONTINUOUS = 0
    """
    the bar has a continuous mode
    """
    DISCRETE = 1
    """
    the bar has a discrete mode
    """

class License(GObject.GEnum):
    """
    The type of license for an application.

    This enumeration can be expanded at later date."""

    UNKNOWN = 0
    """
    No license specified
    """
    CUSTOM = 1
    """
    A license text is going to be specified by the
      developer
    """
    GPL_2_0 = 2
    """
    The GNU General Public License, version 2.0 or later
    """
    GPL_3_0 = 3
    """
    The GNU General Public License, version 3.0 or later
    """
    LGPL_2_1 = 4
    """
    The GNU Lesser General Public License, version 2.1 or later
    """
    LGPL_3_0 = 5
    """
    The GNU Lesser General Public License, version 3.0 or later
    """
    BSD = 6
    """
    The BSD standard license
    """
    MIT_X11 = 7
    """
    The MIT/X11 standard license
    """
    ARTISTIC = 8
    """
    The Artistic License, version 2.0
    """
    GPL_2_0_ONLY = 9
    """
    The GNU General Public License, version 2.0 only
    """
    GPL_3_0_ONLY = 10
    """
    The GNU General Public License, version 3.0 only
    """
    LGPL_2_1_ONLY = 11
    """
    The GNU Lesser General Public License, version 2.1 only
    """
    LGPL_3_0_ONLY = 12
    """
    The GNU Lesser General Public License, version 3.0 only
    """
    AGPL_3_0 = 13
    """
    The GNU Affero General Public License, version 3.0 or later
    """
    AGPL_3_0_ONLY = 14
    """
    The GNU Affero General Public License, version 3.0 only
    """
    BSD_3 = 15
    """
    The 3-clause BSD licence
    """
    APACHE_2_0 = 16
    """
    The Apache License, version 2.0
    """
    MPL_2_0 = 17
    """
    The Mozilla Public License, version 2.0
    """
    _0BSD = 18  # [0bsd]: changed because started with a number
    """
    Zero-Clause BSD license
    """

class ListScrollFlags(GObject.GFlags):
    """
    List of actions to perform when scrolling to items in
    a list widget."""

    NONE = 0
    """
    Don't do anything extra
    """
    FOCUS = 1
    """
    Focus the target item
    """
    SELECT = 2
    """
    Select the target item and
      unselect all other items.
    """

class ListTabBehavior(GObject.GEnum):
    """
    Used to configure the focus behavior in the `GTK_DIR_TAB_FORWARD`
    and `GTK_DIR_TAB_BACKWARD` direction, like the <kbd>Tab</kbd> key
    in a [class@Gtk.ListView]."""

    ALL = 0
    """
    Cycle through all focusable items of the list
    """
    ITEM = 1
    """
    Cycle through a single list element, then move
      focus out of the list. Moving focus between items needs to be
      done with the arrow keys.
    """
    CELL = 2
    """
    Cycle only through a single cell, then
      move focus out of the list. Moving focus between cells needs to
      be done with the arrow keys. This is only relevant for
      cell-based widgets like #GtkColumnView, otherwise it behaves
      like `GTK_LIST_TAB_ITEM`.
    """

class MessageType(GObject.GEnum):
    """
    The type of message being displayed in a [class@MessageDialog]."""

    INFO = 0
    """
    Informational message
    """
    WARNING = 1
    """
    Non-fatal warning message
    """
    QUESTION = 2
    """
    Question requiring a choice
    """
    ERROR = 3
    """
    Fatal error message
    """
    OTHER = 4
    """
    None of the above
    """

class MovementStep(GObject.GEnum):
    """
    Passed as argument to various keybinding signals for moving the
    cursor position."""

    LOGICAL_POSITIONS = 0
    """
    Move forward or back by graphemes
    """
    VISUAL_POSITIONS = 1
    """
    Move left or right by graphemes
    """
    WORDS = 2
    """
    Move forward or back by words
    """
    DISPLAY_LINES = 3
    """
    Move up or down lines (wrapped lines)
    """
    DISPLAY_LINE_ENDS = 4
    """
    Move to either end of a line
    """
    PARAGRAPHS = 5
    """
    Move up or down paragraphs (newline-ended lines)
    """
    PARAGRAPH_ENDS = 6
    """
    Move to either end of a paragraph
    """
    PAGES = 7
    """
    Move by pages
    """
    BUFFER_ENDS = 8
    """
    Move to ends of the buffer
    """
    HORIZONTAL_PAGES = 9
    """
    Move horizontally by pages
    """

class NaturalWrapMode(GObject.GEnum):
    """
    Options for selecting a different wrap mode for natural size
    requests.

    See for example the [property@Gtk.Label:natural-wrap-mode] property."""

    INHERIT = 0
    """
    Inherit the minimum size request.
      In particular, this should be used with %PANGO_WRAP_CHAR.
    """
    NONE = 1
    """
    Try not to wrap the text. This mode is the
      closest to GTK3's behavior but can lead to a wide label leaving
      lots of empty space below the text.
    """
    WORD = 2
    """
    Attempt to wrap at word boundaries. This
      is useful in particular when using %PANGO_WRAP_WORD_CHAR as the
      wrap mode.
    """

class NotebookTab(GObject.GEnum):
    """
    The parameter used in the action signals of `GtkNotebook`."""

    FIRST = 0
    """
    the first tab in the notebook
    """
    LAST = 1
    """
    the last tab in the notebook
    """

class NumberUpLayout(GObject.GEnum):
    """
    Used to determine the layout of pages on a sheet when printing
    multiple pages per sheet."""

    LRTB = 0
    """
    ![](layout-lrtb.png)
    """
    LRBT = 1
    """
    ![](layout-lrbt.png)
    """
    RLTB = 2
    """
    ![](layout-rltb.png)
    """
    RLBT = 3
    """
    ![](layout-rlbt.png)
    """
    TBLR = 4
    """
    ![](layout-tblr.png)
    """
    TBRL = 5
    """
    ![](layout-tbrl.png)
    """
    BTLR = 6
    """
    ![](layout-btlr.png)
    """
    BTRL = 7
    """
    ![](layout-btrl.png)
    """

class Ordering(GObject.GEnum):
    """
    Describes the way two values can be compared.

    These values can be used with a [callback@GLib.CompareFunc]. However,
    a `GCompareFunc` is allowed to return any integer values.
    For converting such a value to a `GtkOrdering` value, use
    [func@Gtk.Ordering.from_cmpfunc]."""

    SMALLER = -1
    """
    the first value is smaller than the second
    """
    EQUAL = 0
    """
    the two values are equal
    """
    LARGER = 1
    """
    the first value is larger than the second
    """

class Orientation(GObject.GEnum):
    """
    Represents the orientation of widgets and other objects.

    Typical examples are [class@Box] or [class@GesturePan]."""

    HORIZONTAL = 0
    """
    The element is in horizontal orientation.
    """
    VERTICAL = 1
    """
    The element is in vertical orientation.
    """

class Overflow(GObject.GEnum):
    """
    Defines how content overflowing a given area should be handled.

    This is used in [method@Gtk.Widget.set_overflow]. The
    [property@Gtk.Widget:overflow] property is modeled after the
    CSS overflow property, but implements it only partially."""

    VISIBLE = 0
    """
    No change is applied. Content is drawn at the specified
      position.
    """
    HIDDEN = 1
    """
    Content is clipped to the bounds of the area. Content
      outside the area is not drawn and cannot be interacted with.
    """

class PackType(GObject.GEnum):
    """
    Represents the packing location of a children in its parent.

    See [class@WindowControls] for example."""

    START = 0
    """
    The child is packed into the start of the widget
    """
    END = 1
    """
    The child is packed into the end of the widget
    """

class PadActionType(GObject.GEnum):
    """
    The type of a pad action."""

    BUTTON = 0
    """
    Action is triggered by a pad button
    """
    RING = 1
    """
    Action is triggered by a pad ring
    """
    STRIP = 2
    """
    Action is triggered by a pad strip
    """

class PageOrientation(GObject.GEnum):
    """
    See also gtk_print_settings_set_orientation()."""

    PORTRAIT = 0
    """
    Portrait mode.
    """
    LANDSCAPE = 1
    """
    Landscape mode.
    """
    REVERSE_PORTRAIT = 2
    """
    Reverse portrait mode.
    """
    REVERSE_LANDSCAPE = 3
    """
    Reverse landscape mode.
    """

class PageSet(GObject.GEnum):
    """
    See also gtk_print_job_set_page_set()."""

    ALL = 0
    """
    All pages.
    """
    EVEN = 1
    """
    Even pages.
    """
    ODD = 2
    """
    Odd pages.
    """

class PanDirection(GObject.GEnum):
    """
    Describes the panning direction of a [class@GesturePan]."""

    LEFT = 0
    """
    panned towards the left
    """
    RIGHT = 1
    """
    panned towards the right
    """
    UP = 2
    """
    panned upwards
    """
    DOWN = 3
    """
    panned downwards
    """

class PickFlags(GObject.GFlags):
    """
    Flags that influence the behavior of [method@Widget.pick]."""

    DEFAULT = 0
    """
    The default behavior, include widgets that are receiving events
    """
    INSENSITIVE = 1
    """
    Include widgets that are insensitive
    """
    NON_TARGETABLE = 2
    """
    Include widgets that are marked as non-targetable. See [property@Widget:can-target]
    """

class PolicyType(GObject.GEnum):
    """
    Determines how the size should be computed to achieve the one of the
    visibility mode for the scrollbars."""

    ALWAYS = 0
    """
    The scrollbar is always visible. The view size is
      independent of the content.
    """
    AUTOMATIC = 1
    """
    The scrollbar will appear and disappear as necessary.
      For example, when all of a `GtkTreeView` can not be seen.
    """
    NEVER = 2
    """
    The scrollbar should never appear. In this mode the
      content determines the size.
    """
    EXTERNAL = 3
    """
    Don't show a scrollbar, but don't force the
      size to follow the content. This can be used e.g. to make multiple
      scrolled windows share a scrollbar.
    """

class PopoverMenuFlags(GObject.GFlags):
    """
    Flags that affect how [class@Gtk.PopoverMenu] widgets built from
    a [class@Gio.MenuModel] are created and displayed."""

    SLIDING = 0
    """
    Submenus are presented as sliding submenus that replace the main menu.
    """
    NESTED = 1
    """
    Submenus are presented as traditional, nested
      popovers.
    """

class PositionType(GObject.GEnum):
    """
    Describes which edge of a widget a certain feature is positioned at.

    For examples, see the tabs of a [class@Notebook], or the label
    of a [class@Scale]."""

    LEFT = 0
    """
    The feature is at the left edge.
    """
    RIGHT = 1
    """
    The feature is at the right edge.
    """
    TOP = 2
    """
    The feature is at the top edge.
    """
    BOTTOM = 3
    """
    The feature is at the bottom edge.
    """

class PrintCapabilities(GObject.GFlags):
    """
    Specifies which features the print dialog should offer.

    If neither %GTK_PRINT_CAPABILITY_GENERATE_PDF nor
    %GTK_PRINT_CAPABILITY_GENERATE_PS is specified, GTK assumes that all
    formats are supported."""

    PAGE_SET = 1
    """
    Print dialog will offer printing even/odd pages.
    """
    COPIES = 2
    """
    Print dialog will allow to print multiple copies.
    """
    COLLATE = 4
    """
    Print dialog will allow to collate multiple copies.
    """
    REVERSE = 8
    """
    Print dialog will allow to print pages in reverse order.
    """
    SCALE = 16
    """
    Print dialog will allow to scale the output.
    """
    GENERATE_PDF = 32
    """
    The program will send the document to
      the printer in PDF format
    """
    GENERATE_PS = 64
    """
    The program will send the document to
      the printer in Postscript format
    """
    PREVIEW = 128
    """
    Print dialog will offer a preview
    """
    NUMBER_UP = 256
    """
    Print dialog will offer printing multiple
      pages per sheet
    """
    NUMBER_UP_LAYOUT = 512
    """
    Print dialog will allow to rearrange
      pages when printing multiple pages per sheet
    """

class PrintDuplex(GObject.GEnum):
    """
    See also gtk_print_settings_set_duplex()."""

    SIMPLEX = 0
    """
    No duplex.
    """
    HORIZONTAL = 1
    """
    Horizontal duplex.
    """
    VERTICAL = 2
    """
    Vertical duplex.
    """

class PrintError(GObject.GEnum):
    """
    Error codes that identify various errors that can occur while
    using the GTK printing support."""

    GENERAL = 0
    """
    An unspecified error occurred.
    """
    INTERNAL_ERROR = 1
    """
    An internal error occurred.
    """
    NOMEM = 2
    """
    A memory allocation failed.
    """
    INVALID_FILE = 3
    """
    An error occurred while loading a page setup
      or paper size from a key file.
    """

class PrintOperationAction(GObject.GEnum):
    """
    Determines what action the print operation should perform.

    A parameter of this typs is passed to [method@Gtk.PrintOperation.run]."""

    PRINT_DIALOG = 0
    """
    Show the print dialog.
    """
    PRINT = 1
    PREVIEW = 2
    """
    Show the print preview.
    """
    EXPORT = 3
    """
    Export to a file. This requires
      the export-filename property to be set.
    """

class PrintOperationResult(GObject.GEnum):
    """
    The result of a print operation.

    A value of this type is returned by [method@Gtk.PrintOperation.run]."""

    ERROR = 0
    """
    An error has occurred.
    """
    APPLY = 1
    """
    The print settings should be stored.
    """
    CANCEL = 2
    """
    The print operation has been canceled,
      the print settings should not be stored.
    """
    IN_PROGRESS = 3
    """
    The print operation is not complete
      yet. This value will only be returned when running asynchronously.
    """

class PrintPages(GObject.GEnum):
    """
    See also gtk_print_job_set_pages()"""

    ALL = 0
    """
    All pages.
    """
    CURRENT = 1
    """
    Current page.
    """
    RANGES = 2
    """
    Range of pages.
    """
    SELECTION = 3
    """
    Selected pages.
    """

class PrintQuality(GObject.GEnum):
    """
    See also gtk_print_settings_set_quality()."""

    LOW = 0
    """
    Low quality.
    """
    NORMAL = 1
    """
    Normal quality.
    """
    HIGH = 2
    """
    High quality.
    """
    DRAFT = 3
    """
    Draft quality.
    """

class PrintStatus(GObject.GEnum):
    """
    The status gives a rough indication of the completion of a running
    print operation."""

    INITIAL = 0
    """
    The printing has not started yet; this
      status is set initially, and while the print dialog is shown.
    """
    PREPARING = 1
    """
    This status is set while the begin-print
      signal is emitted and during pagination.
    """
    GENERATING_DATA = 2
    """
    This status is set while the
      pages are being rendered.
    """
    SENDING_DATA = 3
    """
    The print job is being sent off to the
      printer.
    """
    PENDING = 4
    """
    The print job has been sent to the printer,
      but is not printed for some reason, e.g. the printer may be stopped.
    """
    PENDING_ISSUE = 5
    """
    Some problem has occurred during
      printing, e.g. a paper jam.
    """
    PRINTING = 6
    """
    The printer is processing the print job.
    """
    FINISHED = 7
    """
    The printing has been completed successfully.
    """
    FINISHED_ABORTED = 8
    """
    The printing has been aborted.
    """

class PropagationLimit(GObject.GEnum):
    """
    Describes limits of a [class@EventController] for handling events
    targeting other widgets."""

    NONE = 0
    """
    Events are handled regardless of what their
      target is.
    """
    SAME_NATIVE = 1
    """
    Events are only handled if their target is in
      the same [iface@Native] (or widget with [property@Gtk.Widget:limit-events]
      set) as the event controllers widget.
      Note that some event types have two targets (origin and destination).
    """

class PropagationPhase(GObject.GEnum):
    """
    Describes the stage at which events are fed into a [class@EventController]."""

    NONE = 0
    """
    Events are not delivered.
    """
    CAPTURE = 1
    """
    Events are delivered in the capture phase. The
      capture phase happens before the bubble phase, runs from the toplevel down
      to the event widget. This option should only be used on containers that
      might possibly handle events before their children do.
    """
    BUBBLE = 2
    """
    Events are delivered in the bubble phase. The bubble
      phase happens after the capture phase, and before the default handlers
      are run. This phase runs from the event widget, up to the toplevel.
    """
    TARGET = 3
    """
    Events are delivered in the default widget event handlers,
      note that widget implementations must chain up on button, motion, touch and
      grab broken handlers for controllers in this phase to be run.
    """

class RecentManagerError(GObject.GEnum):
    """
    Error codes for `GtkRecentManager` operations"""

    NOT_FOUND = 0
    """
    the URI specified does not exists in
      the recently used resources list.
    """
    INVALID_URI = 1
    """
    the URI specified is not valid.
    """
    INVALID_ENCODING = 2
    """
    the supplied string is not
      UTF-8 encoded.
    """
    NOT_REGISTERED = 3
    """
    no application has registered
      the specified item.
    """
    READ = 4
    """
    failure while reading the recently used
      resources file.
    """
    WRITE = 5
    """
    failure while writing the recently used
      resources file.
    """
    UNKNOWN = 6
    """
    unspecified error.
    """

class ResponseType(GObject.GEnum):
    """
    Predefined values for use as response ids in gtk_dialog_add_button().

    All predefined values are negative; GTK leaves values of 0 or greater for
    application-defined response ids."""

    NONE = -1
    """
    Returned if an action widget has no response id,
      or if the dialog gets programmatically hidden or destroyed
    """
    REJECT = -2
    """
    Generic response id, not used by GTK dialogs
    """
    ACCEPT = -3
    """
    Generic response id, not used by GTK dialogs
    """
    DELETE_EVENT = -4
    """
    Returned if the dialog is deleted
    """
    OK = -5
    """
    Returned by OK buttons in GTK dialogs
    """
    CANCEL = -6
    """
    Returned by Cancel buttons in GTK dialogs
    """
    CLOSE = -7
    """
    Returned by Close buttons in GTK dialogs
    """
    YES = -8
    """
    Returned by Yes buttons in GTK dialogs
    """
    NO = -9
    """
    Returned by No buttons in GTK dialogs
    """
    APPLY = -10
    """
    Returned by Apply buttons in GTK dialogs
    """
    HELP = -11
    """
    Returned by Help buttons in GTK dialogs
    """

class RevealerTransitionType(GObject.GEnum):
    """
    These enumeration values describe the possible transitions
    when the child of a `GtkRevealer` widget is shown or hidden."""

    NONE = 0
    """
    No transition
    """
    CROSSFADE = 1
    """
    Fade in
    """
    SLIDE_RIGHT = 2
    """
    Slide in from the left
    """
    SLIDE_LEFT = 3
    """
    Slide in from the right
    """
    SLIDE_UP = 4
    """
    Slide in from the bottom
    """
    SLIDE_DOWN = 5
    """
    Slide in from the top
    """
    SWING_RIGHT = 6
    """
    Floop in from the left
    """
    SWING_LEFT = 7
    """
    Floop in from the right
    """
    SWING_UP = 8
    """
    Floop in from the bottom
    """
    SWING_DOWN = 9
    """
    Floop in from the top
    """

class ScrollStep(GObject.GEnum):
    """
    Passed as argument to various keybinding signals."""

    STEPS = 0
    """
    Scroll in steps.
    """
    PAGES = 1
    """
    Scroll by pages.
    """
    ENDS = 2
    """
    Scroll to ends.
    """
    HORIZONTAL_STEPS = 3
    """
    Scroll in horizontal steps.
    """
    HORIZONTAL_PAGES = 4
    """
    Scroll by horizontal pages.
    """
    HORIZONTAL_ENDS = 5
    """
    Scroll to the horizontal ends.
    """

class ScrollType(GObject.GEnum):
    """
    Scrolling types."""

    NONE = 0
    """
    No scrolling.
    """
    JUMP = 1
    """
    Jump to new location.
    """
    STEP_BACKWARD = 2
    """
    Step backward.
    """
    STEP_FORWARD = 3
    """
    Step forward.
    """
    PAGE_BACKWARD = 4
    """
    Page backward.
    """
    PAGE_FORWARD = 5
    """
    Page forward.
    """
    STEP_UP = 6
    """
    Step up.
    """
    STEP_DOWN = 7
    """
    Step down.
    """
    PAGE_UP = 8
    """
    Page up.
    """
    PAGE_DOWN = 9
    """
    Page down.
    """
    STEP_LEFT = 10
    """
    Step to the left.
    """
    STEP_RIGHT = 11
    """
    Step to the right.
    """
    PAGE_LEFT = 12
    """
    Page to the left.
    """
    PAGE_RIGHT = 13
    """
    Page to the right.
    """
    START = 14
    """
    Scroll to start.
    """
    END = 15
    """
    Scroll to end.
    """

class ScrollablePolicy(GObject.GEnum):
    """
    Defines the policy to be used in a scrollable widget when updating
    the scrolled window adjustments in a given orientation."""

    MINIMUM = 0
    """
    Scrollable adjustments are based on the minimum size
    """
    NATURAL = 1
    """
    Scrollable adjustments are based on the natural size
    """

class SelectionMode(GObject.GEnum):
    """
    Used to control what selections users are allowed to make."""

    NONE = 0
    """
    No selection is possible.
    """
    SINGLE = 1
    """
    Zero or one element may be selected.
    """
    BROWSE = 2
    """
    Exactly one element is selected.
      In some circumstances, such as initially or during a search
      operation, it’s possible for no element to be selected with
      %GTK_SELECTION_BROWSE. What is really enforced is that the user
      can’t deselect a currently selected element except by selecting
      another element.
    """
    MULTIPLE = 3
    """
    Any number of elements may be selected.
      The Ctrl key may be used to enlarge the selection, and Shift
      key to select between the focus and the child pointed to.
      Some widgets may also allow Click-drag to select a range of elements.
    """

class SensitivityType(GObject.GEnum):
    """
    Determines how GTK handles the sensitivity of various controls,
    such as combo box buttons."""

    AUTO = 0
    """
    The control is made insensitive if no
      action can be triggered
    """
    ON = 1
    """
    The control is always sensitive
    """
    OFF = 2
    """
    The control is always insensitive
    """

class ShortcutActionFlags(GObject.GFlags):
    """
    Flags that can be passed to action activation.

    More flags may be added in the future."""

    EXCLUSIVE = 1
    """
    The action is the only
      action that can be activated. If this flag is not set,
      a future activation may select a different action.
    """

class ShortcutScope(GObject.GEnum):
    """
    Describes where [class@Shortcut]s added to a
    [class@ShortcutController] get handled."""

    LOCAL = 0
    """
    Shortcuts are handled inside
      the widget the controller belongs to.
    """
    MANAGED = 1
    """
    Shortcuts are handled by
      the first ancestor that is a [iface@ShortcutManager]
    """
    GLOBAL = 2

class ShortcutType(GObject.GEnum):
    """
    GtkShortcutType specifies the kind of shortcut that is being described.

    More values may be added to this enumeration over time."""

    ACCELERATOR = 0
    """
    The shortcut is a keyboard accelerator. The GtkShortcutsShortcut:accelerator
      property will be used.
    """
    GESTURE_PINCH = 1
    """
    The shortcut is a pinch gesture. GTK provides an icon and subtitle.
    """
    GESTURE_STRETCH = 2
    """
    The shortcut is a stretch gesture. GTK provides an icon and subtitle.
    """
    GESTURE_ROTATE_CLOCKWISE = 3
    """
    The shortcut is a clockwise rotation gesture. GTK provides an icon and subtitle.
    """
    GESTURE_ROTATE_COUNTERCLOCKWISE = 4
    """
    The shortcut is a counterclockwise rotation gesture. GTK provides an icon and subtitle.
    """
    GESTURE_TWO_FINGER_SWIPE_LEFT = 5
    """
    The shortcut is a two-finger swipe gesture. GTK provides an icon and subtitle.
    """
    GESTURE_TWO_FINGER_SWIPE_RIGHT = 6
    """
    The shortcut is a two-finger swipe gesture. GTK provides an icon and subtitle.
    """
    GESTURE = 7
    """
    The shortcut is a gesture. The GtkShortcutsShortcut:icon property will be
      used.
    """
    GESTURE_SWIPE_LEFT = 8
    """
    The shortcut is a swipe gesture. GTK provides an icon and subtitle.
    """
    GESTURE_SWIPE_RIGHT = 9
    """
    The shortcut is a swipe gesture. GTK provides an icon and subtitle.
    """

class SizeGroupMode(GObject.GEnum):
    """
    The mode of the size group determines the directions in which the size
    group affects the requested sizes of its component widgets."""

    NONE = 0
    """
    group has no effect
    """
    HORIZONTAL = 1
    """
    group affects horizontal requisition
    """
    VERTICAL = 2
    """
    group affects vertical requisition
    """
    BOTH = 3
    """
    group affects both horizontal and vertical requisition
    """

class SizeRequestMode(GObject.GEnum):
    """
    Specifies a preference for height-for-width or
    width-for-height geometry management."""

    HEIGHT_FOR_WIDTH = 0
    """
    Prefer height-for-width geometry management
    """
    WIDTH_FOR_HEIGHT = 1
    """
    Prefer width-for-height geometry management
    """
    CONSTANT_SIZE = 2
    """
    Don’t trade height-for-width or width-for-height
    """

class SortType(GObject.GEnum):
    """
    Determines the direction of a sort."""

    ASCENDING = 0
    """
    Sorting is in ascending order.
    """
    DESCENDING = 1
    """
    Sorting is in descending order.
    """

class SorterChange(GObject.GEnum):
    """
    Describes changes in a sorter in more detail and allows users
    to optimize resorting."""

    DIFFERENT = 0
    """
    The sorter change cannot be described
      by any of the other enumeration values
    """
    INVERTED = 1
    """
    The sort order was inverted. Comparisons
      that returned %GTK_ORDERING_SMALLER now return %GTK_ORDERING_LARGER
      and vice versa. Other comparisons return the same values as before.
    """
    LESS_STRICT = 2
    """
    The sorter is less strict: Comparisons
      may now return %GTK_ORDERING_EQUAL that did not do so before.
    """
    MORE_STRICT = 3
    """
    The sorter is more strict: Comparisons
      that did return %GTK_ORDERING_EQUAL may not do so anymore.
    """

class SorterOrder(GObject.GEnum):
    """
    Describes the type of order that a `GtkSorter` may produce."""

    PARTIAL = 0
    """
    A partial order. Any `GtkOrdering` is possible.
    """
    NONE = 1
    """
    No order, all elements are considered equal.
      gtk_sorter_compare() will only return %GTK_ORDERING_EQUAL.
    """
    TOTAL = 2
    """
    A total order. gtk_sorter_compare() will only
      return %GTK_ORDERING_EQUAL if an item is compared with itself. Two
      different items will never cause this value to be returned.
    """

class SpinButtonUpdatePolicy(GObject.GEnum):
    """
    Determines whether the spin button displays values outside the adjustment
    bounds.

    See [method@Gtk.SpinButton.set_update_policy]."""

    ALWAYS = 0
    """
    When refreshing your `GtkSpinButton`, the value is
      always displayed
    """
    IF_VALID = 1
    """
    When refreshing your `GtkSpinButton`, the value is
      only displayed if it is valid within the bounds of the spin button's
      adjustment
    """

class SpinType(GObject.GEnum):
    """
    The values of the GtkSpinType enumeration are used to specify the
    change to make in gtk_spin_button_spin()."""

    STEP_FORWARD = 0
    """
    Increment by the adjustments step increment.
    """
    STEP_BACKWARD = 1
    """
    Decrement by the adjustments step increment.
    """
    PAGE_FORWARD = 2
    """
    Increment by the adjustments page increment.
    """
    PAGE_BACKWARD = 3
    """
    Decrement by the adjustments page increment.
    """
    HOME = 4
    """
    Go to the adjustments lower bound.
    """
    END = 5
    """
    Go to the adjustments upper bound.
    """
    USER_DEFINED = 6
    """
    Change by a specified amount.
    """

class StackTransitionType(GObject.GEnum):
    """
    Possible transitions between pages in a `GtkStack` widget.

    New values may be added to this enumeration over time."""

    NONE = 0
    """
    No transition
    """
    CROSSFADE = 1
    """
    A cross-fade
    """
    SLIDE_RIGHT = 2
    """
    Slide from left to right
    """
    SLIDE_LEFT = 3
    """
    Slide from right to left
    """
    SLIDE_UP = 4
    """
    Slide from bottom up
    """
    SLIDE_DOWN = 5
    """
    Slide from top down
    """
    SLIDE_LEFT_RIGHT = 6
    """
    Slide from left or right according to the children order
    """
    SLIDE_UP_DOWN = 7
    """
    Slide from top down or bottom up according to the order
    """
    OVER_UP = 8
    """
    Cover the old page by sliding up
    """
    OVER_DOWN = 9
    """
    Cover the old page by sliding down
    """
    OVER_LEFT = 10
    """
    Cover the old page by sliding to the left
    """
    OVER_RIGHT = 11
    """
    Cover the old page by sliding to the right
    """
    UNDER_UP = 12
    """
    Uncover the new page by sliding up
    """
    UNDER_DOWN = 13
    """
    Uncover the new page by sliding down
    """
    UNDER_LEFT = 14
    """
    Uncover the new page by sliding to the left
    """
    UNDER_RIGHT = 15
    """
    Uncover the new page by sliding to the right
    """
    OVER_UP_DOWN = 16
    """
    Cover the old page sliding up or uncover the new page sliding down, according to order
    """
    OVER_DOWN_UP = 17
    """
    Cover the old page sliding down or uncover the new page sliding up, according to order
    """
    OVER_LEFT_RIGHT = 18
    """
    Cover the old page sliding left or uncover the new page sliding right, according to order
    """
    OVER_RIGHT_LEFT = 19
    """
    Cover the old page sliding right or uncover the new page sliding left, according to order
    """
    ROTATE_LEFT = 20
    """
    Pretend the pages are sides of a cube and rotate that cube to the left
    """
    ROTATE_RIGHT = 21
    """
    Pretend the pages are sides of a cube and rotate that cube to the right
    """
    ROTATE_LEFT_RIGHT = 22
    """
    Pretend the pages are sides of a cube and rotate that cube to the left or right according to the children order
    """

class StateFlags(GObject.GFlags):
    """
    Describes a widget state.

    Widget states are used to match the widget against CSS pseudo-classes.
    Note that GTK extends the regular CSS classes and sometimes uses
    different names."""

    NORMAL = 0
    """
    State during normal operation
    """
    ACTIVE = 1
    """
    Widget is active
    """
    PRELIGHT = 2
    """
    Widget has a mouse pointer over it
    """
    SELECTED = 4
    """
    Widget is selected
    """
    INSENSITIVE = 8
    """
    Widget is insensitive
    """
    INCONSISTENT = 16
    """
    Widget is inconsistent
    """
    FOCUSED = 32
    """
    Widget has the keyboard focus
    """
    BACKDROP = 64
    """
    Widget is in a background toplevel window
    """
    DIR_LTR = 128
    """
    Widget is in left-to-right text direction
    """
    DIR_RTL = 256
    """
    Widget is in right-to-left text direction
    """
    LINK = 512
    """
    Widget is a link
    """
    VISITED = 1024
    """
    The location the widget points to has already been visited
    """
    CHECKED = 2048
    """
    Widget is checked
    """
    DROP_ACTIVE = 4096
    """
    Widget is highlighted as a drop target for DND
    """
    FOCUS_VISIBLE = 8192
    """
    Widget has the visible focus
    """
    FOCUS_WITHIN = 16384
    """
    Widget contains the keyboard focus
    """

class StringFilterMatchMode(GObject.GEnum):
    """
    Specifies how search strings are matched inside text."""

    EXACT = 0
    """
    The search string and
      text must match exactly
    """
    SUBSTRING = 1
    """
    The search string
      must be contained as a substring inside the text
    """
    PREFIX = 2
    """
    The text must begin
      with the search string
    """

class StyleContextPrintFlags(GObject.GFlags):
    """
    Flags that modify the behavior of gtk_style_context_to_string().

    New values may be added to this enumeration."""

    NONE = 0
    """
    Default value.
    """
    RECURSE = 1
    """
    Print the entire tree of
      CSS nodes starting at the style context's node
    """
    SHOW_STYLE = 2
    """
    Show the values of the
      CSS properties for each node
    """
    SHOW_CHANGE = 4
    """
    Show information about
      what changes affect the styles
    """

class SymbolicColor(GObject.GEnum):
    """
    The indexes of colors passed to symbolic color rendering, such as
    [vfunc@Gtk.SymbolicPaintable.snapshot_symbolic].

    More values may be added over time."""

    FOREGROUND = 0
    """
    The default foreground color
    """
    ERROR = 1
    """
    Indication color for errors
    """
    WARNING = 2
    """
    Indication color for warnings
    """
    SUCCESS = 3
    """
    Indication color for success
    """

class SystemSetting(GObject.GEnum):
    """
    Values that can be passed to the [vfunc@Gtk.Widget.system_setting_changed]
    vfunc.

    The values indicate which system setting has changed.
    Widgets may need to drop caches, or react otherwise.

    Most of the values correspond to [class@Settings] properties.

    More values may be added over time."""

    DPI = 0
    """
    the [property@Gtk.Settings:gtk-xft-dpi] setting has changed
    """
    FONT_NAME = 1
    """
    The [property@Gtk.Settings:gtk-font-name] setting has changed
    """
    FONT_CONFIG = 2
    """
    The font configuration has changed in a way that
      requires text to be redrawn. This can be any of the
      [property@Gtk.Settings:gtk-xft-antialias],
      [property@Gtk.Settings:gtk-xft-hinting],
      [property@Gtk.Settings:gtk-xft-hintstyle],
      [property@Gtk.Settings:gtk-xft-rgba] or
      [property@Gtk.Settings:gtk-fontconfig-timestamp] settings
    """
    DISPLAY = 3
    """
    The display has changed
    """
    ICON_THEME = 4
    """
    The icon theme has changed in a way that requires
      icons to be looked up again
    """

class TextBufferNotifyFlags(GObject.GFlags):
    """
    Values for [callback@Gtk.TextBufferCommitNotify] to denote the
    point of the notification."""

    BEFORE_INSERT = 1
    """
    Be notified before text
      is inserted into the underlying buffer.
    """
    AFTER_INSERT = 2
    """
    Be notified after text
      has been inserted into the underlying buffer.
    """
    BEFORE_DELETE = 4
    """
    Be notified before text
      is deleted from the underlying buffer.
    """
    AFTER_DELETE = 8
    """
    Be notified after text
      has been deleted from the underlying buffer.
    """

class TextDirection(GObject.GEnum):
    """
    Reading directions for text."""

    NONE = 0
    """
    No direction.
    """
    LTR = 1
    """
    Left to right text direction.
    """
    RTL = 2
    """
    Right to left text direction.
    """

class TextExtendSelection(GObject.GEnum):
    """
    Granularity types that extend the text selection. Use the
    `GtkTextView::extend-selection` signal to customize the selection."""

    WORD = 0
    """
    Selects the current word. It is triggered by
      a double-click for example.
    """
    LINE = 1
    """
    Selects the current line. It is triggered by
      a triple-click for example.
    """

class TextSearchFlags(GObject.GFlags):
    """
    Flags affecting how a search is done.

    If neither `GTK_TEXT_SEARCH_VISIBLE_ONLY` nor `GTK_TEXT_SEARCH_TEXT_ONLY`
    are enabled, the match must be exact; the special 0xFFFC character will
    match embedded paintables or child widgets."""

    VISIBLE_ONLY = 1
    """
    Search only visible data. A search match may
    have invisible text interspersed.
    """
    TEXT_ONLY = 2
    """
    Search only text. A match may have paintables or
    child widgets mixed inside the matched range.
    """
    CASE_INSENSITIVE = 4
    """
    The text will be matched regardless of
    what case it is in.
    """

class TextViewLayer(GObject.GEnum):
    """
    Used to reference the layers of `GtkTextView` for the purpose of customized
    drawing with the ::snapshot_layer vfunc."""

    BELOW_TEXT = 0
    """
    The layer rendered below the text (but above the background).
    """
    ABOVE_TEXT = 1
    """
    The layer rendered above the text.
    """

class TextWindowType(GObject.GEnum):
    """
    Used to reference the parts of `GtkTextView`."""

    WIDGET = 1
    """
    Window that floats over scrolling areas.
    """
    TEXT = 2
    """
    Scrollable text window.
    """
    LEFT = 3
    """
    Left side border window.
    """
    RIGHT = 4
    """
    Right side border window.
    """
    TOP = 5
    """
    Top border window.
    """
    BOTTOM = 6
    """
    Bottom border window.
    """

class TreeModelFlags(GObject.GFlags):
    """
    These flags indicate various properties of a `GtkTreeModel`.

    They are returned by [method@Gtk.TreeModel.get_flags], and must be
    static for the lifetime of the object. A more complete description
    of %GTK_TREE_MODEL_ITERS_PERSIST can be found in the overview of
    this section."""

    ITERS_PERSIST = 1
    """
    iterators survive all signals
      emitted by the tree
    """
    LIST_ONLY = 2
    """
    the model is a list only, and never
      has children
    """

class TreeViewColumnSizing(GObject.GEnum):
    """
    The sizing method the column uses to determine its width.  Please note
    that %GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for large views, and
    can make columns appear choppy."""

    GROW_ONLY = 0
    """
    Columns only get bigger in reaction to changes in the model
    """
    AUTOSIZE = 1
    """
    Columns resize to be the optimal size every time the model changes.
    """
    FIXED = 2
    """
    Columns are a fixed numbers of pixels wide.
    """

class TreeViewDropPosition(GObject.GEnum):
    """
    An enum for determining where a dropped row goes."""

    BEFORE = 0
    """
    dropped row is inserted before
    """
    AFTER = 1
    """
    dropped row is inserted after
    """
    INTO_OR_BEFORE = 2
    """
    dropped row becomes a child or is inserted before
    """
    INTO_OR_AFTER = 3
    """
    dropped row becomes a child or is inserted after
    """

class TreeViewGridLines(GObject.GEnum):
    """
    Used to indicate which grid lines to draw in a tree view."""

    NONE = 0
    """
    No grid lines.
    """
    HORIZONTAL = 1
    """
    Horizontal grid lines.
    """
    VERTICAL = 2
    """
    Vertical grid lines.
    """
    BOTH = 3
    """
    Horizontal and vertical grid lines.
    """

class Unit(GObject.GEnum):
    """
    See also gtk_print_settings_set_paper_width()."""

    NONE = 0
    """
    No units.
    """
    POINTS = 1
    """
    Dimensions in points.
    """
    INCH = 2
    """
    Dimensions in inches.
    """
    MM = 3
    """
    Dimensions in millimeters
    """

class WrapMode(GObject.GEnum):
    """
    Describes a type of line wrapping."""

    NONE = 0
    """
    do not wrap lines; just make the text area wider
    """
    CHAR = 1
    """
    wrap text, breaking lines anywhere the cursor can
      appear (between characters, usually - if you want to be technical,
      between graphemes, see pango_get_log_attrs())
    """
    WORD = 2
    """
    wrap text, breaking lines in between words
    """
    WORD_CHAR = 3
    """
    wrap text, breaking lines in between words, or if
      that is not enough, also between graphemes
    """

###############################################################
# classes
###############################################################

class ATContext(GObject.Object):
    """
    Communicates with platform-specific assistive technologies API.

    Each platform supported by GTK implements a `GtkATContext` subclass, and
    is responsible for updating the accessible state in response to state
    changes in `GtkAccessible`.
    """

    class Props(GObject.Object.Props):
        accessible: Accessible | None
        accessible_role: AccessibleRole  # [accessible-role]: changed because contained invalid characters
        display: Gdk.Display | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accessible: Accessible | None = ...,
        accessible_role: AccessibleRole = ...,
        display: Gdk.Display | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def create(
        cls, accessible_role: AccessibleRole, accessible: Accessible, display: Gdk.Display
    ) -> ATContext | None: ...
    @builtins.property
    def get_accessible(self) -> Accessible: ...
    @builtins.property
    def get_accessible_role(self) -> AccessibleRole: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["state-change"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accessible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accessible_role"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::display"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ATContextClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AboutDialog(Window):
    """
    Displays information about a program.

    The shown information includes the programs' logo, name, copyright,
    website and license. It is also possible to give credits to the authors,
    documenters, translators and artists who have worked on the program.

    An about dialog is typically opened when the user selects the `About`
    option from the `Help` menu. All parts of the dialog are optional.

    <picture>
      <source srcset="aboutdialot-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkAboutDialog" src="aboutdialog.png">
    </picture>

    About dialogs often contain links and email addresses. `GtkAboutDialog`
    displays these as clickable links. By default, it calls [method@Gtk.FileLauncher.launch]
    when a user clicks one. The behaviour can be overridden with the
    [signal@Gtk.AboutDialog::activate-link] signal.

    To specify a person with an email address, use a string like
    `Edgar Allan Poe <edgar@poe.com>`. To specify a website with a title,
    use a string like `GTK team https://www.gtk.org`.

    To make constructing an about dialog as convenient as possible, you can
    use the function [func@Gtk.show_about_dialog] which constructs and shows
    a dialog and keeps it around so that it can be shown again.

    Note that GTK sets a default title of `_("About %s")` on the dialog
    window (where `%s` is replaced by the name of the application, but in
    order to ensure proper translation of the title, applications should
    set the title property explicitly when constructing an about dialog,
    as shown in the following example:

    ```c
    GFile *logo_file = g_file_new_for_path ("./logo.png");
    GdkTexture *example_logo = gdk_texture_new_from_file (logo_file, NULL);
    g_object_unref (logo_file);

    gtk_show_about_dialog (NULL,
                           "program-name", "ExampleCode",
                           "logo", example_logo,
                           "title", _("About ExampleCode"),
                           NULL);
    ```

    ## Shortcuts and Gestures

    `GtkAboutDialog` supports the following keyboard shortcuts:

    - <kbd>Escape</kbd> closes the window.

    ## CSS nodes

    `GtkAboutDialog` has a single CSS node with the name `window` and style
    class `.aboutdialog`.
    """

    class Props(Window.Props):
        artists: list | None
        authors: list | None
        comments: str
        copyright: str
        documenters: list | None
        license: str
        license_type: License  # [license-type]: changed because contained invalid characters
        logo: Gdk.Paintable | None
        logo_icon_name: str  # [logo-icon-name]: changed because contained invalid characters
        program_name: str  # [program-name]: changed because contained invalid characters
        system_information: str  # [system-information]: changed because contained invalid characters
        translator_credits: str  # [translator-credits]: changed because contained invalid characters
        version: str
        website: str
        website_label: str  # [website-label]: changed because contained invalid characters
        wrap_license: bool  # [wrap-license]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        artists: list | None = ...,
        authors: list | None = ...,
        comments: str = ...,
        copyright: str = ...,
        documenters: list | None = ...,
        license: str = ...,
        license_type: License = ...,
        logo: Gdk.Paintable | None = ...,
        logo_icon_name: str = ...,
        program_name: str = ...,
        system_information: str = ...,
        translator_credits: str = ...,
        version: str = ...,
        website: str = ...,
        website_label: str = ...,
        wrap_license: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_credit_section(self, section_name: str, people: list) -> None: ...
    @builtins.property
    def get_artists(self) -> list: ...
    @builtins.property
    def get_authors(self) -> list: ...
    @builtins.property
    def get_comments(self) -> str | None: ...
    @builtins.property
    def get_copyright(self) -> str | None: ...
    @builtins.property
    def get_documenters(self) -> list: ...
    @builtins.property
    def get_license(self) -> str | None: ...
    @builtins.property
    def get_license_type(self) -> License: ...
    @builtins.property
    def get_logo(self) -> Gdk.Paintable | None: ...
    @builtins.property
    def get_logo_icon_name(self) -> str | None: ...
    @builtins.property
    def get_program_name(self) -> str | None: ...
    @builtins.property
    def get_system_information(self) -> str | None: ...
    @builtins.property
    def get_translator_credits(self) -> str | None: ...
    @builtins.property
    def get_version(self) -> str | None: ...
    @builtins.property
    def get_website(self) -> str | None: ...
    @builtins.property
    def get_website_label(self) -> str | None: ...
    @builtins.property
    def get_wrap_license(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_artists(self, artists: list) -> None: ...
    def set_authors(self, authors: list) -> None: ...
    def set_comments(self, comments: str | None = None) -> None: ...
    def set_copyright(self, copyright: str | None = None) -> None: ...
    def set_documenters(self, documenters: list) -> None: ...
    def set_license(self, license: str | None = None) -> None: ...
    def set_license_type(self, license_type: License) -> None: ...
    def set_logo(self, logo: Gdk.Paintable | None = None) -> None: ...
    def set_logo_icon_name(self, icon_name: str | None = None) -> None: ...
    def set_program_name(self, name: str | None = None) -> None: ...
    def set_system_information(self, system_information: str | None = None) -> None: ...
    def set_translator_credits(self, translator_credits: str | None = None) -> None: ...
    def set_version(self, version: str | None = None) -> None: ...
    def set_website(self, website: str | None = None) -> None: ...
    def set_website_label(self, website_label: str) -> None: ...
    def set_wrap_license(self, wrap_license: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate-link"],
        handler: typing.Callable[[typing_extensions.Self, str], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::artists"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::authors"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::comments"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::copyright"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::documenters"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::license"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::license_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::logo"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::logo_icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::program_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::system_information"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::translator_credits"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::version"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::website"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::website_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap_license"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Accessible(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        accessible_role: AccessibleRole  # [accessible-role]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, accessible_role: AccessibleRole = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def announce(self, message: str, priority: AccessibleAnnouncementPriority) -> None: ...
    def get_accessible_parent(self) -> Accessible | None: ...
    @builtins.property
    def get_accessible_role(self) -> AccessibleRole: ...
    def get_at_context(self) -> ATContext: ...
    def get_bounds(self) -> tuple[bool, int, int, int, int]: ...
    def get_first_accessible_child(self) -> Accessible | None: ...
    def get_next_accessible_sibling(self) -> Accessible | None: ...
    def get_platform_state(self, state: AccessiblePlatformState) -> bool: ...
    def reset_property(self, property: AccessibleProperty) -> None: ...
    def reset_relation(self, relation: AccessibleRelation) -> None: ...
    def reset_state(self, state: AccessibleState) -> None: ...
    def set_accessible_parent(
        self, parent: Accessible | None = None, next_sibling: Accessible | None = None
    ) -> None: ...
    def update_next_accessible_sibling(self, new_sibling: Accessible | None = None) -> None: ...
    def update_platform_state(self, state: AccessiblePlatformState) -> None: ...
    def update_property(self, n_properties: int, properties: list, values: list) -> None: ...
    def update_relation(self, n_relations: int, relations: list, values: list) -> None: ...
    def update_state(self, n_states: int, states: list, values: list) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accessible_role"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AccessibleInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_accessible_parent(self) -> get_accessible_parentAccessibleInterfaceCB | None: ...
    @builtins.property
    def get_at_context(self) -> get_at_contextAccessibleInterfaceCB | None: ...
    @builtins.property
    def get_bounds(self) -> get_boundsAccessibleInterfaceCB: ...
    @builtins.property
    def get_first_accessible_child(self) -> get_first_accessible_childAccessibleInterfaceCB | None: ...
    @builtins.property
    def get_next_accessible_sibling(self) -> get_next_accessible_siblingAccessibleInterfaceCB | None: ...
    @builtins.property
    def get_platform_state(self) -> get_platform_stateAccessibleInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AccessibleList(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_objects(self) -> list: ...
    @classmethod
    def new_from_array(cls, accessibles: list, n_accessibles: int) -> AccessibleList: ...
    @classmethod
    def new_from_list(cls, list: list) -> AccessibleList: ...

class AccessibleRange(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AccessibleRangeInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def set_current_value(self) -> set_current_valueAccessibleRangeInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AccessibleText(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def update_caret_position(self) -> None: ...
    def update_contents(self, change: AccessibleTextContentChange, start: int, end: int) -> None: ...
    def update_selection_bound(self) -> None: ...

class AccessibleTextInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_attributes(self) -> get_attributesAccessibleTextInterfaceCB: ...
    @builtins.property
    def get_caret_position(self) -> get_caret_positionAccessibleTextInterfaceCB: ...
    @builtins.property
    def get_contents(self) -> get_contentsAccessibleTextInterfaceCB: ...
    @builtins.property
    def get_contents_at(self) -> get_contents_atAccessibleTextInterfaceCB: ...
    @builtins.property
    def get_default_attributes(self) -> get_default_attributesAccessibleTextInterfaceCB: ...
    @builtins.property
    def get_extents(self) -> get_extentsAccessibleTextInterfaceCB: ...
    @builtins.property
    def get_offset(self) -> get_offsetAccessibleTextInterfaceCB: ...
    @builtins.property
    def get_selection(self) -> get_selectionAccessibleTextInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AccessibleTextRange(GObject.GPointer):
    # gi Fields
    length: int = ...
    start: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ActionBar(Widget):
    """
    Presents contextual actions.

    <picture>
      <source srcset="action-bar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkActionBar" src="action-bar.png">
    </picture>

    `GtkActionBar` is expected to be displayed below the content and expand
    horizontally to fill the area.

    It allows placing children at the start or the end. In addition, it
    contains an internal centered box which is centered with respect to
    the full width of the box, even if the children at either side take
    up different amounts of space.

    # GtkActionBar as GtkBuildable

    The `GtkActionBar` implementation of the `GtkBuildable` interface supports
    adding children at the start or end sides by specifying “start” or “end” as
    the “type” attribute of a `<child>` element, or setting the center widget
    by specifying “center” value.

    # CSS nodes

    ```
    actionbar
    ╰── revealer
        ╰── box
            ├── box.start
            │   ╰── [start children]
            ├── [center widget]
            ╰── box.end
                ╰── [end children]
    ```

    A `GtkActionBar`'s CSS node is called `actionbar`. It contains a `revealer`
    subnode, which contains a `box` subnode, which contains two `box` subnodes at
    the start and end of the action bar, with `start` and `end` style classes
    respectively, as well as a center node that represents the center child.

    Each of the boxes contains children packed for that side.
    """

    class Props(Widget.Props):
        revealed: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, revealed: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_center_widget(self) -> Widget | None: ...
    @builtins.property
    def get_revealed(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def pack_end(self, child: Widget) -> None: ...
    def pack_start(self, child: Widget) -> None: ...
    def remove(self, child: Widget) -> None: ...
    def set_center_widget(self, center_widget: Widget | None = None) -> None: ...
    def set_revealed(self, revealed: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::revealed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Actionable(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        action_name: str  # [action-name]: changed because contained invalid characters
        action_target: GLib.Variant | None  # [action-target]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, action_name: str = ..., action_target: GLib.Variant | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_action_name(self) -> str | None: ...
    @builtins.property
    def get_action_target_value(self) -> GLib.Variant | None: ...
    def set_action_name(self, action_name: str | None = None) -> None: ...
    def set_action_target_value(self, target_value: GLib.Variant | None = None) -> None: ...
    def set_detailed_action_name(self, detailed_action_name: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::action_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::action_target"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ActionableInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_action_name(self) -> get_action_nameActionableInterfaceCB | None: ...
    @builtins.property
    def get_action_target_value(self) -> get_action_target_valueActionableInterfaceCB | None: ...
    @builtins.property
    def set_action_name(self) -> set_action_nameActionableInterfaceCB: ...
    @builtins.property
    def set_action_target_value(self) -> set_action_target_valueActionableInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ActivateAction(ShortcutAction):
    """
    Activates a widget.

    Widgets are activated by calling [method@Gtk.Widget.activate].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get() -> ActivateAction: ...

class ActivateActionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Adjustment(GObject.InitiallyUnowned):
    """
    A model for a numeric value.

    The `GtkAdjustment` has an associated lower and upper bound.
    It also contains step and page increments, and a page size.

    Adjustments are used within several GTK widgets, including
    [class@Gtk.SpinButton], [class@Gtk.Viewport], [class@Gtk.Scrollbar]
    and [class@Gtk.Scale].

    The `GtkAdjustment` object does not update the value itself. Instead
    it is left up to the owner of the `GtkAdjustment` to control the value.
    """

    class Props(GObject.InitiallyUnowned.Props):
        lower: float
        page_increment: float  # [page-increment]: changed because contained invalid characters
        page_size: float  # [page-size]: changed because contained invalid characters
        step_increment: float  # [step-increment]: changed because contained invalid characters
        upper: float
        value: float

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def clamp_page(self, lower: float, upper: float) -> None: ...
    def configure(
        self, value: float, lower: float, upper: float, step_increment: float, page_increment: float, page_size: float
    ) -> None: ...
    @builtins.property
    def get_lower(self) -> float: ...
    def get_minimum_increment(self) -> float: ...
    @builtins.property
    def get_page_increment(self) -> float: ...
    @builtins.property
    def get_page_size(self) -> float: ...
    @builtins.property
    def get_step_increment(self) -> float: ...
    @builtins.property
    def get_upper(self) -> float: ...
    @builtins.property
    def get_value(self) -> float: ...
    @classmethod
    def new(
        cls, value: float, lower: float, upper: float, step_increment: float, page_increment: float, page_size: float
    ) -> Adjustment: ...
    def set_lower(self, lower: float) -> None: ...
    def set_page_increment(self, page_increment: float) -> None: ...
    def set_page_size(self, page_size: float) -> None: ...
    def set_step_increment(self, step_increment: float) -> None: ...
    def set_upper(self, upper: float) -> None: ...
    def set_value(self, value: float) -> None: ...

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["value-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::lower"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::page_increment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::page_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::step_increment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::upper"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::value"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AdjustmentClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def changed(self) -> changedAdjustmentClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.InitiallyUnownedClass | None: ...
    @builtins.property
    def value_changed(self) -> value_changedAdjustmentClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AlertDialog(GObject.Object):
    """
    Collects the arguments that are needed to present a message to the user.

    The message is shown with the [method@Gtk.AlertDialog.choose]
    function.

    If you don't need to wait for a button to be clicked, you can use
    [method@Gtk.AlertDialog.show].
    """

    class Props(GObject.Object.Props):
        buttons: list | None
        cancel_button: int  # [cancel-button]: changed because contained invalid characters
        default_button: int  # [default-button]: changed because contained invalid characters
        detail: str
        message: str
        modal: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        buttons: list | None = ...,
        cancel_button: int = ...,
        default_button: int = ...,
        detail: str = ...,
        message: str = ...,
        modal: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def choose(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def choose_finish(self, result: Gio.AsyncResult) -> int: ...
    @builtins.property
    def get_buttons(self) -> list | None: ...
    @builtins.property
    def get_cancel_button(self) -> int: ...
    @builtins.property
    def get_default_button(self) -> int: ...
    @builtins.property
    def get_detail(self) -> str: ...
    @builtins.property
    def get_message(self) -> str: ...
    @builtins.property
    def get_modal(self) -> bool: ...
    def set_buttons(self, labels: list) -> None: ...
    def set_cancel_button(self, button: int) -> None: ...
    def set_default_button(self, button: int) -> None: ...
    def set_detail(self, detail: str) -> None: ...
    def set_message(self, message: str) -> None: ...
    def set_modal(self, modal: bool) -> None: ...
    def show(self, parent: Window | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buttons"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cancel_button"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_button"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::detail"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::message"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AlertDialogClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AlternativeTrigger(ShortcutTrigger):
    """
    Combines two shortcut triggers.

    The `GtkAlternativeTrigger` triggers when either of the two trigger.

    This can be cascaded to combine more than two triggers.
    """

    class Props(ShortcutTrigger.Props):
        first: ShortcutTrigger | None
        second: ShortcutTrigger | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, first: ShortcutTrigger | None = ..., second: ShortcutTrigger | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_first(self) -> ShortcutTrigger: ...
    @builtins.property
    def get_second(self) -> ShortcutTrigger: ...
    @classmethod
    def new(cls, first: ShortcutTrigger, second: ShortcutTrigger) -> ShortcutTrigger: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::first"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::second"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AlternativeTriggerClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AnyFilter(MultiFilter):
    """
    Matches an item when at least one of its filters matches.

    To add filters to a `GtkAnyFilter`, use [method@Gtk.MultiFilter.append].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> AnyFilter: ...

class AnyFilterClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AppChooser(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        content_type: str  # [content-type]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, content_type: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def get_app_info(self) -> Gio.AppInfo | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_content_type(self) -> str: ...
    @deprecated("deprecated")
    def refresh(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::content_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AppChooserButton(Widget):
    """
    The `GtkAppChooserButton` lets the user select an application.

    <picture>
      <source srcset="appchooserbutton-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkAppChooserButton" src="appchooserbutton.png">
    </picture>

    Initially, a `GtkAppChooserButton` selects the first application
    in its list, which will either be the most-recently used application
    or, if [property@Gtk.AppChooserButton:show-default-item] is %TRUE, the
    default application.

    The list of applications shown in a `GtkAppChooserButton` includes
    the recommended applications for the given content type. When
    [property@Gtk.AppChooserButton:show-default-item] is set, the default
    application is also included. To let the user chooser other applications,
    you can set the [property@Gtk.AppChooserButton:show-dialog-item] property,
    which allows to open a full [class@Gtk.AppChooserDialog].

    It is possible to add custom items to the list, using
    [method@Gtk.AppChooserButton.append_custom_item]. These items cause
    the [signal@Gtk.AppChooserButton::custom-item-activated] signal to be
    emitted when they are selected.

    To track changes in the selected application, use the
    [signal@Gtk.AppChooserButton::changed] signal.

    ## CSS nodes

    `GtkAppChooserButton` has a single CSS node with the name “appchooserbutton”.
    """

    class Props(Widget.Props):
        heading: str
        modal: bool
        show_default_item: bool  # [show-default-item]: changed because contained invalid characters
        show_dialog_item: bool  # [show-dialog-item]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, heading: str = ..., modal: bool = ..., show_default_item: bool = ..., show_dialog_item: bool = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def append_custom_item(self, name: str, label: str, icon: Gio.Icon) -> None: ...
    @deprecated("deprecated")
    def append_separator(self) -> None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_heading(self) -> str | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_modal(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_default_item(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_dialog_item(self) -> bool: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls, content_type: str) -> Widget: ...
    @deprecated("deprecated")
    def set_active_custom_item(self, name: str) -> None: ...
    @deprecated("deprecated")
    def set_heading(self, heading: str) -> None: ...
    @deprecated("deprecated")
    def set_modal(self, modal: bool) -> None: ...
    @deprecated("deprecated")
    def set_show_default_item(self, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_show_dialog_item(self, setting: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["custom-item-activated"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::heading"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_default_item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_dialog_item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AppChooserDialog(Dialog):
    """
    `GtkAppChooserDialog` shows a `GtkAppChooserWidget` inside a `GtkDialog`.

    <picture>
      <source srcset="appchooserdialog-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkAppChooserDialog" src="appchooserdialog.png">
    </picture>

    Note that `GtkAppChooserDialog` does not have any interesting methods
    of its own. Instead, you should get the embedded `GtkAppChooserWidget`
    using [method@Gtk.AppChooserDialog.get_widget] and call its methods if
    the generic [iface@Gtk.AppChooser] interface is not sufficient for
    your needs.

    To set the heading that is shown above the `GtkAppChooserWidget`,
    use [method@Gtk.AppChooserDialog.set_heading].

    ## CSS nodes

    `GtkAppChooserDialog` has a single CSS node with the name `window` and style
    class `.appchooser`.
    """

    class Props(Dialog.Props):
        gfile: Gio.File | None
        heading: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, gfile: Gio.File | None = ..., heading: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_heading(self) -> str | None: ...
    @deprecated("deprecated")
    def get_widget(self) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls, parent: Window | None, flags: DialogFlags, file: Gio.File) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_for_content_type(cls, parent: Window | None, flags: DialogFlags, content_type: str) -> Widget: ...
    @deprecated("deprecated")
    def set_heading(self, heading: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gfile"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::heading"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AppChooserWidget(Widget):
    """
    `GtkAppChooserWidget` is a widget for selecting applications.

    It is the main building block for [class@Gtk.AppChooserDialog].
    Most applications only need to use the latter; but you can use
    this widget as part of a larger widget if you have special needs.

    `GtkAppChooserWidget` offers detailed control over what applications
    are shown, using the
    [property@Gtk.AppChooserWidget:show-default],
    [property@Gtk.AppChooserWidget:show-recommended],
    [property@Gtk.AppChooserWidget:show-fallback],
    [property@Gtk.AppChooserWidget:show-other] and
    [property@Gtk.AppChooserWidget:show-all] properties. See the
    [iface@Gtk.AppChooser] documentation for more information about these
    groups of applications.

    To keep track of the selected application, use the
    [signal@Gtk.AppChooserWidget::application-selected] and
    [signal@Gtk.AppChooserWidget::application-activated] signals.

    ## CSS nodes

    `GtkAppChooserWidget` has a single CSS node with name appchooser.
    """

    class Props(Widget.Props):
        default_text: str  # [default-text]: changed because contained invalid characters
        show_all: bool  # [show-all]: changed because contained invalid characters
        show_default: bool  # [show-default]: changed because contained invalid characters
        show_fallback: bool  # [show-fallback]: changed because contained invalid characters
        show_other: bool  # [show-other]: changed because contained invalid characters
        show_recommended: bool  # [show-recommended]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        default_text: str = ...,
        show_all: bool = ...,
        show_default: bool = ...,
        show_fallback: bool = ...,
        show_other: bool = ...,
        show_recommended: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_default_text(self) -> str | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_all(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_default(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_fallback(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_other(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_recommended(self) -> bool: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls, content_type: str) -> Widget: ...
    @deprecated("deprecated")
    def set_default_text(self, text: str) -> None: ...
    @deprecated("deprecated")
    def set_show_all(self, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_show_default(self, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_show_fallback(self, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_show_other(self, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_show_recommended(self, setting: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["application-activated"],
        handler: typing.Callable[[typing_extensions.Self, Gio.AppInfo], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["application-selected"],
        handler: typing.Callable[[typing_extensions.Self, Gio.AppInfo], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_all"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_default"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_fallback"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_other"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_recommended"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Application(GObject.Object):
    """
    A high-level API for writing applications.

    `GtkApplication` supports many aspects of writing a GTK application
    in a convenient fashion, without enforcing a one-size-fits-all model.

    Currently, it handles GTK initialization, application uniqueness, session
    management, provides some basic scriptability and desktop shell integration
    by exporting actions and menus and manages a list of toplevel windows whose
    life-cycle is automatically tied to the life-cycle of your application.

    While `GtkApplication` works fine with plain [class@Gtk.Window]s,
    it is recommended to use it together with [class@Gtk.ApplicationWindow].

    ## Automatic resources

    `GtkApplication` will automatically load menus from the `GtkBuilder`
    resource located at "gtk/menus.ui", relative to the application's
    resource base path (see [method@Gio.Application.set_resource_base_path]).
    The menu with the ID "menubar" is taken as the application's
    menubar. Additional menus (most interesting submenus) can be named
    and accessed via [method@Gtk.Application.get_menu_by_id] which allows for
    dynamic population of a part of the menu structure.

    Note that automatic resource loading uses the resource base path
    that is set at construction time and will not work if the resource
    base path is changed at a later time.

    It is also possible to provide the menubar manually using
    [method@Gtk.Application.set_menubar].

    `GtkApplication` will also automatically setup an icon search path for
    the default icon theme by appending "icons" to the resource base
    path. This allows your application to easily store its icons as
    resources. See [method@Gtk.IconTheme.add_resource_path] for more
    information.

    If there is a resource located at `gtk/help-overlay.ui` which
    defines a [class@Gtk.ShortcutsWindow] with ID `help_overlay` then
    `GtkApplication` associates an instance of this shortcuts window with
    each [class@Gtk.ApplicationWindow] and sets up the keyboard accelerator
    <kbd>Control</kbd>+<kbd>?</kbd> to open it. To create a menu item that
    displays the shortcuts window, associate the item with the action
    `win.show-help-overlay`.

    `GtkApplication` will also automatically set the application id as the
    default window icon. Use [func@Gtk.Window.set_default_icon_name] or
    [property@Gtk.Window:icon-name] to override that behavior.

    ## A simple application

    [A simple example](https://gitlab.gnome.org/GNOME/gtk/tree/main/examples/bp/bloatpad.c)
    is available in the GTK source code repository

    `GtkApplication` optionally registers with a session manager of the
    users session (if you set the [property@Gtk.Application:register-session]
    property) and offers various functionality related to the session
    life-cycle.

    An application can block various ways to end the session with
    the [method@Gtk.Application.inhibit] function. Typical use cases for
    this kind of inhibiting are long-running, uninterruptible operations,
    such as burning a CD or performing a disk backup. The session
    manager may not honor the inhibitor, but it can be expected to
    inform the user about the negative consequences of ending the
    session while inhibitors are present.

    ## See Also

    - [Using GtkApplication](https://developer.gnome.org/documentation/tutorials/application.html)
    - [Getting Started with GTK: Basics](getting_started.html#basics)
    """

    class Props(GObject.Object.Props):
        active_window: Window | None  # [active-window]: changed because contained invalid characters
        menubar: Gio.MenuModel | None
        register_session: bool  # [register-session]: changed because contained invalid characters
        screensaver_active: bool  # [screensaver-active]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, menubar: Gio.MenuModel | None = ..., register_session: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_window(self, window: Window) -> None: ...
    def get_accels_for_action(self, detailed_action_name: str) -> list: ...
    def get_actions_for_accel(self, accel: str) -> list: ...
    @builtins.property
    def get_active_window(self) -> Window | None: ...
    def get_menu_by_id(self, id: str) -> Gio.Menu | None: ...
    @builtins.property
    def get_menubar(self) -> Gio.MenuModel | None: ...
    def get_window_by_id(self, id: int) -> Window | None: ...
    def get_windows(self) -> list: ...
    def inhibit(self, window: Window | None, flags: ApplicationInhibitFlags, reason: str | None = None) -> int: ...
    def list_action_descriptions(self) -> list: ...
    @classmethod
    def new(cls, application_id: str | None, flags: Gio.ApplicationFlags) -> Application: ...
    def remove_window(self, window: Window) -> None: ...
    def set_accels_for_action(self, detailed_action_name: str, accels: list) -> None: ...
    def set_menubar(self, menubar: Gio.MenuModel | None = None) -> None: ...
    def uninhibit(self, cookie: int) -> None: ...

    # python methods (overrides?)
    def do_window_added(
        self,
        window: Window,
    ) -> None:
        """
        window_added(self, window:Gtk.Window)
        """
    def do_window_removed(
        self,
        window: Window,
    ) -> None:
        """
        window_removed(self, window:Gtk.Window)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["query-end"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["window-added"],
        handler: typing.Callable[[typing_extensions.Self, Window], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["window-removed"],
        handler: typing.Callable[[typing_extensions.Self, Window], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active_window"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::menubar"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::register_session"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::screensaver_active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ApplicationClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> Gio.ApplicationClass | None: ...
    @builtins.property
    def window_added(self) -> window_addedApplicationClassCB: ...
    @builtins.property
    def window_removed(self) -> window_removedApplicationClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ApplicationWindow(Window):
    """
    A `GtkWindow` subclass that integrates with `GtkApplication`.

    Notably, `GtkApplicationWindow` can handle an application menubar.

    This class implements the [iface@Gio.ActionGroup] and [iface@Gio.ActionMap]
    interfaces, to let you add window-specific actions that will be exported
    by the associated [class@Gtk.Application], together with its application-wide
    actions. Window-specific actions are prefixed with the “win.”
    prefix and application-wide actions are prefixed with the “app.”
    prefix. Actions must be addressed with the prefixed name when
    referring to them from a menu model.

    Note that widgets that are placed inside a `GtkApplicationWindow`
    can also activate these actions, if they implement the
    [iface@Gtk.Actionable] interface.

    The settings [property@Gtk.Settings:gtk-shell-shows-app-menu] and
    [property@Gtk.Settings:gtk-shell-shows-menubar] tell GTK whether the
    desktop environment is showing the application menu and menubar
    models outside the application as part of the desktop shell.
    For instance, on OS X, both menus will be displayed remotely;
    on Windows neither will be.

    If the desktop environment does not display the menubar, it can be shown in
    the `GtkApplicationWindow` by setting the
    [property@Gtk.ApplicationWindow:show-menubar] property to true. If the
    desktop environment does not display the application menu, then it will
    automatically be included in the menubar or in the window’s client-side
    decorations.

    See [class@Gtk.PopoverMenu] for information about the XML language
    used by `GtkBuilder` for menu models.

    See also: [method@Gtk.Application.set_menubar].

    ## A GtkApplicationWindow with a menubar

    The code sample below shows how to set up a `GtkApplicationWindow`
    with a menu bar defined on the [class@Gtk.Application]:

    ```c
    GtkApplication *app = gtk_application_new ("org.gtk.test", 0);

    GtkBuilder *builder = gtk_builder_new_from_string (
        "<interface>"
        "  <menu id='menubar'>"
        "    <submenu>"
        "      <attribute name='label' translatable='yes'>_Edit</attribute>"
        "      <item>"
        "        <attribute name='label' translatable='yes'>_Copy</attribute>"
        "        <attribute name='action'>win.copy</attribute>"
        "      </item>"
        "      <item>"
        "        <attribute name='label' translatable='yes'>_Paste</attribute>"
        "        <attribute name='action'>win.paste</attribute>"
        "      </item>"
        "    </submenu>"
        "  </menu>"
        "</interface>",
        -1);

    GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder, "menubar"));
    gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
    g_object_unref (builder);

    // ...

    GtkWidget *window = gtk_application_window_new (app);
    ```
    """

    class Props(Window.Props):
        show_menubar: bool  # [show-menubar]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, show_menubar: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def get_help_overlay(self) -> ShortcutsWindow | None: ...
    def get_id(self) -> int: ...
    @builtins.property
    def get_show_menubar(self) -> bool: ...
    @classmethod
    def new(cls, application: Application) -> Widget: ...
    @deprecated("deprecated")
    def set_help_overlay(self, help_overlay: ShortcutsWindow | None = None) -> None: ...
    def set_show_menubar(self, show_menubar: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_menubar"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ApplicationWindowClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WindowClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AspectFrame(Widget):
    """
    Preserves the aspect ratio of its child.

    The frame can respect the aspect ratio of the child widget,
    or use its own aspect ratio.

    # CSS nodes

    `GtkAspectFrame` uses a CSS node with name `aspectframe`.

    # Accessibility

    Until GTK 4.10, `GtkAspectFrame` used the [enum@Gtk.AccessibleRole.group] role.

    Starting from GTK 4.12, `GtkAspectFrame` uses the [enum@Gtk.AccessibleRole.generic] role.
    """

    class Props(Widget.Props):
        child: Widget | None
        obey_child: bool  # [obey-child]: changed because contained invalid characters
        ratio: float
        xalign: float
        yalign: float

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        child: Widget | None = ...,
        obey_child: bool = ...,
        ratio: float = ...,
        xalign: float = ...,
        yalign: float = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_obey_child(self) -> bool: ...
    @builtins.property
    def get_ratio(self) -> float: ...
    @builtins.property
    def get_xalign(self) -> float: ...
    @builtins.property
    def get_yalign(self) -> float: ...
    @classmethod
    def new(cls, xalign: float, yalign: float, ratio: float, obey_child: bool) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_obey_child(self, obey_child: bool) -> None: ...
    def set_ratio(self, ratio: float) -> None: ...
    def set_xalign(self, xalign: float) -> None: ...
    def set_yalign(self, yalign: float) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::obey_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ratio"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::xalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::yalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Assistant(Window):
    """
    `GtkAssistant` is used to represent a complex as a series of steps.

    <picture>
      <source srcset="assistant-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkAssistant" src="assistant.png">
    </picture>

    Each step consists of one or more pages. `GtkAssistant` guides the user
    through the pages, and controls the page flow to collect the data needed
    for the operation.

    `GtkAssistant` handles which buttons to show and to make sensitive based
    on page sequence knowledge and the [enum@Gtk.AssistantPageType] of each
    page in addition to state information like the *completed* and *committed*
    page statuses.

    If you have a case that doesn’t quite fit in `GtkAssistant`s way of
    handling buttons, you can use the %GTK_ASSISTANT_PAGE_CUSTOM page
    type and handle buttons yourself.

    `GtkAssistant` maintains a `GtkAssistantPage` object for each added
    child, which holds additional per-child properties. You
    obtain the `GtkAssistantPage` for a child with [method@Gtk.Assistant.get_page].

    # GtkAssistant as GtkBuildable

    The `GtkAssistant` implementation of the `GtkBuildable` interface
    exposes the @action_area as internal children with the name
    “action_area”.

    To add pages to an assistant in `GtkBuilder`, simply add it as a
    child to the `GtkAssistant` object. If you need to set per-object
    properties, create a `GtkAssistantPage` object explicitly, and
    set the child widget as a property on it.

    # CSS nodes

    `GtkAssistant` has a single CSS node with the name window and style
    class .assistant.
    """

    class Props(Window.Props):
        pages: Gio.ListModel | None
        use_header_bar: int  # [use-header-bar]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, use_header_bar: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_action_widget(self, child: Widget) -> None: ...
    @deprecated("deprecated")
    def append_page(self, page: Widget) -> int: ...
    @deprecated("deprecated")
    def commit(self) -> None: ...
    @deprecated("deprecated")
    def get_current_page(self) -> int: ...
    @deprecated("deprecated")
    def get_n_pages(self) -> int: ...
    @deprecated("deprecated")
    def get_nth_page(self, page_num: int) -> Widget | None: ...
    @deprecated("deprecated")
    def get_page(self, child: Widget) -> AssistantPage: ...
    @deprecated("deprecated")
    def get_page_complete(self, page: Widget) -> bool: ...
    @deprecated("deprecated")
    def get_page_title(self, page: Widget) -> str: ...
    @deprecated("deprecated")
    def get_page_type(self, page: Widget) -> AssistantPageType: ...
    @deprecated("deprecated")
    @builtins.property
    def get_pages(self) -> Gio.ListModel: ...
    @deprecated("deprecated")
    def insert_page(self, page: Widget, position: int) -> int: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    def next_page(self) -> None: ...
    @deprecated("deprecated")
    def prepend_page(self, page: Widget) -> int: ...
    @deprecated("deprecated")
    def previous_page(self) -> None: ...
    @deprecated("deprecated")
    def remove_action_widget(self, child: Widget) -> None: ...
    @deprecated("deprecated")
    def remove_page(self, page_num: int) -> None: ...
    @deprecated("deprecated")
    def set_current_page(self, page_num: int) -> None: ...
    @deprecated("deprecated")
    def set_forward_page_func(
        self, page_func: AssistantPageFunc | None, data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...
    @deprecated("deprecated")
    def set_page_complete(self, page: Widget, complete: bool) -> None: ...
    @deprecated("deprecated")
    def set_page_title(self, page: Widget, title: str) -> None: ...
    @deprecated("deprecated")
    def set_page_type(self, page: Widget, type: AssistantPageType) -> None: ...
    @deprecated("deprecated")
    def update_buttons_state(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["apply"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["cancel"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["close"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["escape"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["prepare"],
        handler: typing.Callable[[typing_extensions.Self, Widget], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pages"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_header_bar"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AssistantPage(GObject.Object):
    """
    `GtkAssistantPage` is an auxiliary object used by `GtkAssistant`.
    """

    class Props(GObject.Object.Props):
        child: Widget | None
        complete: bool
        page_type: AssistantPageType  # [page-type]: changed because contained invalid characters
        title: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, child: Widget | None = ..., complete: bool = ..., page_type: AssistantPageType = ..., title: str = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_child(self) -> Widget: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::complete"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::page_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BinLayout(LayoutManager):
    """
    A layout manager for widgets with a single child.

    `GtkBinLayout` will stack each child of a widget on top of each other,
    using the [property@Gtk.Widget:hexpand], [property@Gtk.Widget:vexpand],
    [property@Gtk.Widget:halign], and [property@Gtk.Widget:valign] properties
    of each child to determine where they should be positioned.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> LayoutManager: ...

class BinLayoutClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutManagerClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Bitset(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add(self, value: int) -> bool: ...
    def add_range(self, start: int, n_items: int) -> None: ...
    def add_range_closed(self, first: int, last: int) -> None: ...
    def add_rectangle(self, start: int, width: int, height: int, stride: int) -> None: ...
    def contains(self, value: int) -> bool: ...
    def copy(self) -> Bitset: ...
    def difference(self, other: Bitset) -> None: ...
    def equals(self, other: Bitset) -> bool: ...
    def get_maximum(self) -> int: ...
    def get_minimum(self) -> int: ...
    def get_nth(self, nth: int) -> int: ...
    def get_size(self) -> int: ...
    def get_size_in_range(self, first: int, last: int) -> int: ...
    def intersect(self, other: Bitset) -> None: ...
    def is_empty(self) -> bool: ...
    @classmethod
    def new_empty(cls) -> Bitset: ...
    @classmethod
    def new_range(cls, start: int, n_items: int) -> Bitset: ...
    def ref(self) -> Bitset: ...
    def remove(self, value: int) -> bool: ...
    def remove_all(self) -> None: ...
    def remove_range(self, start: int, n_items: int) -> None: ...
    def remove_range_closed(self, first: int, last: int) -> None: ...
    def remove_rectangle(self, start: int, width: int, height: int, stride: int) -> None: ...
    def shift_left(self, amount: int) -> None: ...
    def shift_right(self, amount: int) -> None: ...
    def splice(self, position: int, removed: int, added: int) -> None: ...
    def subtract(self, other: Bitset) -> None: ...
    def union(self, other: Bitset) -> None: ...
    def unref(self) -> None: ...

class BitsetIter(GObject.GBoxed):
    # gi Fields
    @builtins.property
    def private_data(self) -> list | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_value(self) -> int: ...
    @staticmethod
    def init_at(set: Bitset, target: int) -> tuple[bool, BitsetIter, int | None]: ...
    @staticmethod
    def init_first(set: Bitset) -> tuple[bool, BitsetIter, int | None]: ...
    @staticmethod
    def init_last(set: Bitset) -> tuple[bool, BitsetIter, int | None]: ...
    def is_valid(self) -> bool: ...
    def next(self) -> tuple[bool, int | None]: ...
    def previous(self) -> tuple[bool, int | None]: ...

class BookmarkList(GObject.Object):
    """
    A list model that wraps `GBookmarkFile`.

    It presents a `GListModel` and fills it asynchronously with the
    `GFileInfo`s returned from that function.

    The `GFileInfo`s in the list have some attributes in the recent
    namespace added: `recent::private` (boolean) and `recent:applications`
    (stringv).
    """

    class Props(GObject.Object.Props):
        attributes: str
        filename: str
        io_priority: int  # [io-priority]: changed because contained invalid characters
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        loading: bool
        n_items: int  # [n-items]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, attributes: str = ..., filename: str = ..., io_priority: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_attributes(self) -> str | None: ...
    @builtins.property
    def get_filename(self) -> str: ...
    @builtins.property
    def get_io_priority(self) -> int: ...
    @builtins.property
    def is_loading(self) -> bool: ...
    @classmethod
    def new(cls, filename: str | None = None, attributes: str | None = None) -> BookmarkList: ...
    def set_attributes(self, attributes: str | None = None) -> None: ...
    def set_io_priority(self, io_priority: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::attributes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::filename"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::io_priority"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::loading"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BookmarkListClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BoolFilter(Filter):
    """
    Evaluates a boolean expression to determine whether to include items.
    """

    class Props(Filter.Props):
        expression: Expression | None
        invert: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, expression: Expression | None = ..., invert: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_expression(self) -> Expression | None: ...
    @builtins.property
    def get_invert(self) -> bool: ...
    @classmethod
    def new(cls, expression: Expression | None = None) -> BoolFilter: ...
    def set_expression(self, expression: Expression | None = None) -> None: ...
    def set_invert(self, invert: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expression"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::invert"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BoolFilterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> FilterClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Border(GObject.GBoxed):
    # gi Fields
    bottom: int = ...
    left: int = ...
    right: int = ...
    top: int = ...

    # gi Methods
    def copy(self) -> Border: ...
    def free(self) -> None: ...
    @classmethod
    def new(cls) -> Border: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class Box(Widget):
    """
    Arranges child widgets into a single row or column.

    <picture>
      <source srcset="box-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkBox" src="box.png">
    </picture>

    Whether it is a row or column depends on the value of its
    [property@Gtk.Orientable:orientation] property. Within the other
    dimension, all children are allocated the same size. The
    [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
    properties can be used on the children to influence their allocation.

    Use repeated calls to [method@Gtk.Box.append] to pack widgets into a
    `GtkBox` from start to end. Use [method@Gtk.Box.remove] to remove widgets
    from the `GtkBox`. [method@Gtk.Box.insert_child_after] can be used to add
    a child at a particular position.

    Use [method@Gtk.Box.set_homogeneous] to specify whether or not all children
    of the `GtkBox` are forced to get the same amount of space.

    Use [method@Gtk.Box.set_spacing] to determine how much space will be minimally
    placed between all children in the `GtkBox`. Note that spacing is added
    *between* the children.

    Use [method@Gtk.Box.reorder_child_after] to move a child to a different
    place in the box.

    # CSS nodes

    `GtkBox` uses a single CSS node with name box.

    # Accessibility

    Until GTK 4.10, `GtkBox` used the [enum@Gtk.AccessibleRole.group] role.

    Starting from GTK 4.12, `GtkBox` uses the [enum@Gtk.AccessibleRole.generic] role.
    """

    class Props(Widget.Props):
        baseline_child: int  # [baseline-child]: changed because contained invalid characters
        baseline_position: BaselinePosition  # [baseline-position]: changed because contained invalid characters
        homogeneous: bool
        spacing: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        baseline_child: int = ...,
        baseline_position: BaselinePosition = ...,
        homogeneous: bool = ...,
        spacing: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, child: Widget) -> None: ...
    @builtins.property
    def get_baseline_child(self) -> int: ...
    @builtins.property
    def get_baseline_position(self) -> BaselinePosition: ...
    @builtins.property
    def get_homogeneous(self) -> bool: ...
    @builtins.property
    def get_spacing(self) -> int: ...
    def insert_child_after(self, child: Widget, sibling: Widget | None = None) -> None: ...
    @classmethod
    def new(cls, orientation: Orientation, spacing: int) -> Widget: ...
    def prepend(self, child: Widget) -> None: ...
    def remove(self, child: Widget) -> None: ...
    def reorder_child_after(self, child: Widget, sibling: Widget | None = None) -> None: ...
    def set_baseline_child(self, child: int) -> None: ...
    def set_baseline_position(self, position: BaselinePosition) -> None: ...
    def set_homogeneous(self, homogeneous: bool) -> None: ...
    def set_spacing(self, spacing: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::baseline_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::baseline_position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::homogeneous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BoxClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BoxLayout(LayoutManager):
    """
    Arranges children in a single row or column.

    Whether it is a row or column depends on the value of its
    [property@Gtk.Orientable:orientation] property. Within the other dimension
    all children all allocated the same size. The `GtkBoxLayout` will respect
    the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
    properties of each child widget.

    If you want all children to be assigned the same size, you can use
    the [property@Gtk.BoxLayout:homogeneous] property.

    If you want to specify the amount of space placed between each child,
    you can use the [property@Gtk.BoxLayout:spacing] property.
    """

    class Props(LayoutManager.Props):
        baseline_child: int  # [baseline-child]: changed because contained invalid characters
        baseline_position: BaselinePosition  # [baseline-position]: changed because contained invalid characters
        homogeneous: bool
        spacing: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        baseline_child: int = ...,
        baseline_position: BaselinePosition = ...,
        homogeneous: bool = ...,
        spacing: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_baseline_child(self) -> int: ...
    @builtins.property
    def get_baseline_position(self) -> BaselinePosition: ...
    @builtins.property
    def get_homogeneous(self) -> bool: ...
    @builtins.property
    def get_spacing(self) -> int: ...
    @classmethod
    def new(cls, orientation: Orientation) -> LayoutManager: ...
    def set_baseline_child(self, child: int) -> None: ...
    def set_baseline_position(self, position: BaselinePosition) -> None: ...
    def set_homogeneous(self, homogeneous: bool) -> None: ...
    def set_spacing(self, spacing: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::baseline_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::baseline_position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::homogeneous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BoxLayoutClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutManagerClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Buildable(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_buildable_id(self) -> str | None: ...

class BuildableIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def add_child(self) -> add_childBuildableIfaceCB: ...
    @builtins.property
    def custom_finished(self) -> custom_finishedBuildableIfaceCB: ...
    @builtins.property
    def custom_tag_end(self) -> custom_tag_endBuildableIfaceCB: ...
    @builtins.property
    def custom_tag_start(self) -> custom_tag_startBuildableIfaceCB: ...
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_id(self) -> get_idBuildableIfaceCB: ...
    @builtins.property
    def get_internal_child(self) -> get_internal_childBuildableIfaceCB: ...
    @builtins.property
    def parser_finished(self) -> parser_finishedBuildableIfaceCB: ...
    @builtins.property
    def set_buildable_property(self) -> set_buildable_propertyBuildableIfaceCB: ...
    @builtins.property
    def set_id(self) -> set_idBuildableIfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BuildableParseContext(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_element(self) -> str | None: ...
    def get_element_stack(self) -> list: ...
    def get_position(self) -> tuple[int | None, int | None]: ...
    def pop(self) -> object | None: ...
    def push(self, parser: BuildableParser, user_data: object | None = None) -> None: ...

class BuildableParser(GObject.GPointer):
    # gi Fields
    @builtins.property
    def end_element(self) -> end_elementBuildableParserCB: ...
    @builtins.property
    def error(self) -> errorBuildableParserCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def start_element(self) -> start_elementBuildableParserCB: ...
    @builtins.property
    def text(self) -> textBuildableParserCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Builder(GObject.Object):
    """
    Reads XML descriptions of a user interface and instantiates the described objects.

    To create a `GtkBuilder` from a user interface description, call
    [ctor@Gtk.Builder.new_from_file], [ctor@Gtk.Builder.new_from_resource]
    or [ctor@Gtk.Builder.new_from_string].

    In the (unusual) case that you want to add user interface
    descriptions from multiple sources to the same `GtkBuilder` you can
    call [ctor@Gtk.Builder.new] to get an empty builder and populate it by
    (multiple) calls to [method@Gtk.Builder.add_from_file],
    [method@Gtk.Builder.add_from_resource] or
    [method@Gtk.Builder.add_from_string].

    A `GtkBuilder` holds a reference to all objects that it has constructed
    and drops these references when it is finalized. This finalization can
    cause the destruction of non-widget objects or widgets which are not
    contained in a toplevel window. For toplevel windows constructed by a
    builder, it is the responsibility of the user to call
    [method@Gtk.Window.destroy] to get rid of them and all the widgets
    they contain.

    The functions [method@Gtk.Builder.get_object] and
    [method@Gtk.Builder.get_objects] can be used to access the widgets in
    the interface by the names assigned to them inside the UI description.
    Toplevel windows returned by these functions will stay around until the
    user explicitly destroys them with [method@Gtk.Window.destroy]. Other
    widgets will either be part of a larger hierarchy constructed by the
    builder (in which case you should not have to worry about their lifecycle),
    or without a parent, in which case they have to be added to some container
    to make use of them. Non-widget objects need to be reffed with
    g_object_ref() to keep them beyond the lifespan of the builder.

    ## GtkBuilder UI Definitions

    `GtkBuilder` parses textual descriptions of user interfaces which are
    specified in XML format. We refer to these descriptions as “GtkBuilder
    UI definitions” or just “UI definitions” if the context is clear.

    ### Structure of UI definitions

    UI definition files are always encoded in UTF-8.

    The toplevel element is `<interface>`. It optionally takes a “domain”
    attribute, which will make the builder look for translated strings
    using `dgettext()` in the domain specified. This can also be done by
    calling [method@Gtk.Builder.set_translation_domain] on the builder.
    For example:

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <interface domain="your-app">
      ...
    </interface>
    ```

    ### Requirements

    The target toolkit version(s) are described by `<requires>` elements,
    the “lib” attribute specifies the widget library in question (currently
    the only supported value is “gtk”) and the “version” attribute specifies
    the target version in the form “`<major>`.`<minor>`”. `GtkBuilder` will
    error out if the version requirements are not met. For example:

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <interface domain="your-app">
      <requires lib="gtk" version="4.0" />
    </interface>
    ```

    ### Objects

    Objects are defined as children of the `<interface>` element.

    Objects are described by `<object>` elements, which can contain
    `<property>` elements to set properties, `<signal>` elements which
    connect signals to handlers, and `<child>` elements, which describe
    child objects.

    Typically, the specific kind of object represented by an `<object>`
    element is specified by the “class” attribute. If the type has not
    been loaded yet, GTK tries to find the `get_type()` function from the
    class name by applying heuristics. This works in most cases, but if
    necessary, it is possible to specify the name of the `get_type()`
    function explicitly with the "type-func" attribute. If your UI definition
    is referencing internal types, you should make sure to call
    `g_type_ensure()` for each object type before parsing the UI definition.

    Objects may be given a name with the “id” attribute, which allows the
    application to retrieve them from the builder with
    [method@Gtk.Builder.get_object]. An id is also necessary to use the
    object as property value in other parts of the UI definition. GTK
    reserves ids starting and ending with `___` (three consecutive
    underscores) for its own purposes.

    ### Properties

    Setting properties of objects is pretty straightforward with the
    `<property>` element: the “name” attribute specifies the name of the
    property, and the content of the element specifies the value:

    ```xml
    <object class="GtkButton">
      <property name="label">Hello, world</property>
    </object>
    ```

    If the “translatable” attribute is set to a true value, GTK uses
    `gettext()` (or `dgettext()` if the builder has a translation domain set)
    to find a translation for the value. This happens before the value
    is parsed, so it can be used for properties of any type, but it is
    probably most useful for string properties. It is also possible to
    specify a context to disambiguate short strings, and comments which
    may help the translators:

    ```xml
    <object class="GtkButton">
      <property name="label"
                translatable="yes"
                context="button"
                comments="A classic">Hello, world</property>
    </object>
    ```

    The xgettext tool that is part of gettext can extract these strings,
    but note that it only looks for translatable="yes".

    `GtkBuilder` can parse textual representations for the most common
    property types:

    - characters
    - strings
    - integers
    - floating-point numbers
    - booleans (strings like “TRUE”, “t”, “yes”, “y”, “1” are interpreted
      as true values, strings like “FALSE”, “f”, “no”, “n”, “0” are interpreted
      as false values)
    - string lists (separated by newlines)
    - enumeration types (can be specified by their full C identifier their short
      name used when registering the enumeration type, or their integer value)
    - flag types (can be specified by their C identifier or short name,
      optionally combined with “|” for bitwise OR, or a single integer value
      e.g., “GTK_INPUT_HINT_EMOJI|GTK_INPUT_HINT_LOWERCASE”, or “emoji|lowercase” or 520).
    - colors (in the format understood by [method@Gdk.RGBA.parse])
    - transforms (in the format understood by [func@Gsk.Transform.parse])
    - Pango attribute lists (in the format understood by [method@Pango.AttrList.to_string])
    - Pango tab arrays (in the format understood by [method@Pango.TabArray.to_string])
    - Pango font descriptions (in the format understood by [func@Pango.FontDescription.from_string])
    - `GVariant` (in the format understood by [func@GLib.Variant.parse])
    - textures (can be specified as an object id, a resource path or a filename of an image file to load relative to the Builder file or the CWD if [method@Gtk.Builder.add_from_string] was used)
    - GFile (like textures, can be specified as an object id, a URI or a filename of a file to load relative to the Builder file or the CWD if [method@Gtk.Builder.add_from_string] was used)

    Objects can be referred to by their name and by default refer to
    objects declared in the local XML fragment and objects exposed via
    [method@Gtk.Builder.expose_object]. In general, `GtkBuilder` allows
    forward references to objects declared in the local XML; an object
    doesn’t have to be constructed before it can be referred to. The
    exception to this rule is that an object has to be constructed before
    it can be used as the value of a construct-only property.

    ### Child objects

    Many widgets have properties for child widgets, such as
    [property@Gtk.Expander:child]. In this case, the preferred way to
    specify the child widget in a ui file is to simply set the property:

    ```xml
    <object class="GtkExpander">
      <property name="child">
        <object class="GtkLabel">
        ...
        </object>
      </property>
    </object>
    ```

    Generic containers that can contain an arbitrary number of children,
    such as [class@Gtk.Box] instead use the `<child>` element. A `<child>`
    element contains an `<object>` element which describes the child object.
    Most often, child objects are widgets inside a container, but they can
    also be, e.g., actions in an action group, or columns in a tree model.

    Any object type that implements the [iface@Gtk.Buildable] interface can
    specify how children may be added to it. Since many objects and widgets that
    are included with GTK already implement the `GtkBuildable` interface,
    typically child objects can be added using the `<child>` element without
    having to be concerned about the underlying implementation.

    See the [`GtkWidget` documentation](class.Widget.html#gtkwidget-as-gtkbuildable)
    for many examples of using `GtkBuilder` with widgets, including setting
    child objects using the `<child>` element.

    A noteworthy special case to the general rule that only objects implementing
    `GtkBuildable` may specify how to handle the `<child>` element is that
    `GtkBuilder` provides special support for adding objects to a
    [class@Gio.ListStore] by using the `<child>` element. For instance:

    ```xml
    <object class="GListStore">
      <property name="item-type">MyObject</property>
      <child>
        <object class="MyObject" />
      </child>
      ...
    </object>
    ```

    ### Property bindings

    It is also possible to bind a property value to another object's
    property value using the attributes "bind-source" to specify the
    source object of the binding, and optionally, "bind-property" and
    "bind-flags" to specify the source property and source binding flags
    respectively. Internally, `GtkBuilder` implements this using
    [class@GObject.Binding] objects.

    For instance, in the example below the “label” property of the
    `bottom_label` widget is bound to the “label” property of the
    `top_button` widget:

    ```xml
    <object class="GtkBox">
      <property name="orientation">vertical</property>
      <child>
        <object class="GtkButton" id="top_button">
          <property name="label">Hello, world</property>
        </object>
      </child>
      <child>
        <object class="GtkLabel" id="bottom_label">
          <property name="label"
                    bind-source="top_button"
                    bind-property="label"
                    bind-flags="sync-create" />
        </object>
      </child>
    </object>
    ```

    For more information, see the documentation of the
    [method@GObject.Object.bind_property] method.

    Please note that another way to set up bindings between objects in .ui files
    is to use the `GtkExpression` methodology. See the
    [`GtkExpression` documentation](class.Expression.html#gtkexpression-in-ui-files)
    for more information.

    ### Internal children

    Sometimes it is necessary to refer to widgets which have implicitly
    been constructed by GTK as part of a composite widget, to set
    properties on them or to add further children (e.g. the content area
    of a `GtkDialog`). This can be achieved by setting the “internal-child”
    property of the `<child>` element to a true value. Note that `GtkBuilder`
    still requires an `<object>` element for the internal child, even if it
    has already been constructed.

    ### Specialized children

    A number of widgets have different places where a child can be added
    (e.g. tabs vs. page content in notebooks). This can be reflected in
    a UI definition by specifying the “type” attribute on a `<child>`
    The possible values for the “type” attribute are described in the
    sections describing the widget-specific portions of UI definitions.

    ### Signal handlers and function pointers

    Signal handlers are set up with the `<signal>` element. The “name”
    attribute specifies the name of the signal, and the “handler” attribute
    specifies the function to connect to the signal.

    ```xml
    <object class="GtkButton" id="hello_button">
      <signal name="clicked" handler="hello_button__clicked" />
    </object>
    ```

    The remaining attributes, “after”, “swapped” and “object”, have the
    same meaning as the corresponding parameters of the
    [func@GObject.signal_connect_object] or [func@GObject.signal_connect_data]
    functions:

    - “after” matches the `G_CONNECT_AFTER` flag, and will ensure that the
      handler is called after the default class closure for the signal
    - “swapped” matches the `G_CONNECT_SWAPPED` flag, and will swap the
      instance and closure arguments when invoking the signal handler
    - “object” will bind the signal handler to the lifetime of the object
      referenced by the attribute

    By default "swapped" will be set to "yes" if not specified otherwise, in
    the case where "object" is set, for convenience. A “last_modification_time”
    attribute is also allowed, but it does not have a meaning to the builder.

    When compiling applications for Windows, you must declare signal callbacks
    with the `G_MODULE_EXPORT` decorator, or they will not be put in the symbol
    table:

    ```c
    G_MODULE_EXPORT void
    hello_button__clicked (GtkButton *button,
                           gpointer data)
    {
      // ...
    }
    ```

    On Linux and Unix, this is not necessary; applications should instead
    be compiled with the `-Wl,--export-dynamic` argument inside their compiler
    flags, and linked against `gmodule-export-2.0`.

    ## Example UI Definition

    ```xml
    <interface>
      <object class="GtkDialog" id="dialog1">
        <child internal-child="content_area">
          <object class="GtkBox">
            <child internal-child="action_area">
              <object class="GtkBox">
                <child>
                  <object class="GtkButton" id="ok_button">
                    <property name="label" translatable="yes">_Ok</property>
                    <property name="use-underline">True</property>
                    <signal name="clicked" handler="ok_button_clicked"/>
                  </object>
                </child>
              </object>
            </child>
          </object>
        </child>
      </object>
    </interface>
    ```

    ## Using GtkBuildable for extending UI definitions

    Objects can implement the [iface@Gtk.Buildable] interface to add custom
    elements and attributes to the XML. Typically, any extension will be
    documented in each type that implements the interface.

    ## Menus

    In addition to objects with properties that are created with `<object>` and
    `<property>` elements, `GtkBuilder` also allows to parse XML menu definitions
    as used by [class@Gio.Menu] when exporting menu models over D-Bus, and as
    described in the [class@Gtk.PopoverMenu] documentation. Menus can be defined
    as toplevel elements, or as property values for properties of type `GMenuModel`.

    ## Templates

    When describing a [class@Gtk.Widget], you can use the `<template>` tag to
    describe a UI bound to a specific widget type. GTK will automatically load
    the UI definition when instantiating the type, and bind children and
    signal handlers to instance fields and function symbols.

    For more information, see the [`GtkWidget` documentation](class.Widget.html#building-composite-widgets-from-template-xml)
    for details.
    """

    class Props(GObject.Object.Props):
        current_object: GObject.Object | None  # [current-object]: changed because contained invalid characters
        scope: BuilderScope | None
        translation_domain: str  # [translation-domain]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def add_from_file(self, filename: str) -> bool: ...
    def add_from_resource(self, resource_path: str) -> bool: ...
    def add_from_string(self, buffer: str, length: int) -> bool: ...
    def add_objects_from_file(self, filename: str, object_ids: list) -> bool: ...
    def add_objects_from_resource(self, resource_path: str, object_ids: list) -> bool: ...
    def add_objects_from_string(self, buffer: str, length: int, object_ids: list) -> bool: ...
    def create_closure(
        self, function_name: str, flags: BuilderClosureFlags, object: GObject.Object | None = None
    ) -> GObject.Closure | None: ...
    def expose_object(self, name: str, object: GObject.Object) -> None: ...
    def extend_with_template(
        self, object: GObject.Object, template_type: GObject.GType, buffer: str, length: int
    ) -> bool: ...
    @builtins.property
    def get_current_object(self) -> GObject.Object | None: ...
    def get_object(self, name: str) -> GObject.Object | None: ...
    def get_objects(self) -> list: ...
    @builtins.property
    def get_scope(self) -> BuilderScope: ...
    @builtins.property
    def get_translation_domain(self) -> str | None: ...
    def get_type_from_name(self, type_name: str) -> GObject.GType: ...
    @classmethod
    def new(cls) -> Builder: ...
    @classmethod
    def new_from_file(cls, filename: str) -> Builder: ...
    @classmethod
    def new_from_resource(cls, resource_path: str) -> Builder: ...
    @classmethod
    def new_from_string(cls, string: str, length: int) -> Builder: ...
    def set_current_object(self, current_object: GObject.Object | None = None) -> None: ...
    def set_scope(self, scope: BuilderScope | None = None) -> None: ...
    def set_translation_domain(self, domain: str | None = None) -> None: ...
    def value_from_string(self, pspec: GObject.ParamSpec, string: str) -> tuple[bool, GObject.Value]: ...
    def value_from_string_type(self, type: GObject.GType, string: str) -> tuple[bool, GObject.Value]: ...

    # python methods (overrides?)
    def __init__(
        self,
        scope_object_or_map: typing.Any = None,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    @staticmethod
    def define_builder_scope() -> typing.Any: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_object"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scope"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::translation_domain"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BuilderCScope(GObject.Object):
    """
    A `GtkBuilderScope` implementation for the C language.

    `GtkBuilderCScope` instances use symbols explicitly added to @builder
    with prior calls to [method@Gtk.BuilderCScope.add_callback_symbol].
    If developers want to do that, they are encouraged to create their
    own scopes for that purpose.

    In the case that symbols are not explicitly added; GTK will uses
    `GModule`’s introspective features (by opening the module %NULL) to
    look at the application’s symbol table. From here it tries to match
    the signal function names given in the interface description with
    symbols in the application.

    Note that unless [method@Gtk.BuilderCScope.add_callback_symbol] is
    called for all signal callbacks which are referenced by the loaded XML,
    this functionality will require that `GModule` be supported on the platform.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_callback_symbol(self, callback_name: str, callback_symbol: GObject.Callback) -> None: ...
    @classmethod
    def new(cls) -> BuilderCScope: ...

class BuilderCScopeClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BuilderClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BuilderListItemFactory(ListItemFactory):
    """
    Creates widgets by instantiating `GtkBuilder` UI templates.

    The templates must extend the class that the parent widget expects.
    For example, a factory provided to [property@Gtk.ListView:factory] must have
    a template that extends [class@Gtk.ListItem].

    Templates typically use [class@Gtk.Expression] to obtain data from the items
    in the model.

    Example:
    ```xml
      <interface>
        <template class="GtkListItem">
          <property name="child">
            <object class="GtkLabel">
              <property name="xalign">0</property>
              <binding name="label">
                <lookup name="name" type="SettingsKey">
                  <lookup name="item">GtkListItem</lookup>
                </lookup>
              </binding>
            </object>
          </property>
        </template>
      </interface>
    ```
    """

    class Props(ListItemFactory.Props):
        bytes: GLib.Bytes | None
        resource: str
        scope: BuilderScope | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, bytes: GLib.Bytes | None = ..., resource: str = ..., scope: BuilderScope | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_bytes(self) -> GLib.Bytes: ...
    @builtins.property
    def get_resource(self) -> str | None: ...
    @builtins.property
    def get_scope(self) -> BuilderScope | None: ...
    @classmethod
    def new_from_bytes(cls, scope: BuilderScope | None, bytes: GLib.Bytes) -> ListItemFactory: ...
    @classmethod
    def new_from_resource(cls, scope: BuilderScope | None, resource_path: str) -> ListItemFactory: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resource"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scope"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BuilderListItemFactoryClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BuilderScope(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BuilderScopeInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def create_closure(self) -> create_closureBuilderScopeInterfaceCB: ...
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_type_from_function(self) -> get_type_from_functionBuilderScopeInterfaceCB: ...
    @builtins.property
    def get_type_from_name(self) -> get_type_from_nameBuilderScopeInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Button(Widget):
    """
    Calls a callback function when the button is clicked.

    <picture>
      <source srcset="button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkButton" src="button.png">
    </picture>

    The `GtkButton` widget can hold any valid child widget. That is, it can hold
    almost any other standard `GtkWidget`. The most commonly used child is the
    `GtkLabel`.

    # Shortcuts and Gestures

    The following signals have default keybindings:

    - [signal@Gtk.Button::activate]

    # CSS nodes

    `GtkButton` has a single CSS node with name button. The node will get the
    style classes .image-button or .text-button, if the content is just an
    image or label, respectively. It may also receive the .flat style class.
    When activating a button via the keyboard, the button will temporarily
    gain the .keyboard-activating style class.

    Other style classes that are commonly used with `GtkButton` include
    .suggested-action and .destructive-action. In special cases, buttons
    can be made round by adding the .circular style class.

    Button-like widgets like [class@Gtk.ToggleButton], [class@Gtk.MenuButton],
    [class@Gtk.VolumeButton], [class@Gtk.LockButton], [class@Gtk.ColorButton]
    or [class@Gtk.FontButton] use style classes such as .toggle, .popup, .scale,
    .lock, .color on the button node to differentiate themselves from a plain
    `GtkButton`.

    # Accessibility

    `GtkButton` uses the [enum@Gtk.AccessibleRole.button] role.
    """

    class Props(Widget.Props):
        can_shrink: bool  # [can-shrink]: changed because contained invalid characters
        child: Widget | None
        has_frame: bool  # [has-frame]: changed because contained invalid characters
        icon_name: str  # [icon-name]: changed because contained invalid characters
        label: str
        use_underline: bool  # [use-underline]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        can_shrink: bool = ...,
        child: Widget | None = ...,
        has_frame: bool = ...,
        icon_name: str = ...,
        label: str = ...,
        use_underline: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_can_shrink(self) -> bool: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_has_frame(self) -> bool: ...
    @builtins.property
    def get_icon_name(self) -> str | None: ...
    @builtins.property
    def get_label(self) -> str | None: ...
    @builtins.property
    def get_use_underline(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_from_icon_name(cls, icon_name: str) -> Widget: ...
    @classmethod
    def new_with_label(cls, label: str) -> Widget: ...
    @classmethod
    def new_with_mnemonic(cls, label: str) -> Widget: ...
    def set_can_shrink(self, can_shrink: bool) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_has_frame(self, has_frame: bool) -> None: ...
    def set_icon_name(self, icon_name: str) -> None: ...
    def set_label(self, label: str) -> None: ...
    def set_use_underline(self, use_underline: bool) -> None: ...

    # python methods (overrides?)
    def do_activate(
        self,
    ) -> None:
        """
        activate(self)
        """
    def do_clicked(
        self,
    ) -> None:
        """
        clicked(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["clicked"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_shrink"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_frame"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_underline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ButtonClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate(self) -> activateButtonClassCB: ...
    @builtins.property
    def clicked(self) -> clickedButtonClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ButtonPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CClosureExpression(Expression):
    """
    A variant of `GtkClosureExpression` using a C closure.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(
        cls,
        value_type: GObject.GType,
        marshal: GObject.ClosureMarshal | None,
        n_params: int,
        params: list,
        callback_func: GObject.Callback,
        user_data: object | None = None,
        user_destroy: GObject.ClosureNotify | None = None,
    ) -> CClosureExpression: ...

class Calendar(Widget):
    """
    Displays a Gregorian calendar, one month at a time.

    <picture>
      <source srcset="calendar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkCalendar" src="calendar.png">
    </picture>

    A `GtkCalendar` can be created with [ctor@Gtk.Calendar.new].

    The date that is currently displayed can be altered with
    [method@Gtk.Calendar.select_day].

    To place a visual marker on a particular day, use
    [method@Gtk.Calendar.mark_day] and to remove the marker,
    [method@Gtk.Calendar.unmark_day]. Alternative, all
    marks can be cleared with [method@Gtk.Calendar.clear_marks].

    The selected date can be retrieved from a `GtkCalendar` using
    [method@Gtk.Calendar.get_date].

    Users should be aware that, although the Gregorian calendar is the
    legal calendar in most countries, it was adopted progressively
    between 1582 and 1929. Display before these dates is likely to be
    historically incorrect.

    # Shortcuts and Gestures

    `GtkCalendar` supports the following gestures:

    - Scrolling up or down will switch to the previous or next month.
    - Date strings can be dropped for setting the current day.

    # CSS nodes

    ```
    calendar.view
    ├── header
    │   ├── button
    │   ├── stack.month
    │   ├── button
    │   ├── button
    │   ├── label.year
    │   ╰── button
    ╰── grid
        ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
    ```

    `GtkCalendar` has a main node with name calendar. It contains a subnode
    called header containing the widgets for switching between years and months.

    The grid subnode contains all day labels, including week numbers on the left
    (marked with the .week-number css class) and day names on top (marked with the
    .day-name css class).

    Day labels that belong to the previous or next month get the .other-month
    style class. The label of the current day get the .today style class.

    Marked day labels get the :selected state assigned.
    """

    class Props(Widget.Props):
        day: int
        month: int
        show_day_names: bool  # [show-day-names]: changed because contained invalid characters
        show_heading: bool  # [show-heading]: changed because contained invalid characters
        show_week_numbers: bool  # [show-week-numbers]: changed because contained invalid characters
        year: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        day: int = ...,
        month: int = ...,
        show_day_names: bool = ...,
        show_heading: bool = ...,
        show_week_numbers: bool = ...,
        year: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear_marks(self) -> None: ...
    def get_date(self) -> GLib.DateTime: ...
    @builtins.property
    def get_day(self) -> int: ...
    def get_day_is_marked(self, day: int) -> bool: ...
    @builtins.property
    def get_month(self) -> int: ...
    @builtins.property
    def get_show_day_names(self) -> bool: ...
    @builtins.property
    def get_show_heading(self) -> bool: ...
    @builtins.property
    def get_show_week_numbers(self) -> bool: ...
    @builtins.property
    def get_year(self) -> int: ...
    def mark_day(self, day: int) -> None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def select_day(self, date: GLib.DateTime) -> None: ...
    def set_day(self, day: int) -> None: ...
    def set_month(self, month: int) -> None: ...
    def set_show_day_names(self, value: bool) -> None: ...
    def set_show_heading(self, value: bool) -> None: ...
    def set_show_week_numbers(self, value: bool) -> None: ...
    def set_year(self, year: int) -> None: ...
    def unmark_day(self, day: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["day-selected"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["next-month"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["next-year"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["prev-month"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["prev-year"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::day"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::month"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_day_names"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_heading"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_week_numbers"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::year"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CallbackAction(ShortcutAction):
    """
    Invokes a callback.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, callback: ShortcutFunc, data: object | None, destroy: GLib.DestroyNotify) -> CallbackAction: ...

class CallbackActionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CellArea(GObject.InitiallyUnowned):
    """
    An abstract class for laying out `GtkCellRenderer`s

    The `GtkCellArea` is an abstract class for [iface@Gtk.CellLayout]
    widgets (also referred to as "layouting widgets") to interface with
    an arbitrary number of [class@Gtk.CellRenderer]s and interact with the user
    for a given [iface@Gtk.TreeModel] row.

    The cell area handles events, focus navigation, drawing and
    size requests and allocations for a given row of data.

    Usually users dont have to interact with the `GtkCellArea` directly
    unless they are implementing a cell-layouting widget themselves.

    ## Requesting area sizes

    As outlined in
    [GtkWidget’s geometry management section](class.Widget.html#height-for-width-geometry-management),
    GTK uses a height-for-width
    geometry management system to compute the sizes of widgets and user
    interfaces. `GtkCellArea` uses the same semantics to calculate the
    size of an area for an arbitrary number of `GtkTreeModel` rows.

    When requesting the size of a cell area one needs to calculate
    the size for a handful of rows, and this will be done differently by
    different layouting widgets. For instance a [class@Gtk.TreeViewColumn]
    always lines up the areas from top to bottom while a [class@Gtk.IconView]
    on the other hand might enforce that all areas received the same
    width and wrap the areas around, requesting height for more cell
    areas when allocated less width.

    It’s also important for areas to maintain some cell
    alignments with areas rendered for adjacent rows (cells can
    appear “columnized” inside an area even when the size of
    cells are different in each row). For this reason the `GtkCellArea`
    uses a [class@Gtk.CellAreaContext] object to store the alignments
    and sizes along the way (as well as the overall largest minimum
    and natural size for all the rows which have been calculated
    with the said context).

    The [class@Gtk.CellAreaContext] is an opaque object specific to the
    `GtkCellArea` which created it (see [method@Gtk.CellArea.create_context]).

    The owning cell-layouting widget can create as many contexts as
    it wishes to calculate sizes of rows which should receive the
    same size in at least one orientation (horizontally or vertically),
    However, it’s important that the same [class@Gtk.CellAreaContext] which
    was used to request the sizes for a given `GtkTreeModel` row be
    used when rendering or processing events for that row.

    In order to request the width of all the rows at the root level
    of a `GtkTreeModel` one would do the following:

    ```c
    GtkTreeIter iter;
    int minimum_width;
    int natural_width;

    valid = gtk_tree_model_get_iter_first (model, &iter);
    while (valid)
      {
        gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
        gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);

        valid = gtk_tree_model_iter_next (model, &iter);
      }

    gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
    ```

    Note that in this example it’s not important to observe the
    returned minimum and natural width of the area for each row
    unless the cell-layouting object is actually interested in the
    widths of individual rows. The overall width is however stored
    in the accompanying `GtkCellAreaContext` object and can be consulted
    at any time.

    This can be useful since `GtkCellLayout` widgets usually have to
    support requesting and rendering rows in treemodels with an
    exceedingly large amount of rows. The `GtkCellLayout` widget in
    that case would calculate the required width of the rows in an
    idle or timeout source (see [func@GLib.timeout_add]) and when the widget
    is requested its actual width in [vfunc@Gtk.Widget.measure]
    it can simply consult the width accumulated so far in the
    `GtkCellAreaContext` object.

    A simple example where rows are rendered from top to bottom and
    take up the full width of the layouting widget would look like:

    ```c
    static void
    foo_get_preferred_width (GtkWidget *widget,
                             int       *minimum_size,
                             int       *natural_size)
    {
      Foo *self = FOO (widget);
      FooPrivate *priv = foo_get_instance_private (self);

      foo_ensure_at_least_one_handfull_of_rows_have_been_requested (self);

      gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
    }
    ```

    In the above example the `Foo` widget has to make sure that some
    row sizes have been calculated (the amount of rows that `Foo` judged
    was appropriate to request space for in a single timeout iteration)
    before simply returning the amount of space required by the area via
    the `GtkCellAreaContext`.

    Requesting the height for width (or width for height) of an area is
    a similar task except in this case the `GtkCellAreaContext` does not
    store the data (actually, it does not know how much space the layouting
    widget plans to allocate it for every row. It’s up to the layouting
    widget to render each row of data with the appropriate height and
    width which was requested by the `GtkCellArea`).

    In order to request the height for width of all the rows at the
    root level of a `GtkTreeModel` one would do the following:

    ```c
    GtkTreeIter iter;
    int minimum_height;
    int natural_height;
    int full_minimum_height = 0;
    int full_natural_height = 0;

    valid = gtk_tree_model_get_iter_first (model, &iter);
    while (valid)
      {
        gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
        gtk_cell_area_get_preferred_height_for_width (area, context, widget,
                                                      width, &minimum_height, &natural_height);

        if (width_is_for_allocation)
           cache_row_height (&iter, minimum_height, natural_height);

        full_minimum_height += minimum_height;
        full_natural_height += natural_height;

        valid = gtk_tree_model_iter_next (model, &iter);
      }
    ```

    Note that in the above example we would need to cache the heights
    returned for each row so that we would know what sizes to render the
    areas for each row. However we would only want to really cache the
    heights if the request is intended for the layouting widgets real
    allocation.

    In some cases the layouting widget is requested the height for an
    arbitrary for_width, this is a special case for layouting widgets
    who need to request size for tens of thousands  of rows. For this
    case it’s only important that the layouting widget calculate
    one reasonably sized chunk of rows and return that height
    synchronously. The reasoning here is that any layouting widget is
    at least capable of synchronously calculating enough height to fill
    the screen height (or scrolled window height) in response to a single
    call to [vfunc@Gtk.Widget.measure]. Returning
    a perfect height for width that is larger than the screen area is
    inconsequential since after the layouting receives an allocation
    from a scrolled window it simply continues to drive the scrollbar
    values while more and more height is required for the row heights
    that are calculated in the background.

    ## Rendering Areas

    Once area sizes have been acquired at least for the rows in the
    visible area of the layouting widget they can be rendered at
    [vfunc@Gtk.Widget.snapshot] time.

    A crude example of how to render all the rows at the root level
    runs as follows:

    ```c
    GtkAllocation allocation;
    GdkRectangle cell_area = { 0, };
    GtkTreeIter iter;
    int minimum_width;
    int natural_width;

    gtk_widget_get_allocation (widget, &allocation);
    cell_area.width = allocation.width;

    valid = gtk_tree_model_get_iter_first (model, &iter);
    while (valid)
      {
        cell_area.height = get_cached_height_for_row (&iter);

        gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
        gtk_cell_area_render (area, context, widget, cr,
                              &cell_area, &cell_area, state_flags, FALSE);

        cell_area.y += cell_area.height;

        valid = gtk_tree_model_iter_next (model, &iter);
      }
    ```

    Note that the cached height in this example really depends on how
    the layouting widget works. The layouting widget might decide to
    give every row its minimum or natural height or, if the model content
    is expected to fit inside the layouting widget without scrolling, it
    would make sense to calculate the allocation for each row at
    the time the widget is allocated using [func@Gtk.distribute_natural_allocation].

    ## Handling Events and Driving Keyboard Focus

    Passing events to the area is as simple as handling events on any
    normal widget and then passing them to the [method@Gtk.CellArea.event]
    API as they come in. Usually `GtkCellArea` is only interested in
    button events, however some customized derived areas can be implemented
    who are interested in handling other events. Handling an event can
    trigger the [signal@Gtk.CellArea::focus-changed] signal to fire; as well
    as [signal@Gtk.CellArea::add-editable] in the case that an editable cell
    was clicked and needs to start editing. You can call
    [method@Gtk.CellArea.stop_editing] at any time to cancel any cell editing
    that is currently in progress.

    The `GtkCellArea` drives keyboard focus from cell to cell in a way
    similar to `GtkWidget`. For layouting widgets that support giving
    focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
    to the area functions for the row that has focus and to tell the
    area to paint the focus at render time.

    Layouting widgets that accept focus on cells should implement the
    [vfunc@Gtk.Widget.focus] virtual method. The layouting widget is always
    responsible for knowing where `GtkTreeModel` rows are rendered inside
    the widget, so at [vfunc@Gtk.Widget.focus] time the layouting widget
    should use the `GtkCellArea` methods to navigate focus inside the area
    and then observe the [enum@Gtk.DirectionType] to pass the focus to adjacent
    rows and areas.

    A basic example of how the [vfunc@Gtk.Widget.focus] virtual method
    should be implemented:

    ```
    static gboolean
    foo_focus (GtkWidget       *widget,
               GtkDirectionType direction)
    {
      Foo *self = FOO (widget);
      FooPrivate *priv = foo_get_instance_private (self);
      int focus_row = priv->focus_row;
      gboolean have_focus = FALSE;

      if (!gtk_widget_has_focus (widget))
        gtk_widget_grab_focus (widget);

      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
      while (valid)
        {
          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);

          if (gtk_cell_area_focus (priv->area, direction))
            {
               priv->focus_row = focus_row;
               have_focus = TRUE;
               break;
            }
          else
            {
              if (direction == GTK_DIR_RIGHT ||
                  direction == GTK_DIR_LEFT)
                break;
              else if (direction == GTK_DIR_UP ||
                       direction == GTK_DIR_TAB_BACKWARD)
               {
                  if (focus_row == 0)
                    break;
                  else
                   {
                      focus_row--;
                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
                   }
                }
              else
                {
                  if (focus_row == last_row)
                    break;
                  else
                    {
                      focus_row++;
                      valid = gtk_tree_model_iter_next (priv->model, &iter);
                    }
                }
            }
        }
        return have_focus;
    }
    ```

    Note that the layouting widget is responsible for matching the
    `GtkDirectionType` values to the way it lays out its cells.

    ## Cell Properties

    The `GtkCellArea` introduces cell properties for `GtkCellRenderer`s.
    This provides some general interfaces for defining the relationship
    cell areas have with their cells. For instance in a [class@Gtk.CellAreaBox]
    a cell might “expand” and receive extra space when the area is allocated
    more than its full natural request, or a cell might be configured to “align”
    with adjacent rows which were requested and rendered with the same
    `GtkCellAreaContext`.

    Use [method@Gtk.CellAreaClass.install_cell_property] to install cell
    properties for a cell area class and [method@Gtk.CellAreaClass.find_cell_property]
    or [method@Gtk.CellAreaClass.list_cell_properties] to get information about
    existing cell properties.

    To set the value of a cell property, use [method@Gtk.CellArea.cell_set_property],
    [method@Gtk.CellArea.cell_set] or [method@Gtk.CellArea.cell_set_valist]. To obtain
    the value of a cell property, use [method@Gtk.CellArea.cell_get_property]
    [method@Gtk.CellArea.cell_get] or [method@Gtk.CellArea.cell_get_valist].
    """

    class Props(GObject.InitiallyUnowned.Props):
        edit_widget: CellEditable | None  # [edit-widget]: changed because contained invalid characters
        edited_cell: CellRenderer | None  # [edited-cell]: changed because contained invalid characters
        focus_cell: CellRenderer | None  # [focus-cell]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, focus_cell: CellRenderer | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def activate(
        self,
        context: CellAreaContext,
        widget: Widget,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
        edit_only: bool,
    ) -> bool: ...
    @deprecated("deprecated")
    def activate_cell(
        self,
        widget: Widget,
        renderer: CellRenderer,
        event: Gdk.Event,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> bool: ...
    @deprecated("deprecated")
    def add(self, renderer: CellRenderer) -> None: ...
    @deprecated("deprecated")
    def add_focus_sibling(self, renderer: CellRenderer, sibling: CellRenderer) -> None: ...
    @deprecated("deprecated")
    def apply_attributes(self, tree_model: TreeModel, iter: TreeIter, is_expander: bool, is_expanded: bool) -> None: ...
    @deprecated("deprecated")
    def attribute_connect(self, renderer: CellRenderer, attribute: str, column: int) -> None: ...
    @deprecated("deprecated")
    def attribute_disconnect(self, renderer: CellRenderer, attribute: str) -> None: ...
    @deprecated("deprecated")
    def attribute_get_column(self, renderer: CellRenderer, attribute: str) -> int: ...
    @deprecated("deprecated")
    def cell_get_property(self, renderer: CellRenderer, property_name: str, value: GObject.Value) -> None: ...
    @deprecated("deprecated")
    def cell_set_property(self, renderer: CellRenderer, property_name: str, value: GObject.Value) -> None: ...
    @deprecated("deprecated")
    def copy_context(self, context: CellAreaContext) -> CellAreaContext: ...
    @deprecated("deprecated")
    def create_context(self) -> CellAreaContext: ...
    @deprecated("deprecated")
    def event(
        self,
        context: CellAreaContext,
        widget: Widget,
        event: Gdk.Event,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> int: ...
    @deprecated("deprecated")
    def focus(self, direction: DirectionType) -> bool: ...
    @deprecated("deprecated")
    def foreach(self, callback: CellCallback, callback_data: object | None = None) -> None: ...
    def foreach_alloc(
        self,
        context: CellAreaContext,
        widget: Widget,
        cell_area: Gdk.Rectangle,
        background_area: Gdk.Rectangle,
        callback: CellAllocCallback,
        callback_data: object | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def get_cell_allocation(
        self, context: CellAreaContext, widget: Widget, renderer: CellRenderer, cell_area: Gdk.Rectangle
    ) -> Gdk.Rectangle: ...
    @deprecated("deprecated")
    def get_cell_at_position(
        self, context: CellAreaContext, widget: Widget, cell_area: Gdk.Rectangle, x: int, y: int
    ) -> tuple[CellRenderer, Gdk.Rectangle | None]: ...
    def get_current_path_string(self) -> str: ...
    @deprecated("deprecated")
    @builtins.property
    def get_edit_widget(self) -> CellEditable | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_edited_cell(self) -> CellRenderer | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_focus_cell(self) -> CellRenderer | None: ...
    @deprecated("deprecated")
    def get_focus_from_sibling(self, renderer: CellRenderer) -> CellRenderer | None: ...
    @deprecated("deprecated")
    def get_focus_siblings(self, renderer: CellRenderer) -> list: ...
    @deprecated("deprecated")
    def get_preferred_height(self, context: CellAreaContext, widget: Widget) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_height_for_width(
        self, context: CellAreaContext, widget: Widget, width: int
    ) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_width(self, context: CellAreaContext, widget: Widget) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_width_for_height(
        self, context: CellAreaContext, widget: Widget, height: int
    ) -> tuple[int | None, int | None]: ...
    def get_request_mode(self) -> SizeRequestMode: ...
    @deprecated("deprecated")
    def has_renderer(self, renderer: CellRenderer) -> bool: ...
    @deprecated("deprecated")
    def inner_cell_area(self, widget: Widget, cell_area: Gdk.Rectangle) -> Gdk.Rectangle: ...
    @deprecated("deprecated")
    def is_activatable(self) -> bool: ...
    @deprecated("deprecated")
    def is_focus_sibling(self, renderer: CellRenderer, sibling: CellRenderer) -> bool: ...
    @deprecated("deprecated")
    def remove(self, renderer: CellRenderer) -> None: ...
    @deprecated("deprecated")
    def remove_focus_sibling(self, renderer: CellRenderer, sibling: CellRenderer) -> None: ...
    @deprecated("deprecated")
    def request_renderer(
        self, renderer: CellRenderer, orientation: Orientation, widget: Widget, for_size: int
    ) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def set_focus_cell(self, renderer: CellRenderer | None = None) -> None: ...
    @deprecated("deprecated")
    def snapshot(
        self,
        context: CellAreaContext,
        widget: Widget,
        snapshot: Snapshot,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
        paint_focus: bool,
    ) -> None: ...
    @deprecated("deprecated")
    def stop_editing(self, canceled: bool) -> None: ...

    # python methods (overrides?)
    def do_activate(
        self,
        context: CellAreaContext,
        widget: Widget,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
        edit_only: bool,
    ) -> bool:
        """
        activate(self, context:Gtk.CellAreaContext, widget:Gtk.Widget, cell_area:Gdk.Rectangle, flags:Gtk.CellRendererState, edit_only:bool) -> bool
        """
    def do_add(
        self,
        renderer: CellRenderer,
    ) -> None:
        """
        add(self, renderer:Gtk.CellRenderer)
        """
    def do_apply_attributes(
        self,
        tree_model: TreeModel,
        iter: TreeIter,
        is_expander: bool,
        is_expanded: bool,
    ) -> None:
        """
        apply_attributes(self, tree_model:Gtk.TreeModel, iter:Gtk.TreeIter, is_expander:bool, is_expanded:bool)
        """
    def do_copy_context(
        self,
        context: CellAreaContext,
    ) -> CellAreaContext:
        """
        copy_context(self, context:Gtk.CellAreaContext) -> Gtk.CellAreaContext
        """
    def do_create_context(
        self,
    ) -> CellAreaContext:
        """
        create_context(self) -> Gtk.CellAreaContext
        """
    def do_event(
        self,
        context: CellAreaContext,
        widget: Widget,
        event: Gdk.Event,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> int:
        """
        event(self, context:Gtk.CellAreaContext, widget:Gtk.Widget, event:Gdk.Event, cell_area:Gdk.Rectangle, flags:Gtk.CellRendererState) -> int
        """
    def do_focus(
        self,
        direction: DirectionType,
    ) -> bool:
        """
        focus(self, direction:Gtk.DirectionType) -> bool
        """
    def do_foreach(
        self,
        callback: typing.Callable,
        callback_data: typing.Any = None,
    ) -> None:
        """
        foreach(self, callback:Gtk.CellCallback, callback_data=None)
        """
    def do_foreach_alloc(
        self,
        context: CellAreaContext,
        widget: Widget,
        cell_area: Gdk.Rectangle,
        background_area: Gdk.Rectangle,
        callback: typing.Callable,
        callback_data: typing.Any = None,
    ) -> None:
        """
        foreach_alloc(self, context:Gtk.CellAreaContext, widget:Gtk.Widget, cell_area:Gdk.Rectangle, background_area:Gdk.Rectangle, callback:Gtk.CellAllocCallback, callback_data=None)
        """
    def do_get_cell_property(
        self,
        renderer: CellRenderer,
        property_id: int,
        value: GObject.Value,
        pspec: GObject.ParamSpec,
    ) -> None:
        """
        get_cell_property(self, renderer:Gtk.CellRenderer, property_id:int, value:GObject.Value, pspec:GObject.ParamSpec)
        """
    def do_get_preferred_height(
        self,
        context: CellAreaContext,
        widget: Widget,
    ) -> tuple:
        """
        get_preferred_height(self, context:Gtk.CellAreaContext, widget:Gtk.Widget) -> minimum_height:int, natural_height:int
        """
    def do_get_preferred_height_for_width(
        self,
        context: CellAreaContext,
        widget: Widget,
        width: int,
    ) -> tuple:
        """
        get_preferred_height_for_width(self, context:Gtk.CellAreaContext, widget:Gtk.Widget, width:int) -> minimum_height:int, natural_height:int
        """
    def do_get_preferred_width(
        self,
        context: CellAreaContext,
        widget: Widget,
    ) -> tuple:
        """
        get_preferred_width(self, context:Gtk.CellAreaContext, widget:Gtk.Widget) -> minimum_width:int, natural_width:int
        """
    def do_get_preferred_width_for_height(
        self,
        context: CellAreaContext,
        widget: Widget,
        height: int,
    ) -> tuple:
        """
        get_preferred_width_for_height(self, context:Gtk.CellAreaContext, widget:Gtk.Widget, height:int) -> minimum_width:int, natural_width:int
        """
    def do_get_request_mode(
        self,
    ) -> SizeRequestMode:
        """
        get_request_mode(self) -> Gtk.SizeRequestMode
        """
    def do_is_activatable(
        self,
    ) -> bool:
        """
        is_activatable(self) -> bool
        """
    def do_remove(
        self,
        renderer: CellRenderer,
    ) -> None:
        """
        remove(self, renderer:Gtk.CellRenderer)
        """
    def do_set_cell_property(
        self,
        renderer: CellRenderer,
        property_id: int,
        value: GObject.Value,
        pspec: GObject.ParamSpec,
    ) -> None:
        """
        set_cell_property(self, renderer:Gtk.CellRenderer, property_id:int, value:GObject.Value, pspec:GObject.ParamSpec)
        """
    def do_snapshot(
        self,
        context: CellAreaContext,
        widget: Widget,
        snapshot: Snapshot,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
        paint_focus: bool,
    ) -> None:
        """
        snapshot(self, context:Gtk.CellAreaContext, widget:Gtk.Widget, snapshot:Gtk.Snapshot, background_area:Gdk.Rectangle, cell_area:Gdk.Rectangle, flags:Gtk.CellRendererState, paint_focus:bool)
        """
    @classmethod
    def find_cell_property(
        cls,
        property_name: str,
    ) -> GObject.ParamSpec:
        """
        find_cell_property(self, property_name:str) -> GObject.ParamSpec
        """
    @classmethod
    def install_cell_property(
        cls,
        property_id: int,
        pspec: GObject.ParamSpec,
    ) -> None:
        """
        install_cell_property(self, property_id:int, pspec:GObject.ParamSpec)
        """
    @classmethod
    def list_cell_properties(
        cls,
    ) -> list:
        """
        list_cell_properties(self) -> list
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["add-editable"],
        handler: typing.Callable[[typing_extensions.Self, CellRenderer, CellEditable, Gdk.Rectangle, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["apply-attributes"],
        handler: typing.Callable[[typing_extensions.Self, TreeModel, TreeIter, bool, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["focus-changed"],
        handler: typing.Callable[[typing_extensions.Self, CellRenderer, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["remove-editable"],
        handler: typing.Callable[[typing_extensions.Self, CellRenderer, CellEditable], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::edit_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::edited_cell"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::focus_cell"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellAreaBox(CellArea):
    """
    A cell area that renders GtkCellRenderers into a row or a column

    The `GtkCellAreaBox` renders cell renderers into a row or a column
    depending on its `GtkOrientation`.

    GtkCellAreaBox uses a notion of packing. Packing
    refers to adding cell renderers with reference to a particular position
    in a `GtkCellAreaBox`. There are two reference positions: the
    start and the end of the box.
    When the `GtkCellAreaBox` is oriented in the %GTK_ORIENTATION_VERTICAL
    orientation, the start is defined as the top of the box and the end is
    defined as the bottom. In the %GTK_ORIENTATION_HORIZONTAL orientation
    start is defined as the left side and the end is defined as the right
    side.

    Alignments of `GtkCellRenderer`s rendered in adjacent rows can be
    configured by configuring the `GtkCellAreaBox` align child cell property
    with gtk_cell_area_cell_set_property() or by specifying the "align"
    argument to gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
    """

    class Props(CellArea.Props):
        spacing: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, spacing: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_spacing(self) -> int: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> CellArea: ...
    @deprecated("deprecated")
    def pack_end(self, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) -> None: ...
    @deprecated("deprecated")
    def pack_start(self, renderer: CellRenderer, expand: bool, align: bool, fixed: bool) -> None: ...
    @deprecated("deprecated")
    def set_spacing(self, spacing: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellAreaClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate(self) -> activateCellAreaClassCB: ...
    @builtins.property
    def add(self) -> addCellAreaClassCB: ...
    @builtins.property
    def apply_attributes(self) -> apply_attributesCellAreaClassCB: ...
    @builtins.property
    def copy_context(self) -> copy_contextCellAreaClassCB: ...
    @builtins.property
    def create_context(self) -> create_contextCellAreaClassCB: ...
    @builtins.property
    def event(self) -> eventCellAreaClassCB: ...
    @builtins.property
    def focus(self) -> focusCellAreaClassCB: ...
    @builtins.property
    def foreach(self) -> foreachCellAreaClassCB: ...
    @builtins.property
    def foreach_alloc(self) -> foreach_allocCellAreaClassCB: ...
    @builtins.property
    def get_cell_property(self) -> get_cell_propertyCellAreaClassCB: ...
    @builtins.property
    def get_preferred_height(self) -> get_preferred_heightCellAreaClassCB: ...
    @builtins.property
    def get_preferred_height_for_width(self) -> get_preferred_height_for_widthCellAreaClassCB: ...
    @builtins.property
    def get_preferred_width(self) -> get_preferred_widthCellAreaClassCB: ...
    @builtins.property
    def get_preferred_width_for_height(self) -> get_preferred_width_for_heightCellAreaClassCB: ...
    @builtins.property
    def get_request_mode(self) -> get_request_modeCellAreaClassCB: ...
    @builtins.property
    def is_activatable(self) -> is_activatableCellAreaClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.InitiallyUnownedClass | None: ...
    @builtins.property
    def remove(self) -> removeCellAreaClassCB: ...
    @builtins.property
    def set_cell_property(self) -> set_cell_propertyCellAreaClassCB: ...
    @builtins.property
    def snapshot(self) -> snapshotCellAreaClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def find_cell_property(self, property_name: str) -> GObject.ParamSpec: ...
    @deprecated("deprecated")
    def install_cell_property(self, property_id: int, pspec: GObject.ParamSpec) -> None: ...
    @deprecated("deprecated")
    def list_cell_properties(self) -> tuple[list, int]: ...

class CellAreaContext(GObject.Object):
    """
    Stores geometrical information for a series of rows in a GtkCellArea

    The `GtkCellAreaContext` object is created by a given `GtkCellArea`
    implementation via its `GtkCellAreaClass.create_context()` virtual
    method and is used to store cell sizes and alignments for a series of
    `GtkTreeModel` rows that are requested and rendered in the same context.

    `GtkCellLayout` widgets can create any number of contexts in which to
    request and render groups of data rows. However, it’s important that the
    same context which was used to request sizes for a given `GtkTreeModel`
    row also be used for the same row when calling other `GtkCellArea` APIs
    such as gtk_cell_area_render() and gtk_cell_area_event().
    """

    class Props(GObject.Object.Props):
        area: CellArea | None
        minimum_height: int  # [minimum-height]: changed because contained invalid characters
        minimum_width: int  # [minimum-width]: changed because contained invalid characters
        natural_height: int  # [natural-height]: changed because contained invalid characters
        natural_width: int  # [natural-width]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, area: CellArea | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def allocate(self, width: int, height: int) -> None: ...
    @deprecated("deprecated")
    def get_allocation(self) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    @builtins.property
    def get_area(self) -> CellArea: ...
    @deprecated("deprecated")
    def get_preferred_height(self) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_height_for_width(self, width: int) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_width(self) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_width_for_height(self, height: int) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def push_preferred_height(self, minimum_height: int, natural_height: int) -> None: ...
    @deprecated("deprecated")
    def push_preferred_width(self, minimum_width: int, natural_width: int) -> None: ...
    @deprecated("deprecated")
    def reset(self) -> None: ...

    # python methods (overrides?)
    def do_allocate(
        self,
        width: int,
        height: int,
    ) -> None:
        """
        allocate(self, width:int, height:int)
        """
    def do_get_preferred_height_for_width(
        self,
        width: int,
    ) -> tuple:
        """
        get_preferred_height_for_width(self, width:int) -> minimum_height:int, natural_height:int
        """
    def do_get_preferred_width_for_height(
        self,
        height: int,
    ) -> tuple:
        """
        get_preferred_width_for_height(self, height:int) -> minimum_width:int, natural_width:int
        """
    def do_reset(
        self,
    ) -> None:
        """
        reset(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::area"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::minimum_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::minimum_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::natural_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::natural_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellAreaContextClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def allocate(self) -> allocateCellAreaContextClassCB: ...
    @builtins.property
    def get_preferred_height_for_width(self) -> get_preferred_height_for_widthCellAreaContextClassCB: ...
    @builtins.property
    def get_preferred_width_for_height(self) -> get_preferred_width_for_heightCellAreaContextClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def reset(self) -> resetCellAreaContextClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CellAreaContextPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CellEditable(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        editing_canceled: bool  # [editing-canceled]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, editing_canceled: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def editing_done(self) -> None: ...
    @deprecated("deprecated")
    def remove_widget(self) -> None: ...
    def start_editing(self, event: Gdk.Event | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["editing-done"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["remove-widget"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::editing_canceled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellEditableIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def editing_done(self) -> editing_doneCellEditableIfaceCB: ...
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def remove_widget(self) -> remove_widgetCellEditableIfaceCB: ...
    @builtins.property
    def start_editing(self) -> start_editingCellEditableIfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CellLayout(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_attribute(self, cell: CellRenderer, attribute: str, column: int) -> None: ...
    @deprecated("deprecated")
    def clear(self) -> None: ...
    @deprecated("deprecated")
    def clear_attributes(self, cell: CellRenderer) -> None: ...
    @deprecated("deprecated")
    def get_area(self) -> CellArea | None: ...
    @deprecated("deprecated")
    def get_cells(self) -> list: ...
    @deprecated("deprecated")
    def pack_end(self, cell: CellRenderer, expand: bool) -> None: ...
    @deprecated("deprecated")
    def pack_start(self, cell: CellRenderer, expand: bool) -> None: ...
    @deprecated("deprecated")
    def reorder(self, cell: CellRenderer, position: int) -> None: ...
    @deprecated("deprecated")
    def set_cell_data_func(
        self, cell: CellRenderer, func: CellLayoutDataFunc | None, func_data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...

class CellLayoutIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def add_attribute(self) -> add_attributeCellLayoutIfaceCB: ...
    @builtins.property
    def clear(self) -> clearCellLayoutIfaceCB: ...
    @builtins.property
    def clear_attributes(self) -> clear_attributesCellLayoutIfaceCB: ...
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_area(self) -> get_areaCellLayoutIfaceCB | None: ...
    @builtins.property
    def get_cells(self) -> get_cellsCellLayoutIfaceCB: ...
    @builtins.property
    def pack_end(self) -> pack_endCellLayoutIfaceCB: ...
    @builtins.property
    def pack_start(self) -> pack_startCellLayoutIfaceCB: ...
    @builtins.property
    def reorder(self) -> reorderCellLayoutIfaceCB: ...
    @builtins.property
    def set_cell_data_func(self) -> set_cell_data_funcCellLayoutIfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CellRenderer(GObject.InitiallyUnowned):
    """
    An object for rendering a single cell

    The `GtkCellRenderer` is a base class of a set of objects used for
    rendering a cell to a `cairo_t`.  These objects are used primarily by
    the `GtkTreeView` widget, though they aren’t tied to them in any
    specific way.  It is worth noting that `GtkCellRenderer` is not a
    `GtkWidget` and cannot be treated as such.

    The primary use of a `GtkCellRenderer` is for drawing a certain graphical
    elements on a `cairo_t`. Typically, one cell renderer is used to
    draw many cells on the screen.  To this extent, it isn’t expected that a
    CellRenderer keep any permanent state around.  Instead, any state is set
    just prior to use using `GObject`s property system.  Then, the
    cell is measured using gtk_cell_renderer_get_preferred_size(). Finally, the cell
    is rendered in the correct location using gtk_cell_renderer_snapshot().

    There are a number of rules that must be followed when writing a new
    `GtkCellRenderer`.  First and foremost, it’s important that a certain set
    of properties will always yield a cell renderer of the same size,
    barring a style change. The `GtkCellRenderer` also has a number of
    generic properties that are expected to be honored by all children.

    Beyond merely rendering a cell, cell renderers can optionally
    provide active user interface elements. A cell renderer can be
    “activatable” like `GtkCellRenderer`Toggle,
    which toggles when it gets activated by a mouse click, or it can be
    “editable” like `GtkCellRenderer`Text, which
    allows the user to edit the text using a widget implementing the
    `GtkCellEditable` interface, e.g. `GtkEntry`.
    To make a cell renderer activatable or editable, you have to
    implement the `GtkCellRenderer`Class.activate or
    `GtkCellRenderer`Class.start_editing virtual functions, respectively.

    Many properties of `GtkCellRenderer` and its subclasses have a
    corresponding “set” property, e.g. “cell-background-set” corresponds
    to “cell-background”. These “set” properties reflect whether a property
    has been set or not. You should not set them independently.
    """

    class Props(GObject.InitiallyUnowned.Props):
        cell_background: str  # [cell-background]: changed because contained invalid characters
        cell_background_rgba: Gdk.RGBA | None  # [cell-background-rgba]: changed because contained invalid characters
        cell_background_set: bool  # [cell-background-set]: changed because contained invalid characters
        editing: bool
        height: int
        is_expanded: bool  # [is-expanded]: changed because contained invalid characters
        is_expander: bool  # [is-expander]: changed because contained invalid characters
        mode: CellRendererMode
        sensitive: bool
        visible: bool
        width: int
        xalign: float
        xpad: int
        yalign: float
        ypad: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        cell_background: str = ...,
        cell_background_rgba: Gdk.RGBA | None = ...,
        cell_background_set: bool = ...,
        height: int = ...,
        is_expanded: bool = ...,
        is_expander: bool = ...,
        mode: CellRendererMode = ...,
        sensitive: bool = ...,
        visible: bool = ...,
        width: int = ...,
        xalign: float = ...,
        xpad: int = ...,
        yalign: float = ...,
        ypad: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def activate(
        self,
        event: Gdk.Event,
        widget: Widget,
        path: str,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> bool: ...
    @deprecated("deprecated")
    def get_aligned_area(self, widget: Widget, flags: CellRendererState, cell_area: Gdk.Rectangle) -> Gdk.Rectangle: ...
    @deprecated("deprecated")
    def get_alignment(self) -> tuple[float | None, float | None]: ...
    @deprecated("deprecated")
    def get_fixed_size(self) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    @builtins.property
    def get_is_expanded(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_is_expander(self) -> bool: ...
    @deprecated("deprecated")
    def get_padding(self) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_height(self, widget: Widget) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_height_for_width(self, widget: Widget, width: int) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_size(self, widget: Widget) -> tuple[Requisition | None, Requisition | None]: ...
    @deprecated("deprecated")
    def get_preferred_width(self, widget: Widget) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_preferred_width_for_height(self, widget: Widget, height: int) -> tuple[int | None, int | None]: ...
    @deprecated("deprecated")
    def get_request_mode(self) -> SizeRequestMode: ...
    @deprecated("deprecated")
    @builtins.property
    def get_sensitive(self) -> bool: ...
    @deprecated("deprecated")
    def get_state(self, widget: Widget | None, cell_state: CellRendererState) -> StateFlags: ...
    @deprecated("deprecated")
    @builtins.property
    def get_visible(self) -> bool: ...
    @deprecated("deprecated")
    def is_activatable(self) -> bool: ...
    @deprecated("deprecated")
    def set_alignment(self, xalign: float, yalign: float) -> None: ...
    @deprecated("deprecated")
    def set_fixed_size(self, width: int, height: int) -> None: ...
    @deprecated("deprecated")
    def set_is_expanded(self, is_expanded: bool) -> None: ...
    @deprecated("deprecated")
    def set_is_expander(self, is_expander: bool) -> None: ...
    @deprecated("deprecated")
    def set_padding(self, xpad: int, ypad: int) -> None: ...
    @deprecated("deprecated")
    def set_sensitive(self, sensitive: bool) -> None: ...
    @deprecated("deprecated")
    def set_visible(self, visible: bool) -> None: ...
    @deprecated("deprecated")
    def snapshot(
        self,
        snapshot: Snapshot,
        widget: Widget,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> None: ...
    @deprecated("deprecated")
    def start_editing(
        self,
        event: Gdk.Event | None,
        widget: Widget,
        path: str,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> CellEditable | None: ...
    @deprecated("deprecated")
    def stop_editing(self, canceled: bool) -> None: ...

    # python methods (overrides?)
    def do_activate(
        self,
        event: Gdk.Event,
        widget: Widget,
        path: str,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> bool:
        """
        activate(self, event:Gdk.Event, widget:Gtk.Widget, path:str, background_area:Gdk.Rectangle, cell_area:Gdk.Rectangle, flags:Gtk.CellRendererState) -> bool
        """
    def do_editing_canceled(
        self,
    ) -> None:
        """
        editing_canceled(self)
        """
    def do_editing_started(
        self,
        editable: CellEditable,
        path: str,
    ) -> None:
        """
        editing_started(self, editable:Gtk.CellEditable, path:str)
        """
    def do_get_aligned_area(
        self,
        widget: Widget,
        flags: CellRendererState,
        cell_area: Gdk.Rectangle,
    ) -> Gdk.Rectangle:
        """
        get_aligned_area(self, widget:Gtk.Widget, flags:Gtk.CellRendererState, cell_area:Gdk.Rectangle) -> aligned_area:Gdk.Rectangle
        """
    def do_get_preferred_height(
        self,
        widget: Widget,
    ) -> tuple:
        """
        get_preferred_height(self, widget:Gtk.Widget) -> minimum_size:int, natural_size:int
        """
    def do_get_preferred_height_for_width(
        self,
        widget: Widget,
        width: int,
    ) -> tuple:
        """
        get_preferred_height_for_width(self, widget:Gtk.Widget, width:int) -> minimum_height:int, natural_height:int
        """
    def do_get_preferred_width(
        self,
        widget: Widget,
    ) -> tuple:
        """
        get_preferred_width(self, widget:Gtk.Widget) -> minimum_size:int, natural_size:int
        """
    def do_get_preferred_width_for_height(
        self,
        widget: Widget,
        height: int,
    ) -> tuple:
        """
        get_preferred_width_for_height(self, widget:Gtk.Widget, height:int) -> minimum_width:int, natural_width:int
        """
    def do_get_request_mode(
        self,
    ) -> SizeRequestMode:
        """
        get_request_mode(self) -> Gtk.SizeRequestMode
        """
    def do_snapshot(
        self,
        snapshot: Snapshot,
        widget: Widget,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> None:
        """
        snapshot(self, snapshot:Gtk.Snapshot, widget:Gtk.Widget, background_area:Gdk.Rectangle, cell_area:Gdk.Rectangle, flags:Gtk.CellRendererState)
        """
    def do_start_editing(
        self,
        event: Gdk.Event | None,
        widget: Widget,
        path: str,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> CellEditable | None:
        """
        start_editing(self, event:Gdk.Event=None, widget:Gtk.Widget, path:str, background_area:Gdk.Rectangle, cell_area:Gdk.Rectangle, flags:Gtk.CellRendererState) -> Gtk.CellEditable or None
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["editing-canceled"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["editing-started"],
        handler: typing.Callable[[typing_extensions.Self, CellEditable, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cell_background"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cell_background_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cell_background_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::editing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_expanded"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_expander"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sensitive"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::xalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::xpad"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::yalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ypad"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellRendererAccel(CellRendererText):
    """
    Renders a keyboard accelerator in a cell

    `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
    combination like `Control + a`). If the cell renderer is editable,
    the accelerator can be changed by simply typing the new combination.
    """

    class Props(CellRendererText.Props):
        accel_key: int  # [accel-key]: changed because contained invalid characters
        accel_mode: CellRendererAccelMode  # [accel-mode]: changed because contained invalid characters
        accel_mods: Gdk.ModifierType  # [accel-mods]: changed because contained invalid characters
        keycode: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accel_key: int = ...,
        accel_mode: CellRendererAccelMode = ...,
        accel_mods: Gdk.ModifierType = ...,
        keycode: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> CellRenderer: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["accel-cleared"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["accel-edited"],
        handler: typing.Callable[[typing_extensions.Self, str, int, Gdk.ModifierType, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accel_key"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accel_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accel_mods"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::keycode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellRendererClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate(self) -> activateCellRendererClassCB: ...
    @builtins.property
    def editing_canceled(self) -> editing_canceledCellRendererClassCB: ...
    @builtins.property
    def editing_started(self) -> editing_startedCellRendererClassCB: ...
    @builtins.property
    def get_aligned_area(self) -> get_aligned_areaCellRendererClassCB: ...
    @builtins.property
    def get_preferred_height(self) -> get_preferred_heightCellRendererClassCB: ...
    @builtins.property
    def get_preferred_height_for_width(self) -> get_preferred_height_for_widthCellRendererClassCB: ...
    @builtins.property
    def get_preferred_width(self) -> get_preferred_widthCellRendererClassCB: ...
    @builtins.property
    def get_preferred_width_for_height(self) -> get_preferred_width_for_heightCellRendererClassCB: ...
    @builtins.property
    def get_request_mode(self) -> get_request_modeCellRendererClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.InitiallyUnownedClass | None: ...
    @builtins.property
    def snapshot(self) -> snapshotCellRendererClassCB: ...
    @builtins.property
    def start_editing(self) -> start_editingCellRendererClassCB | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CellRendererClassPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CellRendererCombo(CellRendererText):
    """
    Renders a combobox in a cell

    `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
    which it is derived. But while `GtkCellRendererText` offers a simple entry to
    edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
    widget to edit the text. The values to display in the combo box are taken from
    the tree model specified in the `GtkCellRendererCombo`:model property.

    The combo cell renderer takes care of adding a text cell renderer to the combo
    box and sets it to display the column specified by its
    `GtkCellRendererCombo`:text-column property. Further properties of the combo box
    can be set in a handler for the `GtkCellRenderer::editing-started` signal.
    """

    class Props(CellRendererText.Props):
        has_entry: bool  # [has-entry]: changed because contained invalid characters
        model: TreeModel | None
        text_column: int  # [text-column]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, has_entry: bool = ..., model: TreeModel | None = ..., text_column: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> CellRenderer: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["changed"],
        handler: typing.Callable[[typing_extensions.Self, str, TreeIter], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_entry"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellRendererPixbuf(CellRenderer):
    """
    Renders a pixbuf in a cell

    A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
    to render either a given `GdkPixbuf` (set via the
    `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
    `GtkCellRendererPixbuf:icon-name` property).

    To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
    alternative pixbufs, when the `GtkCellRenderer:is-expander` property is %TRUE.
    If the `GtkCellRenderer:is-expanded property` is %TRUE and the
    `GtkCellRendererPixbuf:pixbuf-expander-open` property is set to a pixbuf, it
    renders that pixbuf, if the `GtkCellRenderer:is-expanded` property is %FALSE
    and the `GtkCellRendererPixbuf:pixbuf-expander-closed` property is set to a
    pixbuf, it renders that one.
    """

    class Props(CellRenderer.Props):
        gicon: Gio.Icon | None
        icon_name: str  # [icon-name]: changed because contained invalid characters
        icon_size: IconSize  # [icon-size]: changed because contained invalid characters
        pixbuf: GdkPixbuf.Pixbuf | None
        pixbuf_expander_closed: (
            GdkPixbuf.Pixbuf | None
        )  # [pixbuf-expander-closed]: changed because contained invalid characters
        pixbuf_expander_open: (
            GdkPixbuf.Pixbuf | None
        )  # [pixbuf-expander-open]: changed because contained invalid characters
        texture: Gdk.Texture | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        gicon: Gio.Icon | None = ...,
        icon_name: str = ...,
        icon_size: IconSize = ...,
        pixbuf: GdkPixbuf.Pixbuf | None = ...,
        pixbuf_expander_closed: GdkPixbuf.Pixbuf | None = ...,
        pixbuf_expander_open: GdkPixbuf.Pixbuf | None = ...,
        texture: Gdk.Texture | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> CellRenderer: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gicon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixbuf"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixbuf_expander_closed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixbuf_expander_open"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::texture"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellRendererPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CellRendererProgress(CellRenderer):
    """
    Renders numbers as progress bars

    `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
    Additionally, it can display a text on top of the progress bar.
    """

    class Props(CellRenderer.Props):
        inverted: bool
        pulse: int
        text: str
        text_xalign: float  # [text-xalign]: changed because contained invalid characters
        text_yalign: float  # [text-yalign]: changed because contained invalid characters
        value: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        inverted: bool = ...,
        pulse: int = ...,
        text: str = ...,
        text_xalign: float = ...,
        text_yalign: float = ...,
        value: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> CellRenderer: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inverted"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pulse"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_xalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_yalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::value"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellRendererSpin(CellRendererText):
    """
    Renders a spin button in a cell

    `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
    which it is derived. But while `GtkCellRendererText` offers a simple entry to
    edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
    that means that the text has to be parseable as a floating point number.

    The range of the spinbutton is taken from the adjustment property of the
    cell renderer, which can be set explicitly or mapped to a column in the
    tree model, like all properties of cell renders. `GtkCellRendererSpin`
    also has properties for the `GtkCellRendererSpin:climb-rate` and the number
    of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
    can be set in a handler for the `GtkCellRenderer::editing-started` signal.
    """

    class Props(CellRendererText.Props):
        adjustment: Adjustment | None
        climb_rate: float  # [climb-rate]: changed because contained invalid characters
        digits: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, adjustment: Adjustment | None = ..., climb_rate: float = ..., digits: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> CellRenderer: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::adjustment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::climb_rate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::digits"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellRendererSpinner(CellRenderer):
    """
    Renders a spinning animation in a cell

    `GtkCellRendererSpinner` renders a spinning animation in a cell, very
    similar to `GtkSpinner`. It can often be used as an alternative
    to a `GtkCellRendererProgress` for displaying indefinite activity,
    instead of actual progress.

    To start the animation in a cell, set the `GtkCellRendererSpinner:active`
    property to %TRUE and increment the `GtkCellRendererSpinner:pulse` property
    at regular intervals. The usual way to set the cell renderer properties
    for each cell is to bind them to columns in your tree model using e.g.
    gtk_tree_view_column_add_attribute().
    """

    class Props(CellRenderer.Props):
        active: bool
        pulse: int
        size: IconSize

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, active: bool = ..., pulse: int = ..., size: IconSize = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> CellRenderer: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pulse"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellRendererText(CellRenderer):
    """
    Renders text in a cell

    A `GtkCellRendererText` renders a given text in its cell, using the font, color and
    style information provided by its properties. The text will be ellipsized if it is
    too long and the `GtkCellRendererText:ellipsize` property allows it.

    If the `GtkCellRenderer:mode` is %GTK_CELL_RENDERER_MODE_EDITABLE,
    the `GtkCellRendererText` allows to edit its text using an entry.
    """

    class Props(CellRenderer.Props):
        align_set: bool  # [align-set]: changed because contained invalid characters
        alignment: Pango.Alignment
        attributes: Pango.AttrList | None
        background: str
        background_rgba: Gdk.RGBA | None  # [background-rgba]: changed because contained invalid characters
        background_set: bool  # [background-set]: changed because contained invalid characters
        editable: bool
        editable_set: bool  # [editable-set]: changed because contained invalid characters
        ellipsize: Pango.EllipsizeMode
        ellipsize_set: bool  # [ellipsize-set]: changed because contained invalid characters
        family: str
        family_set: bool  # [family-set]: changed because contained invalid characters
        font: str
        font_desc: Pango.FontDescription | None  # [font-desc]: changed because contained invalid characters
        foreground: str
        foreground_rgba: Gdk.RGBA | None  # [foreground-rgba]: changed because contained invalid characters
        foreground_set: bool  # [foreground-set]: changed because contained invalid characters
        language: str
        language_set: bool  # [language-set]: changed because contained invalid characters
        markup: str
        max_width_chars: int  # [max-width-chars]: changed because contained invalid characters
        placeholder_text: str  # [placeholder-text]: changed because contained invalid characters
        rise: int
        rise_set: bool  # [rise-set]: changed because contained invalid characters
        scale: float
        scale_set: bool  # [scale-set]: changed because contained invalid characters
        single_paragraph_mode: bool  # [single-paragraph-mode]: changed because contained invalid characters
        size: int
        size_points: float  # [size-points]: changed because contained invalid characters
        size_set: bool  # [size-set]: changed because contained invalid characters
        stretch: Pango.Stretch
        stretch_set: bool  # [stretch-set]: changed because contained invalid characters
        strikethrough: bool
        strikethrough_set: bool  # [strikethrough-set]: changed because contained invalid characters
        style: Pango.Style
        style_set: bool  # [style-set]: changed because contained invalid characters
        text: str
        underline: Pango.Underline
        underline_set: bool  # [underline-set]: changed because contained invalid characters
        variant: Pango.Variant
        variant_set: bool  # [variant-set]: changed because contained invalid characters
        weight: int
        weight_set: bool  # [weight-set]: changed because contained invalid characters
        width_chars: int  # [width-chars]: changed because contained invalid characters
        wrap_mode: Pango.WrapMode  # [wrap-mode]: changed because contained invalid characters
        wrap_width: int  # [wrap-width]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        align_set: bool = ...,
        alignment: Pango.Alignment = ...,
        attributes: Pango.AttrList | None = ...,
        background: str = ...,
        background_rgba: Gdk.RGBA | None = ...,
        background_set: bool = ...,
        editable: bool = ...,
        editable_set: bool = ...,
        ellipsize: Pango.EllipsizeMode = ...,
        ellipsize_set: bool = ...,
        family: str = ...,
        family_set: bool = ...,
        font: str = ...,
        font_desc: Pango.FontDescription | None = ...,
        foreground: str = ...,
        foreground_rgba: Gdk.RGBA | None = ...,
        foreground_set: bool = ...,
        language: str = ...,
        language_set: bool = ...,
        markup: str = ...,
        max_width_chars: int = ...,
        placeholder_text: str = ...,
        rise: int = ...,
        rise_set: bool = ...,
        scale: float = ...,
        scale_set: bool = ...,
        single_paragraph_mode: bool = ...,
        size: int = ...,
        size_points: float = ...,
        size_set: bool = ...,
        stretch: Pango.Stretch = ...,
        stretch_set: bool = ...,
        strikethrough: bool = ...,
        strikethrough_set: bool = ...,
        style: Pango.Style = ...,
        style_set: bool = ...,
        text: str = ...,
        underline: Pango.Underline = ...,
        underline_set: bool = ...,
        variant: Pango.Variant = ...,
        variant_set: bool = ...,
        weight: int = ...,
        weight_set: bool = ...,
        width_chars: int = ...,
        wrap_mode: Pango.WrapMode = ...,
        wrap_width: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> CellRenderer: ...
    @deprecated("deprecated")
    def set_fixed_height_from_font(self, number_of_rows: int) -> None: ...

    # python methods (overrides?)
    def do_edited(
        self,
        path: str,
        new_text: str,
    ) -> None:
        """
        edited(self, path:str, new_text:str)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["edited"],
        handler: typing.Callable[[typing_extensions.Self, str, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::align_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::alignment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::attributes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::background"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::background_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::background_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::editable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::editable_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ellipsize"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ellipsize_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font_desc"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::foreground"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::foreground_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::foreground_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::language"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::language_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::markup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_width_chars"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::placeholder_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rise"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rise_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scale"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scale_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::single_paragraph_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size_points"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stretch"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stretch_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::strikethrough"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::strikethrough_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::style"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::style_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::underline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::underline_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::variant"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::variant_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::weight"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::weight_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::width_chars"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellRendererTextClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def edited(self) -> editedCellRendererTextClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> CellRendererClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CellRendererToggle(CellRenderer):
    """
    Renders a toggle button in a cell

    `GtkCellRendererToggle` renders a toggle button in a cell. The
    button is drawn as a radio or a checkbutton, depending on the
    `GtkCellRendererToggle:radio` property.
    When activated, it emits the `GtkCellRendererToggle::toggled` signal.
    """

    class Props(CellRenderer.Props):
        activatable: bool
        active: bool
        inconsistent: bool
        radio: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, activatable: bool = ..., active: bool = ..., inconsistent: bool = ..., radio: bool = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_activatable(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_active(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_radio(self) -> bool: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> CellRenderer: ...
    @deprecated("deprecated")
    def set_activatable(self, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_active(self, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_radio(self, radio: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["toggled"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activatable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inconsistent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::radio"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CellView(Widget):
    """
    A widget displaying a single row of a GtkTreeModel

    A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
    and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
    `GtkCellView` at construction time in order to keep the cellview in context
    of a group of cell views, this ensures that the renderers displayed will
    be properly aligned with each other (like the aligned cells in the menus
    of `GtkComboBox`).

    `GtkCellView` is `GtkOrientable` in order to decide in which orientation
    the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
    menu as an example, cellviews should be oriented horizontally if the menus are
    listed top-to-bottom and thus all share the same width but may have separate
    individual heights (left-to-right menus should be allocated vertically since
    they all share the same height but may have variable widths).

    ## CSS nodes

    GtkCellView has a single CSS node with name cellview.
    """

    class Props(Widget.Props):
        cell_area: CellArea | None  # [cell-area]: changed because contained invalid characters
        cell_area_context: CellAreaContext | None  # [cell-area-context]: changed because contained invalid characters
        draw_sensitive: bool  # [draw-sensitive]: changed because contained invalid characters
        fit_model: bool  # [fit-model]: changed because contained invalid characters
        model: TreeModel | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        cell_area: CellArea | None = ...,
        cell_area_context: CellAreaContext | None = ...,
        draw_sensitive: bool = ...,
        fit_model: bool = ...,
        model: TreeModel | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def get_displayed_row(self) -> TreePath | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_draw_sensitive(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_fit_model(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_model(self) -> TreeModel | None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_context(cls, area: CellArea, context: CellAreaContext) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_markup(cls, markup: str) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_text(cls, text: str) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_texture(cls, texture: Gdk.Texture) -> Widget: ...
    @deprecated("deprecated")
    def set_displayed_row(self, path: TreePath | None = None) -> None: ...
    @deprecated("deprecated")
    def set_draw_sensitive(self, draw_sensitive: bool) -> None: ...
    @deprecated("deprecated")
    def set_fit_model(self, fit_model: bool) -> None: ...
    @deprecated("deprecated")
    def set_model(self, model: TreeModel | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cell_area"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cell_area_context"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::draw_sensitive"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::fit_model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CenterBox(Widget):
    """
    Arranges three children in a row, keeping the middle child
    centered as well as possible.

    <picture>
      <source srcset="centerbox-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkCenterBox" src="centerbox.png">
    </picture>

    To add children to `GtkCenterBox`, use [method@Gtk.CenterBox.set_start_widget],
    [method@Gtk.CenterBox.set_center_widget] and
    [method@Gtk.CenterBox.set_end_widget].

    The sizing and positioning of children can be influenced with the
    align and expand properties of the children.

    # GtkCenterBox as GtkBuildable

    The `GtkCenterBox` implementation of the `GtkBuildable` interface
    supports placing children in the 3 positions by specifying “start”, “center”
    or “end” as the “type” attribute of a `<child>` element.

    # CSS nodes

    `GtkCenterBox` uses a single CSS node with the name “box”,

    The first child of the `GtkCenterBox` will be allocated depending on the
    text direction, i.e. in left-to-right layouts it will be allocated on the
    left and in right-to-left layouts on the right.

    In vertical orientation, the nodes of the children are arranged from top to
    bottom.

    # Accessibility

    Until GTK 4.10, `GtkCenterBox` used the [enum@Gtk.AccessibleRole.group] role.

    Starting from GTK 4.12, `GtkCenterBox` uses the [enum@Gtk.AccessibleRole.generic]
    role.
    """

    class Props(Widget.Props):
        baseline_position: BaselinePosition  # [baseline-position]: changed because contained invalid characters
        center_widget: Widget | None  # [center-widget]: changed because contained invalid characters
        end_widget: Widget | None  # [end-widget]: changed because contained invalid characters
        shrink_center_last: bool  # [shrink-center-last]: changed because contained invalid characters
        start_widget: Widget | None  # [start-widget]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        baseline_position: BaselinePosition = ...,
        center_widget: Widget | None = ...,
        end_widget: Widget | None = ...,
        shrink_center_last: bool = ...,
        start_widget: Widget | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_baseline_position(self) -> BaselinePosition: ...
    @builtins.property
    def get_center_widget(self) -> Widget | None: ...
    @builtins.property
    def get_end_widget(self) -> Widget | None: ...
    @builtins.property
    def get_shrink_center_last(self) -> bool: ...
    @builtins.property
    def get_start_widget(self) -> Widget | None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_baseline_position(self, position: BaselinePosition) -> None: ...
    def set_center_widget(self, child: Widget | None = None) -> None: ...
    def set_end_widget(self, child: Widget | None = None) -> None: ...
    def set_shrink_center_last(self, shrink_center_last: bool) -> None: ...
    def set_start_widget(self, child: Widget | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::baseline_position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::center_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::end_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::shrink_center_last"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::start_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CenterBoxClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CenterLayout(LayoutManager):
    """
    Manages up to three children.

    The start widget is allocated at the start of the layout (left in
    left-to-right locales and right in right-to-left ones), and the end
    widget at the end.

    The center widget is centered regarding the full width of the layout's.
    """

    class Props(LayoutManager.Props):
        shrink_center_last: bool  # [shrink-center-last]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, shrink_center_last: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_baseline_position(self) -> BaselinePosition: ...
    def get_center_widget(self) -> Widget | None: ...
    def get_end_widget(self) -> Widget | None: ...
    def get_orientation(self) -> Orientation: ...
    @builtins.property
    def get_shrink_center_last(self) -> bool: ...
    def get_start_widget(self) -> Widget | None: ...
    @classmethod
    def new(cls) -> LayoutManager: ...
    def set_baseline_position(self, baseline_position: BaselinePosition) -> None: ...
    def set_center_widget(self, widget: Widget | None = None) -> None: ...
    def set_end_widget(self, widget: Widget | None = None) -> None: ...
    def set_orientation(self, orientation: Orientation) -> None: ...
    def set_shrink_center_last(self, shrink_center_last: bool) -> None: ...
    def set_start_widget(self, widget: Widget | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::shrink_center_last"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CenterLayoutClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutManagerClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CheckButton(Widget):
    """
    Places a label next to an indicator.

    <picture>
      <source srcset="check-button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="Example GtkCheckButtons" src="check-button.png">
    </picture>

    A `GtkCheckButton` is created by calling either [ctor@Gtk.CheckButton.new]
    or [ctor@Gtk.CheckButton.new_with_label].

    The state of a `GtkCheckButton` can be set specifically using
    [method@Gtk.CheckButton.set_active], and retrieved using
    [method@Gtk.CheckButton.get_active].

    # Inconsistent state

    In addition to "on" and "off", check buttons can be an
    "in between" state that is neither on nor off. This can be used
    e.g. when the user has selected a range of elements (such as some
    text or spreadsheet cells) that are affected by a check button,
    and the current values in that range are inconsistent.

    To set a `GtkCheckButton` to inconsistent state, use
    [method@Gtk.CheckButton.set_inconsistent].

    # Grouping

    Check buttons can be grouped together, to form mutually exclusive
    groups - only one of the buttons can be toggled at a time, and toggling
    another one will switch the currently toggled one off.

    Grouped check buttons use a different indicator, and are commonly referred
    to as *radio buttons*.

    <picture>
      <source srcset="radio-button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="Example GtkRadioButtons" src="radio-button.png">
    </picture>

    To add a `GtkCheckButton` to a group, use [method@Gtk.CheckButton.set_group].

    When the code must keep track of the state of a group of radio buttons, it
    is recommended to keep track of such state through a stateful
    `GAction` with a target for each button. Using the `toggled` signals to keep
    track of the group changes and state is discouraged.

    # Shortcuts and Gestures

    `GtkCheckButton` supports the following keyboard shortcuts:

    - <kbd>␣</kbd> or <kbd>Enter</kbd> activates the button.

    # CSS nodes

    ```
    checkbutton[.text-button][.grouped]
    ├── check
    ╰── [label]
    ```

    A `GtkCheckButton` has a main node with name checkbutton. If the
    [property@Gtk.CheckButton:label] or [property@Gtk.CheckButton:child]
    properties are set, it contains a child widget. The indicator node
    is named check when no group is set, and radio if the checkbutton
    is grouped together with other checkbuttons.

    # Accessibility

    `GtkCheckButton` uses the [enum@Gtk.AccessibleRole.checkbox] role.
    """

    class Props(Widget.Props):
        active: bool
        child: Widget | None
        group: CheckButton | None
        inconsistent: bool
        label: str
        use_underline: bool  # [use-underline]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        active: bool = ...,
        child: Widget | None = ...,
        group: CheckButton | None = ...,
        inconsistent: bool = ...,
        label: str = ...,
        use_underline: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_active(self) -> bool: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_inconsistent(self) -> bool: ...
    @builtins.property
    def get_label(self) -> str | None: ...
    @builtins.property
    def get_use_underline(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_with_label(cls, label: str | None = None) -> Widget: ...
    @classmethod
    def new_with_mnemonic(cls, label: str | None = None) -> Widget: ...
    def set_active(self, setting: bool) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_group(self, group: CheckButton | None = None) -> None: ...
    def set_inconsistent(self, inconsistent: bool) -> None: ...
    def set_label(self, label: str | None = None) -> None: ...
    def set_use_underline(self, setting: bool) -> None: ...

    # python methods (overrides?)
    def do_activate(
        self,
    ) -> None:
        """
        activate(self)
        """
    def do_toggled(
        self,
    ) -> None:
        """
        toggled(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["toggled"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::group"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inconsistent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_underline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CheckButtonClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate(self) -> activateCheckButtonClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...
    @builtins.property
    def toggled(self) -> toggledCheckButtonClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ClosureExpression(Expression):
    """
    An expression using a custom `GClosure` to compute the value from
    its parameters.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(
        cls, value_type: GObject.GType, closure: GObject.Closure, n_params: int, params: list | None = None
    ) -> ClosureExpression: ...

class ColorButton(Widget):
    """
    The `GtkColorButton` allows to open a color chooser dialog to change
    the color.

    <picture>
      <source srcset="color-button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkColorButton" src="color-button.png">
    </picture>

    It is suitable widget for selecting a color in a preference dialog.

    # CSS nodes

    ```
    colorbutton
    ╰── button.color
        ╰── [content]
    ```

    `GtkColorButton` has a single CSS node with name colorbutton which
    contains a button node. To differentiate it from a plain `GtkButton`,
    it gets the .color style class.
    """

    class Props(Widget.Props):
        modal: bool
        show_editor: bool  # [show-editor]: changed because contained invalid characters
        title: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, modal: bool = ..., show_editor: bool = ..., title: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_modal(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_title(self) -> str: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_with_rgba(cls, rgba: Gdk.RGBA) -> Widget: ...
    @deprecated("deprecated")
    def set_modal(self, modal: bool) -> None: ...
    @deprecated("deprecated")
    def set_title(self, title: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["color-set"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_editor"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColorChooser(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        rgba: Gdk.RGBA | None
        use_alpha: bool  # [use-alpha]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, rgba: Gdk.RGBA | None = ..., use_alpha: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_palette(
        self, orientation: Orientation, colors_per_line: int, n_colors: int, colors: list | None = None
    ) -> None: ...
    @deprecated("deprecated")
    def get_rgba(self) -> Gdk.RGBA: ...
    @deprecated("deprecated")
    @builtins.property
    def get_use_alpha(self) -> bool: ...
    @deprecated("deprecated")
    def set_rgba(self, color: Gdk.RGBA) -> None: ...
    @deprecated("deprecated")
    def set_use_alpha(self, use_alpha: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["color-activated"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.RGBA], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_alpha"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColorChooserDialog(Dialog):
    """
    A dialog for choosing a color.

    <picture>
      <source srcset="colorchooser-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkColorChooserDialog" src="colorchooser.png">
    </picture>

    `GtkColorChooserDialog` implements the [iface@Gtk.ColorChooser] interface
    and does not provide much API of its own.

    To create a `GtkColorChooserDialog`, use [ctor@Gtk.ColorChooserDialog.new].

    To change the initially selected color, use
    [method@Gtk.ColorChooser.set_rgba]. To get the selected color use
    [method@Gtk.ColorChooser.get_rgba].

    `GtkColorChooserDialog` has been deprecated in favor of [class@Gtk.ColorDialog].

    ## CSS nodes

    `GtkColorChooserDialog` has a single CSS node with the name `window` and style
    class `.colorchooser`.
    """

    class Props(Dialog.Props):
        show_editor: bool  # [show-editor]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, show_editor: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls, title: str | None = None, parent: Window | None = None) -> Widget: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_editor"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColorChooserInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def add_palette(self) -> add_paletteColorChooserInterfaceCB: ...
    @builtins.property
    def base_interface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def color_activated(self) -> color_activatedColorChooserInterfaceCB: ...
    @builtins.property
    def get_rgba(self) -> get_rgbaColorChooserInterfaceCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def set_rgba(self) -> set_rgbaColorChooserInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ColorChooserWidget(Widget):
    """
    The `GtkColorChooserWidget` widget lets the user select a color.

    By default, the chooser presents a predefined palette of colors,
    plus a small number of settable custom colors. It is also possible
    to select a different color with the single-color editor.

    To enter the single-color editing mode, use the context menu of any
    color of the palette, or use the '+' button to add a new custom color.

    The chooser automatically remembers the last selection, as well
    as custom colors.

    To create a `GtkColorChooserWidget`, use [ctor@Gtk.ColorChooserWidget.new].

    To change the initially selected color, use
    [method@Gtk.ColorChooser.set_rgba]. To get the selected color use
    [method@Gtk.ColorChooser.get_rgba].

    The `GtkColorChooserWidget` is used in the [class@Gtk.ColorChooserDialog]
    to provide a dialog for selecting colors.

    # Actions

    `GtkColorChooserWidget` defines a set of built-in actions:

    - `color.customize` activates the color editor for the given color.
    - `color.select` emits the [signal@Gtk.ColorChooser::color-activated] signal
      for the given color.

    # CSS names

    `GtkColorChooserWidget` has a single CSS node with name colorchooser.
    """

    class Props(Widget.Props):
        show_editor: bool  # [show-editor]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, show_editor: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> Widget: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_editor"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColorDialog(GObject.Object):
    """
    Asynchronous API to present a color chooser dialog.

    `GtkColorDialog` collects the arguments that are needed to present
    the dialog to the user, such as a title for the dialog and whether
    it should be modal.

    The dialog is shown with the [method@Gtk.ColorDialog.choose_rgba]
    function.

    See [class@Gtk.ColorDialogButton] for a convenient control
    that uses `GtkColorDialog` and presents the results.
    """

    class Props(GObject.Object.Props):
        modal: bool
        title: str
        with_alpha: bool  # [with-alpha]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, modal: bool = ..., title: str = ..., with_alpha: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def choose_rgba(
        self,
        parent: Window | None = None,
        initial_color: Gdk.RGBA | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def choose_rgba_finish(self, result: Gio.AsyncResult) -> Gdk.RGBA | None: ...
    @builtins.property
    def get_modal(self) -> bool: ...
    @builtins.property
    def get_title(self) -> str: ...
    @builtins.property
    def get_with_alpha(self) -> bool: ...
    @classmethod
    def new(cls) -> ColorDialog: ...
    def set_modal(self, modal: bool) -> None: ...
    def set_title(self, title: str) -> None: ...
    def set_with_alpha(self, with_alpha: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::with_alpha"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColorDialogButton(Widget):
    """
    Opens a color chooser dialog to select a color.

    <picture>
      <source srcset="color-button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkColorDialogButton" src="color-button.png">
    </picture>

    It is suitable widget for selecting a color in a preference dialog.

    # CSS nodes

    ```
    colorbutton
    ╰── button.color
        ╰── [content]
    ```

    `GtkColorDialogButton` has a single CSS node with name colorbutton which
    contains a button node. To differentiate it from a plain `GtkButton`,
    it gets the .color style class.
    """

    class Props(Widget.Props):
        dialog: ColorDialog | None
        rgba: Gdk.RGBA | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, dialog: ColorDialog | None = ..., rgba: Gdk.RGBA | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_dialog(self) -> ColorDialog | None: ...
    @builtins.property
    def get_rgba(self) -> Gdk.RGBA: ...
    @classmethod
    def new(cls, dialog: ColorDialog | None = None) -> Widget: ...
    def set_dialog(self, dialog: ColorDialog) -> None: ...
    def set_rgba(self, color: Gdk.RGBA) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::dialog"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColorDialogButtonClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ColorDialogClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ColumnView(Widget):
    """
    Presents a large dynamic list of items using multiple columns with headers.

    `GtkColumnView` uses the factories of its columns to generate a cell widget for
    each column, for each visible item and displays them together as the row for
    this item.

    The [property@Gtk.ColumnView:show-row-separators] and
    [property@Gtk.ColumnView:show-column-separators] properties offer a simple way
    to display separators between the rows or columns.

    `GtkColumnView` allows the user to select items according to the selection
    characteristics of the model. For models that allow multiple selected items,
    it is possible to turn on *rubberband selection*, using
    [property@Gtk.ColumnView:enable-rubberband].

    The column view supports sorting that can be customized by the user by
    clicking on column headers. To set this up, the `GtkSorter` returned by
    [method@Gtk.ColumnView.get_sorter] must be attached to a sort model for the
    data that the view is showing, and the columns must have sorters attached to
    them by calling [method@Gtk.ColumnViewColumn.set_sorter]. The initial sort
    order can be set with [method@Gtk.ColumnView.sort_by_column].

    The column view also supports interactive resizing and reordering of
    columns, via Drag-and-Drop of the column headers. This can be enabled or
    disabled with the [property@Gtk.ColumnView:reorderable] and
    [property@Gtk.ColumnViewColumn:resizable] properties.

    To learn more about the list widget framework, see the
    [overview](section-list-widget.html).

    # CSS nodes

    ```
    columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
    ├── header
    │   ├── <column header>
    ┊   ┊
    │   ╰── <column header>
    │
    ├── listview
    │
    ┊
    ╰── [rubberband]
    ```

    `GtkColumnView` uses a single CSS node named columnview. It may carry the
    .column-separators style class, when [property@Gtk.ColumnView:show-column-separators]
    property is set. Header widgets appear below a node with name header.
    The rows are contained in a `GtkListView` widget, so there is a listview
    node with the same structure as for a standalone `GtkListView` widget.
    If [property@Gtk.ColumnView:show-row-separators] is set, it will be passed
    on to the list view, causing its CSS node to carry the .separators style class.
    For rubberband selection, a node with name rubberband is used.

    The main columnview node may also carry style classes to select
    the style of [list presentation](section-list-widget.html#list-styles):
    .rich-list, .navigation-sidebar or .data-table.

    # Accessibility

    `GtkColumnView` uses the [enum@Gtk.AccessibleRole.tree_grid] role, header title
    widgets are using the [enum@Gtk.AccessibleRole.column_header] role. The row widgets
    are using the [enum@Gtk.AccessibleRole.row] role, and individual cells are using
    the [enum@Gtk.AccessibleRole.grid_cell] role
    """

    class Props(Widget.Props):
        columns: Gio.ListModel | None
        enable_rubberband: bool  # [enable-rubberband]: changed because contained invalid characters
        header_factory: ListItemFactory | None  # [header-factory]: changed because contained invalid characters
        model: SelectionModel | None
        reorderable: bool
        row_factory: ListItemFactory | None  # [row-factory]: changed because contained invalid characters
        show_column_separators: bool  # [show-column-separators]: changed because contained invalid characters
        show_row_separators: bool  # [show-row-separators]: changed because contained invalid characters
        single_click_activate: bool  # [single-click-activate]: changed because contained invalid characters
        sorter: Sorter | None
        tab_behavior: ListTabBehavior  # [tab-behavior]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        enable_rubberband: bool = ...,
        header_factory: ListItemFactory | None = ...,
        model: SelectionModel | None = ...,
        reorderable: bool = ...,
        row_factory: ListItemFactory | None = ...,
        show_column_separators: bool = ...,
        show_row_separators: bool = ...,
        single_click_activate: bool = ...,
        tab_behavior: ListTabBehavior = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append_column(self, column: ColumnViewColumn) -> None: ...
    @builtins.property
    def get_columns(self) -> Gio.ListModel: ...
    @builtins.property
    def get_enable_rubberband(self) -> bool: ...
    @builtins.property
    def get_header_factory(self) -> ListItemFactory | None: ...
    @builtins.property
    def get_model(self) -> SelectionModel | None: ...
    @builtins.property
    def get_reorderable(self) -> bool: ...
    @builtins.property
    def get_row_factory(self) -> ListItemFactory | None: ...
    @builtins.property
    def get_show_column_separators(self) -> bool: ...
    @builtins.property
    def get_show_row_separators(self) -> bool: ...
    @builtins.property
    def get_single_click_activate(self) -> bool: ...
    @builtins.property
    def get_sorter(self) -> Sorter | None: ...
    @builtins.property
    def get_tab_behavior(self) -> ListTabBehavior: ...
    def insert_column(self, position: int, column: ColumnViewColumn) -> None: ...
    @classmethod
    def new(cls, model: SelectionModel | None = None) -> Widget: ...
    def remove_column(self, column: ColumnViewColumn) -> None: ...
    def scroll_to(
        self, pos: int, column: ColumnViewColumn | None, flags: ListScrollFlags, scroll: ScrollInfo | None = None
    ) -> None: ...
    def set_enable_rubberband(self, enable_rubberband: bool) -> None: ...
    def set_header_factory(self, factory: ListItemFactory | None = None) -> None: ...
    def set_model(self, model: SelectionModel | None = None) -> None: ...
    def set_reorderable(self, reorderable: bool) -> None: ...
    def set_row_factory(self, factory: ListItemFactory | None = None) -> None: ...
    def set_show_column_separators(self, show_column_separators: bool) -> None: ...
    def set_show_row_separators(self, show_row_separators: bool) -> None: ...
    def set_single_click_activate(self, single_click_activate: bool) -> None: ...
    def set_tab_behavior(self, tab_behavior: ListTabBehavior) -> None: ...
    def sort_by_column(self, column: ColumnViewColumn | None, direction: SortType) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate"],
        handler: typing.Callable[[typing_extensions.Self, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::columns"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_rubberband"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::header_factory"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::reorderable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::row_factory"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_column_separators"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_row_separators"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::single_click_activate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sorter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tab_behavior"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColumnViewCell(ListItem):
    """
    Represents items in a cell in [class@Gtk.ColumnView].

    The `GtkColumnViewCell`s are managed by the [class@Gtk.ColumnView]
    widget (with its factory) and cannot be created by applications, but
    they need to be populated by application code. This is done by calling
    [method@Gtk.ColumnViewCell.set_child].

    `GtkColumnViewCell`s exist in 2 stages:

    1. The unbound stage where the listitem is not currently connected to
       an item in the list. In that case, the [property@Gtk.ColumnViewCell:item]
       property is set to %NULL.

    2. The bound stage where the listitem references an item from the list.
       The [property@Gtk.ColumnViewCell:item] property is not %NULL.
    """

    class Props(ListItem.Props):
        child: Widget | None
        focusable: bool
        item: GObject.Object | None
        position: int
        selected: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, child: Widget | None = ..., focusable: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_focusable(self) -> bool: ...
    @builtins.property
    def get_item(self) -> GObject.Object | None: ...
    @builtins.property
    def get_position(self) -> int: ...
    @builtins.property
    def get_selected(self) -> bool: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_focusable(self, focusable: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::focusable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selected"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColumnViewCellClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ColumnViewClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ColumnViewColumn(GObject.Object):
    """
    Represents the columns in a `GtkColumnView`.

    The main ingredient for a `GtkColumnViewColumn` is the `GtkListItemFactory`
    that tells the columnview how to create cells for this column from items in
    the model.

    Columns have a title, and can optionally have a header menu set
    with [method@Gtk.ColumnViewColumn.set_header_menu].

    A sorter can be associated with a column using
    [method@Gtk.ColumnViewColumn.set_sorter], to let users influence sorting
    by clicking on the column header.
    """

    class Props(GObject.Object.Props):
        column_view: ColumnView | None  # [column-view]: changed because contained invalid characters
        expand: bool
        factory: ListItemFactory | None
        fixed_width: int  # [fixed-width]: changed because contained invalid characters
        header_menu: Gio.MenuModel | None  # [header-menu]: changed because contained invalid characters
        id: str
        resizable: bool
        sorter: Sorter | None
        title: str
        visible: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        expand: bool = ...,
        factory: ListItemFactory | None = ...,
        fixed_width: int = ...,
        header_menu: Gio.MenuModel | None = ...,
        id: str = ...,
        resizable: bool = ...,
        sorter: Sorter | None = ...,
        title: str = ...,
        visible: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_column_view(self) -> ColumnView | None: ...
    @builtins.property
    def get_expand(self) -> bool: ...
    @builtins.property
    def get_factory(self) -> ListItemFactory | None: ...
    @builtins.property
    def get_fixed_width(self) -> int: ...
    @builtins.property
    def get_header_menu(self) -> Gio.MenuModel | None: ...
    @builtins.property
    def get_id(self) -> str | None: ...
    @builtins.property
    def get_resizable(self) -> bool: ...
    @builtins.property
    def get_sorter(self) -> Sorter | None: ...
    @builtins.property
    def get_title(self) -> str | None: ...
    @builtins.property
    def get_visible(self) -> bool: ...
    @classmethod
    def new(cls, title: str | None = None, factory: ListItemFactory | None = None) -> ColumnViewColumn: ...
    def set_expand(self, expand: bool) -> None: ...
    def set_factory(self, factory: ListItemFactory | None = None) -> None: ...
    def set_fixed_width(self, fixed_width: int) -> None: ...
    def set_header_menu(self, menu: Gio.MenuModel | None = None) -> None: ...
    def set_id(self, id: str | None = None) -> None: ...
    def set_resizable(self, resizable: bool) -> None: ...
    def set_sorter(self, sorter: Sorter | None = None) -> None: ...
    def set_title(self, title: str | None = None) -> None: ...
    def set_visible(self, visible: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::column_view"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expand"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::factory"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::fixed_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::header_menu"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resizable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sorter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColumnViewColumnClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ColumnViewRow(GObject.Object):
    """
    Configures how rows are displayed in a [class@Gtk.ColumnView].

    It is not used to set the widgets displayed in the individual cells. For that
    see [method@GtkColumnViewColumn.set_factory] and [class@GtkColumnViewCell].
    """

    class Props(GObject.Object.Props):
        accessible_description: str  # [accessible-description]: changed because contained invalid characters
        accessible_label: str  # [accessible-label]: changed because contained invalid characters
        activatable: bool
        focusable: bool
        item: GObject.Object | None
        position: int
        selectable: bool
        selected: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accessible_description: str = ...,
        accessible_label: str = ...,
        activatable: bool = ...,
        focusable: bool = ...,
        selectable: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_accessible_description(self) -> str: ...
    @builtins.property
    def get_accessible_label(self) -> str: ...
    @builtins.property
    def get_activatable(self) -> bool: ...
    @builtins.property
    def get_focusable(self) -> bool: ...
    @builtins.property
    def get_item(self) -> GObject.Object | None: ...
    @builtins.property
    def get_position(self) -> int: ...
    @builtins.property
    def get_selectable(self) -> bool: ...
    @builtins.property
    def get_selected(self) -> bool: ...
    def set_accessible_description(self, description: str) -> None: ...
    def set_accessible_label(self, label: str) -> None: ...
    def set_activatable(self, activatable: bool) -> None: ...
    def set_focusable(self, focusable: bool) -> None: ...
    def set_selectable(self, selectable: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accessible_description"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accessible_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activatable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::focusable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selectable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selected"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColumnViewRowClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ColumnViewSorter(Sorter):
    """
    Sorts [class@Gtk.ColumnView] columns.

    The sorter returned by [method@Gtk.ColumnView.get_sorter] is
    a `GtkColumnViewSorter`.

    In column views, sorting can be configured by associating
    sorters with columns, and users can invert sort order by clicking
    on column headers. The API of `GtkColumnViewSorter` is designed
    to allow saving and restoring this configuration.

    If you are only interested in the primary sort column (i.e. the
    column where a sort indicator is shown in the header), then
    you can just look at [property@Gtk.ColumnViewSorter:primary-sort-column]
    and [property@Gtk.ColumnViewSorter:primary-sort-order].

    If you want to store the full sort configuration, including
    secondary sort columns that are used for tie breaking, then
    you can use [method@Gtk.ColumnViewSorter.get_nth_sort_column].
    To get notified about changes, use [signal@Gtk.Sorter::changed].

    To restore a saved sort configuration on a `GtkColumnView`,
    use code like:

    ```
    sorter = gtk_column_view_get_sorter (view);
    for (i = gtk_column_view_sorter_get_n_sort_columns (sorter) - 1; i >= 0; i--)
      {
        column = gtk_column_view_sorter_get_nth_sort_column (sorter, i, &order);
        gtk_column_view_sort_by_column (view, column, order);
      }
    ```
    """

    class Props(Sorter.Props):
        primary_sort_column: (
            ColumnViewColumn | None
        )  # [primary-sort-column]: changed because contained invalid characters
        primary_sort_order: SortType  # [primary-sort-order]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_n_sort_columns(self) -> int: ...
    def get_nth_sort_column(self, position: int) -> tuple[ColumnViewColumn | None, SortType]: ...
    @builtins.property
    def get_primary_sort_column(self) -> ColumnViewColumn | None: ...
    @builtins.property
    def get_primary_sort_order(self) -> SortType: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_sort_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_sort_order"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ColumnViewSorterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SorterClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ComboBox(Widget):
    """
    A `GtkComboBox` is a widget that allows the user to choose from a list of
    valid choices.

    <picture>
      <source srcset="combo-box-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkComboBox" src="combo-box.png">
    </picture>

    The `GtkComboBox` displays the selected choice; when activated, the
    `GtkComboBox` displays a popup which allows the user to make a new choice.

    The `GtkComboBox` uses the model-view pattern; the list of valid choices
    is specified in the form of a tree model, and the display of the choices
    can be adapted to the data in the model by using cell renderers, as you
    would in a tree view. This is possible since `GtkComboBox` implements the
    [iface@Gtk.CellLayout] interface. The tree model holding the valid
    choices is not restricted to a flat list, it can be a real tree, and the
    popup will reflect the tree structure.

    To allow the user to enter values not in the model, the
    [property@Gtk.ComboBox:has-entry] property allows the `GtkComboBox` to
    contain a [class@Gtk.Entry]. This entry can be accessed by calling
    [method@Gtk.ComboBox.get_child] on the combo box.

    For a simple list of textual choices, the model-view API of `GtkComboBox`
    can be a bit overwhelming. In this case, [class@Gtk.ComboBoxText] offers
    a simple alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain
    an entry.

    ## CSS nodes

    ```
    combobox
    ├── box.linked
    │   ╰── button.combo
    │       ╰── box
    │           ├── cellview
    │           ╰── arrow
    ╰── window.popup
    ```

    A normal combobox contains a box with the .linked class, a button
    with the .combo class and inside those buttons, there are a cellview and
    an arrow.

    ```
    combobox
    ├── box.linked
    │   ├── entry.combo
    │   ╰── button.combo
    │       ╰── box
    │           ╰── arrow
    ╰── window.popup
    ```

    A `GtkComboBox` with an entry has a single CSS node with name combobox.
    It contains a box with the .linked class. That box contains an entry and
    a button, both with the .combo class added. The button also contains another
    node with name arrow.

    ## Accessibility

    `GtkComboBox` uses the [enum@Gtk.AccessibleRole.combo_box] role.
    """

    class Props(Widget.Props):
        active: int
        active_id: str  # [active-id]: changed because contained invalid characters
        button_sensitivity: SensitivityType  # [button-sensitivity]: changed because contained invalid characters
        child: Widget | None
        entry_text_column: int  # [entry-text-column]: changed because contained invalid characters
        has_entry: bool  # [has-entry]: changed because contained invalid characters
        has_frame: bool  # [has-frame]: changed because contained invalid characters
        id_column: int  # [id-column]: changed because contained invalid characters
        model: TreeModel | None
        popup_fixed_width: bool  # [popup-fixed-width]: changed because contained invalid characters
        popup_shown: bool  # [popup-shown]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        active: int = ...,
        active_id: str = ...,
        button_sensitivity: SensitivityType = ...,
        child: Widget | None = ...,
        entry_text_column: int = ...,
        has_entry: bool = ...,
        has_frame: bool = ...,
        id_column: int = ...,
        model: TreeModel | None = ...,
        popup_fixed_width: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_active(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_active_id(self) -> str | None: ...
    @deprecated("deprecated")
    def get_active_iter(self) -> tuple[bool, TreeIter]: ...
    @deprecated("deprecated")
    @builtins.property
    def get_button_sensitivity(self) -> SensitivityType: ...
    @deprecated("deprecated")
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_entry_text_column(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_has_entry(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_id_column(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_model(self) -> TreeModel | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_popup_fixed_width(self) -> bool: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_entry(cls) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_model(cls, model: TreeModel) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_model_and_entry(cls, model: TreeModel) -> Widget: ...
    @deprecated("deprecated")
    def popdown(self) -> None: ...
    @deprecated("deprecated")
    def popup(self) -> None: ...
    @deprecated("deprecated")
    def popup_for_device(self, device: Gdk.Device) -> None: ...
    @deprecated("deprecated")
    def set_active(self, index_: int) -> None: ...
    @deprecated("deprecated")
    def set_active_id(self, active_id: str | None = None) -> bool: ...
    @deprecated("deprecated")
    def set_active_iter(self, iter: TreeIter | None = None) -> None: ...
    @deprecated("deprecated")
    def set_button_sensitivity(self, sensitivity: SensitivityType) -> None: ...
    @deprecated("deprecated")
    def set_child(self, child: Widget | None = None) -> None: ...
    @deprecated("deprecated")
    def set_entry_text_column(self, text_column: int) -> None: ...
    @deprecated("deprecated")
    def set_id_column(self, id_column: int) -> None: ...
    @deprecated("deprecated")
    def set_model(self, model: TreeModel | None = None) -> None: ...
    @deprecated("deprecated")
    def set_popup_fixed_width(self, fixed: bool) -> None: ...
    @deprecated("deprecated")
    def set_row_separator_func(
        self,
        func: TreeViewRowSeparatorFunc | None = None,
        data: object | None = None,
        destroy: GLib.DestroyNotify | None = None,
    ) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["format-entry-text"],
        handler: typing.Callable[[typing_extensions.Self, str], str],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-active"],
        handler: typing.Callable[[typing_extensions.Self, ScrollType], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["popdown"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["popup"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::button_sensitivity"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::entry_text_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_entry"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_frame"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::id_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::popup_fixed_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::popup_shown"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ComboBoxClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate(self) -> activateComboBoxClassCB: ...
    @builtins.property
    def changed(self) -> changedComboBoxClassCB: ...
    @builtins.property
    def format_entry_text(self) -> format_entry_textComboBoxClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ComboBoxText(ComboBox):
    """
    A `GtkComboBoxText` is a simple variant of `GtkComboBox` for text-only
    use cases.

    <picture>
      <source srcset="combo-box-text-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkComboBoxText" src="combo-box-text.png">
    </picture>

    `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.

    To create a `GtkComboBoxText`, use [ctor@Gtk.ComboBoxText.new] or
    [ctor@Gtk.ComboBoxText.new_with_entry].

    You can add items to a `GtkComboBoxText` with
    [method@Gtk.ComboBoxText.append_text],
    [method@Gtk.ComboBoxText.insert_text] or
    [method@Gtk.ComboBoxText.prepend_text] and remove options with
    [method@Gtk.ComboBoxText.remove].

    If the `GtkComboBoxText` contains an entry (via the
    [property@Gtk.ComboBox:has-entry] property), its contents can be retrieved
    using [method@Gtk.ComboBoxText.get_active_text].

    You should not call [method@Gtk.ComboBox.set_model] or attempt to pack more
    cells into this combo box via its [iface@Gtk.CellLayout] interface.

    ## GtkComboBoxText as GtkBuildable

    The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
    adding items directly using the `<items>` element and specifying `<item>`
    elements for each item. Each `<item>` element can specify the “id”
    corresponding to the appended text and also supports the regular
    translation attributes “translatable”, “context” and “comments”.

    Here is a UI definition fragment specifying `GtkComboBoxText` items:
    ```xml
    <object class="GtkComboBoxText">
      <items>
        <item translatable="yes" id="factory">Factory</item>
        <item translatable="yes" id="home">Home</item>
        <item translatable="yes" id="subway">Subway</item>
      </items>
    </object>
    ```

    ## CSS nodes

    ```
    combobox
    ╰── box.linked
        ├── entry.combo
        ├── button.combo
        ╰── window.popup
    ```

    `GtkComboBoxText` has a single CSS node with name combobox. It adds
    the style class .combo to the main CSS nodes of its entry and button
    children, and the .linked class to the node of its internal box.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def append(self, id: str | None, text: str) -> None: ...
    @deprecated("deprecated")
    def append_text(self, text: str) -> None: ...
    @deprecated("deprecated")
    def get_active_text(self) -> str | None: ...
    @deprecated("deprecated")
    def insert(self, position: int, id: str | None, text: str) -> None: ...
    @deprecated("deprecated")
    def insert_text(self, position: int, text: str) -> None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_entry(cls) -> Widget: ...
    @deprecated("deprecated")
    def prepend(self, id: str | None, text: str) -> None: ...
    @deprecated("deprecated")
    def prepend_text(self, text: str) -> None: ...
    @deprecated("deprecated")
    def remove(self, position: int) -> None: ...
    @deprecated("deprecated")
    def remove_all(self) -> None: ...

class ConstantExpression(Expression):
    """
    A constant value in a `GtkExpression`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_value(self) -> GObject.Value: ...
    @classmethod
    def new_for_value(cls, value: GObject.Value) -> ConstantExpression: ...

class Constraint(GObject.Object):
    """
    Describes a constraint between attributes of two widgets,
     expressed as a linear equation.

    The typical equation for a constraint is:

    ```
      target.target_attr = source.source_attr × multiplier + constant
    ```

    Each `GtkConstraint` is part of a system that will be solved by a
    [class@Gtk.ConstraintLayout] in order to allocate and position each
    child widget or guide.

    The source and target, as well as their attributes, of a `GtkConstraint`
    instance are immutable after creation.
    """

    class Props(GObject.Object.Props):
        constant: float
        multiplier: float
        relation: ConstraintRelation
        source: ConstraintTarget | None
        source_attribute: ConstraintAttribute  # [source-attribute]: changed because contained invalid characters
        strength: int
        target: ConstraintTarget | None
        target_attribute: ConstraintAttribute  # [target-attribute]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        constant: float = ...,
        multiplier: float = ...,
        relation: ConstraintRelation = ...,
        source: ConstraintTarget | None = ...,
        source_attribute: ConstraintAttribute = ...,
        strength: int = ...,
        target: ConstraintTarget | None = ...,
        target_attribute: ConstraintAttribute = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_constant(self) -> float: ...
    @builtins.property
    def get_multiplier(self) -> float: ...
    @builtins.property
    def get_relation(self) -> ConstraintRelation: ...
    @builtins.property
    def get_source(self) -> ConstraintTarget | None: ...
    @builtins.property
    def get_source_attribute(self) -> ConstraintAttribute: ...
    @builtins.property
    def get_strength(self) -> int: ...
    @builtins.property
    def get_target(self) -> ConstraintTarget | None: ...
    @builtins.property
    def get_target_attribute(self) -> ConstraintAttribute: ...
    def is_attached(self) -> bool: ...
    def is_constant(self) -> bool: ...
    def is_required(self) -> bool: ...
    @classmethod
    def new(
        cls,
        target: ConstraintTarget | None,
        target_attribute: ConstraintAttribute,
        relation: ConstraintRelation,
        source: ConstraintTarget | None,
        source_attribute: ConstraintAttribute,
        multiplier: float,
        constant: float,
        strength: int,
    ) -> Constraint: ...
    @classmethod
    def new_constant(
        cls,
        target: ConstraintTarget | None,
        target_attribute: ConstraintAttribute,
        relation: ConstraintRelation,
        constant: float,
        strength: int,
    ) -> Constraint: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::constant"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::multiplier"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::relation"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::source"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::source_attribute"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::strength"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::target"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::target_attribute"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ConstraintClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConstraintGuide(GObject.Object):
    """
    An invisible layout element in a `GtkConstraintLayout`.

    The `GtkConstraintLayout` treats guides like widgets. They
    can be used as the source or target of a `GtkConstraint`.

    Guides have a minimum, maximum and natural size. Depending
    on the constraints that are applied, they can act like a
    guideline that widgets can be aligned to, or like *flexible
    space*.

    Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
    """

    class Props(GObject.Object.Props):
        max_height: int  # [max-height]: changed because contained invalid characters
        max_width: int  # [max-width]: changed because contained invalid characters
        min_height: int  # [min-height]: changed because contained invalid characters
        min_width: int  # [min-width]: changed because contained invalid characters
        name: str
        nat_height: int  # [nat-height]: changed because contained invalid characters
        nat_width: int  # [nat-width]: changed because contained invalid characters
        strength: ConstraintStrength

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        max_height: int = ...,
        max_width: int = ...,
        min_height: int = ...,
        min_width: int = ...,
        name: str = ...,
        nat_height: int = ...,
        nat_width: int = ...,
        strength: ConstraintStrength = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_max_size(self) -> tuple[int | None, int | None]: ...
    def get_min_size(self) -> tuple[int | None, int | None]: ...
    @builtins.property
    def get_name(self) -> str | None: ...
    def get_nat_size(self) -> tuple[int | None, int | None]: ...
    @builtins.property
    def get_strength(self) -> ConstraintStrength: ...
    @classmethod
    def new(cls) -> ConstraintGuide: ...
    def set_max_size(self, width: int, height: int) -> None: ...
    def set_min_size(self, width: int, height: int) -> None: ...
    def set_name(self, name: str | None = None) -> None: ...
    def set_nat_size(self, width: int, height: int) -> None: ...
    def set_strength(self, strength: ConstraintStrength) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::nat_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::nat_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::strength"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ConstraintGuideClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConstraintLayout(LayoutManager):
    """
    Uses constraints to describe relations between widgets.

    `GtkConstraintLayout` is a layout manager that uses relations between
    widget attributes, expressed via [class@Gtk.Constraint] instances, to
    measure and allocate widgets.

    ### How do constraints work

    Constraints are objects defining the relationship between attributes
    of a widget; you can read the description of the [class@Gtk.Constraint]
    class to have a more in depth definition.

    By taking multiple constraints and applying them to the children of
    a widget using `GtkConstraintLayout`, it's possible to describe
    complex layout policies; each constraint applied to a child or to the parent
    widgets contributes to the full description of the layout, in terms of
    parameters for resolving the value of each attribute.

    It is important to note that a layout is defined by the totality of
    constraints; removing a child, or a constraint, from an existing layout
    without changing the remaining constraints may result in an unstable
    or unsolvable layout.

    Constraints have an implicit "reading order"; you should start describing
    each edge of each child, as well as their relationship with the parent
    container, from the top left (or top right, in RTL languages), horizontally
    first, and then vertically.

    A constraint-based layout with too few constraints can become "unstable",
    that is: have more than one solution. The behavior of an unstable layout
    is undefined.

    A constraint-based layout with conflicting constraints may be unsolvable,
    and lead to an unstable layout. You can use the [property@Gtk.Constraint:strength]
    property of [class@Gtk.Constraint] to "nudge" the layout towards a solution.

    ### GtkConstraintLayout as GtkBuildable

    `GtkConstraintLayout` implements the [iface@Gtk.Buildable] interface and
    has a custom "constraints" element which allows describing constraints in
    a [class@Gtk.Builder] UI file.

    An example of a UI definition fragment specifying a constraint:

    ```xml
      <object class="GtkConstraintLayout">
        <constraints>
          <constraint target="button" target-attribute="start"
                      relation="eq"
                      source="super" source-attribute="start"
                      constant="12"
                      strength="required" />
          <constraint target="button" target-attribute="width"
                      relation="ge"
                      constant="250"
                      strength="strong" />
        </constraints>
      </object>
    ```

    The definition above will add two constraints to the GtkConstraintLayout:

     - a required constraint between the leading edge of "button" and
       the leading edge of the widget using the constraint layout, plus
       12 pixels
     - a strong, constant constraint making the width of "button" greater
       than, or equal to 250 pixels

    The "target" and "target-attribute" attributes are required.

    The "source" and "source-attribute" attributes of the "constraint"
    element are optional; if they are not specified, the constraint is
    assumed to be a constant.

    The "relation" attribute is optional; if not specified, the constraint
    is assumed to be an equality.

    The "strength" attribute is optional; if not specified, the constraint
    is assumed to be required.

    The "source" and "target" attributes can be set to "super" to indicate
    that the constraint target is the widget using the GtkConstraintLayout.

    There can be "constant" and "multiplier" attributes.

    Additionally, the "constraints" element can also contain a description
    of the `GtkConstraintGuides` used by the layout:

    ```xml
      <constraints>
        <guide min-width="100" max-width="500" name="hspace"/>
        <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
      </constraints>
    ```

    The "guide" element has the following optional attributes:

      - "min-width", "nat-width", and "max-width", describe the minimum,
        natural, and maximum width of the guide, respectively
      - "min-height", "nat-height", and "max-height", describe the minimum,
        natural, and maximum height of the guide, respectively
      - "strength" describes the strength of the constraint on the natural
        size of the guide; if not specified, the constraint is assumed to
        have a medium strength
      - "name" describes a name for the guide, useful when debugging

    ### Using the Visual Format Language

    Complex constraints can be described using a compact syntax called VFL,
    or *Visual Format Language*.

    The Visual Format Language describes all the constraints on a row or
    column, typically starting from the leading edge towards the trailing
    one. Each element of the layout is composed by "views", which identify
    a [iface@Gtk.ConstraintTarget].

    For instance:

    ```
      [button]-[textField]
    ```

    Describes a constraint that binds the trailing edge of "button" to the
    leading edge of "textField", leaving a default space between the two.

    Using VFL is also possible to specify predicates that describe constraints
    on attributes like width and height:

    ```
      // Width must be greater than, or equal to 50
      [button(>=50)]

      // Width of button1 must be equal to width of button2
      [button1(==button2)]
    ```

    The default orientation for a VFL description is horizontal, unless
    otherwise specified:

    ```
      // horizontal orientation, default attribute: width
      H:[button(>=150)]

      // vertical orientation, default attribute: height
      V:[button1(==button2)]
    ```

    It's also possible to specify multiple predicates, as well as their
    strength:

    ```
      // minimum width of button must be 150
      // natural width of button can be 250
      [button(>=150@required, ==250@medium)]
    ```

    Finally, it's also possible to use simple arithmetic operators:

    ```
      // width of button1 must be equal to width of button2
      // divided by 2 plus 12
      [button1(button2 / 2 + 12)]
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_constraint(self, constraint: Constraint) -> None: ...
    def add_constraints_from_description(
        self, lines: list, n_lines: int, hspacing: int, vspacing: int, views: dict
    ) -> list: ...
    def add_guide(self, guide: ConstraintGuide) -> None: ...
    @classmethod
    def new(cls) -> LayoutManager: ...
    def observe_constraints(self) -> Gio.ListModel: ...
    def observe_guides(self) -> Gio.ListModel: ...
    def remove_all_constraints(self) -> None: ...
    def remove_constraint(self, constraint: Constraint) -> None: ...
    def remove_guide(self, guide: ConstraintGuide) -> None: ...

class ConstraintLayoutChild(LayoutChild):
    """
    `GtkLayoutChild` subclass for children in a `GtkConstraintLayout`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConstraintLayoutChildClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutChildClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConstraintLayoutClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutManagerClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConstraintTarget(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConstraintTargetInterface(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CssLocation(GObject.GPointer):
    # gi Fields
    bytes: int = ...
    chars: int = ...
    line_bytes: int = ...
    line_chars: int = ...
    lines: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CssProvider(GObject.Object):
    """
    A style provider for CSS.

    It is able to parse CSS-like input in order to style widgets.

    An application can make GTK parse a specific CSS style sheet by calling
    [method@Gtk.CssProvider.load_from_file] or
    [method@Gtk.CssProvider.load_from_resource]
    and adding the provider with [method@Gtk.StyleContext.add_provider] or
    [func@Gtk.StyleContext.add_provider_for_display].

    In addition, certain files will be read when GTK is initialized.
    First, the file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it
    exists. Then, GTK loads the first existing file among
    `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
    `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
    `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
    `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
    where `THEME` is the name of the current theme (see the
    [property@Gtk.Settings:gtk-theme-name] setting), `VARIANT` is the
    variant to load (see the
    [property@Gtk.Settings:gtk-application-prefer-dark-theme] setting),
    `DATADIR` is the prefix configured when GTK was compiled (unless
    overridden by the `GTK_DATA_PREFIX` environment variable), and
    `VERSION` is the GTK version number. If no file is found for the
    current version, GTK tries older versions all the way back to 4.0.

    To track errors while loading CSS, connect to the
    [signal@Gtk.CssProvider::parsing-error] signal.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def load_from_bytes(self, data: GLib.Bytes) -> None: ...
    @deprecated("deprecated")
    def load_from_data(self, data: str, length: int) -> None: ...
    def load_from_file(self, file: Gio.File) -> None: ...
    def load_from_path(self, path: str) -> None: ...
    def load_from_resource(self, resource_path: str) -> None: ...
    def load_from_string(self, string: str) -> None: ...
    def load_named(self, name: str, variant: str | None = None) -> None: ...
    @classmethod
    def new(cls) -> CssProvider: ...
    def to_string(self) -> str: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["parsing-error"],
        handler: typing.Callable[[typing_extensions.Self, CssSection, None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CssProviderClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CssProviderPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CssSection(GObject.GBoxed):
    # gi Methods
    def get_bytes(self) -> GLib.Bytes | None: ...
    def get_end_location(self) -> CssLocation: ...
    def get_file(self) -> Gio.File | None: ...
    def get_parent(self) -> CssSection | None: ...
    def get_start_location(self) -> CssLocation: ...
    @classmethod
    def new(cls, file: Gio.File | None, start: CssLocation, end: CssLocation) -> CssSection: ...
    @classmethod
    def new_with_bytes(
        cls, file: Gio.File | None, bytes: GLib.Bytes | None, start: CssLocation, end: CssLocation
    ) -> CssSection: ...
    def print_(self, string: GLib.String) -> None: ...
    def ref(self) -> CssSection: ...
    def to_string(self) -> str: ...
    def unref(self) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class CssStyleChange(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CustomFilter(Filter):
    """
    Determines whether to include items with a callback.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(
        cls, match_func: CustomFilterFunc | None, user_data: object | None, user_destroy: GLib.DestroyNotify
    ) -> CustomFilter: ...
    def set_filter_func(
        self, match_func: CustomFilterFunc | None, user_data: object | None, user_destroy: GLib.DestroyNotify
    ) -> None: ...

class CustomFilterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> FilterClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CustomLayout(LayoutManager):
    """
    Uses closures for size negotiation.

    A `GtkCustomLayout` uses closures matching to the old `GtkWidget`
    virtual functions for size negotiation, as a convenience API to
    ease the porting towards the corresponding `GtkLayoutManager`
    virtual functions.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(
        cls, request_mode: CustomRequestModeFunc | None, measure: CustomMeasureFunc, allocate: CustomAllocateFunc
    ) -> LayoutManager: ...

class CustomLayoutClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutManagerClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CustomSorter(Sorter):
    """
    Sorts items via a callback function.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(
        cls,
        sort_func: GLib.CompareDataFunc | None = None,
        user_data: object | None = None,
        user_destroy: GLib.DestroyNotify | None = None,
    ) -> CustomSorter: ...
    def set_sort_func(
        self, sort_func: GLib.CompareDataFunc | None, user_data: object | None, user_destroy: GLib.DestroyNotify
    ) -> None: ...

class CustomSorterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SorterClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Dialog(Window):
    """
    Dialogs are a convenient way to prompt the user for a small amount
    of input.

    <picture>
      <source srcset="dialog-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkDialog" src="dialog.png">
    </picture>

    Typical uses are to display a message, ask a question, or anything else
    that does not require extensive effort on the user’s part.

    The main area of a `GtkDialog` is called the "content area", and is yours
    to populate with widgets such a `GtkLabel` or `GtkEntry`, to present
    your information, questions, or tasks to the user.

    In addition, dialogs allow you to add "action widgets". Most commonly,
    action widgets are buttons. Depending on the platform, action widgets may
    be presented in the header bar at the top of the window, or at the bottom
    of the window. To add action widgets, create your `GtkDialog` using
    [ctor@Gtk.Dialog.new_with_buttons], or use
    [method@Gtk.Dialog.add_button], [method@Gtk.Dialog.add_buttons],
    or [method@Gtk.Dialog.add_action_widget].

    `GtkDialogs` uses some heuristics to decide whether to add a close
    button to the window decorations. If any of the action buttons use
    the response ID %GTK_RESPONSE_CLOSE or %GTK_RESPONSE_CANCEL, the
    close button is omitted.

    Clicking a button that was added as an action widget will emit the
    [signal@Gtk.Dialog::response] signal with a response ID that you specified.
    GTK will never assign a meaning to positive response IDs; these are
    entirely user-defined. But for convenience, you can use the response
    IDs in the [enum@Gtk.ResponseType] enumeration (these all have values
    less than zero). If a dialog receives a delete event, the
    [signal@Gtk.Dialog::response] signal will be emitted with the
    %GTK_RESPONSE_DELETE_EVENT response ID.

    Dialogs are created with a call to [ctor@Gtk.Dialog.new] or
    [ctor@Gtk.Dialog.new_with_buttons]. The latter is recommended; it allows
    you to set the dialog title, some convenient flags, and add buttons.

    A “modal” dialog (that is, one which freezes the rest of the application
    from user input), can be created by calling [method@Gtk.Window.set_modal]
    on the dialog. When using [ctor@Gtk.Dialog.new_with_buttons], you can also
    pass the %GTK_DIALOG_MODAL flag to make a dialog modal.

    For the simple dialog in the following example, a [class@Gtk.MessageDialog]
    would save some effort. But you’d need to create the dialog contents manually
    if you had more than a simple message in the dialog.

    An example for simple `GtkDialog` usage:

    ```c
    // Function to open a dialog box with a message
    void
    quick_message (GtkWindow *parent, char *message)
    {
     GtkWidget *dialog, *label, *content_area;
     GtkDialogFlags flags;

     // Create the widgets
     flags = GTK_DIALOG_DESTROY_WITH_PARENT;
     dialog = gtk_dialog_new_with_buttons ("Message",
                                           parent,
                                           flags,
                                           _("_OK"),
                                           GTK_RESPONSE_NONE,
                                           NULL);
     content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
     label = gtk_label_new (message);

     // Ensure that the dialog box is destroyed when the user responds

     g_signal_connect_swapped (dialog,
                               "response",
                               G_CALLBACK (gtk_window_destroy),
                               dialog);

     // Add the label, and show everything we’ve added

     gtk_box_append (GTK_BOX (content_area), label);
     gtk_widget_show (dialog);
    }
    ```

    # GtkDialog as GtkBuildable

    The `GtkDialog` implementation of the `GtkBuildable` interface exposes the
    @content_area as an internal child with the name “content_area”.

    `GtkDialog` supports a custom `<action-widgets>` element, which can contain
    multiple `<action-widget>` elements. The “response” attribute specifies a
    numeric response, and the content of the element is the id of widget
    (which should be a child of the dialogs @action_area). To mark a response
    as default, set the “default” attribute of the `<action-widget>` element
    to true.

    `GtkDialog` supports adding action widgets by specifying “action” as
    the “type” attribute of a `<child>` element. The widget will be added
    either to the action area or the headerbar of the dialog, depending
    on the “use-header-bar” property. The response id has to be associated
    with the action widget using the `<action-widgets>` element.

    An example of a `GtkDialog` UI definition fragment:

    ```xml
    <object class="GtkDialog" id="dialog1">
      <child type="action">
        <object class="GtkButton" id="button_cancel"/>
      </child>
      <child type="action">
        <object class="GtkButton" id="button_ok">
        </object>
      </child>
      <action-widgets>
        <action-widget response="cancel">button_cancel</action-widget>
        <action-widget response="ok" default="true">button_ok</action-widget>
      </action-widgets>
    </object>
    ```

    # Accessibility

    `GtkDialog` uses the %GTK_ACCESSIBLE_ROLE_DIALOG role.
    """

    class Props(Window.Props):
        use_header_bar: int  # [use-header-bar]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, use_header_bar: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_action_widget(self, child: Widget, response_id: int) -> None: ...
    @deprecated("deprecated")
    def add_button(self, button_text: str, response_id: int) -> Widget: ...
    @deprecated("deprecated")
    def get_content_area(self) -> Box: ...
    @deprecated("deprecated")
    def get_header_bar(self) -> HeaderBar: ...
    @deprecated("deprecated")
    def get_response_for_widget(self, widget: Widget) -> int: ...
    @deprecated("deprecated")
    def get_widget_for_response(self, response_id: int) -> Widget | None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    def response(self, response_id: int) -> None: ...
    @deprecated("deprecated")
    def set_default_response(self, response_id: int) -> None: ...
    @deprecated("deprecated")
    def set_response_sensitive(self, response_id: int, setting: bool) -> None: ...

    # python methods (overrides?)
    def add_buttons(
        self,
        *args: typing.Any,
    ) -> typing.Any:
        """
        The add_buttons() method adds several buttons to the Gtk.Dialog using
        the button data passed as arguments to the method. This method is the
        same as calling the Gtk.Dialog.add_button() repeatedly. The button data
        pairs - button text (or stock ID) and a response ID integer are passed
        individually. For example:

        .. code-block:: python

            dialog.add_buttons(Gtk.STOCK_OPEN, 42, "Close", Gtk.ResponseType.CLOSE)

        will add "Open" and "Close" buttons to dialog.
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["close"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["response"],
        handler: typing.Callable[[typing_extensions.Self, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_header_bar"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DialogClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def close(self) -> closeDialogClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WindowClass | None: ...
    @builtins.property
    def response(self) -> responseDialogClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DirectoryList(GObject.Object):
    """
    A list model that wraps [method@Gio.File.enumerate_children_async].

    It presents a `GListModel` and fills it asynchronously with the `GFileInfo`s
    returned from that function.

    Enumeration will start automatically when the
    [property@Gtk.DirectoryList:file] property is set.

    While the `GtkDirectoryList` is being filled, the
    [property@Gtk.DirectoryList:loading] property will be set to %TRUE. You can
    listen to that property if you want to show information like a `GtkSpinner`
    or a "Loading..." text.

    If loading fails at any point, the [property@Gtk.DirectoryList:error]
    property will be set to give more indication about the failure.

    The `GFileInfo`s returned from a `GtkDirectoryList` have the "standard::file"
    attribute set to the `GFile` they refer to. This way you can get at the file
    that is referred to in the same way you would via g_file_enumerator_get_child().
    This means you do not need access to the `GtkDirectoryList`, but can access
    the `GFile` directly from the `GFileInfo` when operating with a `GtkListView`
    or similar.
    """

    class Props(GObject.Object.Props):
        attributes: str
        error: None | None
        file: Gio.File | None
        io_priority: int  # [io-priority]: changed because contained invalid characters
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        loading: bool
        monitored: bool
        n_items: int  # [n-items]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, attributes: str = ..., file: Gio.File | None = ..., io_priority: int = ..., monitored: bool = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_attributes(self) -> str | None: ...
    @builtins.property
    def get_error(self) -> None: ...
    @builtins.property
    def get_file(self) -> Gio.File | None: ...
    @builtins.property
    def get_io_priority(self) -> int: ...
    @builtins.property
    def get_monitored(self) -> bool: ...
    @builtins.property
    def is_loading(self) -> bool: ...
    @classmethod
    def new(cls, attributes: str | None = None, file: Gio.File | None = None) -> DirectoryList: ...
    def set_attributes(self, attributes: str | None = None) -> None: ...
    def set_file(self, file: Gio.File | None = None) -> None: ...
    def set_io_priority(self, io_priority: int) -> None: ...
    def set_monitored(self, monitored: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::attributes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::error"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::io_priority"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::loading"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::monitored"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DirectoryListClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DragIcon(Widget):
    """
    A `GtkRoot` implementation for drag icons.

    A drag icon moves with the pointer during a Drag-and-Drop operation
    and is destroyed when the drag ends.

    To set up a drag icon and associate it with an ongoing drag operation,
    use [ctor@Gtk.DragIcon.get_for_drag] to get the icon for a drag. You can
    then use it like any other widget and use [method@Gtk.DragIcon.set_child]
    to set whatever widget should be used for the drag icon.

    Keep in mind that drag icons do not allow user input.
    """

    class Props(Widget.Props):
        child: Widget | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, child: Widget | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def create_widget_for_value(value: GObject.Value) -> Widget | None: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @classmethod
    def get_for_drag(cls, drag: Gdk.Drag) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    @staticmethod
    def set_from_paintable(drag: Gdk.Drag, paintable: Gdk.Paintable, hot_x: int, hot_y: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DragIconClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DragSource(GestureSingle):
    """
    An event controller to initiate Drag-And-Drop operations.

    `GtkDragSource` can be set up with the necessary
    ingredients for a DND operation ahead of time. This includes
    the source for the data that is being transferred, in the form
    of a [class@Gdk.ContentProvider], the desired action, and the icon to
    use during the drag operation. After setting it up, the drag
    source must be added to a widget as an event controller, using
    [method@Gtk.Widget.add_controller].

    ```c
    static void
    my_widget_init (MyWidget *self)
    {
      GtkDragSource *drag_source = gtk_drag_source_new ();

      g_signal_connect (drag_source, "prepare", G_CALLBACK (on_drag_prepare), self);
      g_signal_connect (drag_source, "drag-begin", G_CALLBACK (on_drag_begin), self);

      gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (drag_source));
    }
    ```

    Setting up the content provider and icon ahead of time only makes
    sense when the data does not change. More commonly, you will want
    to set them up just in time. To do so, `GtkDragSource` has
    [signal@Gtk.DragSource::prepare] and [signal@Gtk.DragSource::drag-begin]
    signals.

    The ::prepare signal is emitted before a drag is started, and
    can be used to set the content provider and actions that the
    drag should be started with.

    ```c
    static GdkContentProvider *
    on_drag_prepare (GtkDragSource *source,
                     double         x,
                     double         y,
                     MyWidget      *self)
    {
      // This widget supports two types of content: GFile objects
      // and GdkPixbuf objects; GTK will handle the serialization
      // of these types automatically
      GFile *file = my_widget_get_file (self);
      GdkPixbuf *pixbuf = my_widget_get_pixbuf (self);

      return gdk_content_provider_new_union ((GdkContentProvider *[2]) {
          gdk_content_provider_new_typed (G_TYPE_FILE, file),
          gdk_content_provider_new_typed (GDK_TYPE_PIXBUF, pixbuf),
        }, 2);
    }
    ```

    The ::drag-begin signal is emitted after the `GdkDrag` object has
    been created, and can be used to set up the drag icon.

    ```c
    static void
    on_drag_begin (GtkDragSource *source,
                   GdkDrag       *drag,
                   MyWidget      *self)
    {
      // Set the widget as the drag icon
      GdkPaintable *paintable = gtk_widget_paintable_new (GTK_WIDGET (self));
      gtk_drag_source_set_icon (source, paintable, 0, 0);
      g_object_unref (paintable);
    }
    ```

    During the DND operation, `GtkDragSource` emits signals that
    can be used to obtain updates about the status of the operation,
    but it is not normally necessary to connect to any signals,
    except for one case: when the supported actions include
    %GDK_ACTION_MOVE, you need to listen for the
    [signal@Gtk.DragSource::drag-end] signal and delete the
    data after it has been transferred.
    """

    class Props(GestureSingle.Props):
        actions: Gdk.DragAction
        content: Gdk.ContentProvider | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, actions: Gdk.DragAction = ..., content: Gdk.ContentProvider | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def drag_cancel(self) -> None: ...
    @builtins.property
    def get_actions(self) -> Gdk.DragAction: ...
    @builtins.property
    def get_content(self) -> Gdk.ContentProvider | None: ...
    def get_drag(self) -> Gdk.Drag | None: ...
    @classmethod
    def new(cls) -> DragSource: ...
    def set_actions(self, actions: Gdk.DragAction) -> None: ...
    def set_content(self, content: Gdk.ContentProvider | None = None) -> None: ...
    def set_icon(self, paintable: Gdk.Paintable | None, hot_x: int, hot_y: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drag-begin"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Drag], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drag-cancel"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Drag, Gdk.DragCancelReason], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drag-end"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Drag, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["prepare"],
        handler: typing.Callable[[typing_extensions.Self, float, float], Gdk.ContentProvider | None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::actions"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::content"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DragSourceClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DrawingArea(Widget):
    """
    Allows drawing with cairo.

    <picture>
      <source srcset="drawingarea-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkDrawingArea" src="drawingarea.png">
    </picture>

    It’s essentially a blank widget; you can draw on it. After
    creating a drawing area, the application may want to connect to:

    - The [signal@Gtk.Widget::realize] signal to take any necessary actions
      when the widget is instantiated on a particular display.
      (Create GDK resources in response to this signal.)

    - The [signal@Gtk.DrawingArea::resize] signal to take any necessary
      actions when the widget changes size.

    - Call [method@Gtk.DrawingArea.set_draw_func] to handle redrawing the
      contents of the widget.

    The following code portion demonstrates using a drawing
    area to display a circle in the normal widget foreground
    color.

    ## Simple GtkDrawingArea usage

    ```c
    static void
    draw_function (GtkDrawingArea *area,
                   cairo_t        *cr,
                   int             width,
                   int             height,
                   gpointer        data)
    {
      GdkRGBA color;

      cairo_arc (cr,
                 width / 2.0, height / 2.0,
                 MIN (width, height) / 2.0,
                 0, 2 * G_PI);

      gtk_widget_get_color (GTK_WIDGET (area),
                            &color);
      gdk_cairo_set_source_rgba (cr, &color);

      cairo_fill (cr);
    }

    int
    main (int argc, char **argv)
    {
      gtk_init ();

      GtkWidget *area = gtk_drawing_area_new ();
      gtk_drawing_area_set_content_width (GTK_DRAWING_AREA (area), 100);
      gtk_drawing_area_set_content_height (GTK_DRAWING_AREA (area), 100);
      gtk_drawing_area_set_draw_func (GTK_DRAWING_AREA (area),
                                      draw_function,
                                      NULL, NULL);
      return 0;
    }
    ```

    The draw function is normally called when a drawing area first comes
    onscreen, or when it’s covered by another window and then uncovered.
    You can also force a redraw by adding to the “damage region” of the
    drawing area’s window using [method@Gtk.Widget.queue_draw].
    This will cause the drawing area to call the draw function again.

    The available routines for drawing are documented in the
    [Cairo documentation](https://www.cairographics.org/manual/); GDK
    offers additional API to integrate with Cairo, like [func@Gdk.cairo_set_source_rgba]
    or [func@Gdk.cairo_set_source_pixbuf].

    To receive mouse events on a drawing area, you will need to use
    event controllers. To receive keyboard events, you will need to set
    the “can-focus” property on the drawing area, and you should probably
    draw some user-visible indication that the drawing area is focused.

    If you need more complex control over your widget, you should consider
    creating your own `GtkWidget` subclass.
    """

    class Props(Widget.Props):
        content_height: int  # [content-height]: changed because contained invalid characters
        content_width: int  # [content-width]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def widget(self) -> Widget | None: ...

    # gi Methods
    def __init__(self, content_height: int = ..., content_width: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_content_height(self) -> int: ...
    @builtins.property
    def get_content_width(self) -> int: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_content_height(self, height: int) -> None: ...
    def set_content_width(self, width: int) -> None: ...
    def set_draw_func(
        self, draw_func: DrawingAreaDrawFunc | None, user_data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...

    # python methods (overrides?)
    def do_resize(
        self,
        width: int,
        height: int,
    ) -> None:
        """
        resize(self, width:int, height:int)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["resize"],
        handler: typing.Callable[[typing_extensions.Self, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::content_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::content_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DrawingAreaClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...
    @builtins.property
    def resize(self) -> resizeDrawingAreaClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DropControllerMotion(EventController):
    """
    An event controller tracking the pointer during Drag-and-Drop operations.

    It is modeled after [class@Gtk.EventControllerMotion] so if you
    have used that, this should feel really familiar.

    This controller is not able to accept drops, use [class@Gtk.DropTarget]
    for that purpose.
    """

    class Props(EventController.Props):
        contains_pointer: bool  # [contains-pointer]: changed because contained invalid characters
        drop: Gdk.Drop | None
        is_pointer: bool  # [is-pointer]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def contains_pointer(self) -> bool: ...
    @builtins.property
    def get_drop(self) -> Gdk.Drop | None: ...
    @builtins.property
    def is_pointer(self) -> bool: ...
    @classmethod
    def new(cls) -> EventController: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["enter"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["leave"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["motion"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::contains_pointer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::drop"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_pointer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DropControllerMotionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DropDown(Widget):
    """
    Allows the user to choose an item from a list of options.

    <picture>
      <source srcset="drop-down-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkDropDown" src="drop-down.png">
    </picture>

    The `GtkDropDown` displays the [selected][property@Gtk.DropDown:selected]
    choice.

    The options are given to `GtkDropDown` in the form of `GListModel`
    and how the individual options are represented is determined by
    a [class@Gtk.ListItemFactory]. The default factory displays simple strings,
    and adds a checkmark to the selected item in the popup.

    To set your own factory, use [method@Gtk.DropDown.set_factory]. It is
    possible to use a separate factory for the items in the popup, with
    [method@Gtk.DropDown.set_list_factory].

    `GtkDropDown` knows how to obtain strings from the items in a
    [class@Gtk.StringList]; for other models, you have to provide an expression
    to find the strings via [method@Gtk.DropDown.set_expression].

    `GtkDropDown` can optionally allow search in the popup, which is
    useful if the list of options is long. To enable the search entry,
    use [method@Gtk.DropDown.set_enable_search].

    Here is a UI definition example for `GtkDropDown` with a simple model:

    ```xml
    <object class="GtkDropDown">
      <property name="model">
        <object class="GtkStringList">
          <items>
            <item translatable="yes">Factory</item>
            <item translatable="yes">Home</item>
            <item translatable="yes">Subway</item>
          </items>
        </object>
      </property>
    </object>
    ```

    If a `GtkDropDown` is created in this manner, or with
    [ctor@Gtk.DropDown.new_from_strings], for instance, the object returned from
    [method@Gtk.DropDown.get_selected_item] will be a [class@Gtk.StringObject].

    To learn more about the list widget framework, see the
    [overview](section-list-widget.html).

    ## CSS nodes

    `GtkDropDown` has a single CSS node with name dropdown,
    with the button and popover nodes as children.

    ## Accessibility

    `GtkDropDown` uses the [enum@Gtk.AccessibleRole.combo_box] role.
    """

    class Props(Widget.Props):
        enable_search: bool  # [enable-search]: changed because contained invalid characters
        expression: Expression | None
        factory: ListItemFactory | None
        header_factory: ListItemFactory | None  # [header-factory]: changed because contained invalid characters
        list_factory: ListItemFactory | None  # [list-factory]: changed because contained invalid characters
        model: Gio.ListModel | None
        search_match_mode: StringFilterMatchMode  # [search-match-mode]: changed because contained invalid characters
        selected: int
        selected_item: GObject.Object | None  # [selected-item]: changed because contained invalid characters
        show_arrow: bool  # [show-arrow]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        enable_search: bool = ...,
        expression: Expression | None = ...,
        factory: ListItemFactory | None = ...,
        header_factory: ListItemFactory | None = ...,
        list_factory: ListItemFactory | None = ...,
        model: Gio.ListModel | None = ...,
        search_match_mode: StringFilterMatchMode = ...,
        selected: int = ...,
        show_arrow: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_enable_search(self) -> bool: ...
    @builtins.property
    def get_expression(self) -> Expression | None: ...
    @builtins.property
    def get_factory(self) -> ListItemFactory | None: ...
    @builtins.property
    def get_header_factory(self) -> ListItemFactory | None: ...
    @builtins.property
    def get_list_factory(self) -> ListItemFactory | None: ...
    @builtins.property
    def get_model(self) -> Gio.ListModel | None: ...
    @builtins.property
    def get_search_match_mode(self) -> StringFilterMatchMode: ...
    @builtins.property
    def get_selected(self) -> int: ...
    @builtins.property
    def get_selected_item(self) -> GObject.Object | None: ...
    @builtins.property
    def get_show_arrow(self) -> bool: ...
    @classmethod
    def new(cls, model: Gio.ListModel | None = None, expression: Expression | None = None) -> Widget: ...
    @classmethod
    def new_from_strings(cls, strings: list) -> Widget: ...
    def set_enable_search(self, enable_search: bool) -> None: ...
    def set_expression(self, expression: Expression | None = None) -> None: ...
    def set_factory(self, factory: ListItemFactory | None = None) -> None: ...
    def set_header_factory(self, factory: ListItemFactory | None = None) -> None: ...
    def set_list_factory(self, factory: ListItemFactory | None = None) -> None: ...
    def set_model(self, model: Gio.ListModel | None = None) -> None: ...
    def set_search_match_mode(self, search_match_mode: StringFilterMatchMode) -> None: ...
    def set_selected(self, position: int) -> None: ...
    def set_show_arrow(self, show_arrow: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_search"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expression"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::factory"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::header_factory"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::list_factory"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::search_match_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selected"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selected_item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_arrow"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DropDownClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DropTarget(EventController):
    """
    An event controller to receive Drag-and-Drop operations.

    The most basic way to use a `GtkDropTarget` to receive drops on a
    widget is to create it via [ctor@Gtk.DropTarget.new], passing in the
    `GType` of the data you want to receive and connect to the
    [signal@Gtk.DropTarget::drop] signal to receive the data:

    ```c
    static gboolean
    on_drop (GtkDropTarget *target,
             const GValue  *value,
             double         x,
             double         y,
             gpointer       data)
    {
      MyWidget *self = data;

      // Call the appropriate setter depending on the type of data
      // that we received
      if (G_VALUE_HOLDS (value, G_TYPE_FILE))
        my_widget_set_file (self, g_value_get_object (value));
      else if (G_VALUE_HOLDS (value, GDK_TYPE_PIXBUF))
        my_widget_set_pixbuf (self, g_value_get_object (value));
      else
        return FALSE;

      return TRUE;
    }

    static void
    my_widget_init (MyWidget *self)
    {
      GtkDropTarget *target =
        gtk_drop_target_new (G_TYPE_INVALID, GDK_ACTION_COPY);

      // This widget accepts two types of drop types: GFile objects
      // and GdkPixbuf objects
      gtk_drop_target_set_gtypes (target, (GType [2]) {
        G_TYPE_FILE,
        GDK_TYPE_PIXBUF,
      }, 2);

      g_signal_connect (target, "drop", G_CALLBACK (on_drop), self);
      gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (target));
    }
    ```

    `GtkDropTarget` supports more options, such as:

     * rejecting potential drops via the [signal@Gtk.DropTarget::accept] signal
       and the [method@Gtk.DropTarget.reject] function to let other drop
       targets handle the drop
     * tracking an ongoing drag operation before the drop via the
       [signal@Gtk.DropTarget::enter], [signal@Gtk.DropTarget::motion] and
       [signal@Gtk.DropTarget::leave] signals
     * configuring how to receive data by setting the
       [property@Gtk.DropTarget:preload] property and listening for its
       availability via the [property@Gtk.DropTarget:value] property

    However, `GtkDropTarget` is ultimately modeled in a synchronous way
    and only supports data transferred via `GType`. If you want full control
    over an ongoing drop, the [class@Gtk.DropTargetAsync] object gives you
    this ability.

    While a pointer is dragged over the drop target's widget and the drop
    has not been rejected, that widget will receive the
    %GTK_STATE_FLAG_DROP_ACTIVE state, which can be used to style the widget.

    If you are not interested in receiving the drop, but just want to update
    UI state during a Drag-and-Drop operation (e.g. switching tabs), you can
    use [class@Gtk.DropControllerMotion].
    """

    class Props(EventController.Props):
        actions: Gdk.DragAction
        current_drop: Gdk.Drop | None  # [current-drop]: changed because contained invalid characters
        drop: Gdk.Drop | None
        formats: Gdk.ContentFormats | None
        preload: bool
        value: GObject.Value | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, actions: Gdk.DragAction = ..., formats: Gdk.ContentFormats | None = ..., preload: bool = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_actions(self) -> Gdk.DragAction: ...
    @builtins.property
    def get_current_drop(self) -> Gdk.Drop | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_drop(self) -> Gdk.Drop | None: ...
    @builtins.property
    def get_formats(self) -> Gdk.ContentFormats | None: ...
    def get_gtypes(self) -> tuple[list | None, int | None]: ...
    @builtins.property
    def get_preload(self) -> bool: ...
    @builtins.property
    def get_value(self) -> GObject.Value | None: ...
    @classmethod
    def new(cls, type: GObject.GType, actions: Gdk.DragAction) -> DropTarget: ...
    def reject(self) -> None: ...
    def set_actions(self, actions: Gdk.DragAction) -> None: ...
    def set_gtypes(self, types: list | None, n_types: int) -> None: ...
    def set_preload(self, preload: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["accept"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Drop], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drop"],
        handler: typing.Callable[[typing_extensions.Self, GObject.Value, float, float], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["enter"],
        handler: typing.Callable[[typing_extensions.Self, float, float], Gdk.DragAction],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["leave"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["motion"],
        handler: typing.Callable[[typing_extensions.Self, float, float], Gdk.DragAction],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::actions"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_drop"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::drop"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::formats"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::preload"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::value"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DropTargetAsync(EventController):
    """
    An event controller to receive Drag-and-Drop operations, asynchronously.

    It is the more complete but also more complex method of handling drop
    operations compared to [class@Gtk.DropTarget], and you should only use
    it if `GtkDropTarget` doesn't provide all the features you need.

    To use a `GtkDropTargetAsync` to receive drops on a widget, you create
    a `GtkDropTargetAsync` object, configure which data formats and actions
    you support, connect to its signals, and then attach it to the widget
    with [method@Gtk.Widget.add_controller].

    During a drag operation, the first signal that a `GtkDropTargetAsync`
    emits is [signal@Gtk.DropTargetAsync::accept], which is meant to determine
    whether the target is a possible drop site for the ongoing drop. The
    default handler for the ::accept signal accepts the drop if it finds
    a compatible data format and an action that is supported on both sides.

    If it is, and the widget becomes a target, you will receive a
    [signal@Gtk.DropTargetAsync::drag-enter] signal, followed by
    [signal@Gtk.DropTargetAsync::drag-motion] signals as the pointer moves,
    optionally a [signal@Gtk.DropTargetAsync::drop] signal when a drop happens,
    and finally a [signal@Gtk.DropTargetAsync::drag-leave] signal when the
    pointer moves off the widget.

    The ::drag-enter and ::drag-motion handler return a `GdkDragAction`
    to update the status of the ongoing operation. The ::drop handler
    should decide if it ultimately accepts the drop and if it does, it
    should initiate the data transfer and finish the operation by calling
    [method@Gdk.Drop.finish].

    Between the ::drag-enter and ::drag-leave signals the widget is a
    current drop target, and will receive the %GTK_STATE_FLAG_DROP_ACTIVE
    state, which can be used by themes to style the widget as a drop target.
    """

    class Props(EventController.Props):
        actions: Gdk.DragAction
        formats: Gdk.ContentFormats | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, actions: Gdk.DragAction = ..., formats: Gdk.ContentFormats | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_actions(self) -> Gdk.DragAction: ...
    @builtins.property
    def get_formats(self) -> Gdk.ContentFormats | None: ...
    @classmethod
    def new(cls, formats: Gdk.ContentFormats | None, actions: Gdk.DragAction) -> DropTargetAsync: ...
    def reject_drop(self, drop: Gdk.Drop) -> None: ...
    def set_actions(self, actions: Gdk.DragAction) -> None: ...
    def set_formats(self, formats: Gdk.ContentFormats | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["accept"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Drop], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drag-enter"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Drop, float, float], Gdk.DragAction],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drag-leave"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Drop], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drag-motion"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Drop, float, float], Gdk.DragAction],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drop"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Drop, float, float], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::actions"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::formats"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DropTargetAsyncClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DropTargetClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Editable(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        cursor_position: int  # [cursor-position]: changed because contained invalid characters
        editable: bool
        enable_undo: bool  # [enable-undo]: changed because contained invalid characters
        max_width_chars: int  # [max-width-chars]: changed because contained invalid characters
        selection_bound: int  # [selection-bound]: changed because contained invalid characters
        text: str
        width_chars: int  # [width-chars]: changed because contained invalid characters
        xalign: float

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        editable: bool = ...,
        enable_undo: bool = ...,
        max_width_chars: int = ...,
        text: str = ...,
        width_chars: int = ...,
        xalign: float = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def delegate_get_accessible_platform_state(self, state: AccessiblePlatformState) -> bool: ...
    @staticmethod
    def delegate_get_property(
        object: GObject.Object, prop_id: int, value: GObject.Value, pspec: GObject.ParamSpec
    ) -> bool: ...
    @staticmethod
    def delegate_set_property(
        object: GObject.Object, prop_id: int, value: GObject.Value, pspec: GObject.ParamSpec
    ) -> bool: ...
    def delete_selection(self) -> None: ...
    def delete_text(self, start_pos: int, end_pos: int) -> None: ...
    def finish_delegate(self) -> None: ...
    @builtins.property
    def get_alignment(self) -> float: ...
    def get_chars(self, start_pos: int, end_pos: int) -> str: ...
    def get_delegate(self) -> Editable | None: ...
    @builtins.property
    def get_editable(self) -> bool: ...
    @builtins.property
    def get_enable_undo(self) -> bool: ...
    @builtins.property
    def get_max_width_chars(self) -> int: ...
    @builtins.property
    def get_position(self) -> int: ...
    def get_selection_bounds(self) -> tuple[bool, int | None, int | None]: ...
    @builtins.property
    def get_text(self) -> str: ...
    @builtins.property
    def get_width_chars(self) -> int: ...
    def init_delegate(self) -> None: ...
    def insert_text(self, text: str, length: int, position: int) -> int: ...
    @staticmethod
    def install_properties(object_class: GObject.ObjectClass, first_prop: int) -> int: ...
    def select_region(self, start_pos: int, end_pos: int) -> None: ...
    def set_alignment(self, xalign: float) -> None: ...
    def set_editable(self, is_editable: bool) -> None: ...
    def set_enable_undo(self, enable_undo: bool) -> None: ...
    def set_max_width_chars(self, n_chars: int) -> None: ...
    def set_position(self, position: int) -> None: ...
    def set_text(self, text: str) -> None: ...
    def set_width_chars(self, n_chars: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["delete-text"],
        handler: typing.Callable[[typing_extensions.Self, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["insert-text"],
        handler: typing.Callable[[typing_extensions.Self, str, int, int], int],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cursor_position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::editable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_undo"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_width_chars"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selection_bound"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::width_chars"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::xalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EditableInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def base_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def changed(self) -> changedEditableInterfaceCB: ...
    @builtins.property
    def delete_text(self) -> delete_textEditableInterfaceCB: ...
    @builtins.property
    def do_delete_text(self) -> do_delete_textEditableInterfaceCB: ...
    @builtins.property
    def do_insert_text(self) -> do_insert_textEditableInterfaceCB: ...
    @builtins.property
    def get_delegate(self) -> get_delegateEditableInterfaceCB | None: ...
    @builtins.property
    def get_selection_bounds(self) -> get_selection_boundsEditableInterfaceCB: ...
    @builtins.property
    def get_text(self) -> get_textEditableInterfaceCB: ...
    @builtins.property
    def insert_text(self) -> insert_textEditableInterfaceCB: ...
    @builtins.property
    def set_selection_bounds(self) -> set_selection_boundsEditableInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EditableLabel(Widget):
    """
    Allows users to edit the displayed text by switching to an “edit mode”.

    <picture>
      <source srcset="editable-label-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkEditableLabel" src="editable-label.png">
    </picture>

    `GtkEditableLabel` does not have API of its own, but it
    implements the [iface@Gtk.Editable] interface.

    The default bindings for activating the edit mode is
    to click or press the Enter key. The default bindings
    for leaving the edit mode are the Enter key (to save
    the results) or the Escape key (to cancel the editing).

    # Shortcuts and Gestures

    `GtkEditableLabel` supports the following keyboard shortcuts:

    - <kbd>Enter</kbd> starts editing.
    - <kbd>Escape</kbd> stops editing.

    # Actions

    `GtkEditableLabel` defines a set of built-in actions:

    - `editing.starts` switches the widget into editing mode.
    - `editing.stop` switches the widget out of editing mode.

    # CSS nodes

    ```
    editablelabel[.editing]
    ╰── stack
        ├── label
        ╰── text
    ```

    `GtkEditableLabel` has a main node with the name editablelabel.
    When the entry is in editing mode, it gets the .editing style
    class.

    For all the subnodes added to the text node in various situations,
    see [class@Gtk.Text].
    """

    class Props(Widget.Props):
        editing: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, editing: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_editing(self) -> bool: ...
    @classmethod
    def new(cls, str: str) -> Widget: ...
    def start_editing(self) -> None: ...
    def stop_editing(self, commit: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::editing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EditableLabelClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EmojiChooser(Popover):
    """
    Used by text widgets to let users insert Emoji characters.

    <picture>
      <source srcset="emojichooser-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkEmojiChooser" src="emojichooser.png">
    </picture>

    `GtkEmojiChooser` emits the [signal@Gtk.EmojiChooser::emoji-picked]
    signal when an Emoji is selected.

    # Shortcuts and Gestures

    `GtkEmojiChooser` supports the following keyboard shortcuts:

    - <kbd>Ctrl</kbd>+<kbd>N</kbd> scrolls th the next section.
    - <kbd>Ctrl</kbd>+<kbd>P</kbd> scrolls th the previous section.

    # Actions

    `GtkEmojiChooser` defines a set of built-in actions:

    - `scroll.section` scrolls to the next or previous section.

    # CSS nodes

    ```
    popover
    ├── box.emoji-searchbar
    │   ╰── entry.search
    ╰── box.emoji-toolbar
        ├── button.image-button.emoji-section
        ├── ...
        ╰── button.image-button.emoji-section
    ```

    Every `GtkEmojiChooser` consists of a main node called popover.
    The contents of the popover are largely implementation defined
    and supposed to inherit general styles.
    The top searchbar used to search emoji and gets the .emoji-searchbar
    style class itself.
    The bottom toolbar used to switch between different emoji categories
    consists of buttons with the .emoji-section style class and gets the
    .emoji-toolbar style class itself.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> Widget: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["emoji-picked"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EmojiChooserClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Entry(Widget):
    """
    A single-line text entry widget.

    <picture>
      <source srcset="entry-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkEntry" src="entry.png">
    </picture>

    A fairly large set of key bindings are supported by default. If the
    entered text is longer than the allocation of the widget, the widget
    will scroll so that the cursor position is visible.

    When using an entry for passwords and other sensitive information, it
    can be put into “password mode” using [method@Gtk.Entry.set_visibility].
    In this mode, entered text is displayed using a “invisible” character.
    By default, GTK picks the best invisible character that is available
    in the current font, but it can be changed with
    [method@Gtk.Entry.set_invisible_char].

    `GtkEntry` has the ability to display progress or activity
    information behind the text. To make an entry display such information,
    use [method@Gtk.Entry.set_progress_fraction] or
    [method@Gtk.Entry.set_progress_pulse_step].

    Additionally, `GtkEntry` can show icons at either side of the entry.
    These icons can be activatable by clicking, can be set up as drag source
    and can have tooltips. To add an icon, use
    [method@Gtk.Entry.set_icon_from_gicon] or one of the various other functions
    that set an icon from an icon name or a paintable. To trigger an action when
    the user clicks an icon, connect to the [signal@Gtk.Entry::icon-press] signal.
    To allow DND operations from an icon, use
    [method@Gtk.Entry.set_icon_drag_source]. To set a tooltip on an icon, use
    [method@Gtk.Entry.set_icon_tooltip_text] or the corresponding function
    for markup.

    Note that functionality or information that is only available by clicking
    on an icon in an entry may not be accessible at all to users which are not
    able to use a mouse or other pointing device. It is therefore recommended
    that any such functionality should also be available by other means, e.g.
    via the context menu of the entry.

    # CSS nodes

    ```
    entry[.flat][.warning][.error]
    ├── text[.readonly]
    ├── image.left
    ├── image.right
    ╰── [progress[.pulse]]
    ```

    `GtkEntry` has a main node with the name entry. Depending on the properties
    of the entry, the style classes .read-only and .flat may appear. The style
    classes .warning and .error may also be used with entries.

    When the entry shows icons, it adds subnodes with the name image and the
    style class .left or .right, depending on where the icon appears.

    When the entry shows progress, it adds a subnode with the name progress.
    The node has the style class .pulse when the shown progress is pulsing.

    For all the subnodes added to the text node in various situations,
    see [class@Gtk.Text].

    # GtkEntry as GtkBuildable

    The `GtkEntry` implementation of the `GtkBuildable` interface supports a
    custom `<attributes>` element, which supports any number of `<attribute>`
    elements. The `<attribute>` element has attributes named “name“, “value“,
    “start“ and “end“ and allows you to specify `PangoAttribute` values for
    this label.

    An example of a UI definition fragment specifying Pango attributes:
    ```xml
    <object class="GtkEntry">
      <attributes>
        <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
        <attribute name="background" value="red" start="5" end="10"/>
      </attributes>
    </object>
    ```

    The start and end attributes specify the range of characters to which the
    Pango attribute applies. If start and end are not specified, the attribute
    is applied to the whole text. Note that specifying ranges does not make much
    sense with translatable attributes. Use markup embedded in the translatable
    content instead.

    # Accessibility

    `GtkEntry` uses the [enum@Gtk.AccessibleRole.text_box] role.
    """

    class Props(Widget.Props):
        activates_default: bool  # [activates-default]: changed because contained invalid characters
        attributes: Pango.AttrList | None
        buffer: EntryBuffer | None
        completion: EntryCompletion | None
        enable_emoji_completion: bool  # [enable-emoji-completion]: changed because contained invalid characters
        extra_menu: Gio.MenuModel | None  # [extra-menu]: changed because contained invalid characters
        has_frame: bool  # [has-frame]: changed because contained invalid characters
        im_module: str  # [im-module]: changed because contained invalid characters
        input_hints: InputHints  # [input-hints]: changed because contained invalid characters
        input_purpose: InputPurpose  # [input-purpose]: changed because contained invalid characters
        invisible_char: int  # [invisible-char]: changed because contained invalid characters
        invisible_char_set: bool  # [invisible-char-set]: changed because contained invalid characters
        max_length: int  # [max-length]: changed because contained invalid characters
        overwrite_mode: bool  # [overwrite-mode]: changed because contained invalid characters
        placeholder_text: str  # [placeholder-text]: changed because contained invalid characters
        primary_icon_activatable: bool  # [primary-icon-activatable]: changed because contained invalid characters
        primary_icon_gicon: Gio.Icon | None  # [primary-icon-gicon]: changed because contained invalid characters
        primary_icon_name: str  # [primary-icon-name]: changed because contained invalid characters
        primary_icon_paintable: (
            Gdk.Paintable | None
        )  # [primary-icon-paintable]: changed because contained invalid characters
        primary_icon_sensitive: bool  # [primary-icon-sensitive]: changed because contained invalid characters
        primary_icon_storage_type: (
            ImageType  # [primary-icon-storage-type]: changed because contained invalid characters
        )
        primary_icon_tooltip_markup: str  # [primary-icon-tooltip-markup]: changed because contained invalid characters
        primary_icon_tooltip_text: str  # [primary-icon-tooltip-text]: changed because contained invalid characters
        progress_fraction: float  # [progress-fraction]: changed because contained invalid characters
        progress_pulse_step: float  # [progress-pulse-step]: changed because contained invalid characters
        scroll_offset: int  # [scroll-offset]: changed because contained invalid characters
        secondary_icon_activatable: bool  # [secondary-icon-activatable]: changed because contained invalid characters
        secondary_icon_gicon: Gio.Icon | None  # [secondary-icon-gicon]: changed because contained invalid characters
        secondary_icon_name: str  # [secondary-icon-name]: changed because contained invalid characters
        secondary_icon_paintable: (
            Gdk.Paintable | None
        )  # [secondary-icon-paintable]: changed because contained invalid characters
        secondary_icon_sensitive: bool  # [secondary-icon-sensitive]: changed because contained invalid characters
        secondary_icon_storage_type: (
            ImageType  # [secondary-icon-storage-type]: changed because contained invalid characters
        )
        secondary_icon_tooltip_markup: (
            str  # [secondary-icon-tooltip-markup]: changed because contained invalid characters
        )
        secondary_icon_tooltip_text: str  # [secondary-icon-tooltip-text]: changed because contained invalid characters
        show_emoji_icon: bool  # [show-emoji-icon]: changed because contained invalid characters
        tabs: Pango.TabArray | None
        text_length: int  # [text-length]: changed because contained invalid characters
        truncate_multiline: bool  # [truncate-multiline]: changed because contained invalid characters
        visibility: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        activates_default: bool = ...,
        attributes: Pango.AttrList | None = ...,
        buffer: EntryBuffer | None = ...,
        completion: EntryCompletion | None = ...,
        enable_emoji_completion: bool = ...,
        extra_menu: Gio.MenuModel | None = ...,
        has_frame: bool = ...,
        im_module: str = ...,
        input_hints: InputHints = ...,
        input_purpose: InputPurpose = ...,
        invisible_char: int = ...,
        invisible_char_set: bool = ...,
        max_length: int = ...,
        overwrite_mode: bool = ...,
        placeholder_text: str = ...,
        primary_icon_activatable: bool = ...,
        primary_icon_gicon: Gio.Icon | None = ...,
        primary_icon_name: str = ...,
        primary_icon_paintable: Gdk.Paintable | None = ...,
        primary_icon_sensitive: bool = ...,
        primary_icon_tooltip_markup: str = ...,
        primary_icon_tooltip_text: str = ...,
        progress_fraction: float = ...,
        progress_pulse_step: float = ...,
        secondary_icon_activatable: bool = ...,
        secondary_icon_gicon: Gio.Icon | None = ...,
        secondary_icon_name: str = ...,
        secondary_icon_paintable: Gdk.Paintable | None = ...,
        secondary_icon_sensitive: bool = ...,
        secondary_icon_tooltip_markup: str = ...,
        secondary_icon_tooltip_text: str = ...,
        show_emoji_icon: bool = ...,
        tabs: Pango.TabArray | None = ...,
        truncate_multiline: bool = ...,
        visibility: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_activates_default(self) -> bool: ...
    def get_alignment(self) -> float: ...
    @builtins.property
    def get_attributes(self) -> Pango.AttrList | None: ...
    @builtins.property
    def get_buffer(self) -> EntryBuffer: ...
    @deprecated("deprecated")
    @builtins.property
    def get_completion(self) -> EntryCompletion | None: ...
    def get_current_icon_drag_source(self) -> int: ...
    @builtins.property
    def get_extra_menu(self) -> Gio.MenuModel | None: ...
    @builtins.property
    def get_has_frame(self) -> bool: ...
    def get_icon_activatable(self, icon_pos: EntryIconPosition) -> bool: ...
    def get_icon_area(self, icon_pos: EntryIconPosition) -> Gdk.Rectangle: ...
    def get_icon_at_pos(self, x: int, y: int) -> int: ...
    def get_icon_gicon(self, icon_pos: EntryIconPosition) -> Gio.Icon | None: ...
    def get_icon_name(self, icon_pos: EntryIconPosition) -> str | None: ...
    def get_icon_paintable(self, icon_pos: EntryIconPosition) -> Gdk.Paintable | None: ...
    def get_icon_sensitive(self, icon_pos: EntryIconPosition) -> bool: ...
    def get_icon_storage_type(self, icon_pos: EntryIconPosition) -> ImageType: ...
    def get_icon_tooltip_markup(self, icon_pos: EntryIconPosition) -> str | None: ...
    def get_icon_tooltip_text(self, icon_pos: EntryIconPosition) -> str | None: ...
    @builtins.property
    def get_input_hints(self) -> InputHints: ...
    @builtins.property
    def get_input_purpose(self) -> InputPurpose: ...
    @builtins.property
    def get_invisible_char(self) -> str: ...
    @builtins.property
    def get_max_length(self) -> int: ...
    @builtins.property
    def get_overwrite_mode(self) -> bool: ...
    @builtins.property
    def get_placeholder_text(self) -> str | None: ...
    @builtins.property
    def get_progress_fraction(self) -> float: ...
    @builtins.property
    def get_progress_pulse_step(self) -> float: ...
    @builtins.property
    def get_tabs(self) -> Pango.TabArray | None: ...
    @builtins.property
    def get_text_length(self) -> int: ...
    @builtins.property
    def get_visibility(self) -> bool: ...
    def grab_focus_without_selecting(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_with_buffer(cls, buffer: EntryBuffer) -> Widget: ...
    def progress_pulse(self) -> None: ...
    def reset_im_context(self) -> None: ...
    def set_activates_default(self, setting: bool) -> None: ...
    def set_alignment(self, xalign: float) -> None: ...
    def set_attributes(self, attrs: Pango.AttrList) -> None: ...
    def set_buffer(self, buffer: EntryBuffer) -> None: ...
    @deprecated("deprecated")
    def set_completion(self, completion: EntryCompletion | None = None) -> None: ...
    def set_extra_menu(self, model: Gio.MenuModel | None = None) -> None: ...
    def set_has_frame(self, setting: bool) -> None: ...
    def set_icon_activatable(self, icon_pos: EntryIconPosition, activatable: bool) -> None: ...
    def set_icon_drag_source(
        self, icon_pos: EntryIconPosition, provider: Gdk.ContentProvider, actions: Gdk.DragAction
    ) -> None: ...
    def set_icon_from_gicon(self, icon_pos: EntryIconPosition, icon: Gio.Icon | None = None) -> None: ...
    def set_icon_from_icon_name(self, icon_pos: EntryIconPosition, icon_name: str | None = None) -> None: ...
    def set_icon_from_paintable(self, icon_pos: EntryIconPosition, paintable: Gdk.Paintable | None = None) -> None: ...
    def set_icon_sensitive(self, icon_pos: EntryIconPosition, sensitive: bool) -> None: ...
    def set_icon_tooltip_markup(self, icon_pos: EntryIconPosition, tooltip: str | None = None) -> None: ...
    def set_icon_tooltip_text(self, icon_pos: EntryIconPosition, tooltip: str | None = None) -> None: ...
    def set_input_hints(self, hints: InputHints) -> None: ...
    def set_input_purpose(self, purpose: InputPurpose) -> None: ...
    def set_invisible_char(self, ch: str) -> None: ...
    def set_max_length(self, max: int) -> None: ...
    def set_overwrite_mode(self, overwrite: bool) -> None: ...
    def set_placeholder_text(self, text: str | None = None) -> None: ...
    def set_progress_fraction(self, fraction: float) -> None: ...
    def set_progress_pulse_step(self, fraction: float) -> None: ...
    def set_tabs(self, tabs: Pango.TabArray | None = None) -> None: ...
    def set_visibility(self, visible: bool) -> None: ...
    def unset_invisible_char(self) -> None: ...

    # python methods (overrides?)
    def do_activate(
        self,
    ) -> None:
        """
        activate(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["icon-press"],
        handler: typing.Callable[[typing_extensions.Self, EntryIconPosition], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["icon-release"],
        handler: typing.Callable[[typing_extensions.Self, EntryIconPosition], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activates_default"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::attributes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::completion"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_emoji_completion"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::extra_menu"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_frame"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::im_module"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_hints"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_purpose"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::invisible_char"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::invisible_char_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_length"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::overwrite_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::placeholder_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_icon_activatable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_icon_gicon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_icon_paintable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_icon_sensitive"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_icon_storage_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_icon_tooltip_markup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary_icon_tooltip_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::progress_fraction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::progress_pulse_step"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scroll_offset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_icon_activatable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_icon_gicon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_icon_paintable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_icon_sensitive"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_icon_storage_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_icon_tooltip_markup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_icon_tooltip_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_emoji_icon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tabs"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_length"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::truncate_multiline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visibility"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EntryBuffer(GObject.Object):
    """
    Holds the text that is displayed in a single-line text entry widget.

    A single `GtkEntryBuffer` object can be shared by multiple widgets
    which will then share the same text content, but not the cursor
    position, visibility attributes, icon etc.

    `GtkEntryBuffer` may be derived from. Such a derived class might allow
    text to be stored in an alternate location, such as non-pageable memory,
    useful in the case of important passwords. Or a derived class could
    integrate with an application’s concept of undo/redo.
    """

    class Props(GObject.Object.Props):
        length: int
        max_length: int  # [max-length]: changed because contained invalid characters
        text: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, max_length: int = ..., text: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def delete_text(self, position: int, n_chars: int) -> int: ...
    def emit_deleted_text(self, position: int, n_chars: int) -> None: ...
    def emit_inserted_text(self, position: int, chars: str, n_chars: int) -> None: ...
    def get_bytes(self) -> int: ...
    @builtins.property
    def get_length(self) -> int: ...
    @builtins.property
    def get_max_length(self) -> int: ...
    @builtins.property
    def get_text(self) -> str: ...
    def insert_text(self, position: int, chars: str, n_chars: int) -> int: ...
    @classmethod
    def new(cls, initial_chars: str | None, n_initial_chars: int) -> EntryBuffer: ...
    def set_max_length(self, max_length: int) -> None: ...
    def set_text(self, chars: str, n_chars: int) -> None: ...

    # python methods (overrides?)
    def do_delete_text(
        self,
        position: int,
        n_chars: int,
    ) -> int:
        """
        delete_text(self, position:int, n_chars:int) -> int
        """
    def do_deleted_text(
        self,
        position: int,
        n_chars: int,
    ) -> None:
        """
        deleted_text(self, position:int, n_chars:int)
        """
    def do_get_length(
        self,
    ) -> int:
        """
        get_length(self) -> int
        """
    def do_get_text(
        self,
        n_bytes: int,
    ) -> str:
        """
        get_text(self, n_bytes:int) -> str
        """
    def do_insert_text(
        self,
        position: int,
        chars: str,
        n_chars: int,
    ) -> int:
        """
        insert_text(self, position:int, chars:str, n_chars:int) -> int
        """
    def do_inserted_text(
        self,
        position: int,
        chars: str,
        n_chars: int,
    ) -> None:
        """
        inserted_text(self, position:int, chars:str, n_chars:int)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["deleted-text"],
        handler: typing.Callable[[typing_extensions.Self, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["inserted-text"],
        handler: typing.Callable[[typing_extensions.Self, int, str, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::length"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_length"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EntryBufferClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def delete_text(self) -> delete_textEntryBufferClassCB: ...
    @builtins.property
    def deleted_text(self) -> deleted_textEntryBufferClassCB: ...
    @builtins.property
    def get_length(self) -> get_lengthEntryBufferClassCB: ...
    @builtins.property
    def get_text(self) -> get_textEntryBufferClassCB: ...
    @builtins.property
    def insert_text(self) -> insert_textEntryBufferClassCB: ...
    @builtins.property
    def inserted_text(self) -> inserted_textEntryBufferClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EntryClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate(self) -> activateEntryClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EntryCompletion(GObject.Object):
    """
    `GtkEntryCompletion` is an auxiliary object to provide completion functionality
    for `GtkEntry`.

    It implements the [iface@Gtk.CellLayout] interface, to allow the user
    to add extra cells to the `GtkTreeView` with completion matches.

    “Completion functionality” means that when the user modifies the text
    in the entry, `GtkEntryCompletion` checks which rows in the model match
    the current content of the entry, and displays a list of matches.
    By default, the matching is done by comparing the entry text
    case-insensitively against the text column of the model (see
    [method@Gtk.EntryCompletion.set_text_column]), but this can be overridden
    with a custom match function (see [method@Gtk.EntryCompletion.set_match_func]).

    When the user selects a completion, the content of the entry is
    updated. By default, the content of the entry is replaced by the
    text column of the model, but this can be overridden by connecting
    to the [signal@Gtk.EntryCompletion::match-selected] signal and updating the
    entry in the signal handler. Note that you should return %TRUE from
    the signal handler to suppress the default behaviour.

    To add completion functionality to an entry, use
    [method@Gtk.Entry.set_completion].

    `GtkEntryCompletion` uses a [class@Gtk.TreeModelFilter] model to
    represent the subset of the entire model that is currently matching.
    While the `GtkEntryCompletion` signals
    [signal@Gtk.EntryCompletion::match-selected] and
    [signal@Gtk.EntryCompletion::cursor-on-match] take the original model
    and an iter pointing to that model as arguments, other callbacks and
    signals (such as `GtkCellLayoutDataFunc` or
    [signal@Gtk.CellArea::apply-attributes)]
    will generally take the filter model as argument. As long as you are
    only calling [method@Gtk.TreeModel.get], this will make no difference to
    you. If for some reason, you need the original model, use
    [method@Gtk.TreeModelFilter.get_model]. Don’t forget to use
    [method@Gtk.TreeModelFilter.convert_iter_to_child_iter] to obtain a
    matching iter.
    """

    class Props(GObject.Object.Props):
        cell_area: CellArea | None  # [cell-area]: changed because contained invalid characters
        inline_completion: bool  # [inline-completion]: changed because contained invalid characters
        inline_selection: bool  # [inline-selection]: changed because contained invalid characters
        minimum_key_length: int  # [minimum-key-length]: changed because contained invalid characters
        model: TreeModel | None
        popup_completion: bool  # [popup-completion]: changed because contained invalid characters
        popup_set_width: bool  # [popup-set-width]: changed because contained invalid characters
        popup_single_match: bool  # [popup-single-match]: changed because contained invalid characters
        text_column: int  # [text-column]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        cell_area: CellArea | None = ...,
        inline_completion: bool = ...,
        inline_selection: bool = ...,
        minimum_key_length: int = ...,
        model: TreeModel | None = ...,
        popup_completion: bool = ...,
        popup_set_width: bool = ...,
        popup_single_match: bool = ...,
        text_column: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def complete(self) -> None: ...
    @deprecated("deprecated")
    def compute_prefix(self, key: str) -> str | None: ...
    @deprecated("deprecated")
    def get_completion_prefix(self) -> str | None: ...
    @deprecated("deprecated")
    def get_entry(self) -> Widget: ...
    @deprecated("deprecated")
    @builtins.property
    def get_inline_completion(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_inline_selection(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_minimum_key_length(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_model(self) -> TreeModel | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_popup_completion(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_popup_set_width(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_popup_single_match(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_text_column(self) -> int: ...
    @deprecated("deprecated")
    def insert_prefix(self) -> None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> EntryCompletion: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_area(cls, area: CellArea) -> EntryCompletion: ...
    @deprecated("deprecated")
    def set_inline_completion(self, inline_completion: bool) -> None: ...
    @deprecated("deprecated")
    def set_inline_selection(self, inline_selection: bool) -> None: ...
    @deprecated("deprecated")
    def set_match_func(
        self, func: EntryCompletionMatchFunc, func_data: object | None, func_notify: GLib.DestroyNotify
    ) -> None: ...
    @deprecated("deprecated")
    def set_minimum_key_length(self, length: int) -> None: ...
    @deprecated("deprecated")
    def set_model(self, model: TreeModel | None = None) -> None: ...
    @deprecated("deprecated")
    def set_popup_completion(self, popup_completion: bool) -> None: ...
    @deprecated("deprecated")
    def set_popup_set_width(self, popup_set_width: bool) -> None: ...
    @deprecated("deprecated")
    def set_popup_single_match(self, popup_single_match: bool) -> None: ...
    @deprecated("deprecated")
    def set_text_column(self, column: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["cursor-on-match"],
        handler: typing.Callable[[typing_extensions.Self, TreeModel, TreeIter], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["insert-prefix"],
        handler: typing.Callable[[typing_extensions.Self, str], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["match-selected"],
        handler: typing.Callable[[typing_extensions.Self, TreeModel, TreeIter], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["no-matches"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cell_area"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inline_completion"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inline_selection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::minimum_key_length"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::popup_completion"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::popup_set_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::popup_single_match"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EventController(GObject.Object):
    """
    The base class for event controllers.

    These are ancillary objects associated to widgets, which react
    to `GdkEvents`, and possibly trigger actions as a consequence.

    Event controllers are added to a widget with
    [method@Gtk.Widget.add_controller]. It is rarely necessary to
    explicitly remove a controller with [method@Gtk.Widget.remove_controller].

    See the chapter on [input handling](input-handling.html) for
    an overview of the basic concepts, such as the capture and bubble
    phases of event propagation.
    """

    class Props(GObject.Object.Props):
        name: str
        propagation_limit: PropagationLimit  # [propagation-limit]: changed because contained invalid characters
        propagation_phase: PropagationPhase  # [propagation-phase]: changed because contained invalid characters
        widget: Widget | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, name: str = ..., propagation_limit: PropagationLimit = ..., propagation_phase: PropagationPhase = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_current_event(self) -> Gdk.Event | None: ...
    def get_current_event_device(self) -> Gdk.Device | None: ...
    def get_current_event_state(self) -> Gdk.ModifierType: ...
    def get_current_event_time(self) -> int: ...
    @builtins.property
    def get_name(self) -> str | None: ...
    @builtins.property
    def get_propagation_limit(self) -> PropagationLimit: ...
    @builtins.property
    def get_propagation_phase(self) -> PropagationPhase: ...
    @builtins.property
    def get_widget(self) -> Widget | None: ...
    def reset(self) -> None: ...
    def set_name(self, name: str | None = None) -> None: ...
    def set_propagation_limit(self, limit: PropagationLimit) -> None: ...
    def set_propagation_phase(self, phase: PropagationPhase) -> None: ...
    def set_static_name(self, name: str | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::propagation_limit"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::propagation_phase"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EventControllerClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EventControllerFocus(EventController):
    """
    Tracks keyboard focus.

    The event controller offers [signal@Gtk.EventControllerFocus::enter]
    and [signal@Gtk.EventControllerFocus::leave] signals, as well as
    [property@Gtk.EventControllerFocus:is-focus] and
    [property@Gtk.EventControllerFocus:contains-focus] properties
    which are updated to reflect focus changes inside the widget hierarchy
    that is rooted at the controllers widget.
    """

    class Props(EventController.Props):
        contains_focus: bool  # [contains-focus]: changed because contained invalid characters
        is_focus: bool  # [is-focus]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def contains_focus(self) -> bool: ...
    @builtins.property
    def is_focus(self) -> bool: ...
    @classmethod
    def new(cls) -> EventController: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["enter"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["leave"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::contains_focus"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_focus"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EventControllerFocusClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EventControllerKey(EventController):
    """
    Provides access to key events.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def forward(self, widget: Widget) -> bool: ...
    def get_group(self) -> int: ...
    def get_im_context(self) -> IMContext | None: ...
    @classmethod
    def new(cls) -> EventController: ...
    def set_im_context(self, im_context: IMContext | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["im-update"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["key-pressed"],
        handler: typing.Callable[[typing_extensions.Self, int, int, Gdk.ModifierType], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["key-released"],
        handler: typing.Callable[[typing_extensions.Self, int, int, Gdk.ModifierType], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["modifiers"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.ModifierType], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EventControllerKeyClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EventControllerLegacy(EventController):
    """
    Provides raw access to the event stream.

    It should only be used as a last resort if none of the other event
    controllers or gestures do the job.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> EventController: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["event"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Event], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EventControllerLegacyClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EventControllerMotion(EventController):
    """
    Tracks the pointer position.

    The event controller offers [signal@Gtk.EventControllerMotion::enter]
    and [signal@Gtk.EventControllerMotion::leave] signals, as well as
    [property@Gtk.EventControllerMotion:is-pointer] and
    [property@Gtk.EventControllerMotion:contains-pointer] properties
    which are updated to reflect changes in the pointer position as it
    moves over the widget.
    """

    class Props(EventController.Props):
        contains_pointer: bool  # [contains-pointer]: changed because contained invalid characters
        is_pointer: bool  # [is-pointer]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def contains_pointer(self) -> bool: ...
    @builtins.property
    def is_pointer(self) -> bool: ...
    @classmethod
    def new(cls) -> EventController: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["enter"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["leave"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["motion"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::contains_pointer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_pointer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EventControllerMotionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EventControllerScroll(EventController):
    """
    Handles scroll events.

    It is capable of handling both discrete and continuous scroll
    events from mice or touchpads, abstracting them both with the
    [signal@Gtk.EventControllerScroll::scroll] signal. Deltas in
    the discrete case are multiples of 1.

    In the case of continuous scroll events, `GtkEventControllerScroll`
    encloses all [signal@Gtk.EventControllerScroll::scroll] emissions
    between two [signal@Gtk.EventControllerScroll::scroll-begin] and
    [signal@Gtk.EventControllerScroll::scroll-end] signals.

    The behavior of the event controller can be modified by the flags
    given at creation time, or modified at a later point through
    [method@Gtk.EventControllerScroll.set_flags] (e.g. because the scrolling
    conditions of the widget changed).

    The controller can be set up to emit motion for either/both vertical
    and horizontal scroll events through %GTK_EVENT_CONTROLLER_SCROLL_VERTICAL,
    %GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL and %GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES.
    If any axis is disabled, the respective [signal@Gtk.EventControllerScroll::scroll]
    delta will be 0. Vertical scroll events will be translated to horizontal
    motion for the devices incapable of horizontal scrolling.

    The event controller can also be forced to emit discrete events on all
    devices through %GTK_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used
    to implement discrete actions triggered through scroll events (e.g.
    switching across combobox options).

    The %GTK_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
    [signal@Gtk.EventControllerScroll::decelerate] signal, emitted at the end
    of scrolling with two X/Y velocity arguments that are consistent with the
    motion that was received.
    """

    class Props(EventController.Props):
        flags: EventControllerScrollFlags

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, flags: EventControllerScrollFlags = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_flags(self) -> EventControllerScrollFlags: ...
    def get_unit(self) -> Gdk.ScrollUnit: ...
    @classmethod
    def new(cls, flags: EventControllerScrollFlags) -> EventController: ...
    def set_flags(self, flags: EventControllerScrollFlags) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["decelerate"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["scroll"],
        handler: typing.Callable[[typing_extensions.Self, float, float], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["scroll-begin"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["scroll-end"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EventControllerScrollClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EveryFilter(MultiFilter):
    """
    Matches an item when each of its filters matches.

    To add filters to a `GtkEveryFilter`, use [method@Gtk.MultiFilter.append].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> EveryFilter: ...

class EveryFilterClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Expander(Widget):
    """
    Allows the user to reveal or conceal a child widget.

    <picture>
      <source srcset="expander-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkExpander" src="expander.png">
    </picture>

    This is similar to the triangles used in a `GtkTreeView`.

    Normally you use an expander as you would use a frame; you create
    the child widget and use [method@Gtk.Expander.set_child] to add it
    to the expander. When the expander is toggled, it will take care of
    showing and hiding the child automatically.

    # Special Usage

    There are situations in which you may prefer to show and hide the
    expanded widget yourself, such as when you want to actually create
    the widget at expansion time. In this case, create a `GtkExpander`
    but do not add a child to it. The expander widget has an
    [property@Gtk.Expander:expanded] property which can be used to
    monitor its expansion state. You should watch this property with
    a signal connection as follows:

    ```c
    static void
    expander_callback (GObject    *object,
                       GParamSpec *param_spec,
                       gpointer    user_data)
    {
      GtkExpander *expander;

      expander = GTK_EXPANDER (object);

      if (gtk_expander_get_expanded (expander))
        {
          // Show or create widgets
        }
      else
        {
          // Hide or destroy widgets
        }
    }

    static void
    create_expander (void)
    {
      GtkWidget *expander = gtk_expander_new_with_mnemonic ("_More Options");
      g_signal_connect (expander, "notify::expanded",
                        G_CALLBACK (expander_callback), NULL);

      // ...
    }
    ```

    # GtkExpander as GtkBuildable

    The `GtkExpander` implementation of the `GtkBuildable` interface supports
    placing a child in the label position by specifying “label” as the
    “type” attribute of a `<child>` element. A normal content child can be
    specified without specifying a `<child>` type attribute.

    An example of a UI definition fragment with GtkExpander:

    ```xml
    <object class="GtkExpander">
      <child type="label">
        <object class="GtkLabel" id="expander-label"/>
      </child>
      <child>
        <object class="GtkEntry" id="expander-content"/>
      </child>
    </object>
    ```

    # CSS nodes

    ```
    expander-widget
    ╰── box
        ├── title
        │   ├── expander
        │   ╰── <label widget>
        ╰── <child>
    ```

    `GtkExpander` has a main node `expander-widget`, and subnode `box` containing
    the title and child widget. The box subnode `title` contains node `expander`,
    i.e. the expand/collapse arrow; then the label widget if any. The arrow of an
    expander that is showing its child gets the `:checked` pseudoclass set on it.

    # Accessibility

    `GtkExpander` uses the [enum@Gtk.AccessibleRole.button] role.
    """

    class Props(Widget.Props):
        child: Widget | None
        expanded: bool
        label: str
        label_widget: Widget | None  # [label-widget]: changed because contained invalid characters
        resize_toplevel: bool  # [resize-toplevel]: changed because contained invalid characters
        use_markup: bool  # [use-markup]: changed because contained invalid characters
        use_underline: bool  # [use-underline]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        child: Widget | None = ...,
        expanded: bool = ...,
        label: str = ...,
        label_widget: Widget | None = ...,
        resize_toplevel: bool = ...,
        use_markup: bool = ...,
        use_underline: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_expanded(self) -> bool: ...
    @builtins.property
    def get_label(self) -> str | None: ...
    @builtins.property
    def get_label_widget(self) -> Widget | None: ...
    @builtins.property
    def get_resize_toplevel(self) -> bool: ...
    @builtins.property
    def get_use_markup(self) -> bool: ...
    @builtins.property
    def get_use_underline(self) -> bool: ...
    @classmethod
    def new(cls, label: str | None = None) -> Widget: ...
    @classmethod
    def new_with_mnemonic(cls, label: str | None = None) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_expanded(self, expanded: bool) -> None: ...
    def set_label(self, label: str | None = None) -> None: ...
    def set_label_widget(self, label_widget: Widget | None = None) -> None: ...
    def set_resize_toplevel(self, resize_toplevel: bool) -> None: ...
    def set_use_markup(self, use_markup: bool) -> None: ...
    def set_use_underline(self, use_underline: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expanded"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::label_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resize_toplevel"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_markup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_underline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Expression(object):
    """
    Provides a way to describe references to values.

    An important aspect of expressions is that the value can be obtained
    from a source that is several steps away. For example, an expression
    may describe ‘the value of property A of `object1`, which is itself the
    value of a property of `object2`’. And `object1` may not even exist yet
    at the time that the expression is created. This is contrast to `GObject`
    property bindings, which can only create direct connections between
    the properties of two objects that must both exist for the duration
    of the binding.

    An expression needs to be "evaluated" to obtain the value that it currently
    refers to. An evaluation always happens in the context of a current object
    called `this` (it mirrors the behavior of object-oriented languages),
    which may or may not influence the result of the evaluation. Use
    [method@Gtk.Expression.evaluate] for evaluating an expression.

    Various methods for defining expressions exist, from simple constants via
    [ctor@Gtk.ConstantExpression.new] to looking up properties in a `GObject`
    (even recursively) via [ctor@Gtk.PropertyExpression.new] or providing
    custom functions to transform and combine expressions via
    [ctor@Gtk.ClosureExpression.new].

    Here is an example of a complex expression:

    ```c
      color_expr = gtk_property_expression_new (GTK_TYPE_LIST_ITEM,
                                                NULL, "item");
      expression = gtk_property_expression_new (GTK_TYPE_COLOR,
                                                color_expr, "name");
    ```

    when evaluated with `this` being a `GtkListItem`, it will obtain the
    "item" property from the `GtkListItem`, and then obtain the "name" property
    from the resulting object (which is assumed to be of type `GTK_TYPE_COLOR`).

    A more concise way to describe this would be

    ```
      this->item->name
    ```

    The most likely place where you will encounter expressions is in the context
    of list models and list widgets using them. For example, `GtkDropDown` is
    evaluating a `GtkExpression` to obtain strings from the items in its model
    that it can then use to match against the contents of its search entry.
    `GtkStringFilter` is using a `GtkExpression` for similar reasons.

    By default, expressions are not paying attention to changes and evaluation is
    just a snapshot of the current state at a given time. To get informed about
    changes, an expression needs to be "watched" via a [struct@Gtk.ExpressionWatch],
    which will cause a callback to be called whenever the value of the expression may
    have changed; [method@Gtk.Expression.watch] starts watching an expression, and
    [method@Gtk.ExpressionWatch.unwatch] stops.

    Watches can be created for automatically updating the property of an object,
    similar to GObject's `GBinding` mechanism, by using [method@Gtk.Expression.bind].

    ## GtkExpression in GObject properties

    In order to use a `GtkExpression` as a `GObject` property, you must use the
    [func@Gtk.param_spec_expression] when creating a `GParamSpec` to install in the
    `GObject` class being defined; for instance:

    ```c
    obj_props[PROP_EXPRESSION] =
      gtk_param_spec_expression ("expression",
                                 "Expression",
                                 "The expression used by the widget",
                                 G_PARAM_READWRITE |
                                 G_PARAM_STATIC_STRINGS |
                                 G_PARAM_EXPLICIT_NOTIFY);
    ```

    When implementing the `GObjectClass.set_property` and `GObjectClass.get_property`
    virtual functions, you must use [func@Gtk.value_get_expression], to retrieve the
    stored `GtkExpression` from the `GValue` container, and [func@Gtk.value_set_expression],
    to store the `GtkExpression` into the `GValue`; for instance:

    ```c
      // in set_property()...
      case PROP_EXPRESSION:
        foo_widget_set_expression (foo, gtk_value_get_expression (value));
        break;

      // in get_property()...
      case PROP_EXPRESSION:
        gtk_value_set_expression (value, foo->expression);
        break;
    ```

    ## GtkExpression in .ui files

    `GtkBuilder` has support for creating expressions. The syntax here can be used where
    a `GtkExpression` object is needed like in a `<property>` tag for an expression
    property, or in a `<binding name="property">` tag to bind a property to an expression.

    To create a property expression, use the `<lookup>` element. It can have a `type`
    attribute to specify the object type, and a `name` attribute to specify the property
    to look up. The content of `<lookup>` can either be a string that specifies the name
    of the object to use, an element specifying an expression to provide an object, or
    empty to use the `this` object.

    Example:

    ```xml
      <lookup name='search'>string_filter</lookup>
    ```

    Since the `<lookup>` element creates an expression and its element content can
    itself be an expression, this means that `<lookup>` tags can also be nested.
    This is a common idiom when dealing with `GtkListItem`s. See
    [class@Gtk.BuilderListItemFactory] for an example of this technique.

    To create a constant expression, use the `<constant>` element. If the type attribute
    is specified, the element content is interpreted as a value of that type. Otherwise,
    it is assumed to be an object. For instance:

    ```xml
      <constant>string_filter</constant>
      <constant type='gchararray'>Hello, world</constant>
    ```

    To create a closure expression, use the `<closure>` element. The `function`
    attribute specifies what function to use for the closure, and the `type`
    attribute specifies its return type. The content of the element contains the
    expressions for the parameters. For instance:

    ```xml
      <closure type='gchararray' function='combine_args_somehow'>
        <constant type='gchararray'>File size:</constant>
        <lookup type='GFile' name='size'>myfile</lookup>
      </closure>
    ```

    To create a property binding, use the `<binding>` element in place of where a
    `<property>` tag would ordinarily be used. The `name` and `object` attributes are
    supported. The `name` attribute is required, and pertains to the applicable property
    name. The `object` attribute is optional. If provided, it will use the specified object
    as the `this` object when the expression is evaluated. Here is an example in which the
    `label` property of a `GtkLabel` is bound to the `string` property of another arbitrary
    object:

    ```xml
      <object class='GtkLabel'>
        <binding name='label'>
          <lookup name='string'>some_other_object</lookup>
        </binding>
      </object>
    ```
    """

    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def bind(self, target: GObject.Object, property: str, this_: GObject.Object | None = None) -> ExpressionWatch: ...
    def evaluate(self, this_: GObject.Object | None, value: GObject.Value) -> bool: ...
    def get_value_type(self) -> GObject.GType: ...
    def is_static(self) -> bool: ...
    def ref(self) -> Expression: ...
    def unref(self) -> None: ...
    def watch(
        self,
        this_: GObject.Object | None,
        notify: ExpressionNotify,
        user_data: object | None,
        user_destroy: GLib.DestroyNotify,
    ) -> ExpressionWatch: ...

class ExpressionWatch(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def evaluate(self, value: GObject.Value) -> bool: ...
    def ref(self) -> ExpressionWatch: ...
    def unref(self) -> None: ...
    def unwatch(self) -> None: ...

class FileChooser(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        action: FileChooserAction
        create_folders: bool  # [create-folders]: changed because contained invalid characters
        filter: FileFilter | None
        filters: Gio.ListModel | None
        select_multiple: bool  # [select-multiple]: changed because contained invalid characters
        shortcut_folders: Gio.ListModel | None  # [shortcut-folders]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        action: FileChooserAction = ...,
        create_folders: bool = ...,
        filter: FileFilter | None = ...,
        select_multiple: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_choice(
        self, id: str, label: str, options: list | None = None, option_labels: list | None = None
    ) -> None: ...
    @deprecated("deprecated")
    def add_filter(self, filter: FileFilter) -> None: ...
    @deprecated("deprecated")
    def add_shortcut_folder(self, folder: Gio.File) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_action(self) -> FileChooserAction: ...
    @deprecated("deprecated")
    def get_choice(self, id: str) -> str | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_create_folders(self) -> bool: ...
    @deprecated("deprecated")
    def get_current_folder(self) -> Gio.File | None: ...
    @deprecated("deprecated")
    def get_current_name(self) -> str | None: ...
    @deprecated("deprecated")
    def get_file(self) -> Gio.File | None: ...
    @deprecated("deprecated")
    def get_files(self) -> Gio.ListModel: ...
    @deprecated("deprecated")
    @builtins.property
    def get_filter(self) -> FileFilter | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_filters(self) -> Gio.ListModel: ...
    @deprecated("deprecated")
    @builtins.property
    def get_select_multiple(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_shortcut_folders(self) -> Gio.ListModel: ...
    @deprecated("deprecated")
    def remove_choice(self, id: str) -> None: ...
    @deprecated("deprecated")
    def remove_filter(self, filter: FileFilter) -> None: ...
    @deprecated("deprecated")
    def remove_shortcut_folder(self, folder: Gio.File) -> bool: ...
    @deprecated("deprecated")
    def set_action(self, action: FileChooserAction) -> None: ...
    @deprecated("deprecated")
    def set_choice(self, id: str, option: str) -> None: ...
    @deprecated("deprecated")
    def set_create_folders(self, create_folders: bool) -> None: ...
    @deprecated("deprecated")
    def set_current_folder(self, file: Gio.File | None = None) -> bool: ...
    @deprecated("deprecated")
    def set_current_name(self, name: str) -> None: ...
    @deprecated("deprecated")
    def set_file(self, file: Gio.File) -> bool: ...
    @deprecated("deprecated")
    def set_filter(self, filter: FileFilter) -> None: ...
    @deprecated("deprecated")
    def set_select_multiple(self, select_multiple: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::action"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::create_folders"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::filter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::filters"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::select_multiple"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::shortcut_folders"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FileChooserDialog(Dialog):
    """
    `GtkFileChooserDialog` is a dialog suitable for use with
    “File Open” or “File Save” commands.

    ![An example GtkFileChooserDialog](filechooser.png)

    This widget works by putting a [class@Gtk.FileChooserWidget]
    inside a [class@Gtk.Dialog]. It exposes the [iface@Gtk.FileChooser]
    interface, so you can use all of the [iface@Gtk.FileChooser] functions
    on the file chooser dialog as well as those for [class@Gtk.Dialog].

    Note that `GtkFileChooserDialog` does not have any methods of its
    own. Instead, you should use the functions that work on a
    [iface@Gtk.FileChooser].

    If you want to integrate well with the platform you should use the
    [class@Gtk.FileChooserNative] API, which will use a platform-specific
    dialog if available and fall back to `GtkFileChooserDialog`
    otherwise.

    ## Typical usage

    In the simplest of cases, you can the following code to use
    `GtkFileChooserDialog` to select a file for opening:

    ```c
    static void
    on_open_response (GtkDialog *dialog,
                      int        response)
    {
      if (response == GTK_RESPONSE_ACCEPT)
        {
          GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);

          g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);

          open_file (file);
        }

      gtk_window_destroy (GTK_WINDOW (dialog));
    }

      // ...
      GtkWidget *dialog;
      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;

      dialog = gtk_file_chooser_dialog_new ("Open File",
                                            parent_window,
                                            action,
                                            _("_Cancel"),
                                            GTK_RESPONSE_CANCEL,
                                            _("_Open"),
                                            GTK_RESPONSE_ACCEPT,
                                            NULL);

      gtk_window_present (GTK_WINDOW (dialog));

      g_signal_connect (dialog, "response",
                        G_CALLBACK (on_open_response),
                        NULL);
    ```

    To use a dialog for saving, you can use this:

    ```c
    static void
    on_save_response (GtkDialog *dialog,
                      int        response)
    {
      if (response == GTK_RESPONSE_ACCEPT)
        {
          GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);

          g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);

          save_to_file (file);
        }

      gtk_window_destroy (GTK_WINDOW (dialog));
    }

      // ...
      GtkWidget *dialog;
      GtkFileChooser *chooser;
      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;

      dialog = gtk_file_chooser_dialog_new ("Save File",
                                            parent_window,
                                            action,
                                            _("_Cancel"),
                                            GTK_RESPONSE_CANCEL,
                                            _("_Save"),
                                            GTK_RESPONSE_ACCEPT,
                                            NULL);
      chooser = GTK_FILE_CHOOSER (dialog);

      if (user_edited_a_new_document)
        gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
      else
        gtk_file_chooser_set_file (chooser, existing_filename);

      gtk_window_present (GTK_WINDOW (dialog));

      g_signal_connect (dialog, "response",
                        G_CALLBACK (on_save_response),
                        NULL);
    ```

    ## Setting up a file chooser dialog

    There are various cases in which you may need to use a `GtkFileChooserDialog`:

    - To select a file for opening, use %GTK_FILE_CHOOSER_ACTION_OPEN.

    - To save a file for the first time, use %GTK_FILE_CHOOSER_ACTION_SAVE,
      and suggest a name such as “Untitled” with
      [method@Gtk.FileChooser.set_current_name].

    - To save a file under a different name, use %GTK_FILE_CHOOSER_ACTION_SAVE,
      and set the existing file with [method@Gtk.FileChooser.set_file].

    - To choose a folder instead of a filem use %GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.

    In general, you should only cause the file chooser to show a specific
    folder when it is appropriate to use [method@Gtk.FileChooser.set_file],
    i.e. when you are doing a “Save As” command and you already have a file
    saved somewhere.

    ## Response Codes

    `GtkFileChooserDialog` inherits from [class@Gtk.Dialog], so buttons that
    go in its action area have response codes such as %GTK_RESPONSE_ACCEPT and
    %GTK_RESPONSE_CANCEL. For example, you could call
    [ctor@Gtk.FileChooserDialog.new] as follows:

    ```c
    GtkWidget *dialog;
    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;

    dialog = gtk_file_chooser_dialog_new ("Open File",
                                          parent_window,
                                          action,
                                          _("_Cancel"),
                                          GTK_RESPONSE_CANCEL,
                                          _("_Open"),
                                          GTK_RESPONSE_ACCEPT,
                                          NULL);
    ```

    This will create buttons for “Cancel” and “Open” that use predefined
    response identifiers from [enum@Gtk.ResponseType].  For most dialog
    boxes you can use your own custom response codes rather than the
    ones in [enum@Gtk.ResponseType], but `GtkFileChooserDialog` assumes that
    its “accept”-type action, e.g. an “Open” or “Save” button,
    will have one of the following response codes:

    - %GTK_RESPONSE_ACCEPT
    - %GTK_RESPONSE_OK
    - %GTK_RESPONSE_YES
    - %GTK_RESPONSE_APPLY

    This is because `GtkFileChooserDialog` must intercept responses and switch
    to folders if appropriate, rather than letting the dialog terminate — the
    implementation uses these known response codes to know which responses can
    be blocked if appropriate.

    To summarize, make sure you use a predefined response code
    when you use `GtkFileChooserDialog` to ensure proper operation.

    ## CSS nodes

    `GtkFileChooserDialog` has a single CSS node with the name `window` and style
    class `.filechooser`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileChooserNative(NativeDialog):
    """
    `GtkFileChooserNative` is an abstraction of a dialog suitable
    for use with “File Open” or “File Save as” commands.

    By default, this just uses a `GtkFileChooserDialog` to implement
    the actual dialog. However, on some platforms, such as Windows and
    macOS, the native platform file chooser is used instead. When the
    application is running in a sandboxed environment without direct
    filesystem access (such as Flatpak), `GtkFileChooserNative` may call
    the proper APIs (portals) to let the user choose a file and make it
    available to the application.

    While the API of `GtkFileChooserNative` closely mirrors `GtkFileChooserDialog`,
    the main difference is that there is no access to any `GtkWindow` or `GtkWidget`
    for the dialog. This is required, as there may not be one in the case of a
    platform native dialog.

    Showing, hiding and running the dialog is handled by the
    [class@Gtk.NativeDialog] functions.

    Note that unlike `GtkFileChooserDialog`, `GtkFileChooserNative` objects
    are not toplevel widgets, and GTK does not keep them alive. It is your
    responsibility to keep a reference until you are done with the
    object.

    ## Typical usage

    In the simplest of cases, you can the following code to use
    `GtkFileChooserNative` to select a file for opening:

    ```c
    static void
    on_response (GtkNativeDialog *native,
                 int              response)
    {
      if (response == GTK_RESPONSE_ACCEPT)
        {
          GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
          GFile *file = gtk_file_chooser_get_file (chooser);

          open_file (file);

          g_object_unref (file);
        }

      g_object_unref (native);
    }

      // ...
      GtkFileChooserNative *native;
      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;

      native = gtk_file_chooser_native_new ("Open File",
                                            parent_window,
                                            action,
                                            "_Open",
                                            "_Cancel");

      g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
      gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
    ```

    To use a `GtkFileChooserNative` for saving, you can use this:

    ```c
    static void
    on_response (GtkNativeDialog *native,
                 int              response)
    {
      if (response == GTK_RESPONSE_ACCEPT)
        {
          GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
          GFile *file = gtk_file_chooser_get_file (chooser);

          save_to_file (file);

          g_object_unref (file);
        }

      g_object_unref (native);
    }

      // ...
      GtkFileChooserNative *native;
      GtkFileChooser *chooser;
      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;

      native = gtk_file_chooser_native_new ("Save File",
                                            parent_window,
                                            action,
                                            "_Save",
                                            "_Cancel");
      chooser = GTK_FILE_CHOOSER (native);

      if (user_edited_a_new_document)
        gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
      else
        gtk_file_chooser_set_file (chooser, existing_file, NULL);

      g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
      gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
    ```

    For more information on how to best set up a file dialog,
    see the [class@Gtk.FileChooserDialog] documentation.

    ## Response Codes

    `GtkFileChooserNative` inherits from [class@Gtk.NativeDialog],
    which means it will return %GTK_RESPONSE_ACCEPT if the user accepted,
    and %GTK_RESPONSE_CANCEL if he pressed cancel. It can also return
    %GTK_RESPONSE_DELETE_EVENT if the window was unexpectedly closed.

    ## Differences from `GtkFileChooserDialog`

    There are a few things in the [iface@Gtk.FileChooser] interface that
    are not possible to use with `GtkFileChooserNative`, as such use would
    prohibit the use of a native dialog.

    No operations that change the dialog work while the dialog is visible.
    Set all the properties that are required before showing the dialog.

    ## Win32 details

    On windows the `IFileDialog` implementation (added in Windows Vista) is
    used. It supports many of the features that `GtkFileChooser` has, but
    there are some things it does not handle:

    * Any [class@Gtk.FileFilter] added using a mimetype

    If any of these features are used the regular `GtkFileChooserDialog`
    will be used in place of the native one.

    ## Portal details

    When the `org.freedesktop.portal.FileChooser` portal is available on
    the session bus, it is used to bring up an out-of-process file chooser.
    Depending on the kind of session the application is running in, this may
    or may not be a GTK file chooser.

    ## macOS details

    On macOS the `NSSavePanel` and `NSOpenPanel` classes are used to provide
    native file chooser dialogs. Some features provided by `GtkFileChooser`
    are not supported:

    * Shortcut folders.
    """

    class Props(NativeDialog.Props):
        accept_label: str  # [accept-label]: changed because contained invalid characters
        cancel_label: str  # [cancel-label]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, accept_label: str = ..., cancel_label: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_accept_label(self) -> str | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_cancel_label(self) -> str | None: ...
    @deprecated("deprecated")
    @classmethod
    def new(
        cls,
        title: str | None,
        parent: Window | None,
        action: FileChooserAction,
        accept_label: str | None = None,
        cancel_label: str | None = None,
    ) -> FileChooserNative: ...
    @deprecated("deprecated")
    def set_accept_label(self, accept_label: str | None = None) -> None: ...
    @deprecated("deprecated")
    def set_cancel_label(self, cancel_label: str | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accept_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cancel_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FileChooserNativeClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> NativeDialogClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileChooserWidget(Widget):
    """
    `GtkFileChooserWidget` is a widget for choosing files.

    It exposes the [iface@Gtk.FileChooser] interface, and you should
    use the methods of this interface to interact with the
    widget.

    # Shortcuts and Gestures

    `GtkFileChooserWidget` supports the following keyboard shortcuts:

    - <kbd>Shift</kbd>+<kbd>F10</kbd> or <kbd>Menu</kbd> opens the context menu.

    The following signals have default keybindings:

    - [signal@Gtk.FileChooserWidget::desktop-folder]
    - [signal@Gtk.FileChooserWidget::down-folder]
    - [signal@Gtk.FileChooserWidget::home-folder]
    - [signal@Gtk.FileChooserWidget::location-popup]
    - [signal@Gtk.FileChooserWidget::location-popup-on-paste]
    - [signal@Gtk.FileChooserWidget::location-toggle-popup]
    - [signal@Gtk.FileChooserWidget::places-shortcut]
    - [signal@Gtk.FileChooserWidget::quick-bookmark]
    - [signal@Gtk.FileChooserWidget::recent-shortcut]
    - [signal@Gtk.FileChooserWidget::search-shortcut]
    - [signal@Gtk.FileChooserWidget::show-hidden]
    - [signal@Gtk.FileChooserWidget::up-folder]

    # CSS nodes

    `GtkFileChooserWidget` has a single CSS node with name filechooser.
    """

    class Props(Widget.Props):
        search_mode: bool  # [search-mode]: changed because contained invalid characters
        show_time: bool  # [show-time]: changed because contained invalid characters
        subtitle: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, search_mode: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls, action: FileChooserAction) -> Widget: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["desktop-folder"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["down-folder"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["home-folder"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["location-popup"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["location-popup-on-paste"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["location-toggle-popup"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["places-shortcut"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["quick-bookmark"],
        handler: typing.Callable[[typing_extensions.Self, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["recent-shortcut"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["search-shortcut"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["show-hidden"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["up-folder"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::search_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::subtitle"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FileDialog(GObject.Object):
    """
    Asynchronous API to present a file chooser dialog.

    `GtkFileDialog` collects the arguments that are needed to present
    the dialog to the user, such as a title for the dialog and whether
    it should be modal.

    The dialog is shown with [method@Gtk.FileDialog.open],
    [method@Gtk.FileDialog.save], etc.
    """

    class Props(GObject.Object.Props):
        accept_label: str  # [accept-label]: changed because contained invalid characters
        default_filter: FileFilter | None  # [default-filter]: changed because contained invalid characters
        filters: Gio.ListModel | None
        initial_file: Gio.File | None  # [initial-file]: changed because contained invalid characters
        initial_folder: Gio.File | None  # [initial-folder]: changed because contained invalid characters
        initial_name: str  # [initial-name]: changed because contained invalid characters
        modal: bool
        title: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accept_label: str = ...,
        default_filter: FileFilter | None = ...,
        filters: Gio.ListModel | None = ...,
        initial_file: Gio.File | None = ...,
        initial_folder: Gio.File | None = ...,
        initial_name: str = ...,
        modal: bool = ...,
        title: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_accept_label(self) -> str | None: ...
    @builtins.property
    def get_default_filter(self) -> FileFilter | None: ...
    @builtins.property
    def get_filters(self) -> Gio.ListModel | None: ...
    @builtins.property
    def get_initial_file(self) -> Gio.File | None: ...
    @builtins.property
    def get_initial_folder(self) -> Gio.File | None: ...
    @builtins.property
    def get_initial_name(self) -> str | None: ...
    @builtins.property
    def get_modal(self) -> bool: ...
    @builtins.property
    def get_title(self) -> str: ...
    @classmethod
    def new(cls) -> FileDialog: ...
    def open(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def open_finish(self, result: Gio.AsyncResult) -> Gio.File | None: ...
    def open_multiple(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def open_multiple_finish(self, result: Gio.AsyncResult) -> Gio.ListModel | None: ...
    def open_multiple_text_files(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def open_multiple_text_files_finish(self, result: Gio.AsyncResult) -> tuple[Gio.ListModel | None, str]: ...
    def open_text_file(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def open_text_file_finish(self, result: Gio.AsyncResult) -> tuple[Gio.File | None, str]: ...
    def save(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def save_finish(self, result: Gio.AsyncResult) -> Gio.File | None: ...
    def save_text_file(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def save_text_file_finish(self, result: Gio.AsyncResult) -> tuple[Gio.File | None, str, str]: ...
    def select_folder(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def select_folder_finish(self, result: Gio.AsyncResult) -> Gio.File | None: ...
    def select_multiple_folders(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def select_multiple_folders_finish(self, result: Gio.AsyncResult) -> Gio.ListModel | None: ...
    def set_accept_label(self, accept_label: str | None = None) -> None: ...
    def set_default_filter(self, filter: FileFilter | None = None) -> None: ...
    def set_filters(self, filters: Gio.ListModel | None = None) -> None: ...
    def set_initial_file(self, file: Gio.File | None = None) -> None: ...
    def set_initial_folder(self, folder: Gio.File | None = None) -> None: ...
    def set_initial_name(self, name: str | None = None) -> None: ...
    def set_modal(self, modal: bool) -> None: ...
    def set_title(self, title: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accept_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_filter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::filters"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::initial_file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::initial_folder"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::initial_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FileDialogClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileFilter(Filter):
    """
    Filters files by name or mime type.

    `GtkFileFilter` can be used to restrict the files being shown in a
    file chooser. Files can be filtered based on their name (with
    [method@Gtk.FileFilter.add_pattern] or [method@Gtk.FileFilter.add_suffix])
    or on their mime type (with [method@Gtk.FileFilter.add_mime_type]).

    Filtering by mime types handles aliasing and subclassing of mime
    types; e.g. a filter for text/plain also matches a file with mime
    type application/rtf, since application/rtf is a subclass of
    text/plain. Note that `GtkFileFilter` allows wildcards for the
    subtype of a mime type, so you can e.g. filter for image/*.

    Normally, file filters are used by adding them to a file chooser
    (see [method@Gtk.FileDialog.set_filters]), but it is also possible to
    manually use a file filter on any [class@Gtk.FilterListModel] containing
    `GFileInfo` objects.

    # GtkFileFilter as GtkBuildable

    The `GtkFileFilter` implementation of the `GtkBuildable` interface
    supports adding rules using the `<mime-types>` and `<patterns>` and
    `<suffixes>` elements and listing the rules within. Specifying a
    `<mime-type>` or `<pattern>` or `<suffix>` has the same effect as
    as calling
    [method@Gtk.FileFilter.add_mime_type] or
    [method@Gtk.FileFilter.add_pattern] or
    [method@Gtk.FileFilter.add_suffix].

    An example of a UI definition fragment specifying `GtkFileFilter`
    rules:
    ```xml
    <object class="GtkFileFilter">
      <property name="name" translatable="yes">Text and Images</property>
      <mime-types>
        <mime-type>text/plain</mime-type>
        <mime-type>image/ *</mime-type>
      </mime-types>
      <patterns>
        <pattern>*.txt</pattern>
      </patterns>
      <suffixes>
        <suffix>png</suffix>
      </suffixes>
    </object>
    ```
    """

    class Props(Filter.Props):
        mime_types: list | None  # [mime-types]: changed because contained invalid characters
        name: str
        patterns: list | None
        suffixes: list | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, mime_types: list | None = ..., name: str = ..., patterns: list | None = ..., suffixes: list | None = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_mime_type(self, mime_type: str) -> None: ...
    def add_pattern(self, pattern: str) -> None: ...
    def add_pixbuf_formats(self) -> None: ...
    def add_suffix(self, suffix: str) -> None: ...
    def get_attributes(self) -> list: ...
    @builtins.property
    def get_name(self) -> str | None: ...
    @classmethod
    def new(cls) -> FileFilter: ...
    @classmethod
    def new_from_gvariant(cls, variant: GLib.Variant) -> FileFilter: ...
    def set_name(self, name: str | None = None) -> None: ...
    def to_gvariant(self) -> GLib.Variant: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mime_types"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::patterns"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::suffixes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FileLauncher(GObject.Object):
    """
    Asynchronous API to open a file with an application.

    `GtkFileLauncher` collects the arguments that are needed to open the file.

    Depending on system configuration, user preferences and available APIs, this
    may or may not show an app chooser dialog or launch the default application
    right away.

    The operation is started with the [method@Gtk.FileLauncher.launch] function.

    To launch uris that don't represent files, use [class@Gtk.UriLauncher].
    """

    class Props(GObject.Object.Props):
        always_ask: bool  # [always-ask]: changed because contained invalid characters
        file: Gio.File | None
        writable: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, always_ask: bool = ..., file: Gio.File | None = ..., writable: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_always_ask(self) -> bool: ...
    @builtins.property
    def get_file(self) -> Gio.File | None: ...
    @builtins.property
    def get_writable(self) -> bool: ...
    def launch(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def launch_finish(self, result: Gio.AsyncResult) -> bool: ...
    @classmethod
    def new(cls, file: Gio.File | None = None) -> FileLauncher: ...
    def open_containing_folder(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def open_containing_folder_finish(self, result: Gio.AsyncResult) -> bool: ...
    def set_always_ask(self, always_ask: bool) -> None: ...
    def set_file(self, file: Gio.File | None = None) -> None: ...
    def set_writable(self, writable: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::always_ask"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::writable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FileLauncherClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Filter(GObject.Object):
    """
    Describes the filtering to be performed by a [class@Gtk.FilterListModel].

    The model will use the filter to determine if it should include items
    or not by calling [method@Gtk.Filter.match] for each item and only
    keeping the ones that the function returns true for.

    Filters may change what items they match through their lifetime. In that
    case, they will emit the [signal@Gtk.Filter::changed] signal to notify
    that previous filter results are no longer valid and that items should
    be checked again via [method@Gtk.Filter.match].

    GTK provides various pre-made filter implementations for common filtering
    operations. These filters often include properties that can be linked to
    various widgets to easily allow searches.

    However, in particular for large lists or complex search methods, it is
    also possible to subclass `GtkFilter` and provide one's own filter.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def changed(self, change: FilterChange) -> None: ...
    def get_strictness(self) -> FilterMatch: ...
    def match(self, item: GObject.Object) -> bool: ...

    # python methods (overrides?)
    def do_get_strictness(
        self,
    ) -> FilterMatch:
        """
        get_strictness(self) -> Gtk.FilterMatch
        """
    def do_match(
        self,
        item: GObject.Object | None = None,
    ) -> bool:
        """
        match(self, item:GObject.Object=None) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["changed"],
        handler: typing.Callable[[typing_extensions.Self, FilterChange], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FilterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def get_strictness(self) -> get_strictnessFilterClassCB: ...
    @builtins.property
    def match(self) -> matchFilterClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FilterListModel(GObject.Object):
    """
    A list model that filters the elements of another model.

    It hides some elements from the underlying model according to
    criteria given by a `GtkFilter`.

    The model can be set up to do incremental filtering, so that
    filtering long lists doesn't block the UI. See
    [method@Gtk.FilterListModel.set_incremental] for details.

    `GtkFilterListModel` passes through sections from the underlying model.
    """

    class Props(GObject.Object.Props):
        filter: Filter | None
        incremental: bool
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters
        pending: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, filter: Filter | None = ..., incremental: bool = ..., model: Gio.ListModel | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_filter(self) -> Filter | None: ...
    @builtins.property
    def get_incremental(self) -> bool: ...
    @builtins.property
    def get_model(self) -> Gio.ListModel | None: ...
    @builtins.property
    def get_pending(self) -> int: ...
    @classmethod
    def new(cls, model: Gio.ListModel | None = None, filter: Filter | None = None) -> FilterListModel: ...
    def set_filter(self, filter: Filter | None = None) -> None: ...
    def set_incremental(self, incremental: bool) -> None: ...
    def set_model(self, model: Gio.ListModel | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::filter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::incremental"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pending"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FilterListModelClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Fixed(Widget):
    """
    Places its child widgets at fixed positions and with fixed sizes.

    `GtkFixed` performs no automatic layout management.

    For most applications, you should not use this container! It keeps
    you from having to learn about the other GTK containers, but it
    results in broken applications.  With `GtkFixed`, the following
    things will result in truncated text, overlapping widgets, and
    other display bugs:

    - Themes, which may change widget sizes.

    - Fonts other than the one you used to write the app will of course
      change the size of widgets containing text; keep in mind that
      users may use a larger font because of difficulty reading the
      default, or they may be using a different OS that provides different fonts.

    - Translation of text into other languages changes its size. Also,
      display of non-English text will use a different font in many
      cases.

    In addition, `GtkFixed` does not pay attention to text direction and
    thus may produce unwanted results if your app is run under right-to-left
    languages such as Hebrew or Arabic. That is: normally GTK will order
    containers appropriately for the text direction, e.g. to put labels to
    the right of the thing they label when using an RTL language, but it can’t
    do that with `GtkFixed`. So if you need to reorder widgets depending on
    the text direction, you would need to manually detect it and adjust child
    positions accordingly.

    Finally, fixed positioning makes it kind of annoying to add/remove
    UI elements, since you have to reposition all the other elements. This
    is a long-term maintenance problem for your application.

    If you know none of these things are an issue for your application,
    and prefer the simplicity of `GtkFixed`, by all means use the
    widget. But you should be aware of the tradeoffs.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_child_position(self, widget: Widget) -> tuple[float, float]: ...
    def get_child_transform(self, widget: Widget) -> Gsk.Transform | None: ...
    def move(self, widget: Widget, x: float, y: float) -> None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def put(self, widget: Widget, x: float, y: float) -> None: ...
    def remove(self, widget: Widget) -> None: ...
    def set_child_transform(self, widget: Widget, transform: Gsk.Transform | None = None) -> None: ...

class FixedClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FixedLayout(LayoutManager):
    """
    Places child widgets at fixed positions.

    Most applications should never use this layout manager; fixed positioning
    and sizing requires constant recalculations on where children need to be
    positioned and sized. Other layout managers perform this kind of work
    internally so that application developers don't need to do it. Specifically,
    widgets positioned in a fixed layout manager will need to take into account:

    - Themes, which may change widget sizes.

    - Fonts other than the one you used to write the app will of course
      change the size of widgets containing text; keep in mind that
      users may use a larger font because of difficulty reading the
      default, or they may be using a different OS that provides different
      fonts.

    - Translation of text into other languages changes its size. Also,
      display of non-English text will use a different font in many
      cases.

    In addition, `GtkFixedLayout` does not pay attention to text direction and
    thus may produce unwanted results if your app is run under right-to-left
    languages such as Hebrew or Arabic. That is: normally GTK will order
    containers appropriately depending on the text direction, e.g. to put labels
    to the right of the thing they label when using an RTL language;
    `GtkFixedLayout` won't be able to do that for you.

    Finally, fixed positioning makes it kind of annoying to add/remove UI
    elements, since you have to reposition all the other  elements. This is a
    long-term maintenance problem for your application.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> LayoutManager: ...

class FixedLayoutChild(LayoutChild):
    """
    `GtkLayoutChild` subclass for children in a `GtkFixedLayout`.
    """

    class Props(LayoutChild.Props):
        transform: Gsk.Transform | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, transform: Gsk.Transform | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_transform(self) -> Gsk.Transform | None: ...
    def set_transform(self, transform: Gsk.Transform) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::transform"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FixedLayoutChildClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutChildClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FixedLayoutClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutManagerClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FlattenListModel(GObject.Object):
    """
    A list model that concatenates other list models.

    `GtkFlattenListModel` takes a list model containing list models, and flattens
    it into a single model. Each list model becomes a section in the single model.
    """

    class Props(GObject.Object.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, model: Gio.ListModel | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_model(self) -> Gio.ListModel | None: ...
    def get_model_for_item(self, position: int) -> Gio.ListModel | None: ...
    @classmethod
    def new(cls, model: Gio.ListModel | None = None) -> FlattenListModel: ...
    def set_model(self, model: Gio.ListModel | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FlattenListModelClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FlowBox(Widget):
    """
    Puts child widgets in a reflowing grid.

    <picture>
      <source srcset="flow-box-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkFlowBox" src="flow-box.png">
    </picture>

    For instance, with the horizontal orientation, the widgets will be
    arranged from left to right, starting a new row under the previous
    row when necessary. Reducing the width in this case will require more
    rows, so a larger height will be requested.

    Likewise, with the vertical orientation, the widgets will be arranged
    from top to bottom, starting a new column to the right when necessary.
    Reducing the height will require more columns, so a larger width will
    be requested.

    The size request of a `GtkFlowBox` alone may not be what you expect;
    if you need to be able to shrink it along both axes and dynamically
    reflow its children, you may have to wrap it in a `GtkScrolledWindow`
    to enable that.

    The children of a `GtkFlowBox` can be dynamically sorted and filtered.

    Although a `GtkFlowBox` must have only `GtkFlowBoxChild` children, you
    can add any kind of widget to it via [method@Gtk.FlowBox.insert], and a
    `GtkFlowBoxChild` widget will automatically be inserted between the box
    and the widget.

    Also see [class@Gtk.ListBox].

    # Shortcuts and Gestures

    The following signals have default keybindings:

    - [signal@Gtk.FlowBox::move-cursor]
    - [signal@Gtk.FlowBox::select-all]
    - [signal@Gtk.FlowBox::toggle-cursor-child]
    - [signal@Gtk.FlowBox::unselect-all]

    # CSS nodes

    ```
    flowbox
    ├── flowboxchild
    │   ╰── <child>
    ├── flowboxchild
    │   ╰── <child>
    ┊
    ╰── [rubberband]
    ```

    `GtkFlowBox` uses a single CSS node with name flowbox. `GtkFlowBoxChild`
    uses a single CSS node with name flowboxchild. For rubberband selection,
    a subnode with name rubberband is used.

    # Accessibility

    `GtkFlowBox` uses the [enum@Gtk.AccessibleRole.grid] role, and `GtkFlowBoxChild`
    uses the [enum@Gtk.AccessibleRole.grid_cell] role.
    """

    class Props(Widget.Props):
        accept_unpaired_release: bool  # [accept-unpaired-release]: changed because contained invalid characters
        activate_on_single_click: bool  # [activate-on-single-click]: changed because contained invalid characters
        column_spacing: int  # [column-spacing]: changed because contained invalid characters
        homogeneous: bool
        max_children_per_line: int  # [max-children-per-line]: changed because contained invalid characters
        min_children_per_line: int  # [min-children-per-line]: changed because contained invalid characters
        row_spacing: int  # [row-spacing]: changed because contained invalid characters
        selection_mode: SelectionMode  # [selection-mode]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accept_unpaired_release: bool = ...,
        activate_on_single_click: bool = ...,
        column_spacing: int = ...,
        homogeneous: bool = ...,
        max_children_per_line: int = ...,
        min_children_per_line: int = ...,
        row_spacing: int = ...,
        selection_mode: SelectionMode = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, child: Widget) -> None: ...
    def bind_model(
        self,
        model: Gio.ListModel | None,
        create_widget_func: FlowBoxCreateWidgetFunc,
        user_data: object | None,
        user_data_free_func: GLib.DestroyNotify,
    ) -> None: ...
    @builtins.property
    def get_activate_on_single_click(self) -> bool: ...
    def get_child_at_index(self, idx: int) -> FlowBoxChild | None: ...
    def get_child_at_pos(self, x: int, y: int) -> FlowBoxChild | None: ...
    @builtins.property
    def get_column_spacing(self) -> int: ...
    @builtins.property
    def get_homogeneous(self) -> bool: ...
    @builtins.property
    def get_max_children_per_line(self) -> int: ...
    @builtins.property
    def get_min_children_per_line(self) -> int: ...
    @builtins.property
    def get_row_spacing(self) -> int: ...
    def get_selected_children(self) -> list: ...
    @builtins.property
    def get_selection_mode(self) -> SelectionMode: ...
    def insert(self, widget: Widget, position: int) -> None: ...
    def invalidate_filter(self) -> None: ...
    def invalidate_sort(self) -> None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def prepend(self, child: Widget) -> None: ...
    def remove(self, widget: Widget) -> None: ...
    def remove_all(self) -> None: ...
    def select_all(self) -> None: ...
    def select_child(self, child: FlowBoxChild) -> None: ...
    def selected_foreach(self, func: FlowBoxForeachFunc, data: object | None = None) -> None: ...
    def set_activate_on_single_click(self, single: bool) -> None: ...
    def set_column_spacing(self, spacing: int) -> None: ...
    def set_filter_func(
        self, filter_func: FlowBoxFilterFunc | None, user_data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...
    def set_hadjustment(self, adjustment: Adjustment) -> None: ...
    def set_homogeneous(self, homogeneous: bool) -> None: ...
    def set_max_children_per_line(self, n_children: int) -> None: ...
    def set_min_children_per_line(self, n_children: int) -> None: ...
    def set_row_spacing(self, spacing: int) -> None: ...
    def set_selection_mode(self, mode: SelectionMode) -> None: ...
    def set_sort_func(
        self, sort_func: FlowBoxSortFunc | None, user_data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...
    def set_vadjustment(self, adjustment: Adjustment) -> None: ...
    def unselect_all(self) -> None: ...
    def unselect_child(self, child: FlowBoxChild) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate-cursor-child"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["child-activated"],
        handler: typing.Callable[[typing_extensions.Self, FlowBoxChild], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-cursor"],
        handler: typing.Callable[[typing_extensions.Self, MovementStep, int, bool, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["select-all"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["selected-children-changed"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["toggle-cursor-child"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["unselect-all"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accept_unpaired_release"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activate_on_single_click"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::column_spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::homogeneous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_children_per_line"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_children_per_line"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::row_spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selection_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FlowBoxChild(Widget):
    """
    The kind of widget that can be added to a `GtkFlowBox`.

    [class@Gtk.FlowBox] will automatically wrap its children in a `GtkFlowBoxChild`
    when necessary.
    """

    class Props(Widget.Props):
        child: Widget | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, child: Widget | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def changed(self) -> None: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    def get_index(self) -> int: ...
    def is_selected(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...

    # python methods (overrides?)
    def do_activate(
        self,
    ) -> None:
        """
        activate(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FlowBoxChildClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate(self) -> activateFlowBoxChildClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FontButton(Widget):
    """
    The `GtkFontButton` allows to open a font chooser dialog to change
    the font.

    <picture>
      <source srcset="font-button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkFontButton" src="font-button.png">
    </picture>

    It is suitable widget for selecting a font in a preference dialog.

    # CSS nodes

    ```
    fontbutton
    ╰── button.font
        ╰── [content]
    ```

    `GtkFontButton` has a single CSS node with name fontbutton which
    contains a button node with the .font style class.
    """

    class Props(Widget.Props):
        modal: bool
        title: str
        use_font: bool  # [use-font]: changed because contained invalid characters
        use_size: bool  # [use-size]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, modal: bool = ..., title: str = ..., use_font: bool = ..., use_size: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_modal(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_title(self) -> str: ...
    @deprecated("deprecated")
    @builtins.property
    def get_use_font(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_use_size(self) -> bool: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_font(cls, fontname: str) -> Widget: ...
    @deprecated("deprecated")
    def set_modal(self, modal: bool) -> None: ...
    @deprecated("deprecated")
    def set_title(self, title: str) -> None: ...
    @deprecated("deprecated")
    def set_use_font(self, use_font: bool) -> None: ...
    @deprecated("deprecated")
    def set_use_size(self, use_size: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["font-set"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_font"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FontChooser(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        font: str
        font_desc: Pango.FontDescription | None  # [font-desc]: changed because contained invalid characters
        font_features: str  # [font-features]: changed because contained invalid characters
        language: str
        level: FontChooserLevel
        preview_text: str  # [preview-text]: changed because contained invalid characters
        show_preview_entry: bool  # [show-preview-entry]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        font: str = ...,
        font_desc: Pango.FontDescription | None = ...,
        language: str = ...,
        level: FontChooserLevel = ...,
        preview_text: str = ...,
        show_preview_entry: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_font(self) -> str | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_font_desc(self) -> Pango.FontDescription | None: ...
    @deprecated("deprecated")
    def get_font_face(self) -> Pango.FontFace | None: ...
    @deprecated("deprecated")
    def get_font_family(self) -> Pango.FontFamily | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_font_features(self) -> str: ...
    @deprecated("deprecated")
    def get_font_map(self) -> Pango.FontMap | None: ...
    @deprecated("deprecated")
    def get_font_size(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_language(self) -> str: ...
    @deprecated("deprecated")
    @builtins.property
    def get_level(self) -> FontChooserLevel: ...
    @deprecated("deprecated")
    @builtins.property
    def get_preview_text(self) -> str: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_preview_entry(self) -> bool: ...
    @deprecated("deprecated")
    def set_filter_func(
        self, filter: FontFilterFunc | None, user_data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...
    @deprecated("deprecated")
    def set_font(self, fontname: str) -> None: ...
    @deprecated("deprecated")
    def set_font_desc(self, font_desc: Pango.FontDescription) -> None: ...
    @deprecated("deprecated")
    def set_font_map(self, fontmap: Pango.FontMap | None = None) -> None: ...
    @deprecated("deprecated")
    def set_language(self, language: str) -> None: ...
    @deprecated("deprecated")
    def set_level(self, level: FontChooserLevel) -> None: ...
    @deprecated("deprecated")
    def set_preview_text(self, text: str) -> None: ...
    @deprecated("deprecated")
    def set_show_preview_entry(self, show_preview_entry: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["font-activated"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font_desc"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font_features"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::language"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::level"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::preview_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_preview_entry"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FontChooserDialog(Dialog):
    """
    The `GtkFontChooserDialog` widget is a dialog for selecting a font.

    <picture>
      <source srcset="fontchooser-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkFontChooserDialog" src="fontchooser.png">
    </picture>

    `GtkFontChooserDialog` implements the [iface@Gtk.FontChooser] interface
    and does not provide much API of its own.

    To create a `GtkFontChooserDialog`, use [ctor@Gtk.FontChooserDialog.new].

    # GtkFontChooserDialog as GtkBuildable

    The `GtkFontChooserDialog` implementation of the `GtkBuildable`
    interface exposes the buttons with the names “select_button”
    and “cancel_button”.

    ## CSS nodes

    `GtkFontChooserDialog` has a single CSS node with the name `window` and style
    class `.fontchooser`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls, title: str | None = None, parent: Window | None = None) -> Widget: ...

class FontChooserIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def base_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def font_activated(self) -> font_activatedFontChooserIfaceCB: ...
    @builtins.property
    def get_font_face(self) -> get_font_faceFontChooserIfaceCB | None: ...
    @builtins.property
    def get_font_family(self) -> get_font_familyFontChooserIfaceCB | None: ...
    @builtins.property
    def get_font_map(self) -> get_font_mapFontChooserIfaceCB | None: ...
    @builtins.property
    def get_font_size(self) -> get_font_sizeFontChooserIfaceCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def set_filter_func(self) -> set_filter_funcFontChooserIfaceCB: ...
    @builtins.property
    def set_font_map(self) -> set_font_mapFontChooserIfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FontChooserWidget(Widget):
    """
    The `GtkFontChooserWidget` widget lets the user select a font.

    It is used in the `GtkFontChooserDialog` widget to provide a
    dialog for selecting fonts.

    To set the font which is initially selected, use
    [method@Gtk.FontChooser.set_font] or [method@Gtk.FontChooser.set_font_desc].

    To get the selected font use [method@Gtk.FontChooser.get_font] or
    [method@Gtk.FontChooser.get_font_desc].

    To change the text which is shown in the preview area, use
    [method@Gtk.FontChooser.set_preview_text].

    # CSS nodes

    `GtkFontChooserWidget` has a single CSS node with name fontchooser.
    """

    class Props(Widget.Props):
        tweak_action: Gio.Action | None  # [tweak-action]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tweak_action"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FontDialog(GObject.Object):
    """
    Asynchronous API to present a font chooser dialog.

    `GtkFontDialog` collects the arguments that are needed to present
    the dialog to the user, such as a title for the dialog and whether
    it should be modal.

    The dialog is shown with the [method@Gtk.FontDialog.choose_font]
    function or its variants.

    See [class@Gtk.FontDialogButton] for a convenient control
    that uses `GtkFontDialog` and presents the results.
    """

    class Props(GObject.Object.Props):
        filter: Filter | None
        font_map: Pango.FontMap | None  # [font-map]: changed because contained invalid characters
        language: Pango.Language | None
        modal: bool
        title: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        filter: Filter | None = ...,
        font_map: Pango.FontMap | None = ...,
        language: Pango.Language | None = ...,
        modal: bool = ...,
        title: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def choose_face(
        self,
        parent: Window | None = None,
        initial_value: Pango.FontFace | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def choose_face_finish(self, result: Gio.AsyncResult) -> Pango.FontFace | None: ...
    def choose_family(
        self,
        parent: Window | None = None,
        initial_value: Pango.FontFamily | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def choose_family_finish(self, result: Gio.AsyncResult) -> Pango.FontFamily | None: ...
    def choose_font(
        self,
        parent: Window | None = None,
        initial_value: Pango.FontDescription | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def choose_font_and_features(
        self,
        parent: Window | None = None,
        initial_value: Pango.FontDescription | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def choose_font_and_features_finish(
        self, result: Gio.AsyncResult
    ) -> tuple[bool, Pango.FontDescription, str, Pango.Language]: ...
    def choose_font_finish(self, result: Gio.AsyncResult) -> Pango.FontDescription | None: ...
    @builtins.property
    def get_filter(self) -> Filter | None: ...
    @builtins.property
    def get_font_map(self) -> Pango.FontMap | None: ...
    @builtins.property
    def get_language(self) -> Pango.Language | None: ...
    @builtins.property
    def get_modal(self) -> bool: ...
    @builtins.property
    def get_title(self) -> str: ...
    @classmethod
    def new(cls) -> FontDialog: ...
    def set_filter(self, filter: Filter | None = None) -> None: ...
    def set_font_map(self, fontmap: Pango.FontMap | None = None) -> None: ...
    def set_language(self, language: Pango.Language) -> None: ...
    def set_modal(self, modal: bool) -> None: ...
    def set_title(self, title: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::filter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font_map"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::language"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FontDialogButton(Widget):
    """
    Opens a font chooser dialog to select a font.

    <picture>
      <source srcset="font-button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkFontDialogButton" src="font-button.png">
    </picture>

    It is suitable widget for selecting a font in a preference dialog.

    # CSS nodes

    ```
    fontbutton
    ╰── button.font
        ╰── [content]
    ```

    `GtkFontDialogButton` has a single CSS node with name fontbutton which
    contains a button node with the .font style class.
    """

    class Props(Widget.Props):
        dialog: FontDialog | None
        font_desc: Pango.FontDescription | None  # [font-desc]: changed because contained invalid characters
        font_features: str  # [font-features]: changed because contained invalid characters
        language: Pango.Language | None
        level: FontLevel
        use_font: bool  # [use-font]: changed because contained invalid characters
        use_size: bool  # [use-size]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        dialog: FontDialog | None = ...,
        font_desc: Pango.FontDescription | None = ...,
        font_features: str = ...,
        language: Pango.Language | None = ...,
        level: FontLevel = ...,
        use_font: bool = ...,
        use_size: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_dialog(self) -> FontDialog | None: ...
    @builtins.property
    def get_font_desc(self) -> Pango.FontDescription | None: ...
    @builtins.property
    def get_font_features(self) -> str | None: ...
    @builtins.property
    def get_language(self) -> Pango.Language | None: ...
    @builtins.property
    def get_level(self) -> FontLevel: ...
    @builtins.property
    def get_use_font(self) -> bool: ...
    @builtins.property
    def get_use_size(self) -> bool: ...
    @classmethod
    def new(cls, dialog: FontDialog | None = None) -> Widget: ...
    def set_dialog(self, dialog: FontDialog) -> None: ...
    def set_font_desc(self, font_desc: Pango.FontDescription) -> None: ...
    def set_font_features(self, font_features: str | None = None) -> None: ...
    def set_language(self, language: Pango.Language | None = None) -> None: ...
    def set_level(self, level: FontLevel) -> None: ...
    def set_use_font(self, use_font: bool) -> None: ...
    def set_use_size(self, use_size: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::dialog"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font_desc"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font_features"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::language"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::level"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_font"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FontDialogButtonClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FontDialogClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Frame(Widget):
    """
    Surrounds its child with a decorative frame and an optional label.

    <picture>
      <source srcset="frame-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkFrame" src="frame.png">
    </picture>

    If present, the label is drawn inside the top edge of the frame.
    The horizontal position of the label can be controlled with
    [method@Gtk.Frame.set_label_align].

    `GtkFrame` clips its child. You can use this to add rounded corners
    to widgets, but be aware that it also cuts off shadows.

    # GtkFrame as GtkBuildable

    The `GtkFrame` implementation of the `GtkBuildable` interface supports
    placing a child in the label position by specifying “label” as the
    “type” attribute of a `<child>` element. A normal content child can
    be specified without specifying a `<child>` type attribute.

    An example of a UI definition fragment with GtkFrame:
    ```xml
    <object class="GtkFrame">
      <child type="label">
        <object class="GtkLabel" id="frame_label"/>
      </child>
      <child>
        <object class="GtkEntry" id="frame_content"/>
      </child>
    </object>
    ```

    # CSS nodes

    ```
    frame
    ├── <label widget>
    ╰── <child>
    ```

    `GtkFrame` has a main CSS node with name “frame”, which is used to draw the
    visible border. You can set the appearance of the border using CSS properties
    like “border-style” on this node.

    # Accessibility

    `GtkFrame` uses the [enum@Gtk.AccessibleRole.group] role.
    """

    class Props(Widget.Props):
        child: Widget | None
        label: str
        label_widget: Widget | None  # [label-widget]: changed because contained invalid characters
        label_xalign: float  # [label-xalign]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, child: Widget | None = ..., label: str = ..., label_widget: Widget | None = ..., label_xalign: float = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_label(self) -> str | None: ...
    @builtins.property
    def get_label_align(self) -> float: ...
    @builtins.property
    def get_label_widget(self) -> Widget | None: ...
    @classmethod
    def new(cls, label: str | None = None) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_label(self, label: str | None = None) -> None: ...
    def set_label_align(self, xalign: float) -> None: ...
    def set_label_widget(self, label_widget: Widget | None = None) -> None: ...

    # python methods (overrides?)
    def do_compute_child_allocation(
        self,
        allocation: Gdk.Rectangle,
    ) -> None:
        """
        compute_child_allocation(self, allocation:Gdk.Rectangle)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::label_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::label_xalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FrameClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def compute_child_allocation(self) -> compute_child_allocationFrameClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GLArea(Widget):
    """
    Allows drawing with OpenGL.

    <picture>
      <source srcset="glarea-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkGLArea" src="glarea.png">
    </picture>

    `GtkGLArea` sets up its own [class@Gdk.GLContext], and creates a custom
    GL framebuffer that the widget will do GL rendering onto. It also ensures
    that this framebuffer is the default GL rendering target when rendering.
    The completed rendering is integrated into the larger GTK scene graph as
    a texture.

    In order to draw, you have to connect to the [signal@Gtk.GLArea::render]
    signal, or subclass `GtkGLArea` and override the GtkGLAreaClass.render
    virtual function.

    The `GtkGLArea` widget ensures that the `GdkGLContext` is associated with
    the widget's drawing area, and it is kept updated when the size and
    position of the drawing area changes.

    ## Drawing with GtkGLArea

    The simplest way to draw using OpenGL commands in a `GtkGLArea` is to
    create a widget instance and connect to the [signal@Gtk.GLArea::render] signal:

    The `render()` function will be called when the `GtkGLArea` is ready
    for you to draw its content:

    The initial contents of the framebuffer are transparent.

    ```c
    static gboolean
    render (GtkGLArea *area, GdkGLContext *context)
    {
      // inside this function it's safe to use GL; the given
      // GdkGLContext has been made current to the drawable
      // surface used by the `GtkGLArea` and the viewport has
      // already been set to be the size of the allocation

      // we can start by clearing the buffer
      glClearColor (0, 0, 0, 0);
      glClear (GL_COLOR_BUFFER_BIT);

      // record the active framebuffer ID, so we can return to it
      // with `glBindFramebuffer (GL_FRAMEBUFFER, screen_fb)` should
      // we, for instance, intend on utilizing the results of an
      // intermediate render texture pass
      GLuint screen_fb = 0;
      glGetIntegerv (GL_FRAMEBUFFER_BINDING, &screen_fb);

      // draw your object
      // draw_an_object ();

      // we completed our drawing; the draw commands will be
      // flushed at the end of the signal emission chain, and
      // the buffers will be drawn on the window
      return TRUE;
    }

    void setup_glarea (void)
    {
      // create a GtkGLArea instance
      GtkWidget *gl_area = gtk_gl_area_new ();

      // connect to the "render" signal
      g_signal_connect (gl_area, "render", G_CALLBACK (render), NULL);
    }
    ```

    If you need to initialize OpenGL state, e.g. buffer objects or
    shaders, you should use the [signal@Gtk.Widget::realize] signal;
    you can use the [signal@Gtk.Widget::unrealize] signal to clean up.
    Since the `GdkGLContext` creation and initialization may fail, you
    will need to check for errors, using [method@Gtk.GLArea.get_error].

    An example of how to safely initialize the GL state is:

    ```c
    static void
    on_realize (GtkGLArea *area)
    {
      // We need to make the context current if we want to
      // call GL API
      gtk_gl_area_make_current (area);

      // If there were errors during the initialization or
      // when trying to make the context current, this
      // function will return a GError for you to catch
      if (gtk_gl_area_get_error (area) != NULL)
        return;

      // You can also use gtk_gl_area_set_error() in order
      // to show eventual initialization errors on the
      // GtkGLArea widget itself
      GError *internal_error = NULL;
      init_buffer_objects (&error);
      if (error != NULL)
        {
          gtk_gl_area_set_error (area, error);
          g_error_free (error);
          return;
        }

      init_shaders (&error);
      if (error != NULL)
        {
          gtk_gl_area_set_error (area, error);
          g_error_free (error);
          return;
        }
    }
    ```

    If you need to change the options for creating the `GdkGLContext`
    you should use the [signal@Gtk.GLArea::create-context] signal.
    """

    class Props(Widget.Props):
        allowed_apis: Gdk.GLAPI  # [allowed-apis]: changed because contained invalid characters
        api: Gdk.GLAPI
        auto_render: bool  # [auto-render]: changed because contained invalid characters
        context: Gdk.GLContext | None
        has_depth_buffer: bool  # [has-depth-buffer]: changed because contained invalid characters
        has_stencil_buffer: bool  # [has-stencil-buffer]: changed because contained invalid characters
        use_es: bool  # [use-es]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        allowed_apis: Gdk.GLAPI = ...,
        auto_render: bool = ...,
        has_depth_buffer: bool = ...,
        has_stencil_buffer: bool = ...,
        use_es: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def attach_buffers(self) -> None: ...
    @builtins.property
    def get_allowed_apis(self) -> Gdk.GLAPI: ...
    @builtins.property
    def get_api(self) -> Gdk.GLAPI: ...
    @builtins.property
    def get_auto_render(self) -> bool: ...
    @builtins.property
    def get_context(self) -> Gdk.GLContext | None: ...
    def get_error(self) -> None: ...
    @builtins.property
    def get_has_depth_buffer(self) -> bool: ...
    @builtins.property
    def get_has_stencil_buffer(self) -> bool: ...
    def get_required_version(self) -> tuple[int, int]: ...
    @deprecated("deprecated")
    @builtins.property
    def get_use_es(self) -> bool: ...
    def make_current(self) -> None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def queue_render(self) -> None: ...
    def set_allowed_apis(self, apis: Gdk.GLAPI) -> None: ...
    def set_auto_render(self, auto_render: bool) -> None: ...
    def set_error(self, error: None | None = None) -> None: ...
    def set_has_depth_buffer(self, has_depth_buffer: bool) -> None: ...
    def set_has_stencil_buffer(self, has_stencil_buffer: bool) -> None: ...
    def set_required_version(self, major: int, minor: int) -> None: ...
    @deprecated("deprecated")
    def set_use_es(self, use_es: bool) -> None: ...

    # python methods (overrides?)
    def do_render(
        self,
        context: Gdk.GLContext,
    ) -> bool:
        """
        render(self, context:Gdk.GLContext) -> bool
        """
    def do_resize(
        self,
        width: int,
        height: int,
    ) -> None:
        """
        resize(self, width:int, height:int)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["create-context"],
        handler: typing.Callable[..., Gdk.GLContext],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["render"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.GLContext], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["resize"],
        handler: typing.Callable[[typing_extensions.Self, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::allowed_apis"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::api"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::auto_render"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::context"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_depth_buffer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_stencil_buffer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_es"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GLAreaClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...
    @builtins.property
    def render(self) -> renderGLAreaClassCB: ...
    @builtins.property
    def resize(self) -> resizeGLAreaClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Gesture(EventController):
    """
    The base class for gesture recognition.

    Although `GtkGesture` is quite generalized to serve as a base for
    multi-touch gestures, it is suitable to implement single-touch and
    pointer-based gestures (using the special %NULL `GdkEventSequence`
    value for these).

    The number of touches that a `GtkGesture` need to be recognized is
    controlled by the [property@Gtk.Gesture:n-points] property, if a
    gesture is keeping track of less or more than that number of sequences,
    it won't check whether the gesture is recognized.

    As soon as the gesture has the expected number of touches, it will check
    regularly if it is recognized, the criteria to consider a gesture as
    "recognized" is left to `GtkGesture` subclasses.

    A recognized gesture will then emit the following signals:

    - [signal@Gtk.Gesture::begin] when the gesture is recognized.
    - [signal@Gtk.Gesture::update], whenever an input event is processed.
    - [signal@Gtk.Gesture::end] when the gesture is no longer recognized.

    ## Event propagation

    In order to receive events, a gesture needs to set a propagation phase
    through [method@Gtk.EventController.set_propagation_phase].

    In the capture phase, events are propagated from the toplevel down
    to the target widget, and gestures that are attached to containers
    above the widget get a chance to interact with the event before it
    reaches the target.

    In the bubble phase, events are propagated up from the target widget
    to the toplevel, and gestures that are attached to containers above
    the widget get a chance to interact with events that have not been
    handled yet.

    ## States of a sequence

    Whenever input interaction happens, a single event may trigger a cascade
    of `GtkGesture`s, both across the parents of the widget receiving the
    event and in parallel within an individual widget. It is a responsibility
    of the widgets using those gestures to set the state of touch sequences
    accordingly in order to enable cooperation of gestures around the
    `GdkEventSequence`s triggering those.

    Within a widget, gestures can be grouped through [method@Gtk.Gesture.group].
    Grouped gestures synchronize the state of sequences, so calling
    [method@Gtk.Gesture.set_state] on one will effectively propagate
    the state throughout the group.

    By default, all sequences start out in the %GTK_EVENT_SEQUENCE_NONE state,
    sequences in this state trigger the gesture event handler, but event
    propagation will continue unstopped by gestures.

    If a sequence enters into the %GTK_EVENT_SEQUENCE_DENIED state, the gesture
    group will effectively ignore the sequence, letting events go unstopped
    through the gesture, but the "slot" will still remain occupied while
    the touch is active.

    If a sequence enters in the %GTK_EVENT_SEQUENCE_CLAIMED state, the gesture
    group will grab all interaction on the sequence, by:

    - Setting the same sequence to %GTK_EVENT_SEQUENCE_DENIED on every other
      gesture group within the widget, and every gesture on parent widgets
      in the propagation chain.
    - Emitting [signal@Gtk.Gesture::cancel] on every gesture in widgets
      underneath in the propagation chain.
    - Stopping event propagation after the gesture group handles the event.

    Note: if a sequence is set early to %GTK_EVENT_SEQUENCE_CLAIMED on
    %GDK_TOUCH_BEGIN/%GDK_BUTTON_PRESS (so those events are captured before
    reaching the event widget, this implies %GTK_PHASE_CAPTURE), one similar
    event will be emulated if the sequence changes to %GTK_EVENT_SEQUENCE_DENIED.
    This way event coherence is preserved before event propagation is unstopped
    again.

    Sequence states can't be changed freely.
    See [method@Gtk.Gesture.set_state] to know about the possible
    lifetimes of a `GdkEventSequence`.

    ## Touchpad gestures

    On the platforms that support it, `GtkGesture` will handle transparently
    touchpad gesture events. The only precautions users of `GtkGesture` should
    do to enable this support are:

    - If the gesture has %GTK_PHASE_NONE, ensuring events of type
      %GDK_TOUCHPAD_SWIPE and %GDK_TOUCHPAD_PINCH are handled by the `GtkGesture`
    """

    class Props(EventController.Props):
        n_points: int  # [n-points]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, n_points: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_bounding_box(self) -> tuple[bool, Gdk.Rectangle]: ...
    def get_bounding_box_center(self) -> tuple[bool, float, float]: ...
    def get_device(self) -> Gdk.Device | None: ...
    def get_group(self) -> list: ...
    def get_last_event(self, sequence: Gdk.EventSequence | None = None) -> Gdk.Event | None: ...
    def get_last_updated_sequence(self) -> Gdk.EventSequence | None: ...
    def get_point(self, sequence: Gdk.EventSequence | None = None) -> tuple[bool, float | None, float | None]: ...
    def get_sequence_state(self, sequence: Gdk.EventSequence) -> EventSequenceState: ...
    def get_sequences(self) -> list: ...
    def group(self, gesture: Gesture) -> None: ...
    def handles_sequence(self, sequence: Gdk.EventSequence | None = None) -> bool: ...
    def is_active(self) -> bool: ...
    def is_grouped_with(self, other: Gesture) -> bool: ...
    def is_recognized(self) -> bool: ...
    @deprecated("deprecated")
    def set_sequence_state(self, sequence: Gdk.EventSequence, state: EventSequenceState) -> bool: ...
    def set_state(self, state: EventSequenceState) -> bool: ...
    def ungroup(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["begin"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.EventSequence | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["cancel"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.EventSequence | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["end"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.EventSequence | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["sequence-state-changed"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.EventSequence | None, EventSequenceState], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["update"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.EventSequence | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_points"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GestureClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GestureClick(GestureSingle):
    """
    Recognizes click gestures.

    It is able to recognize multiple clicks on a nearby zone, which
    can be listened for through the [signal@Gtk.GestureClick::pressed]
    signal. Whenever time or distance between clicks exceed the GTK
    defaults, [signal@Gtk.GestureClick::stopped] is emitted, and the
    click counter is reset.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> Gesture: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pressed"],
        handler: typing.Callable[[typing_extensions.Self, int, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["released"],
        handler: typing.Callable[[typing_extensions.Self, int, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["stopped"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["unpaired-release"],
        handler: typing.Callable[[typing_extensions.Self, float, float, int, Gdk.EventSequence | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GestureClickClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GestureDrag(GestureSingle):
    """
    Recognizes drag gestures.

    The drag operation itself can be tracked throughout the
    [signal@Gtk.GestureDrag::drag-begin],
    [signal@Gtk.GestureDrag::drag-update] and
    [signal@Gtk.GestureDrag::drag-end] signals, and the relevant
    coordinates can be extracted through
    [method@Gtk.GestureDrag.get_offset] and
    [method@Gtk.GestureDrag.get_start_point].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_offset(self) -> tuple[bool, float | None, float | None]: ...
    def get_start_point(self) -> tuple[bool, float | None, float | None]: ...
    @classmethod
    def new(cls) -> Gesture: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drag-begin"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drag-end"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drag-update"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GestureDragClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GestureLongPress(GestureSingle):
    """
    Recognizes long press gestures.

    This gesture is also known as “Press and Hold”.

    When the timeout is exceeded, the gesture is triggering the
    [signal@Gtk.GestureLongPress::pressed] signal.

    If the touchpoint is lifted before the timeout passes, or if
    it drifts too far of the initial press point, the
    [signal@Gtk.GestureLongPress::cancelled] signal will be emitted.

    How long the timeout is before the ::pressed signal gets emitted is
    determined by the [property@Gtk.Settings:gtk-long-press-time] setting.
    It can be modified by the [property@Gtk.GestureLongPress:delay-factor]
    property.
    """

    class Props(GestureSingle.Props):
        delay_factor: float  # [delay-factor]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, delay_factor: float = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_delay_factor(self) -> float: ...
    @classmethod
    def new(cls) -> Gesture: ...
    def set_delay_factor(self, delay_factor: float) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["cancelled"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pressed"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::delay_factor"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GestureLongPressClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GesturePan(GestureDrag):
    """
    Recognizes pan gestures.

    These are drags that are locked to happen along one axis. The axis
    that a `GtkGesturePan` handles is defined at construct time, and
    can be changed through [method@Gtk.GesturePan.set_orientation].

    When the gesture starts to be recognized, `GtkGesturePan` will
    attempt to determine as early as possible whether the sequence
    is moving in the expected direction, and denying the sequence if
    this does not happen.

    Once a panning gesture along the expected axis is recognized,
    the [signal@Gtk.GesturePan::pan] signal will be emitted as input
    events are received, containing the offset in the given axis.
    """

    class Props(GestureDrag.Props):
        orientation: Orientation

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, orientation: Orientation = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_orientation(self) -> Orientation: ...
    @classmethod
    def new(cls, orientation: Orientation) -> Gesture: ...
    def set_orientation(self, orientation: Orientation) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["pan"],
        handler: typing.Callable[[typing_extensions.Self, PanDirection, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::orientation"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GesturePanClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GestureRotate(Gesture):
    """
    Recognizes 2-finger rotation gestures.

    Whenever the angle between both handled sequences changes, the
    [signal@Gtk.GestureRotate::angle-changed] signal is emitted.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_angle_delta(self) -> float: ...
    @classmethod
    def new(cls) -> Gesture: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["angle-changed"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GestureRotateClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GestureSingle(Gesture):
    """
    A `GtkGesture` subclass optimized for singe-touch and mouse gestures.

    Under interaction, these gestures stick to the first interacting sequence,
    which is accessible through [method@Gtk.GestureSingle.get_current_sequence]
    while the gesture is being interacted with.

    By default gestures react to both %GDK_BUTTON_PRIMARY and touch events.
    [method@Gtk.GestureSingle.set_touch_only] can be used to change the
    touch behavior. Callers may also specify a different mouse button number
    to interact with through [method@Gtk.GestureSingle.set_button], or react
    to any mouse button by setting it to 0. While the gesture is active, the
    button being currently pressed can be known through
    [method@Gtk.GestureSingle.get_current_button].
    """

    class Props(Gesture.Props):
        button: int
        exclusive: bool
        touch_only: bool  # [touch-only]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, button: int = ..., exclusive: bool = ..., touch_only: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_button(self) -> int: ...
    def get_current_button(self) -> int: ...
    def get_current_sequence(self) -> Gdk.EventSequence | None: ...
    @builtins.property
    def get_exclusive(self) -> bool: ...
    @builtins.property
    def get_touch_only(self) -> bool: ...
    def set_button(self, button: int) -> None: ...
    def set_exclusive(self, exclusive: bool) -> None: ...
    def set_touch_only(self, touch_only: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::button"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::exclusive"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::touch_only"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GestureSingleClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GestureStylus(GestureSingle):
    """
    Recognizes tablet stylus input.

    The provided signals just relay the basic information of the
    stylus events.
    """

    class Props(GestureSingle.Props):
        stylus_only: bool  # [stylus-only]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, stylus_only: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_axes(self, axes: list) -> tuple[bool, list]: ...
    def get_axis(self, axis: Gdk.AxisUse) -> tuple[bool, float]: ...
    def get_backlog(self) -> tuple[bool, list, int]: ...
    def get_device_tool(self) -> Gdk.DeviceTool | None: ...
    @builtins.property
    def get_stylus_only(self) -> bool: ...
    @classmethod
    def new(cls) -> Gesture: ...
    def set_stylus_only(self, stylus_only: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["down"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["motion"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["proximity"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["up"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stylus_only"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GestureStylusClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GestureSwipe(GestureSingle):
    """
    Recognizes swipe gestures.

    After a press/move/.../move/release sequence happens, the
    [signal@Gtk.GestureSwipe::swipe] signal will be emitted,
    providing the velocity and directionality of the sequence
    at the time it was lifted.

    If the velocity is desired in intermediate points,
    [method@Gtk.GestureSwipe.get_velocity] can be called in a
    [signal@Gtk.Gesture::update] handler.

    All velocities are reported in pixels/sec units.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_velocity(self) -> tuple[bool, float, float]: ...
    @classmethod
    def new(cls) -> Gesture: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["swipe"],
        handler: typing.Callable[[typing_extensions.Self, float, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GestureSwipeClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GestureZoom(Gesture):
    """
    Recognizes 2-finger pinch/zoom gestures.

    Whenever the distance between both tracked sequences changes, the
    [signal@Gtk.GestureZoom::scale-changed] signal is emitted to report
    the scale factor.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_scale_delta(self) -> float: ...
    @classmethod
    def new(cls) -> Gesture: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["scale-changed"],
        handler: typing.Callable[[typing_extensions.Self, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GestureZoomClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GraphicsOffload(Widget):
    """
    Bypasses gsk rendering by passing the content of its child directly to the compositor.

    Graphics offload is an optimization to reduce overhead and battery use that is
    most useful for video content. It only works on some platforms and in certain
    situations. GTK will automatically fall back to normal rendering if it doesn't.

    Graphics offload is most efficient if there are no controls drawn on top of the
    video content.

    You should consider using graphics offload for your main widget if it shows
    frequently changing content (such as a video, or a VM display) and you provide
    the content in the form of dmabuf textures (see [class@Gdk.DmabufTextureBuilder]),
    in particular if it may be fullscreen.

    Numerous factors can prohibit graphics offload:

    - Unsupported platforms. Currently, graphics offload only works on Linux with Wayland.

    - Clipping, such as rounded corners that cause the video content to not be rectangular

    - Unsupported dmabuf formats (see [method@Gdk.Display.get_dmabuf_formats])

    - Translucent video content (content with an alpha channel, even if it isn't used)

    - Transforms that are more complex than translations and scales

    - Filters such as opacity, grayscale or similar

    To investigate problems related graphics offload, GTK offers debug flags to print
    out information about graphics offload and dmabuf use:

        GDK_DEBUG=offload
        GDK_DEBUG=dmabuf

    The GTK inspector provides a visual debugging tool for graphics offload.
    """

    class Props(Widget.Props):
        black_background: bool  # [black-background]: changed because contained invalid characters
        child: Widget | None
        enabled: GraphicsOffloadEnabled

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, black_background: bool = ..., child: Widget | None = ..., enabled: GraphicsOffloadEnabled = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_black_background(self) -> bool: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_enabled(self) -> GraphicsOffloadEnabled: ...
    @classmethod
    def new(cls, child: Widget | None = None) -> Widget: ...
    def set_black_background(self, value: bool) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_enabled(self, enabled: GraphicsOffloadEnabled) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::black_background"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GraphicsOffloadClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Grid(Widget):
    """
    Arranges its child widgets in rows and columns.

    <picture>
      <source srcset="grid-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkGrid" src="grid.png">
    </picture>

    It supports arbitrary positions and horizontal/vertical spans.

    Children are added using [method@Gtk.Grid.attach]. They can span multiple
    rows or columns. It is also possible to add a child next to an existing
    child, using [method@Gtk.Grid.attach_next_to]. To remove a child from the
    grid, use [method@Gtk.Grid.remove].

    The behaviour of `GtkGrid` when several children occupy the same grid
    cell is undefined.

    # GtkGrid as GtkBuildable

    Every child in a `GtkGrid` has access to a custom [iface@Gtk.Buildable]
    element, called `<layout>`. It can by used to specify a position in the
    grid and optionally spans. All properties that can be used in the `<layout>`
    element are implemented by [class@Gtk.GridLayoutChild].

    It is implemented by `GtkWidget` using [class@Gtk.LayoutManager].

    To showcase it, here is a simple example:

    ```xml
    <object class="GtkGrid" id="my_grid">
      <child>
        <object class="GtkButton" id="button1">
          <property name="label">Button 1</property>
          <layout>
            <property name="column">0</property>
            <property name="row">0</property>
          </layout>
        </object>
      </child>
      <child>
        <object class="GtkButton" id="button2">
          <property name="label">Button 2</property>
          <layout>
            <property name="column">1</property>
            <property name="row">0</property>
          </layout>
        </object>
      </child>
      <child>
        <object class="GtkButton" id="button3">
          <property name="label">Button 3</property>
          <layout>
            <property name="column">2</property>
            <property name="row">0</property>
            <property name="row-span">2</property>
          </layout>
        </object>
      </child>
      <child>
        <object class="GtkButton" id="button4">
          <property name="label">Button 4</property>
          <layout>
            <property name="column">0</property>
            <property name="row">1</property>
            <property name="column-span">2</property>
          </layout>
        </object>
      </child>
    </object>
    ```

    It organizes the first two buttons side-by-side in one cell each.
    The third button is in the last column but spans across two rows.
    This is defined by the `row-span` property. The last button is
    located in the second row and spans across two columns, which is
    defined by the `column-span` property.

    # CSS nodes

    `GtkGrid` uses a single CSS node with name `grid`.

    # Accessibility

    Until GTK 4.10, `GtkGrid` used the [enum@Gtk.AccessibleRole.group] role.

    Starting from GTK 4.12, `GtkGrid` uses the [enum@Gtk.AccessibleRole.generic] role.
    """

    class Props(Widget.Props):
        baseline_row: int  # [baseline-row]: changed because contained invalid characters
        column_homogeneous: bool  # [column-homogeneous]: changed because contained invalid characters
        column_spacing: int  # [column-spacing]: changed because contained invalid characters
        row_homogeneous: bool  # [row-homogeneous]: changed because contained invalid characters
        row_spacing: int  # [row-spacing]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        baseline_row: int = ...,
        column_homogeneous: bool = ...,
        column_spacing: int = ...,
        row_homogeneous: bool = ...,
        row_spacing: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def attach(self, child: Widget, column: int, row: int, width: int, height: int) -> None: ...
    def attach_next_to(
        self, child: Widget, sibling: Widget | None, side: PositionType, width: int, height: int
    ) -> None: ...
    @builtins.property
    def get_baseline_row(self) -> int: ...
    def get_child_at(self, column: int, row: int) -> Widget | None: ...
    @builtins.property
    def get_column_homogeneous(self) -> bool: ...
    @builtins.property
    def get_column_spacing(self) -> int: ...
    def get_row_baseline_position(self, row: int) -> BaselinePosition: ...
    @builtins.property
    def get_row_homogeneous(self) -> bool: ...
    @builtins.property
    def get_row_spacing(self) -> int: ...
    def insert_column(self, position: int) -> None: ...
    def insert_next_to(self, sibling: Widget, side: PositionType) -> None: ...
    def insert_row(self, position: int) -> None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def query_child(self, child: Widget) -> tuple[int | None, int | None, int | None, int | None]: ...
    def remove(self, child: Widget) -> None: ...
    def remove_column(self, position: int) -> None: ...
    def remove_row(self, position: int) -> None: ...
    def set_baseline_row(self, row: int) -> None: ...
    def set_column_homogeneous(self, homogeneous: bool) -> None: ...
    def set_column_spacing(self, spacing: int) -> None: ...
    def set_row_baseline_position(self, row: int, pos: BaselinePosition) -> None: ...
    def set_row_homogeneous(self, homogeneous: bool) -> None: ...
    def set_row_spacing(self, spacing: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::baseline_row"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::column_homogeneous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::column_spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::row_homogeneous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::row_spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GridClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GridLayout(LayoutManager):
    """
    Arranges child widgets in rows and columns.

    Children have an "attach point" defined by the horizontal and vertical
    index of the cell they occupy; children can span multiple rows or columns.
    The layout properties for setting the attach points and spans are set
    using the [class@Gtk.GridLayoutChild] associated to each child widget.

    The behaviour of `GtkGridLayout` when several children occupy the same
    grid cell is undefined.

    `GtkGridLayout` can be used like a `GtkBoxLayout` if all children are
    attached to the same row or column; however, if you only ever need a
    single row or column, you should consider using `GtkBoxLayout`.
    """

    class Props(LayoutManager.Props):
        baseline_row: int  # [baseline-row]: changed because contained invalid characters
        column_homogeneous: bool  # [column-homogeneous]: changed because contained invalid characters
        column_spacing: int  # [column-spacing]: changed because contained invalid characters
        row_homogeneous: bool  # [row-homogeneous]: changed because contained invalid characters
        row_spacing: int  # [row-spacing]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        baseline_row: int = ...,
        column_homogeneous: bool = ...,
        column_spacing: int = ...,
        row_homogeneous: bool = ...,
        row_spacing: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_baseline_row(self) -> int: ...
    @builtins.property
    def get_column_homogeneous(self) -> bool: ...
    @builtins.property
    def get_column_spacing(self) -> int: ...
    def get_row_baseline_position(self, row: int) -> BaselinePosition: ...
    @builtins.property
    def get_row_homogeneous(self) -> bool: ...
    @builtins.property
    def get_row_spacing(self) -> int: ...
    @classmethod
    def new(cls) -> LayoutManager: ...
    def set_baseline_row(self, row: int) -> None: ...
    def set_column_homogeneous(self, homogeneous: bool) -> None: ...
    def set_column_spacing(self, spacing: int) -> None: ...
    def set_row_baseline_position(self, row: int, pos: BaselinePosition) -> None: ...
    def set_row_homogeneous(self, homogeneous: bool) -> None: ...
    def set_row_spacing(self, spacing: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::baseline_row"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::column_homogeneous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::column_spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::row_homogeneous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::row_spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GridLayoutChild(LayoutChild):
    """
    `GtkLayoutChild` subclass for children in a `GtkGridLayout`.
    """

    class Props(LayoutChild.Props):
        column: int
        column_span: int  # [column-span]: changed because contained invalid characters
        row: int
        row_span: int  # [row-span]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, column: int = ..., column_span: int = ..., row: int = ..., row_span: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_column(self) -> int: ...
    @builtins.property
    def get_column_span(self) -> int: ...
    @builtins.property
    def get_row(self) -> int: ...
    @builtins.property
    def get_row_span(self) -> int: ...
    def set_column(self, column: int) -> None: ...
    def set_column_span(self, span: int) -> None: ...
    def set_row(self, row: int) -> None: ...
    def set_row_span(self, span: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::column_span"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::row"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::row_span"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GridLayoutChildClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutChildClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GridLayoutClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutManagerClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class GridView(ListBase):
    """
    Presents a large dynamic grid of items.

    `GtkGridView` uses its factory to generate one child widget for each
    visible item and shows them in a grid. The orientation of the grid view
    determines if the grid reflows vertically or horizontally.

    `GtkGridView` allows the user to select items according to the selection
    characteristics of the model. For models that allow multiple selected items,
    it is possible to turn on _rubberband selection_, using
    [property@Gtk.GridView:enable-rubberband].

    To learn more about the list widget framework, see the
    [overview](section-list-widget.html).

    # Actions

    `GtkGridView` defines a set of built-in actions:

    - `list.activate-item` activates the item at given position by emitting the
      the [signal@Gtk.GridView::activate] signal.

    # CSS nodes

    ```
    gridview
    ├── child[.activatable]
    │
    ├── child[.activatable]
    │
    ┊
    ╰── [rubberband]
    ```

    `GtkGridView` uses a single CSS node with name `gridview`. Each child uses
    a single CSS node with name `child`. If the [property@Gtk.ListItem:activatable]
    property is set, the corresponding row will have the `.activatable` style
    class. For rubberband selection, a subnode with name `rubberband` is used.

    # Accessibility

    `GtkGridView` uses the [enum@Gtk.AccessibleRole.grid] role, and the items
    use the [enum@Gtk.AccessibleRole.grid_cell] role.
    """

    class Props(ListBase.Props):
        enable_rubberband: bool  # [enable-rubberband]: changed because contained invalid characters
        factory: ListItemFactory | None
        max_columns: int  # [max-columns]: changed because contained invalid characters
        min_columns: int  # [min-columns]: changed because contained invalid characters
        model: SelectionModel | None
        single_click_activate: bool  # [single-click-activate]: changed because contained invalid characters
        tab_behavior: ListTabBehavior  # [tab-behavior]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        enable_rubberband: bool = ...,
        factory: ListItemFactory | None = ...,
        max_columns: int = ...,
        min_columns: int = ...,
        model: SelectionModel | None = ...,
        single_click_activate: bool = ...,
        tab_behavior: ListTabBehavior = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_enable_rubberband(self) -> bool: ...
    @builtins.property
    def get_factory(self) -> ListItemFactory | None: ...
    @builtins.property
    def get_max_columns(self) -> int: ...
    @builtins.property
    def get_min_columns(self) -> int: ...
    @builtins.property
    def get_model(self) -> SelectionModel | None: ...
    @builtins.property
    def get_single_click_activate(self) -> bool: ...
    @builtins.property
    def get_tab_behavior(self) -> ListTabBehavior: ...
    @classmethod
    def new(cls, model: SelectionModel | None = None, factory: ListItemFactory | None = None) -> Widget: ...
    def scroll_to(self, pos: int, flags: ListScrollFlags, scroll: ScrollInfo | None = None) -> None: ...
    def set_enable_rubberband(self, enable_rubberband: bool) -> None: ...
    def set_factory(self, factory: ListItemFactory | None = None) -> None: ...
    def set_max_columns(self, max_columns: int) -> None: ...
    def set_min_columns(self, min_columns: int) -> None: ...
    def set_model(self, model: SelectionModel | None = None) -> None: ...
    def set_single_click_activate(self, single_click_activate: bool) -> None: ...
    def set_tab_behavior(self, tab_behavior: ListTabBehavior) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate"],
        handler: typing.Callable[[typing_extensions.Self, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_rubberband"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::factory"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_columns"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_columns"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::single_click_activate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tab_behavior"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class GridViewClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class HeaderBar(Widget):
    """
    Creates a custom titlebar for a window.

    <picture>
      <source srcset="headerbar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkHeaderBar" src="headerbar.png">
    </picture>

    `GtkHeaderBar` is similar to a horizontal `GtkCenterBox`. It allows
    children to be placed at the start or the end. In addition, it allows
    the window title to be displayed. The title will be centered with respect
    to the width of the box, even if the children at either side take up
    different amounts of space.

    `GtkHeaderBar` can add typical window frame controls, such as minimize,
    maximize and close buttons, or the window icon.

    For these reasons, `GtkHeaderBar` is the natural choice for use as the
    custom titlebar widget of a `GtkWindow` (see [method@Gtk.Window.set_titlebar]),
    as it gives features typical of titlebars while allowing the addition of
    child widgets.

    ## GtkHeaderBar as GtkBuildable

    The `GtkHeaderBar` implementation of the `GtkBuildable` interface supports
    adding children at the start or end sides by specifying “start” or “end” as
    the “type” attribute of a `<child>` element, or setting the title widget by
    specifying “title” value.

    By default the `GtkHeaderBar` uses a `GtkLabel` displaying the title of the
    window it is contained in as the title widget, equivalent to the following
    UI definition:

    ```xml
    <object class="GtkHeaderBar">
      <property name="title-widget">
        <object class="GtkLabel">
          <property name="label" translatable="yes">Label</property>
          <property name="single-line-mode">True</property>
          <property name="ellipsize">end</property>
          <property name="width-chars">5</property>
          <style>
            <class name="title"/>
          </style>
        </object>
      </property>
    </object>
    ```

    # CSS nodes

    ```
    headerbar
    ╰── windowhandle
        ╰── box
            ├── box.start
            │   ├── windowcontrols.start
            │   ╰── [other children]
            ├── [Title Widget]
            ╰── box.end
                ├── [other children]
                ╰── windowcontrols.end
    ```

    A `GtkHeaderBar`'s CSS node is called `headerbar`. It contains a `windowhandle`
    subnode, which contains a `box` subnode, which contains two `box` subnodes at
    the start and end of the header bar, as well as a center node that represents
    the title.

    Each of the boxes contains a `windowcontrols` subnode, see
    [class@Gtk.WindowControls] for details, as well as other children.

    # Accessibility

    `GtkHeaderBar` uses the [enum@Gtk.AccessibleRole.group] role.
    """

    class Props(Widget.Props):
        decoration_layout: str  # [decoration-layout]: changed because contained invalid characters
        show_title_buttons: bool  # [show-title-buttons]: changed because contained invalid characters
        title_widget: Widget | None  # [title-widget]: changed because contained invalid characters
        use_native_controls: bool  # [use-native-controls]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        decoration_layout: str = ...,
        show_title_buttons: bool = ...,
        title_widget: Widget | None = ...,
        use_native_controls: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_decoration_layout(self) -> str | None: ...
    @builtins.property
    def get_show_title_buttons(self) -> bool: ...
    @builtins.property
    def get_title_widget(self) -> Widget | None: ...
    @builtins.property
    def get_use_native_controls(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def pack_end(self, child: Widget) -> None: ...
    def pack_start(self, child: Widget) -> None: ...
    def remove(self, child: Widget) -> None: ...
    def set_decoration_layout(self, layout: str | None = None) -> None: ...
    def set_show_title_buttons(self, setting: bool) -> None: ...
    def set_title_widget(self, title_widget: Widget | None = None) -> None: ...
    def set_use_native_controls(self, setting: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::decoration_layout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_title_buttons"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_native_controls"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class IMContext(GObject.Object):
    """
    The interface for GTK input methods.

    `GtkIMContext` is used by GTK text input widgets like `GtkText`
    to map from key events to Unicode character strings.

    An input method may consume multiple key events in sequence before finally
    outputting the composed result. This is called *preediting*, and an input
    method may provide feedback about this process by displaying the intermediate
    composition states as preedit text. To do so, the `GtkIMContext` will emit
    [signal@Gtk.IMContext::preedit-start], [signal@Gtk.IMContext::preedit-changed]
    and [signal@Gtk.IMContext::preedit-end] signals.

    For instance, the built-in GTK input method [class@Gtk.IMContextSimple]
    implements the input of arbitrary Unicode code points by holding down the
    <kbd>Control</kbd> and <kbd>Shift</kbd> keys and then typing <kbd>u</kbd>
    followed by the hexadecimal digits of the code point. When releasing the
    <kbd>Control</kbd> and <kbd>Shift</kbd> keys, preediting ends and the
    character is inserted as text. For example,

        Ctrl+Shift+u 2 0 A C

    results in the € sign.

    Additional input methods can be made available for use by GTK widgets as
    loadable modules. An input method module is a small shared library which
    provides a `GIOExtension` for the extension point named "gtk-im-module".

    To connect a widget to the users preferred input method, you should use
    [class@Gtk.IMMulticontext].
    """

    class Props(GObject.Object.Props):
        input_hints: InputHints  # [input-hints]: changed because contained invalid characters
        input_purpose: InputPurpose  # [input-purpose]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, input_hints: InputHints = ..., input_purpose: InputPurpose = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def activate_osk(self, event: Gdk.Event | None = None) -> bool: ...
    def delete_surrounding(self, offset: int, n_chars: int) -> bool: ...
    def filter_key(
        self,
        press: bool,
        surface: Gdk.Surface,
        device: Gdk.Device,
        time: int,
        keycode: int,
        state: Gdk.ModifierType,
        group: int,
    ) -> bool: ...
    def filter_keypress(self, event: Gdk.Event) -> bool: ...
    def focus_in(self) -> None: ...
    def focus_out(self) -> None: ...
    def get_preedit_string(self) -> tuple[str, Pango.AttrList, int]: ...
    @deprecated("deprecated")
    def get_surrounding(self) -> tuple[bool, str, int]: ...
    def get_surrounding_with_selection(self) -> tuple[bool, str, int, int]: ...
    def reset(self) -> None: ...
    def set_client_widget(self, widget: Widget | None = None) -> None: ...
    def set_cursor_location(self, area: Gdk.Rectangle) -> None: ...
    @deprecated("deprecated")
    def set_surrounding(self, text: str, len: int, cursor_index: int) -> None: ...
    def set_surrounding_with_selection(self, text: str, len: int, cursor_index: int, anchor_index: int) -> None: ...
    def set_use_preedit(self, use_preedit: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["commit"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["delete-surrounding"],
        handler: typing.Callable[[typing_extensions.Self, int, int], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["preedit-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["preedit-end"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["preedit-start"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["retrieve-surrounding"],
        handler: typing.Callable[..., bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_hints"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_purpose"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class IMContextClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate_osk(self) -> activate_oskIMContextClassCB: ...
    @builtins.property
    def activate_osk_with_event(self) -> activate_osk_with_eventIMContextClassCB: ...
    @builtins.property
    def commit(self) -> commitIMContextClassCB: ...
    @builtins.property
    def delete_surrounding(self) -> delete_surroundingIMContextClassCB: ...
    @builtins.property
    def filter_keypress(self) -> filter_keypressIMContextClassCB: ...
    @builtins.property
    def focus_in(self) -> focus_inIMContextClassCB: ...
    @builtins.property
    def focus_out(self) -> focus_outIMContextClassCB: ...
    @builtins.property
    def get_preedit_string(self) -> get_preedit_stringIMContextClassCB: ...
    @builtins.property
    def get_surrounding(self) -> get_surroundingIMContextClassCB: ...
    @builtins.property
    def get_surrounding_with_selection(self) -> get_surrounding_with_selectionIMContextClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def preedit_changed(self) -> preedit_changedIMContextClassCB: ...
    @builtins.property
    def preedit_end(self) -> preedit_endIMContextClassCB: ...
    @builtins.property
    def preedit_start(self) -> preedit_startIMContextClassCB: ...
    @builtins.property
    def reset(self) -> resetIMContextClassCB: ...
    @builtins.property
    def retrieve_surrounding(self) -> retrieve_surroundingIMContextClassCB: ...
    @builtins.property
    def set_client_widget(self) -> set_client_widgetIMContextClassCB: ...
    @builtins.property
    def set_cursor_location(self) -> set_cursor_locationIMContextClassCB: ...
    @builtins.property
    def set_surrounding(self) -> set_surroundingIMContextClassCB: ...
    @builtins.property
    def set_surrounding_with_selection(self) -> set_surrounding_with_selectionIMContextClassCB: ...
    @builtins.property
    def set_use_preedit(self) -> set_use_preeditIMContextClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IMContextSimple(IMContext):
    """
    Supports compose sequences, dead keys and numeric Unicode input.

    ## Compose sequences

    `GtkIMContextSimple` reads compose sequences from the first of the
    following files that is found: ~/.config/gtk-4.0/Compose, ~/.XCompose,
    /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
    Compose file). A subset of the file syntax described in the Compose(5)
    manual page is supported. Additionally, `include "%L"` loads GTK’s built-in
    table of compose sequences rather than the locale-specific one from X11.

    If none of these files is found, `GtkIMContextSimple` uses a built-in table
    of compose sequences that is derived from the X11 Compose files.

    Note that compose sequences typically start with the Compose_key, which is
    often not available as a dedicated key on keyboards. Keyboard layouts may
    map this keysym to other keys, such as the right Control key.

    ## Unicode characters

    `GtkIMContextSimple` also supports numeric entry of Unicode characters
    by typing <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>u</kbd>, followed by a
    hexadecimal Unicode codepoint.

    For example,

        Ctrl-Shift-u 1 2 3 Enter

    yields U+0123 LATIN SMALL LETTER G WITH CEDILLA, i.e. ģ.

    ## Dead keys

    `GtkIMContextSimple` supports dead keys. For example, typing

        dead_acute a

     yields U+00E! LATIN SMALL LETTER_A WITH ACUTE, i.e. á. Note that this
     depends on the keyboard layout including dead keys.
    """

    # gi Fields
    @builtins.property
    def object(self) -> IMContext | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_compose_file(self, compose_file: str) -> None: ...
    @classmethod
    def new(cls) -> IMContext: ...

class IMContextSimpleClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> IMContextClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IMContextSimplePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IMMulticontext(IMContext):
    """
    Supports switching between multiple input methods.

    Text widgets such as `GtkText` or `GtkTextView` use a `GtkIMMultiContext`
    to implement their `im-module` property for switching between different
    input methods.
    """

    # gi Fields
    @builtins.property
    def object(self) -> IMContext | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_context_id(self) -> str: ...
    @classmethod
    def new(cls) -> IMContext: ...
    def set_context_id(self, context_id: str | None = None) -> None: ...

class IMMulticontextClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> IMContextClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IMMulticontextPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IconPaintable(GObject.Object):
    """
    Contains information found when looking up an icon in `GtkIconTheme`.

    `GtkIconPaintable` implements `GdkPaintable`.
    """

    class Props(GObject.Object.Props):
        file: Gio.File | None
        icon_name: str  # [icon-name]: changed because contained invalid characters
        is_symbolic: bool  # [is-symbolic]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, file: Gio.File | None = ..., icon_name: str = ..., is_symbolic: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_file(self) -> Gio.File | None: ...
    @builtins.property
    def get_icon_name(self) -> str | None: ...
    @builtins.property
    def is_symbolic(self) -> bool: ...
    @classmethod
    def new_for_file(cls, file: Gio.File, size: int, scale: int) -> IconPaintable: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_symbolic"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class IconTheme(GObject.Object):
    """
    Loads themed icons.

    The main reason for using a name rather than simply providing a filename
    is to allow different icons to be used depending on what “icon theme” is
    selected by the user. The operation of icon themes on Linux and Unix
    follows the [Icon Theme Specification](http://www.freedesktop.org/Standards/icon-theme-spec)
    There is a fallback icon theme, named `hicolor`, where applications
    should install their icons, but additional icon themes can be installed
    as operating system vendors and users choose.

    In many cases, named themes are used indirectly, via [class@Gtk.Image]
    rather than directly, but looking up icons directly is also simple. The
    `GtkIconTheme` object acts as a database of all the icons in the current
    theme. You can create new `GtkIconTheme` objects, but it’s much more
    efficient to use the standard icon theme of the `GtkWidget` so that the
    icon information is shared with other people looking up icons.

    ```c
    GtkIconTheme *icon_theme;
    GtkIconPaintable *icon;
    GdkPaintable *paintable;

    icon_theme = gtk_icon_theme_get_for_display (gtk_widget_get_display (my_widget));
    icon = gtk_icon_theme_lookup_icon (icon_theme,
                                       "my-icon-name", // icon name
                                       48, // icon size
                                       1,  // scale
                                       0,  // flags);
    paintable = GDK_PAINTABLE (icon);
    // Use the paintable
    g_object_unref (icon);
    ```
    """

    class Props(GObject.Object.Props):
        display: Gdk.Display | None
        icon_names: list | None  # [icon-names]: changed because contained invalid characters
        resource_path: list | None  # [resource-path]: changed because contained invalid characters
        search_path: list | None  # [search-path]: changed because contained invalid characters
        theme_name: str  # [theme-name]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        display: Gdk.Display | None = ...,
        resource_path: list | None = ...,
        search_path: list | None = ...,
        theme_name: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_resource_path(self, path: str) -> None: ...
    def add_search_path(self, path: str) -> None: ...
    @builtins.property
    def get_display(self) -> Gdk.Display | None: ...
    @staticmethod
    def get_for_display(display: Gdk.Display) -> IconTheme: ...
    @builtins.property
    def get_icon_names(self) -> list: ...
    def get_icon_sizes(self, icon_name: str) -> list: ...
    @builtins.property
    def get_resource_path(self) -> list | None: ...
    @builtins.property
    def get_search_path(self) -> list | None: ...
    @builtins.property
    def get_theme_name(self) -> str: ...
    def has_gicon(self, gicon: Gio.Icon) -> bool: ...
    def has_icon(self, icon_name: str) -> bool: ...
    def lookup_by_gicon(
        self, icon: Gio.Icon, size: int, scale: int, direction: TextDirection, flags: IconLookupFlags
    ) -> IconPaintable: ...
    def lookup_icon(
        self,
        icon_name: str,
        fallbacks: list | None,
        size: int,
        scale: int,
        direction: TextDirection,
        flags: IconLookupFlags,
    ) -> IconPaintable: ...
    @classmethod
    def new(cls) -> IconTheme: ...
    def set_resource_path(self, path: list | None = None) -> None: ...
    def set_search_path(self, path: list | None = None) -> None: ...
    def set_theme_name(self, theme_name: str | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::display"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_names"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resource_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::search_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::theme_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class IconView(Widget):
    """
    `GtkIconView` is a widget which displays data in a grid of icons.

    <picture>
      <source srcset="icon-view-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkIconView" src="icon-view.png">
    </picture>

    `GtkIconView` provides an alternative view on a `GtkTreeModel`.
    It displays the model as a grid of icons with labels. Like
    [class@Gtk.TreeView], it allows to select one or multiple items
    (depending on the selection mode, see [method@Gtk.IconView.set_selection_mode]).
    In addition to selection with the arrow keys, `GtkIconView` supports
    rubberband selection, which is controlled by dragging the pointer.

    Note that if the tree model is backed by an actual tree store (as
    opposed to a flat list where the mapping to icons is obvious),
    `GtkIconView` will only display the first level of the tree and
    ignore the tree’s branches.

    ## CSS nodes

    ```
    iconview.view
    ╰── [rubberband]
    ```

    `GtkIconView` has a single CSS node with name iconview and style class .view.
    For rubberband selection, a subnode with name rubberband is used.
    """

    class Props(Widget.Props):
        activate_on_single_click: bool  # [activate-on-single-click]: changed because contained invalid characters
        cell_area: CellArea | None  # [cell-area]: changed because contained invalid characters
        column_spacing: int  # [column-spacing]: changed because contained invalid characters
        columns: int
        item_orientation: Orientation  # [item-orientation]: changed because contained invalid characters
        item_padding: int  # [item-padding]: changed because contained invalid characters
        item_width: int  # [item-width]: changed because contained invalid characters
        margin: int
        markup_column: int  # [markup-column]: changed because contained invalid characters
        model: TreeModel | None
        pixbuf_column: int  # [pixbuf-column]: changed because contained invalid characters
        reorderable: bool
        row_spacing: int  # [row-spacing]: changed because contained invalid characters
        selection_mode: SelectionMode  # [selection-mode]: changed because contained invalid characters
        spacing: int
        text_column: int  # [text-column]: changed because contained invalid characters
        tooltip_column: int  # [tooltip-column]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        activate_on_single_click: bool = ...,
        cell_area: CellArea | None = ...,
        column_spacing: int = ...,
        columns: int = ...,
        item_orientation: Orientation = ...,
        item_padding: int = ...,
        item_width: int = ...,
        margin: int = ...,
        markup_column: int = ...,
        model: TreeModel | None = ...,
        pixbuf_column: int = ...,
        reorderable: bool = ...,
        row_spacing: int = ...,
        selection_mode: SelectionMode = ...,
        spacing: int = ...,
        text_column: int = ...,
        tooltip_column: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def create_drag_icon(self, path: TreePath) -> Gdk.Paintable | None: ...
    @deprecated("deprecated")
    def enable_model_drag_dest(self, formats: Gdk.ContentFormats, actions: Gdk.DragAction) -> None: ...
    @deprecated("deprecated")
    def enable_model_drag_source(
        self, start_button_mask: Gdk.ModifierType, formats: Gdk.ContentFormats, actions: Gdk.DragAction
    ) -> None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_activate_on_single_click(self) -> bool: ...
    @deprecated("deprecated")
    def get_cell_rect(self, path: TreePath, cell: CellRenderer | None = None) -> tuple[bool, Gdk.Rectangle]: ...
    @deprecated("deprecated")
    @builtins.property
    def get_column_spacing(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_columns(self) -> int: ...
    @deprecated("deprecated")
    def get_cursor(self) -> tuple[bool, TreePath | None, CellRenderer | None]: ...
    @deprecated("deprecated")
    def get_dest_item_at_pos(
        self, drag_x: int, drag_y: int
    ) -> tuple[bool, TreePath | None, IconViewDropPosition | None]: ...
    @deprecated("deprecated")
    def get_drag_dest_item(self) -> tuple[TreePath | None, IconViewDropPosition | None]: ...
    @deprecated("deprecated")
    def get_item_at_pos(self, x: int, y: int) -> tuple[bool, TreePath | None, CellRenderer | None]: ...
    @deprecated("deprecated")
    def get_item_column(self, path: TreePath) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_item_orientation(self) -> Orientation: ...
    @deprecated("deprecated")
    @builtins.property
    def get_item_padding(self) -> int: ...
    @deprecated("deprecated")
    def get_item_row(self, path: TreePath) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_item_width(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_margin(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_markup_column(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_model(self) -> TreeModel | None: ...
    @deprecated("deprecated")
    def get_path_at_pos(self, x: int, y: int) -> TreePath | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_pixbuf_column(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_reorderable(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_row_spacing(self) -> int: ...
    @deprecated("deprecated")
    def get_selected_items(self) -> list: ...
    @deprecated("deprecated")
    @builtins.property
    def get_selection_mode(self) -> SelectionMode: ...
    @deprecated("deprecated")
    @builtins.property
    def get_spacing(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_text_column(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_tooltip_column(self) -> int: ...
    @deprecated("deprecated")
    def get_tooltip_context(
        self, x: int, y: int, keyboard_tip: bool
    ) -> tuple[bool, TreeModel | None, TreePath | None, TreeIter | None]: ...
    @deprecated("deprecated")
    def get_visible_range(self) -> tuple[bool, TreePath | None, TreePath | None]: ...
    @deprecated("deprecated")
    def item_activated(self, path: TreePath) -> None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_area(cls, area: CellArea) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_model(cls, model: TreeModel) -> Widget: ...
    @deprecated("deprecated")
    def path_is_selected(self, path: TreePath) -> bool: ...
    @deprecated("deprecated")
    def scroll_to_path(self, path: TreePath, use_align: bool, row_align: float, col_align: float) -> None: ...
    @deprecated("deprecated")
    def select_all(self) -> None: ...
    @deprecated("deprecated")
    def select_path(self, path: TreePath) -> None: ...
    @deprecated("deprecated")
    def selected_foreach(self, func: IconViewForeachFunc, data: object | None = None) -> None: ...
    @deprecated("deprecated")
    def set_activate_on_single_click(self, single: bool) -> None: ...
    @deprecated("deprecated")
    def set_column_spacing(self, column_spacing: int) -> None: ...
    @deprecated("deprecated")
    def set_columns(self, columns: int) -> None: ...
    @deprecated("deprecated")
    def set_cursor(self, path: TreePath, cell: CellRenderer | None, start_editing: bool) -> None: ...
    @deprecated("deprecated")
    def set_drag_dest_item(self, path: TreePath | None, pos: IconViewDropPosition) -> None: ...
    @deprecated("deprecated")
    def set_item_orientation(self, orientation: Orientation) -> None: ...
    @deprecated("deprecated")
    def set_item_padding(self, item_padding: int) -> None: ...
    @deprecated("deprecated")
    def set_item_width(self, item_width: int) -> None: ...
    @deprecated("deprecated")
    def set_margin(self, margin: int) -> None: ...
    @deprecated("deprecated")
    def set_markup_column(self, column: int) -> None: ...
    @deprecated("deprecated")
    def set_model(self, model: TreeModel | None = None) -> None: ...
    @deprecated("deprecated")
    def set_pixbuf_column(self, column: int) -> None: ...
    @deprecated("deprecated")
    def set_reorderable(self, reorderable: bool) -> None: ...
    @deprecated("deprecated")
    def set_row_spacing(self, row_spacing: int) -> None: ...
    @deprecated("deprecated")
    def set_selection_mode(self, mode: SelectionMode) -> None: ...
    @deprecated("deprecated")
    def set_spacing(self, spacing: int) -> None: ...
    @deprecated("deprecated")
    def set_text_column(self, column: int) -> None: ...
    @deprecated("deprecated")
    def set_tooltip_cell(self, tooltip: Tooltip, path: TreePath, cell: CellRenderer | None = None) -> None: ...
    @deprecated("deprecated")
    def set_tooltip_column(self, column: int) -> None: ...
    @deprecated("deprecated")
    def set_tooltip_item(self, tooltip: Tooltip, path: TreePath) -> None: ...
    @deprecated("deprecated")
    def unselect_all(self) -> None: ...
    @deprecated("deprecated")
    def unselect_path(self, path: TreePath) -> None: ...
    @deprecated("deprecated")
    def unset_model_drag_dest(self) -> None: ...
    @deprecated("deprecated")
    def unset_model_drag_source(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate-cursor-item"],
        handler: typing.Callable[..., bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["item-activated"],
        handler: typing.Callable[[typing_extensions.Self, TreePath], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-cursor"],
        handler: typing.Callable[[typing_extensions.Self, MovementStep, int, bool, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["select-all"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["select-cursor-item"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["selection-changed"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["toggle-cursor-item"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["unselect-all"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activate_on_single_click"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cell_area"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::column_spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::columns"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_orientation"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_padding"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::margin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::markup_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixbuf_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::reorderable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::row_spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selection_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tooltip_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Image(Widget):
    """
    Displays an image.

    picture>
      <source srcset="image-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkImage" src="image.png">
    </picture>

    Various kinds of object can be displayed as an image; most typically,
    you would load a `GdkTexture` from a file, using the convenience function
    [ctor@Gtk.Image.new_from_file], for instance:

    ```c
    GtkWidget *image = gtk_image_new_from_file ("myfile.png");
    ```

    If the file isn’t loaded successfully, the image will contain a
    “broken image” icon similar to that used in many web browsers.

    If you want to handle errors in loading the file yourself,
    for example by displaying an error message, then load the image with
    [ctor@Gdk.Texture.new_from_file], then create the `GtkImage` with
    [ctor@Gtk.Image.new_from_paintable].

    Sometimes an application will want to avoid depending on external data
    files, such as image files. See the documentation of `GResource` inside
    GIO, for details. In this case, [property@Gtk.Image:resource],
    [ctor@Gtk.Image.new_from_resource], and [method@Gtk.Image.set_from_resource]
    should be used.

    `GtkImage` displays its image as an icon, with a size that is determined
    by the application. See [class@Gtk.Picture] if you want to show an image
    at is actual size.

    ## CSS nodes

    `GtkImage` has a single CSS node with the name `image`. The style classes
    `.normal-icons` or `.large-icons` may appear, depending on the
    [property@Gtk.Image:icon-size] property.

    ## Accessibility

    `GtkImage` uses the [enum@Gtk.AccessibleRole.img] role.
    """

    class Props(Widget.Props):
        file: str
        gicon: Gio.Icon | None
        icon_name: str  # [icon-name]: changed because contained invalid characters
        icon_size: IconSize  # [icon-size]: changed because contained invalid characters
        paintable: Gdk.Paintable | None
        pixel_size: int  # [pixel-size]: changed because contained invalid characters
        resource: str
        storage_type: ImageType  # [storage-type]: changed because contained invalid characters
        use_fallback: bool  # [use-fallback]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        file: str = ...,
        gicon: Gio.Icon | None = ...,
        icon_name: str = ...,
        icon_size: IconSize = ...,
        paintable: Gdk.Paintable | None = ...,
        pixel_size: int = ...,
        resource: str = ...,
        use_fallback: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear(self) -> None: ...
    @builtins.property
    def get_gicon(self) -> Gio.Icon | None: ...
    @builtins.property
    def get_icon_name(self) -> str | None: ...
    @builtins.property
    def get_icon_size(self) -> IconSize: ...
    @builtins.property
    def get_paintable(self) -> Gdk.Paintable | None: ...
    @builtins.property
    def get_pixel_size(self) -> int: ...
    @builtins.property
    def get_storage_type(self) -> ImageType: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_from_file(cls, filename: str) -> Widget: ...
    @classmethod
    def new_from_gicon(cls, icon: Gio.Icon) -> Widget: ...
    @classmethod
    def new_from_icon_name(cls, icon_name: str | None = None) -> Widget: ...
    @classmethod
    def new_from_paintable(cls, paintable: Gdk.Paintable | None = None) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_from_pixbuf(cls, pixbuf: GdkPixbuf.Pixbuf | None = None) -> Widget: ...
    @classmethod
    def new_from_resource(cls, resource_path: str) -> Widget: ...
    def set_from_file(self, filename: str | None = None) -> None: ...
    def set_from_gicon(self, icon: Gio.Icon) -> None: ...
    def set_from_icon_name(self, icon_name: str | None = None) -> None: ...
    def set_from_paintable(self, paintable: Gdk.Paintable | None = None) -> None: ...
    @deprecated("deprecated")
    def set_from_pixbuf(self, pixbuf: GdkPixbuf.Pixbuf | None = None) -> None: ...
    def set_from_resource(self, resource_path: str | None = None) -> None: ...
    def set_icon_size(self, icon_size: IconSize) -> None: ...
    def set_pixel_size(self, pixel_size: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gicon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::paintable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixel_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resource"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::storage_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_fallback"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class InfoBar(Widget):
    """
    `GtkInfoBar` can be used to show messages to the user without a dialog.

    <picture>
      <source srcset="info-bar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkInfoBar" src="info-bar.png">
    </picture>

    It is often temporarily shown at the top or bottom of a document.
    In contrast to [class@Gtk.Dialog], which has an action area at the
    bottom, `GtkInfoBar` has an action area at the side.

    The API of `GtkInfoBar` is very similar to `GtkDialog`, allowing you
    to add buttons to the action area with [method@Gtk.InfoBar.add_button]
    or [ctor@Gtk.InfoBar.new_with_buttons]. The sensitivity of action widgets
    can be controlled with [method@Gtk.InfoBar.set_response_sensitive].

    To add widgets to the main content area of a `GtkInfoBar`, use
    [method@Gtk.InfoBar.add_child].

    Similar to [class@Gtk.MessageDialog], the contents of a `GtkInfoBar`
    can by classified as error message, warning, informational message, etc,
    by using [method@Gtk.InfoBar.set_message_type]. GTK may use the message
    type to determine how the message is displayed.

    A simple example for using a `GtkInfoBar`:
    ```c
    GtkWidget *message_label;
    GtkWidget *widget;
    GtkWidget *grid;
    GtkInfoBar *bar;

    // set up info bar
    widget = gtk_info_bar_new ();
    bar = GTK_INFO_BAR (widget);
    grid = gtk_grid_new ();

    message_label = gtk_label_new ("");
    gtk_info_bar_add_child (bar, message_label);
    gtk_info_bar_add_button (bar,
                             _("_OK"),
                             GTK_RESPONSE_OK);
    g_signal_connect (bar,
                      "response",
                      G_CALLBACK (gtk_widget_hide),
                      NULL);
    gtk_grid_attach (GTK_GRID (grid),
                     widget,
                     0, 2, 1, 1);

    // ...

    // show an error message
    gtk_label_set_text (GTK_LABEL (message_label), "An error occurred!");
    gtk_info_bar_set_message_type (bar, GTK_MESSAGE_ERROR);
    gtk_widget_show (bar);
    ```

    # GtkInfoBar as GtkBuildable

    `GtkInfoBar` supports a custom `<action-widgets>` element, which can contain
    multiple `<action-widget>` elements. The “response” attribute specifies a
    numeric response, and the content of the element is the id of widget
    (which should be a child of the dialogs @action_area).

    `GtkInfoBar` supports adding action widgets by specifying “action” as
    the “type” attribute of a `<child>` element. The widget will be added
    either to the action area. The response id has to be associated
    with the action widget using the `<action-widgets>` element.

    # CSS nodes

    `GtkInfoBar` has a single CSS node with name infobar. The node may get
    one of the style classes .info, .warning, .error or .question, depending
    on the message type.
    If the info bar shows a close button, that button will have the .close
    style class applied.
    """

    class Props(Widget.Props):
        message_type: MessageType  # [message-type]: changed because contained invalid characters
        revealed: bool
        show_close_button: bool  # [show-close-button]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, message_type: MessageType = ..., revealed: bool = ..., show_close_button: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_action_widget(self, child: Widget, response_id: int) -> None: ...
    @deprecated("deprecated")
    def add_button(self, button_text: str, response_id: int) -> Button: ...
    @deprecated("deprecated")
    def add_child(self, widget: Widget) -> None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_message_type(self) -> MessageType: ...
    @deprecated("deprecated")
    @builtins.property
    def get_revealed(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_close_button(self) -> bool: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    def remove_action_widget(self, widget: Widget) -> None: ...
    @deprecated("deprecated")
    def remove_child(self, widget: Widget) -> None: ...
    @deprecated("deprecated")
    def response(self, response_id: int) -> None: ...
    @deprecated("deprecated")
    def set_default_response(self, response_id: int) -> None: ...
    @deprecated("deprecated")
    def set_message_type(self, message_type: MessageType) -> None: ...
    @deprecated("deprecated")
    def set_response_sensitive(self, response_id: int, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_revealed(self, revealed: bool) -> None: ...
    @deprecated("deprecated")
    def set_show_close_button(self, setting: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["close"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["response"],
        handler: typing.Callable[[typing_extensions.Self, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::message_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::revealed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_close_button"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Inscription(Widget):
    """
    Shows text in a predefined area.

    You likely want to use `GtkLabel` instead as this widget is intended only
    for a small subset of use cases. The main scenario envisaged is inside lists
    such as `GtkColumnView`.

    While a `GtkLabel` sizes itself depending on the text that is displayed,
    `GtkInscription` is given a size and inscribes the given text into that
    space as well as it can.

    Users of this widget should take care to plan behaviour for the common case
    where the text doesn't fit exactly in the allocated space.

    ## CSS nodes

    `GtkInscription` has a single CSS node with the name label.
    """

    class Props(Widget.Props):
        attributes: Pango.AttrList | None
        markup: str
        min_chars: int  # [min-chars]: changed because contained invalid characters
        min_lines: int  # [min-lines]: changed because contained invalid characters
        nat_chars: int  # [nat-chars]: changed because contained invalid characters
        nat_lines: int  # [nat-lines]: changed because contained invalid characters
        text: str
        text_overflow: InscriptionOverflow  # [text-overflow]: changed because contained invalid characters
        wrap_mode: Pango.WrapMode  # [wrap-mode]: changed because contained invalid characters
        xalign: float
        yalign: float

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        attributes: Pango.AttrList | None = ...,
        markup: str = ...,
        min_chars: int = ...,
        min_lines: int = ...,
        nat_chars: int = ...,
        nat_lines: int = ...,
        text: str = ...,
        text_overflow: InscriptionOverflow = ...,
        wrap_mode: Pango.WrapMode = ...,
        xalign: float = ...,
        yalign: float = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_attributes(self) -> Pango.AttrList | None: ...
    @builtins.property
    def get_min_chars(self) -> int: ...
    @builtins.property
    def get_min_lines(self) -> int: ...
    @builtins.property
    def get_nat_chars(self) -> int: ...
    @builtins.property
    def get_nat_lines(self) -> int: ...
    @builtins.property
    def get_text(self) -> str | None: ...
    @builtins.property
    def get_text_overflow(self) -> InscriptionOverflow: ...
    @builtins.property
    def get_wrap_mode(self) -> Pango.WrapMode: ...
    @builtins.property
    def get_xalign(self) -> float: ...
    @builtins.property
    def get_yalign(self) -> float: ...
    @classmethod
    def new(cls, text: str | None = None) -> Widget: ...
    def set_attributes(self, attrs: Pango.AttrList | None = None) -> None: ...
    def set_markup(self, markup: str | None = None) -> None: ...
    def set_min_chars(self, min_chars: int) -> None: ...
    def set_min_lines(self, min_lines: int) -> None: ...
    def set_nat_chars(self, nat_chars: int) -> None: ...
    def set_nat_lines(self, nat_lines: int) -> None: ...
    def set_text(self, text: str | None = None) -> None: ...
    def set_text_overflow(self, overflow: InscriptionOverflow) -> None: ...
    def set_wrap_mode(self, wrap_mode: Pango.WrapMode) -> None: ...
    def set_xalign(self, xalign: float) -> None: ...
    def set_yalign(self, yalign: float) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::attributes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::markup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_chars"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_lines"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::nat_chars"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::nat_lines"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_overflow"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::xalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::yalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class InscriptionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class KeyvalTrigger(ShortcutTrigger):
    """
    Triggers when a specific keyval and modifiers are pressed.
    """

    class Props(ShortcutTrigger.Props):
        keyval: int
        modifiers: Gdk.ModifierType

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, keyval: int = ..., modifiers: Gdk.ModifierType = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_keyval(self) -> int: ...
    @builtins.property
    def get_modifiers(self) -> Gdk.ModifierType: ...
    @classmethod
    def new(cls, keyval: int, modifiers: Gdk.ModifierType) -> ShortcutTrigger: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::keyval"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modifiers"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class KeyvalTriggerClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Label(Widget):
    """
    Displays a small amount of text.

    Most labels are used to label another widget (such as an [class@Entry]).

    <picture>
      <source srcset="label-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkLabel" src="label.png">
    </picture>

    ## Shortcuts and Gestures

    `GtkLabel` supports the following keyboard shortcuts, when the cursor is
    visible:

    - <kbd>Shift</kbd>+<kbd>F10</kbd> or <kbd>Menu</kbd> opens the context menu.
    - <kbd>Ctrl</kbd>+<kbd>A</kbd> or <kbd>Ctrl</kbd>+<kbd>&sol;</kbd>
      selects all.
    - <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>A</kbd> or
      <kbd>Ctrl</kbd>+<kbd>&bsol;</kbd> unselects all.

    Additionally, the following signals have default keybindings:

    - [signal@Gtk.Label::activate-current-link]
    - [signal@Gtk.Label::copy-clipboard]
    - [signal@Gtk.Label::move-cursor]

    ## Actions

    `GtkLabel` defines a set of built-in actions:

    - `clipboard.copy` copies the text to the clipboard.
    - `clipboard.cut` doesn't do anything, since text in labels can't be deleted.
    - `clipboard.paste` doesn't do anything, since text in labels can't be
      edited.
    - `link.open` opens the link, when activated on a link inside the label.
    - `link.copy` copies the link to the clipboard, when activated on a link
      inside the label.
    - `menu.popup` opens the context menu.
    - `selection.delete` doesn't do anything, since text in labels can't be
      deleted.
    - `selection.select-all` selects all of the text, if the label allows
      selection.

    ## CSS nodes

    ```
    label
    ├── [selection]
    ├── [link]
    ┊
    ╰── [link]
    ```

    `GtkLabel` has a single CSS node with the name label. A wide variety
    of style classes may be applied to labels, such as .title, .subtitle,
    .dim-label, etc. In the `GtkShortcutsWindow`, labels are used with the
    .keycap style class.

    If the label has a selection, it gets a subnode with name selection.

    If the label has links, there is one subnode per link. These subnodes
    carry the link or visited state depending on whether they have been
    visited. In this case, label node also gets a .link style class.

    ## GtkLabel as GtkBuildable

    The GtkLabel implementation of the GtkBuildable interface supports a
    custom `<attributes>` element, which supports any number of `<attribute>`
    elements. The `<attribute>` element has attributes named “name“, “value“,
    “start“ and “end“ and allows you to specify [struct@Pango.Attribute]
    values for this label.

    An example of a UI definition fragment specifying Pango attributes:

    ```xml
    <object class="GtkLabel">
      <attributes>
        <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
        <attribute name="background" value="red" start="5" end="10"/>
      </attributes>
    </object>
    ```

    The start and end attributes specify the range of characters to which the
    Pango attribute applies. If start and end are not specified, the attribute is
    applied to the whole text. Note that specifying ranges does not make much
    sense with translatable attributes. Use markup embedded in the translatable
    content instead.

    ## Accessibility

    `GtkLabel` uses the [enum@Gtk.AccessibleRole.label] role.

    ## Mnemonics

    Labels may contain “mnemonics”. Mnemonics are underlined characters in the
    label, used for keyboard navigation. Mnemonics are created by providing a
    string with an underscore before the mnemonic character, such as `"_File"`,
    to the functions [ctor@Gtk.Label.new_with_mnemonic] or
    [method@Gtk.Label.set_text_with_mnemonic].

    Mnemonics automatically activate any activatable widget the label is
    inside, such as a [class@Gtk.Button]; if the label is not inside the
    mnemonic’s target widget, you have to tell the label about the target
    using [method@Gtk.Label.set_mnemonic_widget].

    Here’s a simple example where the label is inside a button:

    ```c
    // Pressing Alt+H will activate this button
    GtkWidget *button = gtk_button_new ();
    GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
    gtk_button_set_child (GTK_BUTTON (button), label);
    ```

    There’s a convenience function to create buttons with a mnemonic label
    already inside:

    ```c
    // Pressing Alt+H will activate this button
    GtkWidget *button = gtk_button_new_with_mnemonic ("_Hello");
    ```

    To create a mnemonic for a widget alongside the label, such as a
    [class@Gtk.Entry], you have to point the label at the entry with
    [method@Gtk.Label.set_mnemonic_widget]:

    ```c
    // Pressing Alt+H will focus the entry
    GtkWidget *entry = gtk_entry_new ();
    GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
    gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry);
    ```

    ## Markup (styled text)

    To make it easy to format text in a label (changing colors, fonts, etc.),
    label text can be provided in a simple markup format:

    Here’s how to create a label with a small font:
    ```c
    GtkWidget *label = gtk_label_new (NULL);
    gtk_label_set_markup (GTK_LABEL (label), "<small>Small text</small>");
    ```

    (See the Pango manual for complete documentation] of available
    tags, [func@Pango.parse_markup])

    The markup passed to [method@Gtk.Label.set_markup] must be valid XML; for example,
    literal `<`, `>` and `&` characters must be escaped as `&lt;`, `&gt;`, and `&amp;`.
    If you pass text obtained from the user, file, or a network to
    [method@Gtk.Label.set_markup], you’ll want to escape it with
    [func@GLib.markup_escape_text] or [func@GLib.markup_printf_escaped].

    Markup strings are just a convenient way to set the [struct@Pango.AttrList]
    on a label; [method@Gtk.Label.set_attributes] may be a simpler way to set
    attributes in some cases. Be careful though; [struct@Pango.AttrList] tends
    to cause internationalization problems, unless you’re applying attributes
    to the entire string (i.e. unless you set the range of each attribute
    to [0, `G_MAXINT`)). The reason is that specifying the `start_index` and
    `end_index` for a [struct@Pango.Attribute] requires knowledge of the exact
    string being displayed, so translations will cause problems.

    ## Selectable labels

    Labels can be made selectable with [method@Gtk.Label.set_selectable].
    Selectable labels allow the user to copy the label contents to the
    clipboard. Only labels that contain useful-to-copy information — such
    as error messages — should be made selectable.

    ## Text layout

    A label can contain any number of paragraphs, but will have
    performance problems if it contains more than a small number.
    Paragraphs are separated by newlines or other paragraph separators
    understood by Pango.

    Labels can automatically wrap text if you call [method@Gtk.Label.set_wrap].

    [method@Gtk.Label.set_justify] sets how the lines in a label align
    with one another. If you want to set how the label as a whole aligns
    in its available space, see the [property@Gtk.Widget:halign] and
    [property@Gtk.Widget:valign] properties.

    The [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
    properties can be used to control the size allocation of ellipsized or
    wrapped labels. For ellipsizing labels, if either is specified (and less
    than the actual text size), it is used as the minimum width, and the actual
    text size is used as the natural width of the label. For wrapping labels,
    width-chars is used as the minimum width, if specified, and max-width-chars
    is used as the natural width. Even if max-width-chars specified, wrapping
    labels will be rewrapped to use all of the available width.

    ## Links

    GTK supports markup for clickable hyperlinks in addition to regular Pango
    markup. The markup for links is borrowed from HTML, using the `<a>` tag
    with “href“, “title“ and “class“ attributes. GTK renders links similar to
    the way they appear in web browsers, with colored, underlined text. The
    “title“ attribute is displayed as a tooltip on the link. The “class“
    attribute is used as style class on the CSS node for the link.

    An example of inline links looks like this:

    ```c
    const char *text =
    "Go to the "
    "<a href="https://www.gtk.org" title="&lt;i&gt;Our&lt;/i&gt; website">"
    "GTK website</a> for more...";
    GtkWidget *label = gtk_label_new (NULL);
    gtk_label_set_markup (GTK_LABEL (label), text);
    ```

    It is possible to implement custom handling for links and their tooltips
    with the [signal@Gtk.Label::activate-link] signal and the
    [method@Gtk.Label.get_current_uri] function.
    """

    class Props(Widget.Props):
        attributes: Pango.AttrList | None
        ellipsize: Pango.EllipsizeMode
        extra_menu: Gio.MenuModel | None  # [extra-menu]: changed because contained invalid characters
        justify: Justification
        label: str
        lines: int
        max_width_chars: int  # [max-width-chars]: changed because contained invalid characters
        mnemonic_keyval: int  # [mnemonic-keyval]: changed because contained invalid characters
        mnemonic_widget: Widget | None  # [mnemonic-widget]: changed because contained invalid characters
        natural_wrap_mode: NaturalWrapMode  # [natural-wrap-mode]: changed because contained invalid characters
        selectable: bool
        single_line_mode: bool  # [single-line-mode]: changed because contained invalid characters
        tabs: Pango.TabArray | None
        use_markup: bool  # [use-markup]: changed because contained invalid characters
        use_underline: bool  # [use-underline]: changed because contained invalid characters
        width_chars: int  # [width-chars]: changed because contained invalid characters
        wrap: bool
        wrap_mode: Pango.WrapMode  # [wrap-mode]: changed because contained invalid characters
        xalign: float
        yalign: float

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        attributes: Pango.AttrList | None = ...,
        ellipsize: Pango.EllipsizeMode = ...,
        extra_menu: Gio.MenuModel | None = ...,
        justify: Justification = ...,
        label: str = ...,
        lines: int = ...,
        max_width_chars: int = ...,
        mnemonic_widget: Widget | None = ...,
        natural_wrap_mode: NaturalWrapMode = ...,
        selectable: bool = ...,
        single_line_mode: bool = ...,
        tabs: Pango.TabArray | None = ...,
        use_markup: bool = ...,
        use_underline: bool = ...,
        width_chars: int = ...,
        wrap: bool = ...,
        wrap_mode: Pango.WrapMode = ...,
        xalign: float = ...,
        yalign: float = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_attributes(self) -> Pango.AttrList | None: ...
    def get_current_uri(self) -> str | None: ...
    @builtins.property
    def get_ellipsize(self) -> Pango.EllipsizeMode: ...
    @builtins.property
    def get_extra_menu(self) -> Gio.MenuModel | None: ...
    @builtins.property
    def get_justify(self) -> Justification: ...
    @builtins.property
    def get_label(self) -> str: ...
    def get_layout(self) -> Pango.Layout: ...
    def get_layout_offsets(self) -> tuple[int | None, int | None]: ...
    @builtins.property
    def get_lines(self) -> int: ...
    @builtins.property
    def get_max_width_chars(self) -> int: ...
    @builtins.property
    def get_mnemonic_keyval(self) -> int: ...
    @builtins.property
    def get_mnemonic_widget(self) -> Widget | None: ...
    @builtins.property
    def get_natural_wrap_mode(self) -> NaturalWrapMode: ...
    @builtins.property
    def get_selectable(self) -> bool: ...
    def get_selection_bounds(self) -> tuple[bool, int | None, int | None]: ...
    @builtins.property
    def get_single_line_mode(self) -> bool: ...
    @builtins.property
    def get_tabs(self) -> Pango.TabArray | None: ...
    def get_text(self) -> str: ...
    @builtins.property
    def get_use_markup(self) -> bool: ...
    @builtins.property
    def get_use_underline(self) -> bool: ...
    @builtins.property
    def get_width_chars(self) -> int: ...
    @builtins.property
    def get_wrap(self) -> bool: ...
    @builtins.property
    def get_wrap_mode(self) -> Pango.WrapMode: ...
    @builtins.property
    def get_xalign(self) -> float: ...
    @builtins.property
    def get_yalign(self) -> float: ...
    @classmethod
    def new(cls, str: str | None = None) -> Widget: ...
    @classmethod
    def new_with_mnemonic(cls, str: str | None = None) -> Widget: ...
    def select_region(self, start_offset: int, end_offset: int) -> None: ...
    def set_attributes(self, attrs: Pango.AttrList | None = None) -> None: ...
    def set_ellipsize(self, mode: Pango.EllipsizeMode) -> None: ...
    def set_extra_menu(self, model: Gio.MenuModel | None = None) -> None: ...
    def set_justify(self, jtype: Justification) -> None: ...
    def set_label(self, str: str) -> None: ...
    def set_lines(self, lines: int) -> None: ...
    def set_markup(self, str: str) -> None: ...
    def set_markup_with_mnemonic(self, str: str) -> None: ...
    def set_max_width_chars(self, n_chars: int) -> None: ...
    def set_mnemonic_widget(self, widget: Widget | None = None) -> None: ...
    def set_natural_wrap_mode(self, wrap_mode: NaturalWrapMode) -> None: ...
    def set_selectable(self, setting: bool) -> None: ...
    def set_single_line_mode(self, single_line_mode: bool) -> None: ...
    def set_tabs(self, tabs: Pango.TabArray | None = None) -> None: ...
    def set_text(self, str: str) -> None: ...
    def set_text_with_mnemonic(self, str: str) -> None: ...
    def set_use_markup(self, setting: bool) -> None: ...
    def set_use_underline(self, setting: bool) -> None: ...
    def set_width_chars(self, n_chars: int) -> None: ...
    def set_wrap(self, wrap: bool) -> None: ...
    def set_wrap_mode(self, wrap_mode: Pango.WrapMode) -> None: ...
    def set_xalign(self, xalign: float) -> None: ...
    def set_yalign(self, yalign: float) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate-current-link"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate-link"],
        handler: typing.Callable[[typing_extensions.Self, str], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["copy-clipboard"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-cursor"],
        handler: typing.Callable[[typing_extensions.Self, MovementStep, int, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::attributes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ellipsize"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::extra_menu"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::justify"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::lines"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_width_chars"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mnemonic_keyval"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mnemonic_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::natural_wrap_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selectable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::single_line_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tabs"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_markup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_underline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::width_chars"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::xalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::yalign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class LayoutChild(GObject.Object):
    """
    The base class for objects that are meant to hold layout properties.

    If a `GtkLayoutManager` has per-child properties, like their packing type,
    or the horizontal and vertical span, or the icon name, then the layout
    manager should use a `GtkLayoutChild` implementation to store those properties.

    A `GtkLayoutChild` instance is only ever valid while a widget is part
    of a layout.
    """

    class Props(GObject.Object.Props):
        child_widget: Widget | None  # [child-widget]: changed because contained invalid characters
        layout_manager: LayoutManager | None  # [layout-manager]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, child_widget: Widget | None = ..., layout_manager: LayoutManager | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child_widget(self) -> Widget: ...
    @builtins.property
    def get_layout_manager(self) -> LayoutManager: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::layout_manager"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class LayoutChildClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class LayoutManager(GObject.Object):
    """
    Handles the preferred size and allocation for children of a widget.

    You typically subclass `GtkLayoutManager` if you want to implement a
    layout policy for the children of a widget, or if you want to determine
    the size of a widget depending on its contents.

    Each `GtkWidget` can only have a `GtkLayoutManager` instance associated
    to it at any given time; it is possible, though, to replace the layout
    manager instance using [method@Gtk.Widget.set_layout_manager].

    ## Layout properties

    A layout manager can expose properties for controlling the layout of
    each child, by creating an object type derived from [class@Gtk.LayoutChild]
    and installing the properties on it as normal `GObject` properties.

    Each `GtkLayoutChild` instance storing the layout properties for a
    specific child is created through the [method@Gtk.LayoutManager.get_layout_child]
    method; a `GtkLayoutManager` controls the creation of its `GtkLayoutChild`
    instances by overriding the GtkLayoutManagerClass.create_layout_child()
    virtual function. The typical implementation should look like:

    ```c
    static GtkLayoutChild *
    create_layout_child (GtkLayoutManager *manager,
                         GtkWidget        *container,
                         GtkWidget        *child)
    {
      return g_object_new (your_layout_child_get_type (),
                           "layout-manager", manager,
                           "child-widget", child,
                           NULL);
    }
    ```

    The [property@Gtk.LayoutChild:layout-manager] and
    [property@Gtk.LayoutChild:child-widget] properties
    on the newly created `GtkLayoutChild` instance are mandatory. The
    `GtkLayoutManager` will cache the newly created `GtkLayoutChild` instance
    until the widget is removed from its parent, or the parent removes the
    layout manager.

    Each `GtkLayoutManager` instance creating a `GtkLayoutChild` should use
    [method@Gtk.LayoutManager.get_layout_child] every time it needs to query
    the layout properties; each `GtkLayoutChild` instance should call
    [method@Gtk.LayoutManager.layout_changed] every time a property is
    updated, in order to queue a new size measuring and allocation.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def allocate(self, widget: Widget, width: int, height: int, baseline: int) -> None: ...
    def get_layout_child(self, child: Widget) -> LayoutChild: ...
    def get_request_mode(self) -> SizeRequestMode: ...
    def get_widget(self) -> Widget | None: ...
    def layout_changed(self) -> None: ...
    def measure(
        self, widget: Widget, orientation: Orientation, for_size: int
    ) -> tuple[int | None, int | None, int | None, int | None]: ...

    # python methods (overrides?)
    def do_allocate(
        self,
        widget: Widget,
        width: int,
        height: int,
        baseline: int,
    ) -> None:
        """
        allocate(self, widget:Gtk.Widget, width:int, height:int, baseline:int)
        """
    def do_create_layout_child(
        self,
        widget: Widget,
        for_child: Widget,
    ) -> LayoutChild:
        """
        create_layout_child(self, widget:Gtk.Widget, for_child:Gtk.Widget) -> Gtk.LayoutChild
        """
    def do_get_request_mode(
        self,
        widget: Widget,
    ) -> SizeRequestMode:
        """
        get_request_mode(self, widget:Gtk.Widget) -> Gtk.SizeRequestMode
        """
    def do_measure(
        self,
        widget: Widget,
        orientation: Orientation,
        for_size: int,
    ) -> tuple:
        """
        measure(self, widget:Gtk.Widget, orientation:Gtk.Orientation, for_size:int) -> minimum:int, natural:int, minimum_baseline:int, natural_baseline:int
        """
    def do_root(
        self,
    ) -> None:
        """
        root(self)
        """
    def do_unroot(
        self,
    ) -> None:
        """
        unroot(self)
        """

class LayoutManagerClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def allocate(self) -> allocateLayoutManagerClassCB: ...
    @builtins.property
    def create_layout_child(self) -> create_layout_childLayoutManagerClassCB: ...
    @builtins.property
    def get_request_mode(self) -> get_request_modeLayoutManagerClassCB: ...
    @builtins.property
    def layout_child_type(self) -> GObject.GType: ...
    @builtins.property
    def measure(self) -> measureLayoutManagerClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def root(self) -> rootLayoutManagerClassCB: ...
    @builtins.property
    def unroot(self) -> unrootLayoutManagerClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class LevelBar(Widget):
    """
    Shows a level indicator.

    Typical use cases are displaying the strength of a password, or
    showing the charge level of a battery.

    <picture>
      <source srcset="levelbar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkLevelBar" src="levelbar.png">
    </picture>

    Use [method@Gtk.LevelBar.set_value] to set the current value, and
    [method@Gtk.LevelBar.add_offset_value] to set the value offsets at which
    the bar will be considered in a different state. GTK will add a few
    offsets by default on the level bar: %GTK_LEVEL_BAR_OFFSET_LOW,
    %GTK_LEVEL_BAR_OFFSET_HIGH and %GTK_LEVEL_BAR_OFFSET_FULL, with
    values 0.25, 0.75 and 1.0 respectively.

    Note that it is your responsibility to update preexisting offsets
    when changing the minimum or maximum value. GTK will simply clamp
    them to the new range.

    ## Adding a custom offset on the bar

    ```c
    static GtkWidget *
    create_level_bar (void)
    {
      GtkWidget *widget;
      GtkLevelBar *bar;

      widget = gtk_level_bar_new ();
      bar = GTK_LEVEL_BAR (widget);

      // This changes the value of the default low offset

      gtk_level_bar_add_offset_value (bar,
                                      GTK_LEVEL_BAR_OFFSET_LOW,
                                      0.10);

      // This adds a new offset to the bar; the application will
      // be able to change its color CSS like this:
      //
      // levelbar block.my-offset {
      //   background-color: magenta;
      //   border-style: solid;
      //   border-color: black;
      //   border-width: 1px;
      // }

      gtk_level_bar_add_offset_value (bar, "my-offset", 0.60);

      return widget;
    }
    ```

    The default interval of values is between zero and one, but it’s possible
    to modify the interval using [method@Gtk.LevelBar.set_min_value] and
    [method@Gtk.LevelBar.set_max_value]. The value will be always drawn in
    proportion to the admissible interval, i.e. a value of 15 with a specified
    interval between 10 and 20 is equivalent to a value of 0.5 with an interval
    between 0 and 1. When %GTK_LEVEL_BAR_MODE_DISCRETE is used, the bar level
    is rendered as a finite number of separated blocks instead of a single one.
    The number of blocks that will be rendered is equal to the number of units
    specified by the admissible interval.

    For instance, to build a bar rendered with five blocks, it’s sufficient to
    set the minimum value to 0 and the maximum value to 5 after changing the
    indicator mode to discrete.

    # GtkLevelBar as GtkBuildable

    The `GtkLevelBar` implementation of the `GtkBuildable` interface supports a
    custom `<offsets>` element, which can contain any number of `<offset>` elements,
    each of which must have "name" and "value" attributes.

    # CSS nodes

    ```
    levelbar[.discrete]
    ╰── trough
        ├── block.filled.level-name
        ┊
        ├── block.empty
        ┊
    ```

    `GtkLevelBar` has a main CSS node with name levelbar and one of the style
    classes .discrete or .continuous and a subnode with name trough. Below the
    trough node are a number of nodes with name block and style class .filled
    or .empty. In continuous mode, there is exactly one node of each, in discrete
    mode, the number of filled and unfilled nodes corresponds to blocks that are
    drawn. The block.filled nodes also get a style class .level-name corresponding
    to the level for the current value.

    In horizontal orientation, the nodes are always arranged from left to right,
    regardless of text direction.

    # Accessibility

    `GtkLevelBar` uses the [enum@Gtk.AccessibleRole.meter] role.
    """

    class Props(Widget.Props):
        inverted: bool
        max_value: float  # [max-value]: changed because contained invalid characters
        min_value: float  # [min-value]: changed because contained invalid characters
        mode: LevelBarMode
        value: float

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        inverted: bool = ...,
        max_value: float = ...,
        min_value: float = ...,
        mode: LevelBarMode = ...,
        value: float = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_offset_value(self, name: str, value: float) -> None: ...
    @builtins.property
    def get_inverted(self) -> bool: ...
    @builtins.property
    def get_max_value(self) -> float: ...
    @builtins.property
    def get_min_value(self) -> float: ...
    @builtins.property
    def get_mode(self) -> LevelBarMode: ...
    def get_offset_value(self, name: str | None = None) -> tuple[bool, float]: ...
    @builtins.property
    def get_value(self) -> float: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_for_interval(cls, min_value: float, max_value: float) -> Widget: ...
    def remove_offset_value(self, name: str | None = None) -> None: ...
    def set_inverted(self, inverted: bool) -> None: ...
    def set_max_value(self, value: float) -> None: ...
    def set_min_value(self, value: float) -> None: ...
    def set_mode(self, mode: LevelBarMode) -> None: ...
    def set_value(self, value: float) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["offset-changed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inverted"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_value"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_value"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::value"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class LinkButton(Button):
    """
    A button with a hyperlink.

    <picture>
      <source srcset="link-button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkLinkButton" src="link-button.png">
    </picture>

    It is useful to show quick links to resources.

    A link button is created by calling either [ctor@Gtk.LinkButton.new] or
    [ctor@Gtk.LinkButton.new_with_label]. If using the former, the URI you
    pass to the constructor is used as a label for the widget.

    The URI bound to a `GtkLinkButton` can be set specifically using
    [method@Gtk.LinkButton.set_uri].

    By default, `GtkLinkButton` calls [method@Gtk.FileLauncher.launch] when the button
    is clicked. This behaviour can be overridden by connecting to the
    [signal@Gtk.LinkButton::activate-link] signal and returning %TRUE from
    the signal handler.

    # Shortcuts and Gestures

    `GtkLinkButton` supports the following keyboard shortcuts:

    - <kbd>Shift</kbd>+<kbd>F10</kbd> or <kbd>Menu</kbd> opens the context menu.

    # Actions

    `GtkLinkButton` defines a set of built-in actions:

    - `clipboard.copy` copies the url to the clipboard.
    - `menu.popup` opens the context menu.

    # CSS nodes

    `GtkLinkButton` has a single CSS node with name button. To differentiate
    it from a plain `GtkButton`, it gets the .link style class.

    # Accessibility

    `GtkLinkButton` uses the [enum@Gtk.AccessibleRole.link] role.
    """

    class Props(Button.Props):
        uri: str
        visited: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, uri: str = ..., visited: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_uri(self) -> str: ...
    @builtins.property
    def get_visited(self) -> bool: ...
    @classmethod
    def new(cls, uri: str) -> Widget: ...
    @classmethod
    def new_with_label(cls, uri: str, label: str | None = None) -> Widget: ...
    def set_uri(self, uri: str) -> None: ...
    def set_visited(self, visited: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate-link"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visited"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ListBase(Widget):
    """
    The abstract base class for GTK's list widgets.

    # Shortcuts and Gestures

    `GtkListBase` supports the following keyboard shortcuts:

    - <kbd>Ctrl</kbd>+<kbd>A</kbd> or <kbd>Ctrl</kbd>+<kbd>&sol;</kbd>
      selects all items.
    - <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>A</kbd> or
      <kbd>Ctrl</kbd>+<kbd>&bsol;</kbd> unselects all items.

    The focused item is controlled by the navigation keys below, combined
    with the <kbd>Ctrl</kbd> modifier to prevent moving the selection,
    and the <kbd>Shift</kbd> modifier to extend the current selection.

    - <kbd>←</kbd>, <kbd>→</kbd>, <kbd>↑</kbd>, <kbd>↓</kbd> move the focus
      on the next item in the designed direction.
    - <kbd>Home</kbd> and <kbd>End</kbd> focus the first or last item.
    - <kbd>PgUp</kbd> and <kbd>PgDn</kbd> move the focus one page up or down.

    List item widgets support the following keyboard shortcuts:

    - <kbd>Enter</kbd> activates the item.
    - <kbd>␣</kbd> selects the item, with the same <kbd>Ctrl</kbd> and
      <kbd>Shift</kbd> modifiers combinations as the navigation keys.

    # Actions

    `GtkListBase` defines a set of built-in actions:

    - `list.scroll-to-item` moves the visible area to the item at given position
      with the minimum amount of scrolling required. If the item is already
      visible, nothing happens.
    - `list.select-item` changes the selection.
    - `list.select-all` selects all items in the model, if the selection model
      supports it.
    - `list.unselect-all` unselects all items in the model, if the selection
      model supports it.

    List item widgets install the following actions:

    - `listitem.select` changes selection if the item is selectable.
    - `listitem.scroll-to` moves the visible area of the list to this item with
      the minimum amount of scrolling required.
    """

    class Props(Widget.Props):
        orientation: Orientation

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, orientation: Orientation = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::orientation"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ListBaseClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListBox(Widget):
    """
    Shows a vertical list.

    <picture>
      <source srcset="list-box-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkListBox" src="list-box.png">
    </picture>

    A `GtkListBox` only contains `GtkListBoxRow` children. These rows can
    by dynamically sorted and filtered, and headers can be added dynamically
    depending on the row content. It also allows keyboard and mouse navigation
    and selection like a typical list.

    Using `GtkListBox` is often an alternative to `GtkTreeView`, especially
    when the list contents has a more complicated layout than what is allowed
    by a `GtkCellRenderer`, or when the contents is interactive (i.e. has a
    button in it).

    Although a `GtkListBox` must have only `GtkListBoxRow` children, you can
    add any kind of widget to it via [method@Gtk.ListBox.prepend],
    [method@Gtk.ListBox.append] and [method@Gtk.ListBox.insert] and a
    `GtkListBoxRow` widget will automatically be inserted between the list
    and the widget.

    `GtkListBoxRows` can be marked as activatable or selectable. If a row is
    activatable, [signal@Gtk.ListBox::row-activated] will be emitted for it when
    the user tries to activate it. If it is selectable, the row will be marked
    as selected when the user tries to select it.

    # GtkListBox as GtkBuildable

    The `GtkListBox` implementation of the `GtkBuildable` interface supports
    setting a child as the placeholder by specifying “placeholder” as the “type”
    attribute of a `<child>` element. See [method@Gtk.ListBox.set_placeholder]
    for info.

    # Shortcuts and Gestures

    The following signals have default keybindings:

    - [signal@Gtk.ListBox::move-cursor]
    - [signal@Gtk.ListBox::select-all]
    - [signal@Gtk.ListBox::toggle-cursor-row]
    - [signal@Gtk.ListBox::unselect-all]

    # CSS nodes

    ```
    list[.separators][.rich-list][.navigation-sidebar][.boxed-list]
    ╰── row[.activatable]
    ```

    `GtkListBox` uses a single CSS node named list. It may carry the .separators
    style class, when the [property@Gtk.ListBox:show-separators] property is set.
    Each `GtkListBoxRow` uses a single CSS node named row. The row nodes get the
    .activatable style class added when appropriate.

    It may also carry the .boxed-list style class. In this case, the list will be
    automatically surrounded by a frame and have separators.

    The main list node may also carry style classes to select
    the style of [list presentation](section-list-widget.html#list-styles):
    .rich-list, .navigation-sidebar or .data-table.

    # Accessibility

    `GtkListBox` uses the [enum@Gtk.AccessibleRole.list] role and `GtkListBoxRow` uses
    the [enum@Gtk.AccessibleRole.list_item] role.
    """

    class Props(Widget.Props):
        accept_unpaired_release: bool  # [accept-unpaired-release]: changed because contained invalid characters
        activate_on_single_click: bool  # [activate-on-single-click]: changed because contained invalid characters
        selection_mode: SelectionMode  # [selection-mode]: changed because contained invalid characters
        show_separators: bool  # [show-separators]: changed because contained invalid characters
        tab_behavior: ListTabBehavior  # [tab-behavior]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accept_unpaired_release: bool = ...,
        activate_on_single_click: bool = ...,
        selection_mode: SelectionMode = ...,
        show_separators: bool = ...,
        tab_behavior: ListTabBehavior = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, child: Widget) -> None: ...
    def bind_model(
        self,
        model: Gio.ListModel | None,
        create_widget_func: ListBoxCreateWidgetFunc | None,
        user_data: object | None,
        user_data_free_func: GLib.DestroyNotify,
    ) -> None: ...
    def drag_highlight_row(self, row: ListBoxRow) -> None: ...
    def drag_unhighlight_row(self) -> None: ...
    @builtins.property
    def get_activate_on_single_click(self) -> bool: ...
    def get_adjustment(self) -> Adjustment | None: ...
    def get_row_at_index(self, index_: int) -> ListBoxRow | None: ...
    def get_row_at_y(self, y: int) -> ListBoxRow | None: ...
    def get_selected_row(self) -> ListBoxRow | None: ...
    def get_selected_rows(self) -> list: ...
    @builtins.property
    def get_selection_mode(self) -> SelectionMode: ...
    @builtins.property
    def get_show_separators(self) -> bool: ...
    @builtins.property
    def get_tab_behavior(self) -> ListTabBehavior: ...
    def insert(self, child: Widget, position: int) -> None: ...
    def invalidate_filter(self) -> None: ...
    def invalidate_headers(self) -> None: ...
    def invalidate_sort(self) -> None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def prepend(self, child: Widget) -> None: ...
    def remove(self, child: Widget) -> None: ...
    def remove_all(self) -> None: ...
    def select_all(self) -> None: ...
    def select_row(self, row: ListBoxRow | None = None) -> None: ...
    def selected_foreach(self, func: ListBoxForeachFunc, data: object | None = None) -> None: ...
    def set_activate_on_single_click(self, single: bool) -> None: ...
    def set_adjustment(self, adjustment: Adjustment | None = None) -> None: ...
    def set_filter_func(
        self, filter_func: ListBoxFilterFunc | None, user_data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...
    def set_header_func(
        self, update_header: ListBoxUpdateHeaderFunc | None, user_data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...
    def set_placeholder(self, placeholder: Widget | None = None) -> None: ...
    def set_selection_mode(self, mode: SelectionMode) -> None: ...
    def set_show_separators(self, show_separators: bool) -> None: ...
    def set_sort_func(
        self, sort_func: ListBoxSortFunc | None, user_data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...
    def set_tab_behavior(self, behavior: ListTabBehavior) -> None: ...
    def unselect_all(self) -> None: ...
    def unselect_row(self, row: ListBoxRow) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate-cursor-row"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-cursor"],
        handler: typing.Callable[[typing_extensions.Self, MovementStep, int, bool, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["row-activated"],
        handler: typing.Callable[[typing_extensions.Self, ListBoxRow], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["row-selected"],
        handler: typing.Callable[[typing_extensions.Self, ListBoxRow | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["select-all"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["selected-rows-changed"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["toggle-cursor-row"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["unselect-all"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accept_unpaired_release"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activate_on_single_click"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selection_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_separators"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tab_behavior"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ListBoxRow(Widget):
    """
    The kind of widget that can be added to a `GtkListBox`.

    [class@Gtk.ListBox] will automatically wrap its children in a `GtkListboxRow`
    when necessary.
    """

    class Props(Widget.Props):
        activatable: bool
        child: Widget | None
        selectable: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, activatable: bool = ..., child: Widget | None = ..., selectable: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def changed(self) -> None: ...
    @builtins.property
    def get_activatable(self) -> bool: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    def get_header(self) -> Widget | None: ...
    def get_index(self) -> int: ...
    @builtins.property
    def get_selectable(self) -> bool: ...
    def is_selected(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_activatable(self, activatable: bool) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_header(self, header: Widget | None = None) -> None: ...
    def set_selectable(self, selectable: bool) -> None: ...

    # python methods (overrides?)
    def do_activate(
        self,
    ) -> None:
        """
        activate(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activatable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selectable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ListBoxRowClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate(self) -> activateListBoxRowClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListHeader(GObject.Object):
    """
    Used by list widgets to represent the headers they display.

    `GtkListHeader` objects are managed just like [class@Gtk.ListItem]
    objects via their factory, but provide a different set of properties suitable
    for managing the header instead of individual items.
    """

    class Props(GObject.Object.Props):
        child: Widget | None
        end: int
        item: GObject.Object | None
        n_items: int  # [n-items]: changed because contained invalid characters
        start: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, child: Widget | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_end(self) -> int: ...
    @builtins.property
    def get_item(self) -> GObject.Object | None: ...
    @builtins.property
    def get_n_items(self) -> int: ...
    @builtins.property
    def get_start(self) -> int: ...
    def set_child(self, child: Widget | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::end"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::start"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ListHeaderClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListItem(GObject.Object):
    """
    Used by list widgets to represent items in a [iface@Gio.ListModel].

    `GtkListItem` objects are managed by the list widget (with its factory)
    and cannot be created by applications, but they need to be populated
    by application code. This is done by calling [method@Gtk.ListItem.set_child].

    `GtkListItem` objects exist in 2 stages:

    1. The unbound stage where the listitem is not currently connected to
       an item in the list. In that case, the [property@Gtk.ListItem:item]
       property is set to `NULL`.

    2. The bound stage where the listitem references an item from the list.
       The [property@Gtk.ListItem:item] property is not `NULL`.
    """

    class Props(GObject.Object.Props):
        accessible_description: str  # [accessible-description]: changed because contained invalid characters
        accessible_label: str  # [accessible-label]: changed because contained invalid characters
        activatable: bool
        child: Widget | None
        focusable: bool
        item: GObject.Object | None
        position: int
        selectable: bool
        selected: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accessible_description: str = ...,
        accessible_label: str = ...,
        activatable: bool = ...,
        child: Widget | None = ...,
        focusable: bool = ...,
        selectable: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_accessible_description(self) -> str: ...
    @builtins.property
    def get_accessible_label(self) -> str: ...
    @builtins.property
    def get_activatable(self) -> bool: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_focusable(self) -> bool: ...
    @builtins.property
    def get_item(self) -> GObject.Object | None: ...
    @builtins.property
    def get_position(self) -> int: ...
    @builtins.property
    def get_selectable(self) -> bool: ...
    @builtins.property
    def get_selected(self) -> bool: ...
    def set_accessible_description(self, description: str) -> None: ...
    def set_accessible_label(self, label: str) -> None: ...
    def set_activatable(self, activatable: bool) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_focusable(self, focusable: bool) -> None: ...
    def set_selectable(self, selectable: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accessible_description"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accessible_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activatable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::focusable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selectable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selected"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ListItemClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListItemFactory(GObject.Object):
    """
    Creates widgets for the items taken from a `GListModel`.

    This is one of the core concepts of handling list widgets such
    as [class@Gtk.ListView] or [class@Gtk.GridView].

    The `GtkListItemFactory` is tasked with creating widgets for items
    taken from the model when the views need them and updating them as
    the items displayed by the view change.

    A view is usually only able to display anything after both a factory
    and a model have been set on the view. So it is important that you do
    not skip this step when setting up your first view.

    Because views do not display the whole list at once but only a few
    items, they only need to maintain a few widgets at a time. They will
    instruct the `GtkListItemFactory` to create these widgets and bind them
    to the items that are currently displayed.

    As the list model changes or the user scrolls to the list, the items will
    change and the view will instruct the factory to bind the widgets to those
    new items.

    The actual widgets used for displaying those widgets is provided by you.

    When the factory needs widgets created, it will create a `GtkListItem`
    and hand it to your code to set up a widget for. This list item will provide
    various properties with information about what item to display and provide
    you with some opportunities to configure its behavior. See the
    [class@Gtk.ListItem] documentation for further details.

    Various implementations of `GtkListItemFactory` exist to allow you different
    ways to provide those widgets. The most common implementations are
    [class@Gtk.BuilderListItemFactory] which takes a `GtkBuilder` .ui file
    and then creates widgets and manages everything automatically from the
    information in that file and [class@Gtk.SignalListItemFactory] which allows
    you to connect to signals with your own code and retain full control over
    how the widgets are setup and managed.

    A `GtkListItemFactory` is supposed to be final - that means its behavior should
    not change and the first widget created from it should behave the same way as
    the last widget created from it.
    If you intend to do changes to the behavior, it is recommended that you create
    a new `GtkListItemFactory` which will allow the views to recreate its widgets.

    Once you have chosen your factory and created it, you need to set it on the view
    widget you want to use it with, such as via [method@Gtk.ListView.set_factory].
    Reusing factories across different views is allowed, but very uncommon.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListItemFactoryClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListStore(GObject.Object):
    """
    A list-like data structure that can be used with the [class@Gtk.TreeView].

    The `GtkListStore` object is a list model for use with a `GtkTreeView`
    widget.  It implements the `GtkTreeModel` interface, and consequentialy,
    can use all of the methods available there.  It also implements the
    `GtkTreeSortable` interface so it can be sorted by the view.
    Finally, it also implements the tree
    [drag](iface.TreeDragSource.html) and [drop](iface.TreeDragDest.html)
    interfaces.

    The `GtkListStore` can accept most `GType`s as a column type, though
    it can’t accept all custom types.  Internally, it will keep a copy of
    data passed in (such as a string or a boxed pointer).  Columns that
    accept `GObject`s are handled a little differently.  The
    `GtkListStore` will keep a reference to the object instead of copying the
    value.  As a result, if the object is modified, it is up to the
    application writer to call [method@Gtk.TreeModel.row_changed] to emit the
    [signal@Gtk.TreeModel::row_changed] signal. This most commonly affects lists
    with [class@Gdk.Texture]s stored.

    An example for creating a simple list store:

    ```c
    enum {
      COLUMN_STRING,
      COLUMN_INT,
      COLUMN_BOOLEAN,
      N_COLUMNS
    };

    {
      GtkListStore *list_store;
      GtkTreePath *path;
      GtkTreeIter iter;
      int i;

      list_store = gtk_list_store_new (N_COLUMNS,
                                       G_TYPE_STRING,
                                       G_TYPE_INT,
                                       G_TYPE_BOOLEAN);

      for (i = 0; i < 10; i++)
        {
          char *some_data;

          some_data = get_some_data (i);

          // Add a new row to the model
          gtk_list_store_append (list_store, &iter);
          gtk_list_store_set (list_store, &iter,
                              COLUMN_STRING, some_data,
                              COLUMN_INT, i,
                              COLUMN_BOOLEAN,  FALSE,
                              -1);

          // As the store will keep a copy of the string internally,
          // we free some_data.
          g_free (some_data);
        }

      // Modify a particular row
      path = gtk_tree_path_new_from_string ("4");
      gtk_tree_model_get_iter (GTK_TREE_MODEL (list_store),
                               &iter,
                               path);
      gtk_tree_path_free (path);
      gtk_list_store_set (list_store, &iter,
                          COLUMN_BOOLEAN, TRUE,
                          -1);
    }
    ```

    `GtkListStore` is deprecated since GTK 4.10, and should not be used in newly
    written code. You should use [class@Gio.ListStore] instead, and the various
    list models provided by GTK.

    ## Performance Considerations

    Internally, the `GtkListStore` was originally implemented with a linked list
    with a tail pointer.  As a result, it was fast at data insertion and deletion,
    and not fast at random data access.  The `GtkListStore` sets the
    `GTK_TREE_MODEL_ITERS_PERSIST` flag, which means that `GtkTreeIter`s can be
    cached while the row exists.  Thus, if access to a particular row is needed
    often and your code is expected to run on older versions of GTK, it is worth
    keeping the iter around.

    ## Atomic Operations

    It is important to note that only the methods
    gtk_list_store_insert_with_values() and gtk_list_store_insert_with_valuesv()
    are atomic, in the sense that the row is being appended to the store and the
    values filled in in a single operation with regard to `GtkTreeModel` signaling.
    In contrast, using e.g. gtk_list_store_append() and then gtk_list_store_set()
    will first create a row, which triggers the `GtkTreeModel::row-inserted` signal
    on `GtkListStore`. The row, however, is still empty, and any signal handler
    connecting to `GtkTreeModel::row-inserted` on this particular store should be prepared
    for the situation that the row might be empty. This is especially important
    if you are wrapping the `GtkListStore` inside a `GtkTreeModel`Filter and are
    using a `GtkTreeModel`FilterVisibleFunc. Using any of the non-atomic operations
    to append rows to the `GtkListStore` will cause the
    `GtkTreeModel`FilterVisibleFunc to be visited with an empty row first; the
    function must be prepared for that.

    ## GtkListStore as GtkBuildable

    The GtkListStore implementation of the [iface@Gtk.Buildable] interface allows
    to specify the model columns with a `<columns>` element that may contain
    multiple `<column>` elements, each specifying one model column. The “type”
    attribute specifies the data type for the column.

    Additionally, it is possible to specify content for the list store
    in the UI definition, with the `<data>` element. It can contain multiple
    `<row>` elements, each specifying to content for one row of the list model.
    Inside a `<row>`, the `<col>` elements specify the content for individual cells.

    Note that it is probably more common to define your models in the code,
    and one might consider it a layering violation to specify the content of
    a list store in a UI definition, data, not presentation, and common wisdom
    is to separate the two, as far as possible.

    An example of a UI Definition fragment for a list store:

    ```xml
    <object class="GtkListStore">
      <columns>
        <column type="gchararray"/>
        <column type="gchararray"/>
        <column type="gint"/>
      </columns>
      <data>
        <row>
          <col id="0">John</col>
          <col id="1">Doe</col>
          <col id="2">25</col>
        </row>
        <row>
          <col id="0">Johan</col>
          <col id="1">Dahlin</col>
          <col id="2">50</col>
        </row>
      </data>
    </object>
    ```
    """

    # gi Methods
    @deprecated("deprecated")
    def append(self) -> TreeIter: ...
    @deprecated("deprecated")
    def clear(self) -> None: ...
    @deprecated("deprecated")
    def insert(self, position: int) -> TreeIter: ...
    @deprecated("deprecated")
    def insert_after(self, sibling: TreeIter | None = None) -> TreeIter: ...
    @deprecated("deprecated")
    def insert_before(self, sibling: TreeIter | None = None) -> TreeIter: ...
    @deprecated("deprecated")
    def insert_with_values(self, position: int, columns: list, values: list, n_values: int) -> TreeIter | None: ...
    @deprecated("deprecated")
    def iter_is_valid(self, iter: TreeIter) -> bool: ...
    @deprecated("deprecated")
    def move_after(self, iter: TreeIter, position: TreeIter | None = None) -> None: ...
    @deprecated("deprecated")
    def move_before(self, iter: TreeIter, position: TreeIter | None = None) -> None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls, n_columns: int, types: list) -> ListStore: ...
    @deprecated("deprecated")
    def prepend(self) -> TreeIter: ...
    @deprecated("deprecated")
    def remove(self, iter: TreeIter) -> bool: ...
    @deprecated("deprecated")
    def reorder(self, new_order: list) -> None: ...
    @deprecated("deprecated")
    def set(self, iter: TreeIter, columns: list, values: list, n_values: int) -> None: ...
    @deprecated("deprecated")
    def set_column_types(self, n_columns: int, types: list) -> None: ...
    @deprecated("deprecated")
    def set_value(self, iter: TreeIter, column: int, value: GObject.Value) -> None: ...
    @deprecated("deprecated")
    def swap(self, a: TreeIter, b: TreeIter) -> None: ...

    # python methods (overrides?)
    def __init__(
        self,
        *column_types: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class ListStoreClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListStorePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListView(ListBase):
    """
    Presents a large dynamic list of items.

    `GtkListView` uses its factory to generate one row widget for each visible
    item and shows them in a linear display, either vertically or horizontally.

    The [property@Gtk.ListView:show-separators] property offers a simple way to
    display separators between the rows.

    `GtkListView` allows the user to select items according to the selection
    characteristics of the model. For models that allow multiple selected items,
    it is possible to turn on _rubberband selection_, using
    [property@Gtk.ListView:enable-rubberband].

    If you need multiple columns with headers, see [class@Gtk.ColumnView].

    To learn more about the list widget framework, see the
    [overview](section-list-widget.html).

    An example of using `GtkListView`:
    ```c
    static void
    setup_listitem_cb (GtkListItemFactory *factory,
                       GtkListItem        *list_item)
    {
      GtkWidget *image;

      image = gtk_image_new ();
      gtk_image_set_icon_size (GTK_IMAGE (image), GTK_ICON_SIZE_LARGE);
      gtk_list_item_set_child (list_item, image);
    }

    static void
    bind_listitem_cb (GtkListItemFactory *factory,
                      GtkListItem        *list_item)
    {
      GtkWidget *image;
      GAppInfo *app_info;

      image = gtk_list_item_get_child (list_item);
      app_info = gtk_list_item_get_item (list_item);
      gtk_image_set_from_gicon (GTK_IMAGE (image), g_app_info_get_icon (app_info));
    }

    static void
    activate_cb (GtkListView  *list,
                 guint         position,
                 gpointer      unused)
    {
      GAppInfo *app_info;

      app_info = g_list_model_get_item (G_LIST_MODEL (gtk_list_view_get_model (list)), position);
      g_app_info_launch (app_info, NULL, NULL, NULL);
      g_object_unref (app_info);
    }

    ...

      model = create_application_list ();

      factory = gtk_signal_list_item_factory_new ();
      g_signal_connect (factory, "setup", G_CALLBACK (setup_listitem_cb), NULL);
      g_signal_connect (factory, "bind", G_CALLBACK (bind_listitem_cb), NULL);

      list = gtk_list_view_new (GTK_SELECTION_MODEL (gtk_single_selection_new (model)), factory);

      g_signal_connect (list, "activate", G_CALLBACK (activate_cb), NULL);

      gtk_scrolled_window_set_child (GTK_SCROLLED_WINDOW (sw), list);
    ```

    # Actions

    `GtkListView` defines a set of built-in actions:

    - `list.activate-item` activates the item at given position by emitting
      the [signal@Gtk.ListView::activate] signal.

    # CSS nodes

    ```
    listview[.separators][.rich-list][.navigation-sidebar][.data-table]
    ├── row[.activatable]
    │
    ├── row[.activatable]
    │
    ┊
    ╰── [rubberband]
    ```

    `GtkListView` uses a single CSS node named `listview`. It may carry the
    `.separators` style class, when [property@Gtk.ListView:show-separators]
    property is set. Each child widget uses a single CSS node named `row`.
    If the [property@Gtk.ListItem:activatable] property is set, the
    corresponding row will have the `.activatable` style class. For
    rubberband selection, a node with name `rubberband` is used.

    The main listview node may also carry style classes to select
    the style of [list presentation](ListContainers.html#list-styles):
    .rich-list, .navigation-sidebar or .data-table.

    # Accessibility

    `GtkListView` uses the [enum@Gtk.AccessibleRole.list] role, and the list
    items use the [enum@Gtk.AccessibleRole.list_item] role.
    """

    class Props(ListBase.Props):
        enable_rubberband: bool  # [enable-rubberband]: changed because contained invalid characters
        factory: ListItemFactory | None
        header_factory: ListItemFactory | None  # [header-factory]: changed because contained invalid characters
        model: SelectionModel | None
        show_separators: bool  # [show-separators]: changed because contained invalid characters
        single_click_activate: bool  # [single-click-activate]: changed because contained invalid characters
        tab_behavior: ListTabBehavior  # [tab-behavior]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        enable_rubberband: bool = ...,
        factory: ListItemFactory | None = ...,
        header_factory: ListItemFactory | None = ...,
        model: SelectionModel | None = ...,
        show_separators: bool = ...,
        single_click_activate: bool = ...,
        tab_behavior: ListTabBehavior = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_enable_rubberband(self) -> bool: ...
    @builtins.property
    def get_factory(self) -> ListItemFactory | None: ...
    @builtins.property
    def get_header_factory(self) -> ListItemFactory | None: ...
    @builtins.property
    def get_model(self) -> SelectionModel | None: ...
    @builtins.property
    def get_show_separators(self) -> bool: ...
    @builtins.property
    def get_single_click_activate(self) -> bool: ...
    @builtins.property
    def get_tab_behavior(self) -> ListTabBehavior: ...
    @classmethod
    def new(cls, model: SelectionModel | None = None, factory: ListItemFactory | None = None) -> Widget: ...
    def scroll_to(self, pos: int, flags: ListScrollFlags, scroll: ScrollInfo | None = None) -> None: ...
    def set_enable_rubberband(self, enable_rubberband: bool) -> None: ...
    def set_factory(self, factory: ListItemFactory | None = None) -> None: ...
    def set_header_factory(self, factory: ListItemFactory | None = None) -> None: ...
    def set_model(self, model: SelectionModel | None = None) -> None: ...
    def set_show_separators(self, show_separators: bool) -> None: ...
    def set_single_click_activate(self, single_click_activate: bool) -> None: ...
    def set_tab_behavior(self, tab_behavior: ListTabBehavior) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate"],
        handler: typing.Callable[[typing_extensions.Self, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_rubberband"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::factory"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::header_factory"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_separators"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::single_click_activate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tab_behavior"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ListViewClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class LockButton(Button):
    """
    `GtkLockButton` is a widget to obtain and revoke authorizations
    needed to operate the controls.

    <picture>
      <source srcset="lockbutton-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkLockButton" src="lockbutton.png">
    </picture>

    It is typically used in preference dialogs or control panels.

    The required authorization is represented by a `GPermission` object.
    Concrete implementations of `GPermission` may use PolicyKit or some
    other authorization framework. To obtain a PolicyKit-based
    `GPermission`, use `polkit_permission_new()`.

    If the user is not currently allowed to perform the action, but can
    obtain the permission, the widget looks like this:

    <picture>
      <source srcset="lockbutton-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An locked GtkLockButton" src="lockbutton.png">
    </picture>

    and the user can click the button to request the permission. Depending
    on the platform, this may pop up an authentication dialog or ask the user
    to authenticate in some other way. Once the user has obtained the permission,
    the widget changes to this:

    <picture>
      <source srcset="lockbutton-unlocked-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An unlocked GtkLockButton" src="lockbutton-unlocked.png">
    </picture>

    and the permission can be dropped again by clicking the button. If the user
    is not able to obtain the permission at all, the widget looks like this:

    <picture>
      <source srcset="lockbutton-sorry-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An unobtainable GtkLockButton" src="lockbutton-sorry.png">
    </picture>

    If the user has the permission and cannot drop it, the button is hidden.

    The text (and tooltips) that are shown in the various cases can be adjusted
    with the [property@Gtk.LockButton:text-lock],
    [property@Gtk.LockButton:text-unlock],
    [property@Gtk.LockButton:tooltip-lock],
    [property@Gtk.LockButton:tooltip-unlock] and
    [property@Gtk.LockButton:tooltip-not-authorized] properties.
    """

    class Props(Button.Props):
        permission: Gio.Permission | None
        text_lock: str  # [text-lock]: changed because contained invalid characters
        text_unlock: str  # [text-unlock]: changed because contained invalid characters
        tooltip_lock: str  # [tooltip-lock]: changed because contained invalid characters
        tooltip_not_authorized: str  # [tooltip-not-authorized]: changed because contained invalid characters
        tooltip_unlock: str  # [tooltip-unlock]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        permission: Gio.Permission | None = ...,
        text_lock: str = ...,
        text_unlock: str = ...,
        tooltip_lock: str = ...,
        tooltip_not_authorized: str = ...,
        tooltip_unlock: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_permission(self) -> Gio.Permission | None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls, permission: Gio.Permission | None = None) -> Widget: ...
    @deprecated("deprecated")
    def set_permission(self, permission: Gio.Permission | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::permission"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_lock"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_unlock"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tooltip_lock"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tooltip_not_authorized"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tooltip_unlock"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MapListModel(GObject.Object):
    """
    A list model that maps the items in another model to different items.

    `GtkMapListModel` uses a [callback@Gtk.MapListModelMapFunc].

    Example: Create a list of `GtkEventControllers`
    ```c
    static gpointer
    map_to_controllers (gpointer widget,
                        gpointer data)
    {
      gpointer result = gtk_widget_observe_controllers (widget);
      g_object_unref (widget);
      return result;
    }

    widgets = gtk_widget_observe_children (widget);

    controllers = gtk_map_list_model_new (widgets,
                                          map_to_controllers,
                                          NULL, NULL);

    model = gtk_flatten_list_model_new (GTK_TYPE_EVENT_CONTROLLER,
                                        controllers);
    ```

    `GtkMapListModel` will attempt to discard the mapped objects as soon as
    they are no longer needed and recreate them if necessary.

    `GtkMapListModel` passes through sections from the underlying model.
    """

    class Props(GObject.Object.Props):
        has_map: bool  # [has-map]: changed because contained invalid characters
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, model: Gio.ListModel | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_model(self) -> Gio.ListModel | None: ...
    @builtins.property
    def has_map(self) -> bool: ...
    @classmethod
    def new(
        cls,
        model: Gio.ListModel | None,
        map_func: MapListModelMapFunc | None,
        user_data: object | None,
        user_destroy: GLib.DestroyNotify,
    ) -> MapListModel: ...
    def set_map_func(
        self, map_func: MapListModelMapFunc | None, user_data: object | None, user_destroy: GLib.DestroyNotify
    ) -> None: ...
    def set_model(self, model: Gio.ListModel | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_map"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MapListModelClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MediaControls(Widget):
    """
    Shows controls for video playback.

    <picture>
      <source srcset="media-controls-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkMediaControls" src="media-controls.png">
    </picture>

    Usually, `GtkMediaControls` is used as part of [class@Gtk.Video].
    """

    class Props(Widget.Props):
        media_stream: MediaStream | None  # [media-stream]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, media_stream: MediaStream | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_media_stream(self) -> MediaStream | None: ...
    @classmethod
    def new(cls, stream: MediaStream | None = None) -> Widget: ...
    def set_media_stream(self, stream: MediaStream | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::media_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MediaControlsClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MediaFile(MediaStream):
    """
    Implements the `GtkMediaStream` interface for files.

    This provides a simple way to play back video files with GTK.

    GTK provides a GIO extension point for `GtkMediaFile` implementations
    to allow for external implementations using various media frameworks.

    GTK itself includes an implementation using GStreamer.
    """

    class Props(MediaStream.Props):
        file: Gio.File | None
        input_stream: Gio.InputStream | None  # [input-stream]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, file: Gio.File | None = ..., input_stream: Gio.InputStream | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear(self) -> None: ...
    @builtins.property
    def get_file(self) -> Gio.File | None: ...
    @builtins.property
    def get_input_stream(self) -> Gio.InputStream | None: ...
    @classmethod
    def new(cls) -> MediaFile: ...
    @classmethod
    def new_for_file(cls, file: Gio.File) -> MediaFile: ...
    @classmethod
    def new_for_filename(cls, filename: str) -> MediaFile: ...
    @classmethod
    def new_for_input_stream(cls, stream: Gio.InputStream) -> MediaFile: ...
    @classmethod
    def new_for_resource(cls, resource_path: str) -> MediaFile: ...
    def set_file(self, file: Gio.File | None = None) -> None: ...
    def set_filename(self, filename: str | None = None) -> None: ...
    def set_input_stream(self, stream: Gio.InputStream | None = None) -> None: ...
    def set_resource(self, resource_path: str | None = None) -> None: ...

    # python methods (overrides?)
    def do_close(
        self,
    ) -> None:
        """
        close(self)
        """
    def do_open(
        self,
    ) -> None:
        """
        open(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MediaFileClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def close(self) -> closeMediaFileClassCB: ...
    @builtins.property
    def open(self) -> openMediaFileClassCB: ...
    @builtins.property
    def parent_class(self) -> MediaStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MediaStream(GObject.Object):
    """
    The integration point for media playback inside GTK.

    GTK provides an implementation of the `GtkMediaStream` interface that
    is called [class@Gtk.MediaFile].

    Apart from application-facing API for stream playback, `GtkMediaStream`
    has a number of APIs that are only useful for implementations and should
    not be used in applications:
    [method@Gtk.MediaStream.prepared],
    [method@Gtk.MediaStream.unprepared],
    [method@Gtk.MediaStream.update],
    [method@Gtk.MediaStream.ended],
    [method@Gtk.MediaStream.seek_success],
    [method@Gtk.MediaStream.seek_failed],
    [method@Gtk.MediaStream.gerror],
    [method@Gtk.MediaStream.error],
    [method@Gtk.MediaStream.error_valist].
    """

    class Props(GObject.Object.Props):
        duration: int
        ended: bool
        error: None | None
        has_audio: bool  # [has-audio]: changed because contained invalid characters
        has_video: bool  # [has-video]: changed because contained invalid characters
        loop: bool
        muted: bool
        playing: bool
        prepared: bool
        seekable: bool
        seeking: bool
        timestamp: int
        volume: float

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, loop: bool = ..., muted: bool = ..., playing: bool = ..., volume: float = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def gerror(self, error: None) -> None: ...
    @builtins.property
    def get_duration(self) -> int: ...
    @builtins.property
    def get_ended(self) -> bool: ...
    @builtins.property
    def get_error(self) -> None: ...
    @builtins.property
    def get_loop(self) -> bool: ...
    @builtins.property
    def get_muted(self) -> bool: ...
    @builtins.property
    def get_playing(self) -> bool: ...
    @builtins.property
    def get_timestamp(self) -> int: ...
    @builtins.property
    def get_volume(self) -> float: ...
    @builtins.property
    def has_audio(self) -> bool: ...
    @builtins.property
    def has_video(self) -> bool: ...
    @builtins.property
    def is_prepared(self) -> bool: ...
    @builtins.property
    def is_seekable(self) -> bool: ...
    @builtins.property
    def is_seeking(self) -> bool: ...
    def pause(self) -> None: ...
    def play(self) -> None: ...
    def realize(self, surface: Gdk.Surface) -> None: ...
    def seek(self, timestamp: int) -> None: ...
    def seek_failed(self) -> None: ...
    def seek_success(self) -> None: ...
    def set_loop(self, loop: bool) -> None: ...
    def set_muted(self, muted: bool) -> None: ...
    def set_playing(self, playing: bool) -> None: ...
    def set_volume(self, volume: float) -> None: ...
    def stream_ended(self) -> None: ...
    def stream_prepared(self, has_audio: bool, has_video: bool, seekable: bool, duration: int) -> None: ...
    def stream_unprepared(self) -> None: ...
    def unrealize(self, surface: Gdk.Surface) -> None: ...
    def update(self, timestamp: int) -> None: ...

    # python methods (overrides?)
    def do_pause(
        self,
    ) -> None:
        """
        pause(self)
        """
    def do_play(
        self,
    ) -> bool:
        """
        play(self) -> bool
        """
    def do_realize(
        self,
        surface: Gdk.Surface,
    ) -> None:
        """
        realize(self, surface:Gdk.Surface)
        """
    def do_seek(
        self,
        timestamp: int,
    ) -> None:
        """
        seek(self, timestamp:int)
        """
    def do_unrealize(
        self,
        surface: Gdk.Surface,
    ) -> None:
        """
        unrealize(self, surface:Gdk.Surface)
        """
    def do_update_audio(
        self,
        muted: bool,
        volume: float,
    ) -> None:
        """
        update_audio(self, muted:bool, volume:float)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::duration"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ended"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::error"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_audio"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_video"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::loop"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::muted"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::playing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::prepared"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::seekable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::seeking"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::timestamp"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::volume"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MediaStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def pause(self) -> pauseMediaStreamClassCB: ...
    @builtins.property
    def play(self) -> playMediaStreamClassCB: ...
    @builtins.property
    def realize(self) -> realizeMediaStreamClassCB: ...
    @builtins.property
    def seek(self) -> seekMediaStreamClassCB: ...
    @builtins.property
    def unrealize(self) -> unrealizeMediaStreamClassCB: ...
    @builtins.property
    def update_audio(self) -> update_audioMediaStreamClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MenuButton(Widget):
    """
    Displays a popup when clicked.

    <picture>
      <source srcset="menu-button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkMenuButton" src="menu-button.png">
    </picture>

    This popup can be provided either as a `GtkPopover` or as an abstract
    `GMenuModel`.

    The `GtkMenuButton` widget can show either an icon (set with the
    [property@Gtk.MenuButton:icon-name] property) or a label (set with the
    [property@Gtk.MenuButton:label] property). If neither is explicitly set,
    a [class@Gtk.Image] is automatically created, using an arrow image oriented
    according to [property@Gtk.MenuButton:direction] or the generic
    “open-menu-symbolic” icon if the direction is not set.

    The positioning of the popup is determined by the
    [property@Gtk.MenuButton:direction] property of the menu button.

    For menus, the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
    properties of the menu are also taken into account. For example, when the
    direction is %GTK_ARROW_DOWN and the horizontal alignment is %GTK_ALIGN_START,
    the menu will be positioned below the button, with the starting edge
    (depending on the text direction) of the menu aligned with the starting
    edge of the button. If there is not enough space below the button, the
    menu is popped up above the button instead. If the alignment would move
    part of the menu offscreen, it is “pushed in”.

    |           | start                | center                | end                |
    | -         | ---                  | ---                   | ---                |
    | **down**  | ![](down-start.png)  | ![](down-center.png)  | ![](down-end.png)  |
    | **up**    | ![](up-start.png)    | ![](up-center.png)    | ![](up-end.png)    |
    | **left**  | ![](left-start.png)  | ![](left-center.png)  | ![](left-end.png)  |
    | **right** | ![](right-start.png) | ![](right-center.png) | ![](right-end.png) |

    # CSS nodes

    ```
    menubutton
    ╰── button.toggle
        ╰── <content>
             ╰── [arrow]
    ```

    `GtkMenuButton` has a single CSS node with name `menubutton`
    which contains a `button` node with a `.toggle` style class.

    If the button contains an icon, it will have the `.image-button` style class,
    if it contains text, it will have `.text-button` style class. If an arrow is
    visible in addition to an icon, text or a custom child, it will also have
    `.arrow-button` style class.

    Inside the toggle button content, there is an `arrow` node for
    the indicator, which will carry one of the `.none`, `.up`, `.down`,
    `.left` or `.right` style classes to indicate the direction that
    the menu will appear in. The CSS is expected to provide a suitable
    image for each of these cases using the `-gtk-icon-source` property.

    Optionally, the `menubutton` node can carry the `.circular` style class
    to request a round appearance.

    # Accessibility

    `GtkMenuButton` uses the [enum@Gtk.AccessibleRole.button] role.
    """

    class Props(Widget.Props):
        active: bool
        always_show_arrow: bool  # [always-show-arrow]: changed because contained invalid characters
        can_shrink: bool  # [can-shrink]: changed because contained invalid characters
        child: Widget | None
        direction: ArrowType
        has_frame: bool  # [has-frame]: changed because contained invalid characters
        icon_name: str  # [icon-name]: changed because contained invalid characters
        label: str
        menu_model: Gio.MenuModel | None  # [menu-model]: changed because contained invalid characters
        popover: Popover | None
        primary: bool
        use_underline: bool  # [use-underline]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        active: bool = ...,
        always_show_arrow: bool = ...,
        can_shrink: bool = ...,
        child: Widget | None = ...,
        direction: ArrowType = ...,
        has_frame: bool = ...,
        icon_name: str = ...,
        label: str = ...,
        menu_model: Gio.MenuModel | None = ...,
        popover: Popover | None = ...,
        primary: bool = ...,
        use_underline: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_active(self) -> bool: ...
    @builtins.property
    def get_always_show_arrow(self) -> bool: ...
    @builtins.property
    def get_can_shrink(self) -> bool: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_direction(self) -> ArrowType: ...
    @builtins.property
    def get_has_frame(self) -> bool: ...
    @builtins.property
    def get_icon_name(self) -> str | None: ...
    @builtins.property
    def get_label(self) -> str | None: ...
    @builtins.property
    def get_menu_model(self) -> Gio.MenuModel | None: ...
    @builtins.property
    def get_popover(self) -> Popover | None: ...
    @builtins.property
    def get_primary(self) -> bool: ...
    @builtins.property
    def get_use_underline(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def popdown(self) -> None: ...
    def popup(self) -> None: ...
    def set_active(self, active: bool) -> None: ...
    def set_always_show_arrow(self, always_show_arrow: bool) -> None: ...
    def set_can_shrink(self, can_shrink: bool) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_create_popup_func(
        self,
        func: MenuButtonCreatePopupFunc | None = None,
        user_data: object | None = None,
        destroy_notify: GLib.DestroyNotify | None = None,
    ) -> None: ...
    def set_direction(self, direction: ArrowType) -> None: ...
    def set_has_frame(self, has_frame: bool) -> None: ...
    def set_icon_name(self, icon_name: str) -> None: ...
    def set_label(self, label: str) -> None: ...
    def set_menu_model(self, menu_model: Gio.MenuModel | None = None) -> None: ...
    def set_popover(self, popover: Widget | None = None) -> None: ...
    def set_primary(self, primary: bool) -> None: ...
    def set_use_underline(self, use_underline: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::always_show_arrow"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_shrink"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::direction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_frame"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::menu_model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::popover"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::primary"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_underline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MessageDialog(Dialog):
    """
    `GtkMessageDialog` presents a dialog with some message text.

    <picture>
      <source srcset="messagedialog-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkMessageDialog" src="messagedialog.png">
    </picture>

    It’s simply a convenience widget; you could construct the equivalent of
    `GtkMessageDialog` from `GtkDialog` without too much effort, but
    `GtkMessageDialog` saves typing.

    The easiest way to do a modal message dialog is to use the %GTK_DIALOG_MODAL
    flag, which will call [method@Gtk.Window.set_modal] internally. The dialog will
    prevent interaction with the parent window until it's hidden or destroyed.
    You can use the [signal@Gtk.Dialog::response] signal to know when the user
    dismissed the dialog.

    An example for using a modal dialog:
    ```c
    GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL;
    dialog = gtk_message_dialog_new (parent_window,
                                     flags,
                                     GTK_MESSAGE_ERROR,
                                     GTK_BUTTONS_CLOSE,
                                     "Error reading “%s”: %s",
                                     filename,
                                     g_strerror (errno));
    // Destroy the dialog when the user responds to it
    // (e.g. clicks a button)

    g_signal_connect (dialog, "response",
                      G_CALLBACK (gtk_window_destroy),
                      NULL);
    ```

    You might do a non-modal `GtkMessageDialog` simply by omitting the
    %GTK_DIALOG_MODAL flag:

    ```c
    GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
    dialog = gtk_message_dialog_new (parent_window,
                                     flags,
                                     GTK_MESSAGE_ERROR,
                                     GTK_BUTTONS_CLOSE,
                                     "Error reading “%s”: %s",
                                     filename,
                                     g_strerror (errno));

    // Destroy the dialog when the user responds to it
    // (e.g. clicks a button)
    g_signal_connect (dialog, "response",
                      G_CALLBACK (gtk_window_destroy),
                      NULL);
    ```

    # GtkMessageDialog as GtkBuildable

    The `GtkMessageDialog` implementation of the `GtkBuildable` interface exposes
    the message area as an internal child with the name “message_area”.
    """

    class Props(Dialog.Props):
        buttons: ButtonsType
        message_area: Widget | None  # [message-area]: changed because contained invalid characters
        message_type: MessageType  # [message-type]: changed because contained invalid characters
        secondary_text: str  # [secondary-text]: changed because contained invalid characters
        secondary_use_markup: bool  # [secondary-use-markup]: changed because contained invalid characters
        text: str
        use_markup: bool  # [use-markup]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        buttons: ButtonsType = ...,
        message_type: MessageType = ...,
        secondary_text: str = ...,
        secondary_use_markup: bool = ...,
        text: str = ...,
        use_markup: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_message_area(self) -> Widget: ...
    @deprecated("deprecated")
    def set_markup(self, str: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buttons"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::message_area"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::message_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::secondary_use_markup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_markup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MessageDialogClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MnemonicAction(ShortcutAction):
    """
    Activates a widget with a mnemonic.

    This means that [method@Gtk.Widget.mnemonic_activate] is called.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get() -> MnemonicAction: ...

class MnemonicActionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MnemonicTrigger(ShortcutTrigger):
    """
    Triggers when a specific mnemonic is pressed.

    Mnemonics require a *mnemonic modifier* (typically <kbd>Alt</kbd>) to be
    pressed together with the mnemonic key.
    """

    class Props(ShortcutTrigger.Props):
        keyval: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, keyval: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_keyval(self) -> int: ...
    @classmethod
    def new(cls, keyval: int) -> MnemonicTrigger: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::keyval"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MnemonicTriggerClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MountOperation(GObject.Object):
    """
    Asks the user for passwords and other information required to
    mount a volume.

    `GtkMountOperation` is needed when mounting volumes:
    It is an implementation of `GMountOperation` that can be used with
    GIO functions for mounting volumes such as
    [method@Gio.File.mount_enclosing_volume],
    [method@Gio.File.mount_mountable],
    [method@Gio.Volume.mount],
    [method@Gio.Mount.unmount_with_operation] and others.

    When necessary, `GtkMountOperation` shows dialogs to let the user
    enter passwords, ask questions or show processes blocking unmount.
    """

    class Props(GObject.Object.Props):
        display: Gdk.Display | None
        is_showing: bool  # [is-showing]: changed because contained invalid characters
        parent: Window | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, display: Gdk.Display | None = ..., parent: Window | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_display(self) -> Gdk.Display: ...
    @builtins.property
    def get_parent(self) -> Window | None: ...
    @builtins.property
    def is_showing(self) -> bool: ...
    @classmethod
    def new(cls, parent: Window | None = None) -> Gio.MountOperation: ...
    def set_display(self, display: Gdk.Display) -> None: ...
    def set_parent(self, parent: Window | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::display"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_showing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MountOperationClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> Gio.MountOperationClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MountOperationPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MultiFilter(Filter):
    """
    Base class for filters that combine multiple filters.
    """

    class Props(Filter.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        n_items: int  # [n-items]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, filter: Filter) -> None: ...
    def remove(self, position: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MultiFilterClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MultiSelection(GObject.Object):
    """
    A selection model that allows selecting multiple elements.
    """

    class Props(GObject.Object.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, model: Gio.ListModel | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_model(self) -> Gio.ListModel | None: ...
    @classmethod
    def new(cls, model: Gio.ListModel | None = None) -> MultiSelection: ...
    def set_model(self, model: Gio.ListModel | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MultiSelectionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MultiSorter(Sorter):
    """
    Combines multiple sorters by trying them in turn.

    If the first sorter compares two items as equal,
    the second is tried next, and so on.
    """

    class Props(Sorter.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        n_items: int  # [n-items]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, sorter: Sorter) -> None: ...
    @classmethod
    def new(cls) -> MultiSorter: ...
    def remove(self, position: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MultiSorterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SorterClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NamedAction(ShortcutAction):
    """
    Activates a named action.

    See [method@Gtk.WidgetClass.install_action] and
    [method@Gtk.Widget.insert_action_group] for ways
    to associate named actions with widgets.
    """

    class Props(ShortcutAction.Props):
        action_name: str  # [action-name]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, action_name: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_action_name(self) -> str: ...
    @classmethod
    def new(cls, name: str) -> NamedAction: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::action_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class NamedActionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Native(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_for_surface(surface: Gdk.Surface) -> Native | None: ...
    def get_renderer(self) -> Gsk.Renderer | None: ...
    def get_surface(self) -> Gdk.Surface | None: ...
    def get_surface_transform(self) -> tuple[float, float]: ...
    def realize(self) -> None: ...
    def unrealize(self) -> None: ...

class NativeDialog(GObject.Object):
    """
    Base class for platform dialogs that don't use `GtkDialog`.

    Native dialogs are used in order to integrate better with a platform,
    by looking the same as other native applications and supporting
    platform specific features.

    The [class@Gtk.Dialog] functions cannot be used on such objects,
    but we need a similar API in order to drive them. The `GtkNativeDialog`
    object is an API that allows you to do this. It allows you to set
    various common properties on the dialog, as well as show and hide
    it and get a [signal@Gtk.NativeDialog::response] signal when the user
    finished with the dialog.

    Note that unlike `GtkDialog`, `GtkNativeDialog` objects are not
    toplevel widgets, and GTK does not keep them alive. It is your
    responsibility to keep a reference until you are done with the
    object.
    """

    class Props(GObject.Object.Props):
        modal: bool
        title: str
        transient_for: Window | None  # [transient-for]: changed because contained invalid characters
        visible: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, modal: bool = ..., title: str = ..., transient_for: Window | None = ..., visible: bool = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def destroy(self) -> None: ...
    @builtins.property
    def get_modal(self) -> bool: ...
    @builtins.property
    def get_title(self) -> str | None: ...
    @builtins.property
    def get_transient_for(self) -> Window | None: ...
    @builtins.property
    def get_visible(self) -> bool: ...
    def hide(self) -> None: ...
    def set_modal(self, modal: bool) -> None: ...
    def set_title(self, title: str) -> None: ...
    def set_transient_for(self, parent: Window | None = None) -> None: ...
    def show(self) -> None: ...

    # python methods (overrides?)
    def do_hide(
        self,
    ) -> None:
        """
        hide(self)
        """
    def do_response(
        self,
        response_id: int,
    ) -> None:
        """
        response(self, response_id:int)
        """
    def do_show(
        self,
    ) -> None:
        """
        show(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["response"],
        handler: typing.Callable[[typing_extensions.Self, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::transient_for"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class NativeDialogClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def hide(self) -> hideNativeDialogClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def response(self) -> responseNativeDialogClassCB: ...
    @builtins.property
    def show(self) -> showNativeDialogClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NativeInterface(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NeverTrigger(ShortcutTrigger):
    """
    A `GtkShortcutTrigger` that never triggers.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get() -> NeverTrigger: ...

class NeverTriggerClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NoSelection(GObject.Object):
    """
    A selection model that does not allow selecting anything.

    This model is meant to be used as a simple wrapper around a `GListModel`
    when a `GtkSelectionModel` is required.

    `GtkNoSelection` passes through sections from the underlying model.
    """

    class Props(GObject.Object.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, model: Gio.ListModel | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_model(self) -> Gio.ListModel | None: ...
    @classmethod
    def new(cls, model: Gio.ListModel | None = None) -> NoSelection: ...
    def set_model(self, model: Gio.ListModel | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class NoSelectionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Notebook(Widget):
    """
    Switches between children using tabs.

    <picture>
      <source srcset="notebook-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkNotebook" src="notebook.png">
    </picture>

    There are many configuration options for `GtkNotebook`. Among
    other things, you can choose on which edge the tabs appear
    (see [method@Gtk.Notebook.set_tab_pos]), whether, if there are
    too many tabs to fit the notebook should be made bigger or scrolling
    arrows added (see [method@Gtk.Notebook.set_scrollable]), and whether
    there will be a popup menu allowing the users to switch pages.
    (see [method@Gtk.Notebook.popup_enable]).

    # GtkNotebook as GtkBuildable

    The `GtkNotebook` implementation of the `GtkBuildable` interface
    supports placing children into tabs by specifying “tab” as the
    “type” attribute of a `<child>` element. Note that the content
    of the tab must be created before the tab can be filled.
    A tab child can be specified without specifying a `<child>`
    type attribute.

    To add a child widget in the notebooks action area, specify
    "action-start" or “action-end” as the “type” attribute of the
    `<child>` element.

    An example of a UI definition fragment with `GtkNotebook`:

    ```xml
    <object class="GtkNotebook">
      <child>
        <object class="GtkLabel" id="notebook-content">
          <property name="label">Content</property>
        </object>
      </child>
      <child type="tab">
        <object class="GtkLabel" id="notebook-tab">
          <property name="label">Tab</property>
        </object>
      </child>
    </object>
    ```

    # Shortcuts and Gestures

    `GtkNotebook` supports the following keyboard shortcuts:

    - <kbd>Shift</kbd>+<kbd>F10</kbd> or <kbd>Menu</kbd> opens the context menu.
    - <kbd>Home</kbd> moves the focus to the first tab.
    - <kbd>End</kbd> moves the focus to the last tab.

    Additionally, the following signals have default keybindings:

    - [signal@Gtk.Notebook::change-current-page]
    - [signal@Gtk.Notebook::focus-tab]
    - [signal@Gtk.Notebook::move-focus-out]
    - [signal@Gtk.Notebook::reorder-tab]
    - [signal@Gtk.Notebook::select-page]

    Tabs support drag-and-drop between notebooks sharing the same `group-name`,
    or to new windows by handling the `::create-window` signal.

    # Actions

    `GtkNotebook` defines a set of built-in actions:

    - `menu.popup` opens the tabs context menu.

    # CSS nodes

    ```
    notebook
    ├── header.top
    │   ├── [<action widget>]
    │   ├── tabs
    │   │   ├── [arrow]
    │   │   ├── tab
    │   │   │   ╰── <tab label>
    ┊   ┊   ┊
    │   │   ├── tab[.reorderable-page]
    │   │   │   ╰── <tab label>
    │   │   ╰── [arrow]
    │   ╰── [<action widget>]
    │
    ╰── stack
        ├── <child>
        ┊
        ╰── <child>
    ```

    `GtkNotebook` has a main CSS node with name `notebook`, a subnode
    with name `header` and below that a subnode with name `tabs` which
    contains one subnode per tab with name `tab`.

    If action widgets are present, their CSS nodes are placed next
    to the `tabs` node. If the notebook is scrollable, CSS nodes with
    name `arrow` are placed as first and last child of the `tabs` node.

    The main node gets the `.frame` style class when the notebook
    has a border (see [method@Gtk.Notebook.set_show_border]).

    The header node gets one of the style class `.top`, `.bottom`,
    `.left` or `.right`, depending on where the tabs are placed. For
    reorderable pages, the tab node gets the `.reorderable-page` class.

    A `tab` node gets the `.dnd` style class while it is moved with drag-and-drop.

    The nodes are always arranged from left-to-right, regardless of text direction.

    # Accessibility

    `GtkNotebook` uses the following roles:

     - [enum@Gtk.AccessibleRole.group] for the notebook widget
     - [enum@Gtk.AccessibleRole.tab_list] for the list of tabs
     - [enum@Gtk.AccessibleRole.tab] role for each tab
     - [enum@Gtk.AccessibleRole.tab_panel] for each page
    """

    class Props(Widget.Props):
        enable_popup: bool  # [enable-popup]: changed because contained invalid characters
        group_name: str  # [group-name]: changed because contained invalid characters
        page: int
        pages: Gio.ListModel | None
        scrollable: bool
        show_border: bool  # [show-border]: changed because contained invalid characters
        show_tabs: bool  # [show-tabs]: changed because contained invalid characters
        tab_pos: PositionType  # [tab-pos]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        enable_popup: bool = ...,
        group_name: str = ...,
        page: int = ...,
        scrollable: bool = ...,
        show_border: bool = ...,
        show_tabs: bool = ...,
        tab_pos: PositionType = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append_page(self, child: Widget, tab_label: Widget | None = None) -> int: ...
    def append_page_menu(
        self, child: Widget, tab_label: Widget | None = None, menu_label: Widget | None = None
    ) -> int: ...
    def detach_tab(self, child: Widget) -> None: ...
    def get_action_widget(self, pack_type: PackType) -> Widget | None: ...
    @builtins.property
    def get_current_page(self) -> int: ...
    @builtins.property
    def get_group_name(self) -> str | None: ...
    def get_menu_label(self, child: Widget) -> Widget | None: ...
    def get_menu_label_text(self, child: Widget) -> str | None: ...
    def get_n_pages(self) -> int: ...
    def get_nth_page(self, page_num: int) -> Widget | None: ...
    def get_page(self, child: Widget) -> NotebookPage: ...
    @builtins.property
    def get_pages(self) -> Gio.ListModel: ...
    @builtins.property
    def get_scrollable(self) -> bool: ...
    @builtins.property
    def get_show_border(self) -> bool: ...
    @builtins.property
    def get_show_tabs(self) -> bool: ...
    def get_tab_detachable(self, child: Widget) -> bool: ...
    def get_tab_label(self, child: Widget) -> Widget | None: ...
    def get_tab_label_text(self, child: Widget) -> str | None: ...
    @builtins.property
    def get_tab_pos(self) -> PositionType: ...
    def get_tab_reorderable(self, child: Widget) -> bool: ...
    def insert_page(self, child: Widget, tab_label: Widget | None, position: int) -> int: ...
    def insert_page_menu(
        self, child: Widget, tab_label: Widget | None, menu_label: Widget | None, position: int
    ) -> int: ...
    @classmethod
    def new(cls) -> Widget: ...
    def next_page(self) -> None: ...
    def page_num(self, child: Widget) -> int: ...
    def popup_disable(self) -> None: ...
    def popup_enable(self) -> None: ...
    def prepend_page(self, child: Widget, tab_label: Widget | None = None) -> int: ...
    def prepend_page_menu(
        self, child: Widget, tab_label: Widget | None = None, menu_label: Widget | None = None
    ) -> int: ...
    def prev_page(self) -> None: ...
    def remove_page(self, page_num: int) -> None: ...
    def reorder_child(self, child: Widget, position: int) -> None: ...
    def set_action_widget(self, widget: Widget, pack_type: PackType) -> None: ...
    def set_current_page(self, page_num: int) -> None: ...
    def set_group_name(self, group_name: str | None = None) -> None: ...
    def set_menu_label(self, child: Widget, menu_label: Widget | None = None) -> None: ...
    def set_menu_label_text(self, child: Widget, menu_text: str) -> None: ...
    def set_scrollable(self, scrollable: bool) -> None: ...
    def set_show_border(self, show_border: bool) -> None: ...
    def set_show_tabs(self, show_tabs: bool) -> None: ...
    def set_tab_detachable(self, child: Widget, detachable: bool) -> None: ...
    def set_tab_label(self, child: Widget, tab_label: Widget | None = None) -> None: ...
    def set_tab_label_text(self, child: Widget, tab_text: str) -> None: ...
    def set_tab_pos(self, pos: PositionType) -> None: ...
    def set_tab_reorderable(self, child: Widget, reorderable: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["change-current-page"],
        handler: typing.Callable[[typing_extensions.Self, int], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["create-window"],
        handler: typing.Callable[[typing_extensions.Self, Widget], Notebook | None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["focus-tab"],
        handler: typing.Callable[[typing_extensions.Self, NotebookTab], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-focus-out"],
        handler: typing.Callable[[typing_extensions.Self, DirectionType], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["page-added"],
        handler: typing.Callable[[typing_extensions.Self, Widget, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["page-removed"],
        handler: typing.Callable[[typing_extensions.Self, Widget, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["page-reordered"],
        handler: typing.Callable[[typing_extensions.Self, Widget, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["reorder-tab"],
        handler: typing.Callable[[typing_extensions.Self, DirectionType, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["select-page"],
        handler: typing.Callable[[typing_extensions.Self, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["switch-page"],
        handler: typing.Callable[[typing_extensions.Self, Widget, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_popup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::group_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::page"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pages"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scrollable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_border"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_tabs"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tab_pos"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class NotebookPage(GObject.Object):
    """
    An auxiliary object used by `GtkNotebook`.
    """

    class Props(GObject.Object.Props):
        child: Widget | None
        detachable: bool
        menu: Widget | None
        menu_label: str  # [menu-label]: changed because contained invalid characters
        position: int
        reorderable: bool
        tab: Widget | None
        tab_expand: bool  # [tab-expand]: changed because contained invalid characters
        tab_fill: bool  # [tab-fill]: changed because contained invalid characters
        tab_label: str  # [tab-label]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        child: Widget | None = ...,
        detachable: bool = ...,
        menu: Widget | None = ...,
        menu_label: str = ...,
        position: int = ...,
        reorderable: bool = ...,
        tab: Widget | None = ...,
        tab_expand: bool = ...,
        tab_fill: bool = ...,
        tab_label: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::detachable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::menu"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::menu_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::reorderable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tab"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tab_expand"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tab_fill"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tab_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class NothingAction(ShortcutAction):
    """
    Does nothing.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get() -> NothingAction: ...

class NothingActionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NumericSorter(Sorter):
    """
    Sorts items numerically.

    To obtain the numbers to compare, this sorter evaluates a
    [class@Gtk.Expression].
    """

    class Props(Sorter.Props):
        expression: Expression | None
        sort_order: SortType  # [sort-order]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, expression: Expression | None = ..., sort_order: SortType = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_expression(self) -> Expression | None: ...
    @builtins.property
    def get_sort_order(self) -> SortType: ...
    @classmethod
    def new(cls, expression: Expression | None = None) -> NumericSorter: ...
    def set_expression(self, expression: Expression | None = None) -> None: ...
    def set_sort_order(self, sort_order: SortType) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expression"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sort_order"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class NumericSorterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SorterClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ObjectExpression(Expression):
    """
    A `GObject` value in a `GtkExpression`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_object(self) -> GObject.Object | None: ...
    @classmethod
    def new(cls, object: GObject.Object) -> ObjectExpression: ...

class Orientable(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        orientation: Orientation

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, orientation: Orientation = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_orientation(self) -> Orientation: ...
    def set_orientation(self, orientation: Orientation) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::orientation"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class OrientableIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def base_iface(self) -> GObject.TypeInterface | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Overlay(Widget):
    """
    Places “overlay” widgets on top of a single main child.

    <picture>
      <source srcset="overlay-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkOverlay" src="overlay.png">
    </picture>

    The position of each overlay widget is determined by its
    [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
    properties. E.g. a widget with both alignments set to %GTK_ALIGN_START
    will be placed at the top left corner of the `GtkOverlay` container,
    whereas an overlay with halign set to %GTK_ALIGN_CENTER and valign set
    to %GTK_ALIGN_END will be placed a the bottom edge of the `GtkOverlay`,
    horizontally centered. The position can be adjusted by setting the margin
    properties of the child to non-zero values.

    More complicated placement of overlays is possible by connecting
    to the [signal@Gtk.Overlay::get-child-position] signal.

    An overlay’s minimum and natural sizes are those of its main child.
    The sizes of overlay children are not considered when measuring these
    preferred sizes.

    # GtkOverlay as GtkBuildable

    The `GtkOverlay` implementation of the `GtkBuildable` interface
    supports placing a child as an overlay by specifying “overlay” as
    the “type” attribute of a `<child>` element.

    # CSS nodes

    `GtkOverlay` has a single CSS node with the name “overlay”. Overlay children
    whose alignments cause them to be positioned at an edge get the style classes
    “.left”, “.right”, “.top”, and/or “.bottom” according to their position.
    """

    class Props(Widget.Props):
        child: Widget | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, child: Widget | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_overlay(self, widget: Widget) -> None: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    def get_clip_overlay(self, widget: Widget) -> bool: ...
    def get_measure_overlay(self, widget: Widget) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def remove_overlay(self, widget: Widget) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_clip_overlay(self, widget: Widget, clip_overlay: bool) -> None: ...
    def set_measure_overlay(self, widget: Widget, measure: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["get-child-position"],
        handler: typing.Callable[[typing_extensions.Self, Widget], tuple[bool, Gdk.Rectangle]],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class OverlayLayout(LayoutManager):
    """
    The layout manager used by [class@Gtk.Overlay].

    It places widgets as overlays on top of the main child.

    This is not a reusable layout manager, since it expects its widget
    to be a `GtkOverlay`. It is only listed here so that its layout
    properties get documented.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> LayoutManager: ...

class OverlayLayoutChild(LayoutChild):
    """
    `GtkLayoutChild` subclass for children in a `GtkOverlayLayout`.
    """

    class Props(LayoutChild.Props):
        clip_overlay: bool  # [clip-overlay]: changed because contained invalid characters
        measure: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, clip_overlay: bool = ..., measure: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_clip_overlay(self) -> bool: ...
    @builtins.property
    def get_measure(self) -> bool: ...
    def set_clip_overlay(self, clip_overlay: bool) -> None: ...
    def set_measure(self, measure: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::clip_overlay"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::measure"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class OverlayLayoutChildClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutChildClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class OverlayLayoutClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> LayoutManagerClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PadActionEntry(GObject.GPointer):
    # gi Fields
    action_name: str = ...
    index: int = ...
    label: str = ...
    mode: int = ...
    type: PadActionType = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PadController(EventController):
    """
    Handles input from the pads found in drawing tablets.

    Pads are the collection of buttons and tactile sensors often found around
    the stylus-sensitive area.

    These buttons and sensors have no implicit meaning, and by default they
    perform no action. `GtkPadController` is provided to map those to
    [iface@Gio.Action] objects, thus letting the application give them a more
    semantic meaning.

    Buttons and sensors are not constrained to triggering a single action,
    some %GDK_SOURCE_TABLET_PAD devices feature multiple "modes". All these
    input elements have one current mode, which may determine the final action
    being triggered.

    Pad devices often divide buttons and sensors into groups. All elements
    in a group share the same current mode, but different groups may have
    different modes. See [method@Gdk.DevicePad.get_n_groups] and
    [method@Gdk.DevicePad.get_group_n_modes].

    Each of the actions that a given button/strip/ring performs for a given mode
    is defined by a [struct@Gtk.PadActionEntry]. It contains an action name that
    will be looked up in the given [iface@Gio.ActionGroup] and activated whenever
    the specified input element and mode are triggered.

    A simple example of `GtkPadController` usage: Assigning button 1 in all
    modes and pad devices to an "invert-selection" action:

    ```c
    GtkPadActionEntry *pad_actions[] = {
      { GTK_PAD_ACTION_BUTTON, 1, -1, "Invert selection", "pad-actions.invert-selection" },
      …
    };

    …
    action_group = g_simple_action_group_new ();
    action = g_simple_action_new ("pad-actions.invert-selection", NULL);
    g_signal_connect (action, "activate", on_invert_selection_activated, NULL);
    g_action_map_add_action (G_ACTION_MAP (action_group), action);
    …
    pad_controller = gtk_pad_controller_new (action_group, NULL);
    ```

    The actions belonging to rings/strips will be activated with a parameter
    of type %G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it
    is required that those are made stateful and accepting this `GVariantType`.
    """

    class Props(EventController.Props):
        action_group: Gio.ActionGroup | None  # [action-group]: changed because contained invalid characters
        pad: Gdk.Device | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, action_group: Gio.ActionGroup | None = ..., pad: Gdk.Device | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, group: Gio.ActionGroup, pad: Gdk.Device | None = None) -> PadController: ...
    def set_action(self, type: PadActionType, index: int, mode: int, label: str, action_name: str) -> None: ...
    def set_action_entries(self, entries: list, n_entries: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::action_group"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pad"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PadControllerClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PageRange(GObject.GPointer):
    # gi Fields
    end: int = ...
    start: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PageSetup(GObject.Object):
    """
    Stores page size, orientation and margins for printing.

    The idea is that you can get one of these from the page setup dialog
    and then pass it to the `GtkPrintOperation` when printing.
    The benefit of splitting this out of the `GtkPrintSettings` is that
    these affect the actual layout of the page, and thus need to be set
    long before user prints.

    ## Margins

    The margins specified in this object are the “print margins”, i.e. the
    parts of the page that the printer cannot print on. These are different
    from the layout margins that a word processor uses; they are typically
    used to determine the minimal size for the layout margins.

    To obtain a `GtkPageSetup` use [ctor@Gtk.PageSetup.new] to get the defaults,
    or use [func@Gtk.print_run_page_setup_dialog] to show the page setup dialog
    and receive the resulting page setup.

    ## A page setup dialog

    ```c
    static GtkPrintSettings *settings = NULL;
    static GtkPageSetup *page_setup = NULL;

    static void
    do_page_setup (void)
    {
      GtkPageSetup *new_page_setup;

      if (settings == NULL)
        settings = gtk_print_settings_new ();

      new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
                                                        page_setup, settings);

      if (page_setup)
        g_object_unref (page_setup);

      page_setup = new_page_setup;
    }
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def copy(self) -> PageSetup: ...
    def get_bottom_margin(self, unit: Unit) -> float: ...
    def get_left_margin(self, unit: Unit) -> float: ...
    def get_orientation(self) -> PageOrientation: ...
    def get_page_height(self, unit: Unit) -> float: ...
    def get_page_width(self, unit: Unit) -> float: ...
    def get_paper_height(self, unit: Unit) -> float: ...
    def get_paper_size(self) -> PaperSize: ...
    def get_paper_width(self, unit: Unit) -> float: ...
    def get_right_margin(self, unit: Unit) -> float: ...
    def get_top_margin(self, unit: Unit) -> float: ...
    def load_file(self, file_name: str) -> bool: ...
    def load_key_file(self, key_file: GLib.KeyFile, group_name: str | None = None) -> bool: ...
    @classmethod
    def new(cls) -> PageSetup: ...
    @classmethod
    def new_from_file(cls, file_name: str) -> PageSetup: ...
    @classmethod
    def new_from_gvariant(cls, variant: GLib.Variant) -> PageSetup: ...
    @classmethod
    def new_from_key_file(cls, key_file: GLib.KeyFile, group_name: str | None = None) -> PageSetup: ...
    def set_bottom_margin(self, margin: float, unit: Unit) -> None: ...
    def set_left_margin(self, margin: float, unit: Unit) -> None: ...
    def set_orientation(self, orientation: PageOrientation) -> None: ...
    def set_paper_size(self, size: PaperSize) -> None: ...
    def set_paper_size_and_default_margins(self, size: PaperSize) -> None: ...
    def set_right_margin(self, margin: float, unit: Unit) -> None: ...
    def set_top_margin(self, margin: float, unit: Unit) -> None: ...
    def to_file(self, file_name: str) -> bool: ...
    def to_gvariant(self) -> GLib.Variant: ...
    def to_key_file(self, key_file: GLib.KeyFile, group_name: str | None = None) -> None: ...

class PageSetupUnixDialog(Dialog):
    """
    Presents a page setup dialog for platforms which don’t provide
    a native page setup dialog, like Unix.

    <picture>
      <source srcset="pagesetupdialog-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkPageSetupUnixDialog" src="pagesetupdialog.png">
    </picture>

    It can be used very much like any other GTK dialog, at the
    cost of the portability offered by the high-level printing
    API in [class@Gtk.PrintOperation].

    ## CSS nodes

    `GtkPageSetupUnixDialog` has a single CSS node with the name `window` and
    style class `.pagesetup`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_page_setup(self) -> PageSetup: ...
    def get_print_settings(self) -> PrintSettings | None: ...
    @classmethod
    def new(cls, title: str | None = None, parent: Window | None = None) -> Widget: ...
    def set_page_setup(self, page_setup: PageSetup) -> None: ...
    def set_print_settings(self, print_settings: PrintSettings | None = None) -> None: ...

class Paned(Widget):
    """
    Arranges its children in two panes, horizontally or vertically.

    <picture>
      <source srcset="panes-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkPaned" src="panes.png">
    </picture>

    The division between the two panes is adjustable by the user
    by dragging a handle.

    Child widgets are added to the panes of the widget with
    [method@Gtk.Paned.set_start_child] and [method@Gtk.Paned.set_end_child].
    The division between the two children is set by default from the size
    requests of the children, but it can be adjusted by the user.

    A paned widget draws a separator between the two child widgets and a
    small handle that the user can drag to adjust the division. It does not
    draw any relief around the children or around the separator. (The space
    in which the separator is called the gutter.) Often, it is useful to put
    each child inside a [class@Gtk.Frame] so that the gutter appears as a
    ridge. No separator is drawn if one of the children is missing.

    Each child has two options that can be set, "resize" and "shrink". If
    "resize" is true then, when the `GtkPaned` is resized, that child will
    expand or shrink along with the paned widget. If "shrink" is true, then
    that child can be made smaller than its requisition by the user.
    Setting "shrink" to false allows the application to set a minimum size.
    If "resize" is false for both children, then this is treated as if
    "resize" is true for both children.

    The application can set the position of the slider as if it were set
    by the user, by calling [method@Gtk.Paned.set_position].

    # Shortcuts and Gestures

    The following signals have default keybindings:

    - [signal@Gtk.Paned::accept-position]
    - [signal@Gtk.Paned::cancel-position]
    - [signal@Gtk.Paned::cycle-child-focus]
    - [signal@Gtk.Paned::cycle-handle-focus]
    - [signal@Gtk.Paned::move-handle]
    - [signal@Gtk.Paned::toggle-handle-focus]

    # CSS nodes

    ```
    paned
    ├── <child>
    ├── separator[.wide]
    ╰── <child>
    ```

    `GtkPaned` has a main CSS node with name paned, and a subnode for
    the separator with name separator. The subnode gets a .wide style
    class when the paned is supposed to be wide.

    In horizontal orientation, the nodes are arranged based on the text
    direction, so in left-to-right mode, :first-child will select the
    leftmost child, while it will select the rightmost child in
    RTL layouts.

    ## Creating a paned widget with minimum sizes.

    ```c
    GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
    GtkWidget *frame1 = gtk_frame_new (NULL);
    GtkWidget *frame2 = gtk_frame_new (NULL);

    gtk_widget_set_size_request (hpaned, 200, -1);

    gtk_paned_set_start_child (GTK_PANED (hpaned), frame1);
    gtk_paned_set_resize_start_child (GTK_PANED (hpaned), TRUE);
    gtk_paned_set_shrink_start_child (GTK_PANED (hpaned), FALSE);
    gtk_widget_set_size_request (frame1, 50, -1);

    gtk_paned_set_end_child (GTK_PANED (hpaned), frame2);
    gtk_paned_set_resize_end_child (GTK_PANED (hpaned), FALSE);
    gtk_paned_set_shrink_end_child (GTK_PANED (hpaned), FALSE);
    gtk_widget_set_size_request (frame2, 50, -1);
    ```
    """

    class Props(Widget.Props):
        end_child: Widget | None  # [end-child]: changed because contained invalid characters
        max_position: int  # [max-position]: changed because contained invalid characters
        min_position: int  # [min-position]: changed because contained invalid characters
        position: int
        position_set: bool  # [position-set]: changed because contained invalid characters
        resize_end_child: bool  # [resize-end-child]: changed because contained invalid characters
        resize_start_child: bool  # [resize-start-child]: changed because contained invalid characters
        shrink_end_child: bool  # [shrink-end-child]: changed because contained invalid characters
        shrink_start_child: bool  # [shrink-start-child]: changed because contained invalid characters
        start_child: Widget | None  # [start-child]: changed because contained invalid characters
        wide_handle: bool  # [wide-handle]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        end_child: Widget | None = ...,
        position: int = ...,
        position_set: bool = ...,
        resize_end_child: bool = ...,
        resize_start_child: bool = ...,
        shrink_end_child: bool = ...,
        shrink_start_child: bool = ...,
        start_child: Widget | None = ...,
        wide_handle: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_end_child(self) -> Widget | None: ...
    @builtins.property
    def get_position(self) -> int: ...
    @builtins.property
    def get_resize_end_child(self) -> bool: ...
    @builtins.property
    def get_resize_start_child(self) -> bool: ...
    @builtins.property
    def get_shrink_end_child(self) -> bool: ...
    @builtins.property
    def get_shrink_start_child(self) -> bool: ...
    @builtins.property
    def get_start_child(self) -> Widget | None: ...
    @builtins.property
    def get_wide_handle(self) -> bool: ...
    @classmethod
    def new(cls, orientation: Orientation) -> Widget: ...
    def set_end_child(self, child: Widget | None = None) -> None: ...
    def set_position(self, position: int) -> None: ...
    def set_resize_end_child(self, resize: bool) -> None: ...
    def set_resize_start_child(self, resize: bool) -> None: ...
    def set_shrink_end_child(self, resize: bool) -> None: ...
    def set_shrink_start_child(self, resize: bool) -> None: ...
    def set_start_child(self, child: Widget | None = None) -> None: ...
    def set_wide_handle(self, wide: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["accept-position"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["cancel-position"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["cycle-child-focus"],
        handler: typing.Callable[[typing_extensions.Self, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["cycle-handle-focus"],
        handler: typing.Callable[[typing_extensions.Self, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-handle"],
        handler: typing.Callable[[typing_extensions.Self, ScrollType], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["toggle-handle-focus"],
        handler: typing.Callable[..., bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::end_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::position_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resize_end_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resize_start_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::shrink_end_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::shrink_start_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::start_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wide_handle"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PaperSize(GObject.GBoxed):
    # gi Methods
    def copy(self) -> PaperSize: ...
    def free(self) -> None: ...
    @staticmethod
    def get_default() -> str: ...
    def get_default_bottom_margin(self, unit: Unit) -> float: ...
    def get_default_left_margin(self, unit: Unit) -> float: ...
    def get_default_right_margin(self, unit: Unit) -> float: ...
    def get_default_top_margin(self, unit: Unit) -> float: ...
    def get_display_name(self) -> str: ...
    def get_height(self, unit: Unit) -> float: ...
    def get_name(self) -> str: ...
    @staticmethod
    def get_paper_sizes(include_custom: bool) -> list: ...
    def get_ppd_name(self) -> str: ...
    def get_width(self, unit: Unit) -> float: ...
    def is_custom(self) -> bool: ...
    def is_equal(self, size2: PaperSize) -> bool: ...
    def is_ipp(self) -> bool: ...
    @classmethod
    def new(cls, name: str | None = None) -> PaperSize: ...
    @classmethod
    def new_custom(cls, name: str, display_name: str, width: float, height: float, unit: Unit) -> PaperSize: ...
    @classmethod
    def new_from_gvariant(cls, variant: GLib.Variant) -> PaperSize: ...
    @classmethod
    def new_from_ipp(cls, ipp_name: str, width: float, height: float) -> PaperSize: ...
    @classmethod
    def new_from_key_file(cls, key_file: GLib.KeyFile, group_name: str | None = None) -> PaperSize: ...
    @classmethod
    def new_from_ppd(cls, ppd_name: str, ppd_display_name: str, width: float, height: float) -> PaperSize: ...
    def set_size(self, width: float, height: float, unit: Unit) -> None: ...
    def to_gvariant(self) -> GLib.Variant: ...
    def to_key_file(self, key_file: GLib.KeyFile, group_name: str) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class ParamSpecExpression(GObject.ParamSpec):
    """
    A `GParamSpec` for properties holding a `GtkExpression`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PasswordEntry(Widget):
    """
    A single-line text entry widget for entering passwords and other secrets.

    <picture>
      <source srcset="password-entry-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkPasswordEntry" src="password-entry.png">
    </picture>

    It does not show its contents in clear text, does not allow to copy it
    to the clipboard, and it shows a warning when Caps Lock is engaged. If
    the underlying platform allows it, `GtkPasswordEntry` will also place
    the text in a non-pageable memory area, to avoid it being written out
    to disk by the operating system.

    Optionally, it can offer a way to reveal the contents in clear text.

    `GtkPasswordEntry` provides only minimal API and should be used with
    the [iface@Gtk.Editable] API.

    # CSS Nodes

    ```
    entry.password
    ╰── text
        ├── image.caps-lock-indicator
        ┊
    ```

    `GtkPasswordEntry` has a single CSS node with name entry that carries
    a .passwordstyle class. The text Css node below it has a child with
    name image and style class .caps-lock-indicator for the Caps Lock
    icon, and possibly other children.

    # Accessibility

    `GtkPasswordEntry` uses the [enum@Gtk.AccessibleRole.text_box] role.
    """

    class Props(Widget.Props):
        activates_default: bool  # [activates-default]: changed because contained invalid characters
        extra_menu: Gio.MenuModel | None  # [extra-menu]: changed because contained invalid characters
        placeholder_text: str  # [placeholder-text]: changed because contained invalid characters
        show_peek_icon: bool  # [show-peek-icon]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        activates_default: bool = ...,
        extra_menu: Gio.MenuModel | None = ...,
        placeholder_text: str = ...,
        show_peek_icon: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_extra_menu(self) -> Gio.MenuModel | None: ...
    @builtins.property
    def get_show_peek_icon(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_extra_menu(self, model: Gio.MenuModel | None = None) -> None: ...
    def set_show_peek_icon(self, show_peek_icon: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activates_default"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::extra_menu"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::placeholder_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_peek_icon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PasswordEntryBuffer(EntryBuffer):
    """
    A `GtkEntryBuffer` that locks the underlying memory to prevent it
    from being swapped to disk.

    `GtkPasswordEntry` uses a `GtkPasswordEntryBuffer`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> EntryBuffer: ...

class PasswordEntryBufferClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> EntryBufferClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PasswordEntryClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Picture(Widget):
    """
    Displays a `GdkPaintable`.

    picture>
      <source srcset="picture-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkPicture" src="picture.png">
    </picture>

    Many convenience functions are provided to make pictures simple to use.
    For example, if you want to load an image from a file, and then display
    it, there’s a convenience function to do this:

    ```c
    GtkWidget *widget = gtk_picture_new_for_filename ("myfile.png");
    ```

    If the file isn’t loaded successfully, the picture will contain a
    “broken image” icon similar to that used in many web browsers.
    If you want to handle errors in loading the file yourself,
    for example by displaying an error message, then load the image with
    [ctor@Gdk.Texture.new_from_file], then create the `GtkPicture` with
    [ctor@Gtk.Picture.new_for_paintable].

    Sometimes an application will want to avoid depending on external data
    files, such as image files. See the documentation of `GResource` for details.
    In this case, [ctor@Gtk.Picture.new_for_resource] and
    [method@Gtk.Picture.set_resource] should be used.

    `GtkPicture` displays an image at its natural size. See [class@Gtk.Image]
    if you want to display a fixed-size image, such as an icon.

    ## Sizing the paintable

    You can influence how the paintable is displayed inside the `GtkPicture`
    by changing [property@Gtk.Picture:content-fit]. See [enum@Gtk.ContentFit]
    for details. [property@Gtk.Picture:can-shrink] can be unset to make sure
    that paintables are never made smaller than their ideal size - but
    be careful if you do not know the size of the paintable in use (like
    when displaying user-loaded images). This can easily cause the picture to
    grow larger than the screen. And [property@Gtk.Widget:halign] and
    [property@Gtk.Widget:valign] can be used to make sure the paintable doesn't
    fill all available space but is instead displayed at its original size.

    ## CSS nodes

    `GtkPicture` has a single CSS node with the name `picture`.

    ## Accessibility

    `GtkPicture` uses the [enum@Gtk.AccessibleRole.img] role.
    """

    class Props(Widget.Props):
        alternative_text: str  # [alternative-text]: changed because contained invalid characters
        can_shrink: bool  # [can-shrink]: changed because contained invalid characters
        content_fit: ContentFit  # [content-fit]: changed because contained invalid characters
        file: Gio.File | None
        keep_aspect_ratio: bool  # [keep-aspect-ratio]: changed because contained invalid characters
        paintable: Gdk.Paintable | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        alternative_text: str = ...,
        can_shrink: bool = ...,
        content_fit: ContentFit = ...,
        file: Gio.File | None = ...,
        keep_aspect_ratio: bool = ...,
        paintable: Gdk.Paintable | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_alternative_text(self) -> str | None: ...
    @builtins.property
    def get_can_shrink(self) -> bool: ...
    @builtins.property
    def get_content_fit(self) -> ContentFit: ...
    @builtins.property
    def get_file(self) -> Gio.File | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_keep_aspect_ratio(self) -> bool: ...
    @builtins.property
    def get_paintable(self) -> Gdk.Paintable | None: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_for_file(cls, file: Gio.File | None = None) -> Widget: ...
    @classmethod
    def new_for_filename(cls, filename: str | None = None) -> Widget: ...
    @classmethod
    def new_for_paintable(cls, paintable: Gdk.Paintable | None = None) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_for_pixbuf(cls, pixbuf: GdkPixbuf.Pixbuf | None = None) -> Widget: ...
    @classmethod
    def new_for_resource(cls, resource_path: str | None = None) -> Widget: ...
    def set_alternative_text(self, alternative_text: str | None = None) -> None: ...
    def set_can_shrink(self, can_shrink: bool) -> None: ...
    def set_content_fit(self, content_fit: ContentFit) -> None: ...
    def set_file(self, file: Gio.File | None = None) -> None: ...
    def set_filename(self, filename: str | None = None) -> None: ...
    @deprecated("deprecated")
    def set_keep_aspect_ratio(self, keep_aspect_ratio: bool) -> None: ...
    def set_paintable(self, paintable: Gdk.Paintable | None = None) -> None: ...
    @deprecated("deprecated")
    def set_pixbuf(self, pixbuf: GdkPixbuf.Pixbuf | None = None) -> None: ...
    def set_resource(self, resource_path: str | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::alternative_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_shrink"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::content_fit"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::keep_aspect_ratio"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::paintable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PictureClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Popover(Widget):
    """
    Presents a bubble-like popup.

    <picture>
      <source srcset="popover-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkPopover" src="popover.png">
    </picture>

    It is primarily meant to provide context-dependent information
    or options. Popovers are attached to a parent widget. By default,
    they point to the whole widget area, although this behavior can be
    changed with [method@Gtk.Popover.set_pointing_to].

    The position of a popover relative to the widget it is attached to
    can also be changed with [method@Gtk.Popover.set_position]

    By default, `GtkPopover` performs a grab, in order to ensure input
    events get redirected to it while it is shown, and also so the popover
    is dismissed in the expected situations (clicks outside the popover,
    or the Escape key being pressed). If no such modal behavior is desired
    on a popover, [method@Gtk.Popover.set_autohide] may be called on it to
    tweak its behavior.

    ## GtkPopover as menu replacement

    `GtkPopover` is often used to replace menus. The best way to do this
    is to use the [class@Gtk.PopoverMenu] subclass which supports being
    populated from a `GMenuModel` with [ctor@Gtk.PopoverMenu.new_from_model].

    ```xml
    <section>
      <attribute name="display-hint">horizontal-buttons</attribute>
      <item>
        <attribute name="label">Cut</attribute>
        <attribute name="action">app.cut</attribute>
        <attribute name="verb-icon">edit-cut-symbolic</attribute>
      </item>
      <item>
        <attribute name="label">Copy</attribute>
        <attribute name="action">app.copy</attribute>
        <attribute name="verb-icon">edit-copy-symbolic</attribute>
      </item>
      <item>
        <attribute name="label">Paste</attribute>
        <attribute name="action">app.paste</attribute>
        <attribute name="verb-icon">edit-paste-symbolic</attribute>
      </item>
    </section>
    ```

    # Shortcuts and Gestures

    `GtkPopover` supports the following keyboard shortcuts:

    - <kbd>Escape</kbd> closes the popover.
    - <kbd>Alt</kbd> makes the mnemonics visible.

    The following signals have default keybindings:

    - [signal@Gtk.Popover::activate-default]

    # CSS nodes

    ```
    popover.background[.menu]
    ├── arrow
    ╰── contents
        ╰── <child>
    ```

    `GtkPopover` has a main node with name `popover`, an arrow with name `arrow`,
    and another node for the content named `contents`. The `popover` node always
    gets the `.background` style class. It also gets the `.menu` style class
    if the popover is menu-like, e.g. is a [class@Gtk.PopoverMenu].

    Particular uses of `GtkPopover`, such as touch selection popups or
    magnifiers in `GtkEntry` or `GtkTextView` get style classes like
    `.touch-selection` or `.magnifier` to differentiate from plain popovers.

    When styling a popover directly, the `popover` node should usually
    not have any background. The visible part of the popover can have
    a shadow. To specify it in CSS, set the box-shadow of the `contents` node.

    Note that, in order to accomplish appropriate arrow visuals, `GtkPopover`
    uses custom drawing for the `arrow` node. This makes it possible for the
    arrow to change its shape dynamically, but it also limits the possibilities
    of styling it using CSS. In particular, the `arrow` gets drawn over the
    `content` node's border and shadow, so they look like one shape, which
    means that the border width of the `content` node and the `arrow` node should
    be the same. The arrow also does not support any border shape other than
    solid, no border-radius, only one border width (border-bottom-width is
    used) and no box-shadow.
    """

    class Props(Widget.Props):
        autohide: bool
        cascade_popdown: bool  # [cascade-popdown]: changed because contained invalid characters
        child: Widget | None
        default_widget: Widget | None  # [default-widget]: changed because contained invalid characters
        has_arrow: bool  # [has-arrow]: changed because contained invalid characters
        mnemonics_visible: bool  # [mnemonics-visible]: changed because contained invalid characters
        pointing_to: Gdk.Rectangle | None  # [pointing-to]: changed because contained invalid characters
        position: PositionType

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        autohide: bool = ...,
        cascade_popdown: bool = ...,
        child: Widget | None = ...,
        default_widget: Widget | None = ...,
        has_arrow: bool = ...,
        mnemonics_visible: bool = ...,
        pointing_to: Gdk.Rectangle | None = ...,
        position: PositionType = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_autohide(self) -> bool: ...
    @builtins.property
    def get_cascade_popdown(self) -> bool: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_has_arrow(self) -> bool: ...
    @builtins.property
    def get_mnemonics_visible(self) -> bool: ...
    def get_offset(self) -> tuple[int | None, int | None]: ...
    def get_pointing_to(self) -> tuple[bool, Gdk.Rectangle]: ...
    @builtins.property
    def get_position(self) -> PositionType: ...
    @classmethod
    def new(cls) -> Widget: ...
    def popdown(self) -> None: ...
    def popup(self) -> None: ...
    def present(self) -> None: ...
    def set_autohide(self, autohide: bool) -> None: ...
    def set_cascade_popdown(self, cascade_popdown: bool) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_default_widget(self, widget: Widget | None = None) -> None: ...
    def set_has_arrow(self, has_arrow: bool) -> None: ...
    def set_mnemonics_visible(self, mnemonics_visible: bool) -> None: ...
    def set_offset(self, x_offset: int, y_offset: int) -> None: ...
    def set_pointing_to(self, rect: Gdk.Rectangle | None = None) -> None: ...
    def set_position(self, position: PositionType) -> None: ...

    # python methods (overrides?)
    def do_activate_default(
        self,
    ) -> None:
        """
        activate_default(self)
        """
    def do_closed(
        self,
    ) -> None:
        """
        closed(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate-default"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["closed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::autohide"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cascade_popdown"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_arrow"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mnemonics_visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pointing_to"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PopoverClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate_default(self) -> activate_defaultPopoverClassCB: ...
    @builtins.property
    def closed(self) -> closedPopoverClassCB: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...
    @builtins.property
    def reserved(self) -> list | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PopoverMenu(Popover):
    """
    A subclass of `GtkPopover` that implements menu behavior.

    <picture>
      <source srcset="menu-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkPopoverMenu" src="menu.png">
    </picture>

    `GtkPopoverMenu` treats its children like menus and allows switching
    between them. It can open submenus as traditional, nested submenus,
    or in a more touch-friendly sliding fashion.
    The property [property@Gtk.PopoverMenu:flags] controls this appearance.

    `GtkPopoverMenu` is meant to be used primarily with menu models,
    using [ctor@Gtk.PopoverMenu.new_from_model]. If you need to put
    other widgets such as a `GtkSpinButton` or a `GtkSwitch` into a popover,
    you can use [method@Gtk.PopoverMenu.add_child].

    For more dialog-like behavior, use a plain `GtkPopover`.

    ## Menu models

    The XML format understood by `GtkBuilder` for `GMenuModel` consists
    of a toplevel `<menu>` element, which contains one or more `<item>`
    elements. Each `<item>` element contains `<attribute>` and `<link>`
    elements with a mandatory name attribute. `<link>` elements have the
    same content model as `<menu>`. Instead of `<link name="submenu">`
    or `<link name="section">`, you can use `<submenu>` or `<section>`
    elements.

    ```xml
    <menu id='app-menu'>
      <section>
        <item>
          <attribute name='label' translatable='yes'>_New Window</attribute>
          <attribute name='action'>app.new</attribute>
        </item>
        <item>
          <attribute name='label' translatable='yes'>_About Sunny</attribute>
          <attribute name='action'>app.about</attribute>
        </item>
        <item>
          <attribute name='label' translatable='yes'>_Quit</attribute>
          <attribute name='action'>app.quit</attribute>
        </item>
      </section>
    </menu>
    ```

    Attribute values can be translated using gettext, like other `GtkBuilder`
    content. `<attribute>` elements can be marked for translation with a
    `translatable="yes"` attribute. It is also possible to specify message
    context and translator comments, using the context and comments attributes.
    To make use of this, the `GtkBuilder` must have been given the gettext
    domain to use.

    The following attributes are used when constructing menu items:

    - "label": a user-visible string to display
    - "use-markup": whether the text in the menu item includes [Pango markup](https://docs.gtk.org/Pango/pango_markup.html)
    - "action": the prefixed name of the action to trigger
    - "target": the parameter to use when activating the action
    - "icon" and "verb-icon": names of icons that may be displayed
    - "submenu-action": name of an action that may be used to track
         whether a submenu is open
    - "hidden-when": a string used to determine when the item will be hidden.
         Possible values include "action-disabled", "action-missing", "macos-menubar".
         This is mainly useful for exported menus, see [method@Gtk.Application.set_menubar].
    - "custom": a string used to match against the ID of a custom child added with
         [method@Gtk.PopoverMenu.add_child], [method@Gtk.PopoverMenuBar.add_child],
         or in the ui file with `<child type="ID">`.

    The following attributes are used when constructing sections:

    - "label": a user-visible string to use as section heading
    - "display-hint": a string used to determine special formatting for the section.
        Possible values include "horizontal-buttons", "circular-buttons" and
        "inline-buttons". They all indicate that section should be
        displayed as a horizontal row of buttons.
    - "text-direction": a string used to determine the `GtkTextDirection` to use
        when "display-hint" is set to "horizontal-buttons". Possible values
        include "rtl", "ltr", and "none".

    The following attributes are used when constructing submenus:

    - "label": a user-visible string to display
    - "icon": icon name to display

    Menu items will also show accelerators, which are usually associated
    with actions via [method@Gtk.Application.set_accels_for_action],
    [method@WidgetClass.add_binding_action] or
    [method@Gtk.ShortcutController.add_shortcut].

    # Shortcuts and Gestures

    `GtkPopoverMenu` supports the following keyboard shortcuts:

    - <kbd>Space</kbd> activates the default widget.

    # CSS Nodes

    `GtkPopoverMenu` is just a subclass of `GtkPopover` that adds custom content
    to it, therefore it has the same CSS nodes. It is one of the cases that add
    a `.menu` style class to the main `popover` node.

    Menu items have nodes with name `button` and class `.model`. If a section
    display-hint is set, the section gets a node `box` with class `horizontal`
    plus a class with the same text as the display hint. Note that said box may
    not be the direct ancestor of the item `button`s. Thus, for example, to style
    items in an `inline-buttons` section, select `.inline-buttons button.model`.
    Other things that may be of interest to style in menus include `label` nodes.

    # Accessibility

    `GtkPopoverMenu` uses the [enum@Gtk.AccessibleRole.menu] role, and its
    items use the [enum@Gtk.AccessibleRole.menu_item],
    [enum@Gtk.AccessibleRole.checkbox] or [enum@Gtk.AccessibleRole.menu_item_radio]
    roles, depending on the action they are connected to.
    """

    class Props(Popover.Props):
        flags: PopoverMenuFlags
        menu_model: Gio.MenuModel | None  # [menu-model]: changed because contained invalid characters
        visible_submenu: str  # [visible-submenu]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, flags: PopoverMenuFlags = ..., menu_model: Gio.MenuModel | None = ..., visible_submenu: str = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_child(self, child: Widget, id: str) -> bool: ...
    @builtins.property
    def get_flags(self) -> PopoverMenuFlags: ...
    @builtins.property
    def get_menu_model(self) -> Gio.MenuModel | None: ...
    @classmethod
    def new_from_model(cls, model: Gio.MenuModel | None = None) -> Widget: ...
    @classmethod
    def new_from_model_full(cls, model: Gio.MenuModel, flags: PopoverMenuFlags) -> Widget: ...
    def remove_child(self, child: Widget) -> bool: ...
    def set_flags(self, flags: PopoverMenuFlags) -> None: ...
    def set_menu_model(self, model: Gio.MenuModel | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::menu_model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visible_submenu"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PopoverMenuBar(Widget):
    """
    Presents a horizontal bar of items that pop up menus when clicked.

    <picture>
      <source srcset="menubar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkPopoverMenuBar" src="menubar.png">
    </picture>

    The only way to create instances of `GtkPopoverMenuBar` is
    from a `GMenuModel`.

    # CSS nodes

    ```
    menubar
    ├── item[.active]
    ┊   ╰── popover
    ╰── item
        ╰── popover
    ```

    `GtkPopoverMenuBar` has a single CSS node with name menubar, below which
    each item has its CSS node, and below that the corresponding popover.

    The item whose popover is currently open gets the .active
    style class.

    # Accessibility

    `GtkPopoverMenuBar` uses the [enum@Gtk.AccessibleRole.menu_bar] role,
    the menu items use the [enum@Gtk.AccessibleRole.menu_item] role and
    the menus use the [enum@Gtk.AccessibleRole.menu] role.
    """

    class Props(Widget.Props):
        menu_model: Gio.MenuModel | None  # [menu-model]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, menu_model: Gio.MenuModel | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_child(self, child: Widget, id: str) -> bool: ...
    @builtins.property
    def get_menu_model(self) -> Gio.MenuModel | None: ...
    @classmethod
    def new_from_model(cls, model: Gio.MenuModel | None = None) -> Widget: ...
    def remove_child(self, child: Widget) -> bool: ...
    def set_menu_model(self, model: Gio.MenuModel | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::menu_model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PrintBackend(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PrintContext(GObject.Object):
    """
    Encapsulates context information that is required when
    drawing pages for printing.

    This includes the cairo context and important parameters like page size
    and resolution. It also lets you easily create [class@Pango.Layout] and
    [class@Pango.Context] objects that match the font metrics of the cairo surface.

    `GtkPrintContext` objects get passed to the
    [signal@Gtk.PrintOperation::begin-print],
    [signal@Gtk.PrintOperation::end-print],
    [signal@Gtk.PrintOperation::request-page-setup] and
    [signal@Gtk.PrintOperation::draw-page] signals on the
    [class@Gtk.PrintOperation] object.

    ## Using GtkPrintContext in a ::draw-page callback

    ```c
    static void
    draw_page (GtkPrintOperation *operation,
               GtkPrintContext   *context,
               int                page_nr)
    {
      cairo_t *cr;
      PangoLayout *layout;
      PangoFontDescription *desc;

      cr = gtk_print_context_get_cairo_context (context);

      // Draw a red rectangle, as wide as the paper (inside the margins)
      cairo_set_source_rgb (cr, 1.0, 0, 0);
      cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);

      cairo_fill (cr);

      // Draw some lines
      cairo_move_to (cr, 20, 10);
      cairo_line_to (cr, 40, 20);
      cairo_arc (cr, 60, 60, 20, 0, M_PI);
      cairo_line_to (cr, 80, 20);

      cairo_set_source_rgb (cr, 0, 0, 0);
      cairo_set_line_width (cr, 5);
      cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
      cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);

      cairo_stroke (cr);

      // Draw some text
      layout = gtk_print_context_create_pango_layout (context);
      pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
      desc = pango_font_description_from_string ("sans 28");
      pango_layout_set_font_description (layout, desc);
      pango_font_description_free (desc);

      cairo_move_to (cr, 30, 20);
      pango_cairo_layout_path (cr, layout);

      // Font Outline
      cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
      cairo_set_line_width (cr, 0.5);
      cairo_stroke_preserve (cr);

      // Font Fill
      cairo_set_source_rgb (cr, 0, 0.0, 1.0);
      cairo_fill (cr);

      g_object_unref (layout);
    }
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def create_pango_context(self) -> Pango.Context: ...
    def create_pango_layout(self) -> Pango.Layout: ...
    def get_cairo_context(self) -> cairo.Context: ...
    def get_dpi_x(self) -> float: ...
    def get_dpi_y(self) -> float: ...
    def get_hard_margins(self) -> tuple[bool, float, float, float, float]: ...
    def get_height(self) -> float: ...
    def get_page_setup(self) -> PageSetup: ...
    def get_pango_fontmap(self) -> Pango.FontMap: ...
    def get_width(self) -> float: ...
    def set_cairo_context(self, cr: cairo.Context, dpi_x: float, dpi_y: float) -> None: ...

class PrintDialog(GObject.Object):
    """
    Asynchronous API to present a print dialog to the user.

    `GtkPrintDialog` collects the arguments that are needed to present
     the dialog, such as a title for the dialog and whether it should
     be modal.

    The dialog is shown with the [method@Gtk.PrintDialog.setup] function.

    The actual printing can be done with [method@Gtk.PrintDialog.print] or
    [method@Gtk.PrintDialog.print_file]. These APIs follows the GIO async pattern,
    and the results can be obtained by calling the corresponding finish methods.
    """

    class Props(GObject.Object.Props):
        accept_label: str  # [accept-label]: changed because contained invalid characters
        modal: bool
        page_setup: PageSetup | None  # [page-setup]: changed because contained invalid characters
        print_settings: PrintSettings | None  # [print-settings]: changed because contained invalid characters
        title: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accept_label: str = ...,
        modal: bool = ...,
        page_setup: PageSetup | None = ...,
        print_settings: PrintSettings | None = ...,
        title: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_accept_label(self) -> str: ...
    @builtins.property
    def get_modal(self) -> bool: ...
    @builtins.property
    def get_page_setup(self) -> PageSetup | None: ...
    @builtins.property
    def get_print_settings(self) -> PrintSettings | None: ...
    @builtins.property
    def get_title(self) -> str: ...
    @classmethod
    def new(cls) -> PrintDialog: ...
    def print_(
        self,
        parent: Window | None = None,
        setup: PrintSetup | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def print_file(
        self,
        parent: Window | None,
        setup: PrintSetup | None,
        file: Gio.File,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def print_file_finish(self, result: Gio.AsyncResult) -> bool: ...
    def print_finish(self, result: Gio.AsyncResult) -> Gio.OutputStream: ...
    def set_accept_label(self, accept_label: str) -> None: ...
    def set_modal(self, modal: bool) -> None: ...
    def set_page_setup(self, page_setup: PageSetup) -> None: ...
    def set_print_settings(self, print_settings: PrintSettings) -> None: ...
    def set_title(self, title: str) -> None: ...
    def setup(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def setup_finish(self, result: Gio.AsyncResult) -> PrintSetup: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accept_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::page_setup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::print_settings"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PrintDialogClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PrintJob(GObject.Object):
    """
    Represents a job that is sent to a printer.

    You only need to deal directly with print jobs if you use the
    non-portable [class@Gtk.PrintUnixDialog] API.

    Use [method@Gtk.PrintJob.get_surface] to obtain the cairo surface
    onto which the pages must be drawn. Use [method@Gtk.PrintJob.send]
    to send the finished job to the printer. If you don’t use cairo
    `GtkPrintJob` also supports printing of manually generated PostScript,
    via [method@Gtk.PrintJob.set_source_file].
    """

    class Props(GObject.Object.Props):
        page_setup: PageSetup | None  # [page-setup]: changed because contained invalid characters
        printer: Printer | None
        settings: PrintSettings | None
        title: str
        track_print_status: bool  # [track-print-status]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        page_setup: PageSetup | None = ...,
        printer: Printer | None = ...,
        settings: PrintSettings | None = ...,
        title: str = ...,
        track_print_status: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_collate(self) -> bool: ...
    def get_n_up(self) -> int: ...
    def get_n_up_layout(self) -> NumberUpLayout: ...
    def get_num_copies(self) -> int: ...
    def get_page_ranges(self) -> tuple[list, int]: ...
    def get_page_set(self) -> PageSet: ...
    def get_pages(self) -> PrintPages: ...
    @builtins.property
    def get_printer(self) -> Printer: ...
    def get_reverse(self) -> bool: ...
    def get_rotate(self) -> bool: ...
    def get_scale(self) -> float: ...
    @builtins.property
    def get_settings(self) -> PrintSettings: ...
    def get_status(self) -> PrintStatus: ...
    def get_surface(self) -> cairo.Surface: ...
    @builtins.property
    def get_title(self) -> str: ...
    @builtins.property
    def get_track_print_status(self) -> bool: ...
    @classmethod
    def new(cls, title: str, printer: Printer, settings: PrintSettings, page_setup: PageSetup) -> PrintJob: ...
    def send(self, callback: PrintJobCompleteFunc, user_data: object | None, dnotify: GLib.DestroyNotify) -> None: ...
    def set_collate(self, collate: bool) -> None: ...
    def set_n_up(self, n_up: int) -> None: ...
    def set_n_up_layout(self, layout: NumberUpLayout) -> None: ...
    def set_num_copies(self, num_copies: int) -> None: ...
    def set_page_ranges(self, ranges: list, n_ranges: int) -> None: ...
    def set_page_set(self, page_set: PageSet) -> None: ...
    def set_pages(self, pages: PrintPages) -> None: ...
    def set_reverse(self, reverse: bool) -> None: ...
    def set_rotate(self, rotate: bool) -> None: ...
    def set_scale(self, scale: float) -> None: ...
    def set_source_fd(self, fd: int) -> bool: ...
    def set_source_file(self, filename: str) -> bool: ...
    def set_track_print_status(self, track_status: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["status-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::page_setup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::printer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::settings"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::track_print_status"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PrintOperation(GObject.Object):
    """
    High-level, portable printing API.

    It looks a bit different than other GTK dialogs such as the
    `GtkFileChooser`, since some platforms don’t expose enough
    infrastructure to implement a good print dialog. On such
    platforms, `GtkPrintOperation` uses the native print dialog.
    On platforms which do not provide a native print dialog, GTK
    uses its own, see [class@Gtk.PrintUnixDialog].

    The typical way to use the high-level printing API is to create
    a `GtkPrintOperation` object with [ctor@Gtk.PrintOperation.new]
    when the user selects to print. Then you set some properties on it,
    e.g. the page size, any [class@Gtk.PrintSettings] from previous print
    operations, the number of pages, the current page, etc.

    Then you start the print operation by calling [method@Gtk.PrintOperation.run].
    It will then show a dialog, let the user select a printer and options.
    When the user finished the dialog, various signals will be emitted on
    the `GtkPrintOperation`, the main one being
    [signal@Gtk.PrintOperation::draw-page], which you are supposed to handle
    and render the page on the provided [class@Gtk.PrintContext] using Cairo.

    # The high-level printing API

    ```c
    static GtkPrintSettings *settings = NULL;

    static void
    do_print (void)
    {
      GtkPrintOperation *print;
      GtkPrintOperationResult res;

      print = gtk_print_operation_new ();

      if (settings != NULL)
        gtk_print_operation_set_print_settings (print, settings);

      g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
      g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);

      res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
                                     GTK_WINDOW (main_window), NULL);

      if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
        {
          if (settings != NULL)
            g_object_unref (settings);
          settings = g_object_ref (gtk_print_operation_get_print_settings (print));
        }

      g_object_unref (print);
    }
    ```

    By default `GtkPrintOperation` uses an external application to do
    print preview. To implement a custom print preview, an application
    must connect to the preview signal. The functions
    [method@Gtk.PrintOperationPreview.render_page],
    [method@Gtk.PrintOperationPreview.end_preview] and
    [method@Gtk.PrintOperationPreview.is_selected]
    are useful when implementing a print preview.
    """

    class Props(GObject.Object.Props):
        allow_async: bool  # [allow-async]: changed because contained invalid characters
        current_page: int  # [current-page]: changed because contained invalid characters
        custom_tab_label: str  # [custom-tab-label]: changed because contained invalid characters
        default_page_setup: PageSetup | None  # [default-page-setup]: changed because contained invalid characters
        embed_page_setup: bool  # [embed-page-setup]: changed because contained invalid characters
        export_filename: str  # [export-filename]: changed because contained invalid characters
        has_selection: bool  # [has-selection]: changed because contained invalid characters
        job_name: str  # [job-name]: changed because contained invalid characters
        n_pages: int  # [n-pages]: changed because contained invalid characters
        n_pages_to_print: int  # [n-pages-to-print]: changed because contained invalid characters
        print_settings: PrintSettings | None  # [print-settings]: changed because contained invalid characters
        show_progress: bool  # [show-progress]: changed because contained invalid characters
        status: PrintStatus
        status_string: str  # [status-string]: changed because contained invalid characters
        support_selection: bool  # [support-selection]: changed because contained invalid characters
        track_print_status: bool  # [track-print-status]: changed because contained invalid characters
        unit: Unit
        use_full_page: bool  # [use-full-page]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        allow_async: bool = ...,
        current_page: int = ...,
        custom_tab_label: str = ...,
        default_page_setup: PageSetup | None = ...,
        embed_page_setup: bool = ...,
        export_filename: str = ...,
        has_selection: bool = ...,
        job_name: str = ...,
        n_pages: int = ...,
        print_settings: PrintSettings | None = ...,
        show_progress: bool = ...,
        support_selection: bool = ...,
        track_print_status: bool = ...,
        unit: Unit = ...,
        use_full_page: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def cancel(self) -> None: ...
    def draw_page_finish(self) -> None: ...
    @builtins.property
    def get_default_page_setup(self) -> PageSetup: ...
    @builtins.property
    def get_embed_page_setup(self) -> bool: ...
    def get_error(self) -> None: ...
    @builtins.property
    def get_has_selection(self) -> bool: ...
    @builtins.property
    def get_n_pages_to_print(self) -> int: ...
    @builtins.property
    def get_print_settings(self) -> PrintSettings | None: ...
    @builtins.property
    def get_status(self) -> PrintStatus: ...
    @builtins.property
    def get_status_string(self) -> str: ...
    @builtins.property
    def get_support_selection(self) -> bool: ...
    def is_finished(self) -> bool: ...
    @classmethod
    def new(cls) -> PrintOperation: ...
    def run(self, action: PrintOperationAction, parent: Window | None = None) -> PrintOperationResult: ...
    def set_allow_async(self, allow_async: bool) -> None: ...
    def set_current_page(self, current_page: int) -> None: ...
    def set_custom_tab_label(self, label: str | None = None) -> None: ...
    def set_default_page_setup(self, default_page_setup: PageSetup | None = None) -> None: ...
    def set_defer_drawing(self) -> None: ...
    def set_embed_page_setup(self, embed: bool) -> None: ...
    def set_export_filename(self, filename: str) -> None: ...
    def set_has_selection(self, has_selection: bool) -> None: ...
    def set_job_name(self, job_name: str) -> None: ...
    def set_n_pages(self, n_pages: int) -> None: ...
    def set_print_settings(self, print_settings: PrintSettings | None = None) -> None: ...
    def set_show_progress(self, show_progress: bool) -> None: ...
    def set_support_selection(self, support_selection: bool) -> None: ...
    def set_track_print_status(self, track_status: bool) -> None: ...
    def set_unit(self, unit: Unit) -> None: ...
    def set_use_full_page(self, full_page: bool) -> None: ...

    # python methods (overrides?)
    def do_begin_print(
        self,
        context: PrintContext,
    ) -> None:
        """
        begin_print(self, context:Gtk.PrintContext)
        """
    def do_custom_widget_apply(
        self,
        widget: Widget,
    ) -> None:
        """
        custom_widget_apply(self, widget:Gtk.Widget)
        """
    def do_done(
        self,
        result: PrintOperationResult,
    ) -> None:
        """
        done(self, result:Gtk.PrintOperationResult)
        """
    def do_draw_page(
        self,
        context: PrintContext,
        page_nr: int,
    ) -> None:
        """
        draw_page(self, context:Gtk.PrintContext, page_nr:int)
        """
    def do_end_print(
        self,
        context: PrintContext,
    ) -> None:
        """
        end_print(self, context:Gtk.PrintContext)
        """
    def do_paginate(
        self,
        context: PrintContext,
    ) -> bool:
        """
        paginate(self, context:Gtk.PrintContext) -> bool
        """
    def do_preview(
        self,
        preview: PrintOperationPreview,
        context: PrintContext,
        parent: Window,
    ) -> bool:
        """
        preview(self, preview:Gtk.PrintOperationPreview, context:Gtk.PrintContext, parent:Gtk.Window) -> bool
        """
    def do_request_page_setup(
        self,
        context: PrintContext,
        page_nr: int,
        setup: PageSetup,
    ) -> None:
        """
        request_page_setup(self, context:Gtk.PrintContext, page_nr:int, setup:Gtk.PageSetup)
        """
    def do_status_changed(
        self,
    ) -> None:
        """
        status_changed(self)
        """
    def do_update_custom_widget(
        self,
        widget: Widget,
        setup: PageSetup,
        settings: PrintSettings,
    ) -> None:
        """
        update_custom_widget(self, widget:Gtk.Widget, setup:Gtk.PageSetup, settings:Gtk.PrintSettings)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["begin-print"],
        handler: typing.Callable[[typing_extensions.Self, PrintContext], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["create-custom-widget"],
        handler: typing.Callable[..., GObject.Object | None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["custom-widget-apply"],
        handler: typing.Callable[[typing_extensions.Self, Widget], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["done"],
        handler: typing.Callable[[typing_extensions.Self, PrintOperationResult], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["draw-page"],
        handler: typing.Callable[[typing_extensions.Self, PrintContext, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["end-print"],
        handler: typing.Callable[[typing_extensions.Self, PrintContext], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["paginate"],
        handler: typing.Callable[[typing_extensions.Self, PrintContext], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["preview"],
        handler: typing.Callable[[typing_extensions.Self, PrintOperationPreview, PrintContext, Window | None], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["request-page-setup"],
        handler: typing.Callable[[typing_extensions.Self, PrintContext, int, PageSetup], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["status-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["update-custom-widget"],
        handler: typing.Callable[[typing_extensions.Self, Widget, PageSetup, PrintSettings], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::allow_async"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_page"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::custom_tab_label"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_page_setup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::embed_page_setup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::export_filename"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_selection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::job_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_pages"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_pages_to_print"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::print_settings"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_progress"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::status"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::status_string"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::support_selection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::track_print_status"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::unit"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_full_page"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PrintOperationClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def begin_print(self) -> begin_printPrintOperationClassCB: ...
    @builtins.property
    def custom_widget_apply(self) -> custom_widget_applyPrintOperationClassCB: ...
    @builtins.property
    def done(self) -> donePrintOperationClassCB: ...
    @builtins.property
    def draw_page(self) -> draw_pagePrintOperationClassCB: ...
    @builtins.property
    def end_print(self) -> end_printPrintOperationClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def paginate(self) -> paginatePrintOperationClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def preview(self) -> previewPrintOperationClassCB: ...
    @builtins.property
    def request_page_setup(self) -> request_page_setupPrintOperationClassCB: ...
    @builtins.property
    def status_changed(self) -> status_changedPrintOperationClassCB: ...
    @builtins.property
    def update_custom_widget(self) -> update_custom_widgetPrintOperationClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PrintOperationPreview(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def end_preview(self) -> None: ...
    def is_selected(self, page_nr: int) -> bool: ...
    def render_page(self, page_nr: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["got-page-size"],
        handler: typing.Callable[[typing_extensions.Self, PrintContext, PageSetup], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["ready"],
        handler: typing.Callable[[typing_extensions.Self, PrintContext], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PrintOperationPreviewIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def end_preview(self) -> end_previewPrintOperationPreviewIfaceCB: ...
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def got_page_size(self) -> got_page_sizePrintOperationPreviewIfaceCB: ...
    @builtins.property
    def is_selected(self) -> is_selectedPrintOperationPreviewIfaceCB: ...
    @builtins.property
    def ready(self) -> readyPrintOperationPreviewIfaceCB: ...
    @builtins.property
    def render_page(self) -> render_pagePrintOperationPreviewIfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PrintOperationPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PrintSettings(GObject.Object):
    """
    Collects the settings of a print dialog in a system-independent way.

    The main use for this object is that once you’ve printed you can get a
    settings object that represents the settings the user chose, and the next
    time you print you can pass that object in so that the user doesn’t have
    to re-set all his settings.

    Its also possible to enumerate the settings so that you can easily save
    the settings for the next time your app runs, or even store them in a
    document. The predefined keys try to use shared values as much as possible
    so that moving such a document between systems still works.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def copy(self) -> PrintSettings: ...
    def foreach(self, func: PrintSettingsFunc, user_data: object | None = None) -> None: ...
    def get(self, key: str) -> str | None: ...
    def get_bool(self, key: str) -> bool: ...
    def get_collate(self) -> bool: ...
    def get_default_source(self) -> str | None: ...
    def get_dither(self) -> str | None: ...
    def get_double(self, key: str) -> float: ...
    def get_double_with_default(self, key: str, def_: float) -> float: ...
    def get_duplex(self) -> PrintDuplex: ...
    def get_finishings(self) -> str | None: ...
    def get_int(self, key: str) -> int: ...
    def get_int_with_default(self, key: str, def_: int) -> int: ...
    def get_length(self, key: str, unit: Unit) -> float: ...
    def get_media_type(self) -> str | None: ...
    def get_n_copies(self) -> int: ...
    def get_number_up(self) -> int: ...
    def get_number_up_layout(self) -> NumberUpLayout: ...
    def get_orientation(self) -> PageOrientation: ...
    def get_output_bin(self) -> str | None: ...
    def get_page_ranges(self) -> tuple[list, int]: ...
    def get_page_set(self) -> PageSet: ...
    def get_paper_height(self, unit: Unit) -> float: ...
    def get_paper_size(self) -> PaperSize | None: ...
    def get_paper_width(self, unit: Unit) -> float: ...
    def get_print_pages(self) -> PrintPages: ...
    def get_printer(self) -> str | None: ...
    def get_printer_lpi(self) -> float: ...
    def get_quality(self) -> PrintQuality: ...
    def get_resolution(self) -> int: ...
    def get_resolution_x(self) -> int: ...
    def get_resolution_y(self) -> int: ...
    def get_reverse(self) -> bool: ...
    def get_scale(self) -> float: ...
    def get_use_color(self) -> bool: ...
    def has_key(self, key: str) -> bool: ...
    def load_file(self, file_name: str) -> bool: ...
    def load_key_file(self, key_file: GLib.KeyFile, group_name: str | None = None) -> bool: ...
    @classmethod
    def new(cls) -> PrintSettings: ...
    @classmethod
    def new_from_file(cls, file_name: str) -> PrintSettings: ...
    @classmethod
    def new_from_gvariant(cls, variant: GLib.Variant) -> PrintSettings: ...
    @classmethod
    def new_from_key_file(cls, key_file: GLib.KeyFile, group_name: str | None = None) -> PrintSettings: ...
    def set(self, key: str, value: str | None = None) -> None: ...
    def set_bool(self, key: str, value: bool) -> None: ...
    def set_collate(self, collate: bool) -> None: ...
    def set_default_source(self, default_source: str) -> None: ...
    def set_dither(self, dither: str) -> None: ...
    def set_double(self, key: str, value: float) -> None: ...
    def set_duplex(self, duplex: PrintDuplex) -> None: ...
    def set_finishings(self, finishings: str) -> None: ...
    def set_int(self, key: str, value: int) -> None: ...
    def set_length(self, key: str, value: float, unit: Unit) -> None: ...
    def set_media_type(self, media_type: str) -> None: ...
    def set_n_copies(self, num_copies: int) -> None: ...
    def set_number_up(self, number_up: int) -> None: ...
    def set_number_up_layout(self, number_up_layout: NumberUpLayout) -> None: ...
    def set_orientation(self, orientation: PageOrientation) -> None: ...
    def set_output_bin(self, output_bin: str) -> None: ...
    def set_page_ranges(self, page_ranges: list, num_ranges: int) -> None: ...
    def set_page_set(self, page_set: PageSet) -> None: ...
    def set_paper_height(self, height: float, unit: Unit) -> None: ...
    def set_paper_size(self, paper_size: PaperSize) -> None: ...
    def set_paper_width(self, width: float, unit: Unit) -> None: ...
    def set_print_pages(self, pages: PrintPages) -> None: ...
    def set_printer(self, printer: str) -> None: ...
    def set_printer_lpi(self, lpi: float) -> None: ...
    def set_quality(self, quality: PrintQuality) -> None: ...
    def set_resolution(self, resolution: int) -> None: ...
    def set_resolution_xy(self, resolution_x: int, resolution_y: int) -> None: ...
    def set_reverse(self, reverse: bool) -> None: ...
    def set_scale(self, scale: float) -> None: ...
    def set_use_color(self, use_color: bool) -> None: ...
    def to_file(self, file_name: str) -> bool: ...
    def to_gvariant(self) -> GLib.Variant: ...
    def to_key_file(self, key_file: GLib.KeyFile, group_name: str | None = None) -> None: ...
    def unset(self, key: str) -> None: ...

class PrintSetup(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_page_setup(self) -> PageSetup: ...
    def get_print_settings(self) -> PrintSettings: ...
    def ref(self) -> PrintSetup: ...
    def unref(self) -> None: ...

class PrintUnixDialog(Dialog):
    """
    A print dialog for platforms which don’t provide a native
    print dialog, like Unix.

    <picture>
      <source srcset="printdialog-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkPrintUnixDialog" src="printdialog.png">
    </picture>

    It can be used very much like any other GTK dialog, at the cost of
    the portability offered by the high-level printing API with
    [class@Gtk.PrintOperation].

    In order to print something with `GtkPrintUnixDialog`, you need to
    use [method@Gtk.PrintUnixDialog.get_selected_printer] to obtain a
    [class@Gtk.Printer] object and use it to construct a [class@Gtk.PrintJob]
    using [ctor@Gtk.PrintJob.new].

    `GtkPrintUnixDialog` uses the following response values:

    - %GTK_RESPONSE_OK: for the “Print” button
    - %GTK_RESPONSE_APPLY: for the “Preview” button
    - %GTK_RESPONSE_CANCEL: for the “Cancel” button

    # GtkPrintUnixDialog as GtkBuildable

    The `GtkPrintUnixDialog` implementation of the `GtkBuildable` interface
    exposes its @notebook internal children with the name “notebook”.

    An example of a `GtkPrintUnixDialog` UI definition fragment:

    ```xml
    <object class="GtkPrintUnixDialog" id="dialog1">
      <child internal-child="notebook">
        <object class="GtkNotebook" id="notebook">
          <child>
            <object type="GtkNotebookPage">
              <property name="tab_expand">False</property>
              <property name="tab_fill">False</property>
              <property name="tab">
                <object class="GtkLabel" id="tablabel">
                  <property name="label">Tab label</property>
                </object>
              </property>
              <property name="child">
                <object class="GtkLabel" id="tabcontent">
                  <property name="label">Content on notebook tab</property>
                </object>
              </property>
            </object>
          </child>
        </object>
      </child>
    </object>
    ```

    # CSS nodes

    `GtkPrintUnixDialog` has a single CSS node with name window. The style classes
    dialog and print are added.
    """

    class Props(Dialog.Props):
        current_page: int  # [current-page]: changed because contained invalid characters
        embed_page_setup: bool  # [embed-page-setup]: changed because contained invalid characters
        has_selection: bool  # [has-selection]: changed because contained invalid characters
        manual_capabilities: PrintCapabilities  # [manual-capabilities]: changed because contained invalid characters
        page_setup: PageSetup | None  # [page-setup]: changed because contained invalid characters
        print_settings: PrintSettings | None  # [print-settings]: changed because contained invalid characters
        selected_printer: Printer | None  # [selected-printer]: changed because contained invalid characters
        support_selection: bool  # [support-selection]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        current_page: int = ...,
        embed_page_setup: bool = ...,
        has_selection: bool = ...,
        manual_capabilities: PrintCapabilities = ...,
        page_setup: PageSetup | None = ...,
        print_settings: PrintSettings | None = ...,
        support_selection: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_custom_tab(self, child: Widget, tab_label: Widget) -> None: ...
    @builtins.property
    def get_current_page(self) -> int: ...
    @builtins.property
    def get_embed_page_setup(self) -> bool: ...
    @builtins.property
    def get_has_selection(self) -> bool: ...
    @builtins.property
    def get_manual_capabilities(self) -> PrintCapabilities: ...
    @builtins.property
    def get_page_setup(self) -> PageSetup: ...
    def get_page_setup_set(self) -> bool: ...
    @builtins.property
    def get_selected_printer(self) -> Printer | None: ...
    @builtins.property
    def get_settings(self) -> PrintSettings: ...
    @builtins.property
    def get_support_selection(self) -> bool: ...
    @classmethod
    def new(cls, title: str | None = None, parent: Window | None = None) -> Widget: ...
    def set_current_page(self, current_page: int) -> None: ...
    def set_embed_page_setup(self, embed: bool) -> None: ...
    def set_has_selection(self, has_selection: bool) -> None: ...
    def set_manual_capabilities(self, capabilities: PrintCapabilities) -> None: ...
    def set_page_setup(self, page_setup: PageSetup) -> None: ...
    def set_settings(self, settings: PrintSettings | None = None) -> None: ...
    def set_support_selection(self, support_selection: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::current_page"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::embed_page_setup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_selection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::manual_capabilities"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::page_setup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::print_settings"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selected_printer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::support_selection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Printer(GObject.Object):
    """
    Represents a printer.

    You only need to deal directly with printers if you use the
    non-portable [class@Gtk.PrintUnixDialog] API.

    A `GtkPrinter` allows to get status information about the printer,
    such as its description, its location, the number of queued jobs,
    etc. Most importantly, a `GtkPrinter` object can be used to create
    a [class@Gtk.PrintJob] object, which lets you print to the printer.
    """

    class Props(GObject.Object.Props):
        accepting_jobs: bool  # [accepting-jobs]: changed because contained invalid characters
        accepts_pdf: bool  # [accepts-pdf]: changed because contained invalid characters
        accepts_ps: bool  # [accepts-ps]: changed because contained invalid characters
        icon_name: str  # [icon-name]: changed because contained invalid characters
        is_virtual: bool  # [is-virtual]: changed because contained invalid characters
        job_count: int  # [job-count]: changed because contained invalid characters
        location: str
        name: str
        paused: bool
        state_message: str  # [state-message]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, accepts_pdf: bool = ..., accepts_ps: bool = ..., is_virtual: bool = ..., name: str = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def accepts_pdf(self) -> bool: ...
    @builtins.property
    def accepts_ps(self) -> bool: ...
    def compare(self, b: Printer) -> int: ...
    def get_backend(self) -> PrintBackend: ...
    def get_capabilities(self) -> PrintCapabilities: ...
    def get_default_page_size(self) -> PageSetup: ...
    def get_description(self) -> str: ...
    def get_hard_margins(self) -> tuple[bool, float, float, float, float]: ...
    def get_hard_margins_for_paper_size(self, paper_size: PaperSize) -> tuple[bool, float, float, float, float]: ...
    @builtins.property
    def get_icon_name(self) -> str: ...
    @builtins.property
    def get_job_count(self) -> int: ...
    @builtins.property
    def get_location(self) -> str: ...
    @builtins.property
    def get_name(self) -> str: ...
    @builtins.property
    def get_state_message(self) -> str: ...
    def has_details(self) -> bool: ...
    @builtins.property
    def is_accepting_jobs(self) -> bool: ...
    def is_active(self) -> bool: ...
    def is_default(self) -> bool: ...
    @builtins.property
    def is_paused(self) -> bool: ...
    @builtins.property
    def is_virtual(self) -> bool: ...
    def list_papers(self) -> list: ...
    @classmethod
    def new(cls, name: str, backend: PrintBackend, virtual_: bool) -> Printer: ...
    def request_details(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["details-acquired"],
        handler: typing.Callable[[typing_extensions.Self, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accepting_jobs"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accepts_pdf"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accepts_ps"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_virtual"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::job_count"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::location"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::paused"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state_message"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ProgressBar(Widget):
    """
    Displays the progress of a long-running operation.

    `GtkProgressBar` provides a visual clue that processing is underway.
    It can be used in two different modes: percentage mode and activity mode.

    <picture>
      <source srcset="progressbar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkProgressBar" src="progressbar.png">
    </picture>

    When an application can determine how much work needs to take place
    (e.g. read a fixed number of bytes from a file) and can monitor its
    progress, it can use the `GtkProgressBar` in percentage mode and the
    user sees a growing bar indicating the percentage of the work that
    has been completed. In this mode, the application is required to call
    [method@Gtk.ProgressBar.set_fraction] periodically to update the progress bar.

    When an application has no accurate way of knowing the amount of work
    to do, it can use the `GtkProgressBar` in activity mode, which shows
    activity by a block moving back and forth within the progress area. In
    this mode, the application is required to call [method@Gtk.ProgressBar.pulse]
    periodically to update the progress bar.

    There is quite a bit of flexibility provided to control the appearance
    of the `GtkProgressBar`. Functions are provided to control the orientation
    of the bar, optional text can be displayed along with the bar, and the
    step size used in activity mode can be set.

    # CSS nodes

    ```
    progressbar[.osd]
    ├── [text]
    ╰── trough[.empty][.full]
        ╰── progress[.pulse]
    ```

    `GtkProgressBar` has a main CSS node with name progressbar and subnodes with
    names text and trough, of which the latter has a subnode named progress. The
    text subnode is only present if text is shown. The progress subnode has the
    style class .pulse when in activity mode. It gets the style classes .left,
    .right, .top or .bottom added when the progress 'touches' the corresponding
    end of the GtkProgressBar. The .osd class on the progressbar node is for use
    in overlays like the one Epiphany has for page loading progress.

    # Accessibility

    `GtkProgressBar` uses the [enum@Gtk.AccessibleRole.progress_bar] role.
    """

    class Props(Widget.Props):
        ellipsize: Pango.EllipsizeMode
        fraction: float
        inverted: bool
        pulse_step: float  # [pulse-step]: changed because contained invalid characters
        show_text: bool  # [show-text]: changed because contained invalid characters
        text: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        ellipsize: Pango.EllipsizeMode = ...,
        fraction: float = ...,
        inverted: bool = ...,
        pulse_step: float = ...,
        show_text: bool = ...,
        text: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_ellipsize(self) -> Pango.EllipsizeMode: ...
    @builtins.property
    def get_fraction(self) -> float: ...
    @builtins.property
    def get_inverted(self) -> bool: ...
    @builtins.property
    def get_pulse_step(self) -> float: ...
    @builtins.property
    def get_show_text(self) -> bool: ...
    @builtins.property
    def get_text(self) -> str | None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def pulse(self) -> None: ...
    def set_ellipsize(self, mode: Pango.EllipsizeMode) -> None: ...
    def set_fraction(self, fraction: float) -> None: ...
    def set_inverted(self, inverted: bool) -> None: ...
    def set_pulse_step(self, fraction: float) -> None: ...
    def set_show_text(self, show_text: bool) -> None: ...
    def set_text(self, text: str | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ellipsize"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::fraction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inverted"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pulse_step"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PropertyExpression(Expression):
    """
    A `GObject` property value in a `GtkExpression`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_expression(self) -> Expression | None: ...
    def get_pspec(self) -> GObject.ParamSpec: ...
    @classmethod
    def new(cls, this_type: GObject.GType, expression: Expression | None, property_name: str) -> PropertyExpression: ...
    @classmethod
    def new_for_pspec(cls, expression: Expression | None, pspec: GObject.ParamSpec) -> PropertyExpression: ...

class PyGTKDeprecationWarning(gi.PyGIDeprecationWarning):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Range(Widget):
    """
    Base class for widgets which visualize an adjustment.

    Widgets that are derived from `GtkRange` include
    [class@Gtk.Scale] and [class@Gtk.Scrollbar].

    Apart from signals for monitoring the parameters of the adjustment,
    `GtkRange` provides properties and methods for setting a
    “fill level” on range widgets. See [method@Gtk.Range.set_fill_level].

    # Shortcuts and Gestures

    The `GtkRange` slider is draggable. Holding the <kbd>Shift</kbd> key while
    dragging, or initiating the drag with a long-press will enable the
    fine-tuning mode.
    """

    class Props(Widget.Props):
        adjustment: Adjustment | None
        fill_level: float  # [fill-level]: changed because contained invalid characters
        inverted: bool
        restrict_to_fill_level: bool  # [restrict-to-fill-level]: changed because contained invalid characters
        round_digits: int  # [round-digits]: changed because contained invalid characters
        show_fill_level: bool  # [show-fill-level]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        adjustment: Adjustment | None = ...,
        fill_level: float = ...,
        inverted: bool = ...,
        restrict_to_fill_level: bool = ...,
        round_digits: int = ...,
        show_fill_level: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_adjustment(self) -> Adjustment: ...
    @builtins.property
    def get_fill_level(self) -> float: ...
    def get_flippable(self) -> bool: ...
    @builtins.property
    def get_inverted(self) -> bool: ...
    def get_range_rect(self) -> Gdk.Rectangle: ...
    @builtins.property
    def get_restrict_to_fill_level(self) -> bool: ...
    @builtins.property
    def get_round_digits(self) -> int: ...
    @builtins.property
    def get_show_fill_level(self) -> bool: ...
    def get_slider_range(self) -> tuple[int | None, int | None]: ...
    def get_slider_size_fixed(self) -> bool: ...
    def get_value(self) -> float: ...
    def set_adjustment(self, adjustment: Adjustment) -> None: ...
    def set_fill_level(self, fill_level: float) -> None: ...
    def set_flippable(self, flippable: bool) -> None: ...
    def set_increments(self, step: float, page: float) -> None: ...
    def set_inverted(self, setting: bool) -> None: ...
    def set_range(self, min: float, max: float) -> None: ...
    def set_restrict_to_fill_level(self, restrict_to_fill_level: bool) -> None: ...
    def set_round_digits(self, round_digits: int) -> None: ...
    def set_show_fill_level(self, show_fill_level: bool) -> None: ...
    def set_slider_size_fixed(self, size_fixed: bool) -> None: ...
    def set_value(self, value: float) -> None: ...

    # python methods (overrides?)
    def do_adjust_bounds(
        self,
        new_value: float,
    ) -> None:
        """
        adjust_bounds(self, new_value:float)
        """
    def do_change_value(
        self,
        scroll: ScrollType,
        new_value: float,
    ) -> bool:
        """
        change_value(self, scroll:Gtk.ScrollType, new_value:float) -> bool
        """
    def do_get_range_border(
        self,
        border_: Border,
    ) -> None:
        """
        get_range_border(self, border_:Gtk.Border)
        """
    def do_move_slider(
        self,
        scroll: ScrollType,
    ) -> None:
        """
        move_slider(self, scroll:Gtk.ScrollType)
        """
    def do_value_changed(
        self,
    ) -> None:
        """
        value_changed(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["adjust-bounds"],
        handler: typing.Callable[[typing_extensions.Self, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["change-value"],
        handler: typing.Callable[[typing_extensions.Self, ScrollType, float], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-slider"],
        handler: typing.Callable[[typing_extensions.Self, ScrollType], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["value-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::adjustment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::fill_level"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inverted"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::restrict_to_fill_level"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::round_digits"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_fill_level"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class RangeClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def adjust_bounds(self) -> adjust_boundsRangeClassCB: ...
    @builtins.property
    def change_value(self) -> change_valueRangeClassCB: ...
    @builtins.property
    def get_range_border(self) -> get_range_borderRangeClassCB: ...
    @builtins.property
    def move_slider(self) -> move_sliderRangeClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...
    @builtins.property
    def value_changed(self) -> value_changedRangeClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class RecentData(GObject.GPointer):
    # gi Fields
    app_exec: str = ...
    app_name: str = ...
    description: str = ...
    display_name: str = ...
    groups: list | None = ...
    is_private: bool = ...
    mime_type: str = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class RecentInfo(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def create_app_info(self, app_name: str | None = None) -> Gio.AppInfo | None: ...
    def exists(self) -> bool: ...
    def get_added(self) -> GLib.DateTime: ...
    def get_age(self) -> int: ...
    def get_application_info(self, app_name: str) -> tuple[bool, str, int, GLib.DateTime]: ...
    def get_applications(self) -> tuple[list, int | None]: ...
    def get_description(self) -> str: ...
    def get_display_name(self) -> str: ...
    def get_gicon(self) -> Gio.Icon | None: ...
    def get_groups(self) -> tuple[list, int | None]: ...
    def get_mime_type(self) -> str: ...
    def get_modified(self) -> GLib.DateTime: ...
    def get_private_hint(self) -> bool: ...
    def get_short_name(self) -> str: ...
    def get_uri(self) -> str: ...
    def get_uri_display(self) -> str | None: ...
    def get_visited(self) -> GLib.DateTime: ...
    def has_application(self, app_name: str) -> bool: ...
    def has_group(self, group_name: str) -> bool: ...
    def is_local(self) -> bool: ...
    def last_application(self) -> str: ...
    def match(self, info_b: RecentInfo) -> bool: ...
    def ref(self) -> RecentInfo: ...
    def unref(self) -> None: ...

class RecentManager(GObject.Object):
    """
    Manages and looks up recently used files.

    Each recently used file is identified by its URI, and has meta-data
    associated to it, like the names and command lines of the applications
    that have registered it, the number of time each application has
    registered the same file, the mime type of the file and whether
    the file should be displayed only by the applications that have
    registered it.

    The recently used files list is per user.

    `GtkRecentManager` acts like a database of all the recently
    used files. You can create new `GtkRecentManager` objects, but
    it is more efficient to use the default manager created by GTK.

    Adding a new recently used file is as simple as:

    ```c
    GtkRecentManager *manager;

    manager = gtk_recent_manager_get_default ();
    gtk_recent_manager_add_item (manager, file_uri);
    ```

    The `GtkRecentManager` will try to gather all the needed information
    from the file itself through GIO.

    Looking up the meta-data associated with a recently used file
    given its URI requires calling [method@Gtk.RecentManager.lookup_item]:

    ```c
    GtkRecentManager *manager;
    GtkRecentInfo *info;
    GError *error = NULL;

    manager = gtk_recent_manager_get_default ();
    info = gtk_recent_manager_lookup_item (manager, file_uri, &error);
    if (error)
      {
        g_warning ("Could not find the file: %s", error->message);
        g_error_free (error);
      }
    else
     {
       // Use the info object
       gtk_recent_info_unref (info);
     }
    ```

    In order to retrieve the list of recently used files, you can use
    [method@Gtk.RecentManager.get_items], which returns a list of
    [struct@Gtk.RecentInfo].

    Note that the maximum age of the recently used files list is
    controllable through the [property@Gtk.Settings:gtk-recent-files-max-age]
    property.
    """

    class Props(GObject.Object.Props):
        filename: str
        size: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, filename: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_full(self, uri: str, recent_data: RecentData) -> bool: ...
    def add_item(self, uri: str) -> bool: ...
    @staticmethod
    def get_default() -> RecentManager: ...
    def get_items(self) -> list: ...
    def has_item(self, uri: str) -> bool: ...
    def lookup_item(self, uri: str) -> RecentInfo | None: ...
    def move_item(self, uri: str, new_uri: str | None = None) -> bool: ...
    @classmethod
    def new(cls) -> RecentManager: ...
    def purge_items(self) -> int: ...
    def remove_item(self, uri: str) -> bool: ...

    # python methods (overrides?)
    def do_changed(
        self,
    ) -> None:
        """
        changed(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::filename"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class RecentManagerClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def changed(self) -> changedRecentManagerClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class RecentManagerPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class RequestedSize(GObject.GPointer):
    # gi Fields
    minimum_size: int = ...
    natural_size: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Requisition(GObject.GBoxed):
    # gi Fields
    height: int = ...
    width: int = ...

    # gi Methods
    def copy(self) -> Requisition: ...
    def free(self) -> None: ...
    @classmethod
    def new(cls) -> Requisition: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class Revealer(Widget):
    """
    Animates the transition of its child from invisible to visible.

    The style of transition can be controlled with
    [method@Gtk.Revealer.set_transition_type].

    These animations respect the [property@Gtk.Settings:gtk-enable-animations]
    setting.

    # CSS nodes

    `GtkRevealer` has a single CSS node with name revealer.
    When styling `GtkRevealer` using CSS, remember that it only hides its contents,
    not itself. That means applied margin, padding and borders will be visible even
    when the [property@Gtk.Revealer:reveal-child] property is set to %FALSE.

    # Accessibility

    `GtkRevealer` uses the [enum@Gtk.AccessibleRole.group] role.

    The child of `GtkRevealer`, if set, is always available in the accessibility
    tree, regardless of the state of the revealer widget.
    """

    class Props(Widget.Props):
        child: Widget | None
        child_revealed: bool  # [child-revealed]: changed because contained invalid characters
        reveal_child: bool  # [reveal-child]: changed because contained invalid characters
        transition_duration: int  # [transition-duration]: changed because contained invalid characters
        transition_type: RevealerTransitionType  # [transition-type]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        child: Widget | None = ...,
        reveal_child: bool = ...,
        transition_duration: int = ...,
        transition_type: RevealerTransitionType = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_child_revealed(self) -> bool: ...
    @builtins.property
    def get_reveal_child(self) -> bool: ...
    @builtins.property
    def get_transition_duration(self) -> int: ...
    @builtins.property
    def get_transition_type(self) -> RevealerTransitionType: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_reveal_child(self, reveal_child: bool) -> None: ...
    def set_transition_duration(self, duration: int) -> None: ...
    def set_transition_type(self, transition: RevealerTransitionType) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child_revealed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::reveal_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::transition_duration"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::transition_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Root(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_display(self) -> Gdk.Display: ...
    def get_focus(self) -> Widget | None: ...
    def set_focus(self, focus: Widget | None = None) -> None: ...

class RootInterface(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Scale(Range):
    """
    Allows to select a numeric value with a slider control.

    <picture>
      <source srcset="scales-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkScale" src="scales.png">
    </picture>

    To use it, you’ll probably want to investigate the methods on its base
    class, [class@Gtk.Range], in addition to the methods for `GtkScale` itself.
    To set the value of a scale, you would normally use [method@Gtk.Range.set_value].
    To detect changes to the value, you would normally use the
    [signal@Gtk.Range::value-changed] signal.

    Note that using the same upper and lower bounds for the `GtkScale` (through
    the `GtkRange` methods) will hide the slider itself. This is useful for
    applications that want to show an undeterminate value on the scale, without
    changing the layout of the application (such as movie or music players).

    # GtkScale as GtkBuildable

    `GtkScale` supports a custom `<marks>` element, which can contain multiple
    `<mark>` elements. The “value” and “position” attributes have the same
    meaning as [method@Gtk.Scale.add_mark] parameters of the same name. If
    the element is not empty, its content is taken as the markup to show at
    the mark. It can be translated with the usual ”translatable” and
    “context” attributes.

    # Shortcuts and Gestures

    `GtkPopoverMenu` supports the following keyboard shortcuts:

    - Arrow keys, <kbd>+</kbd> and <kbd>-</kbd> will increment or decrement
      by step, or by page when combined with <kbd>Ctrl</kbd>.
    - <kbd>PgUp</kbd> and <kbd>PgDn</kbd> will increment or decrement by page.
    - <kbd>Home</kbd> and <kbd>End</kbd> will set the minimum or maximum value.

    # CSS nodes

    ```
    scale[.fine-tune][.marks-before][.marks-after]
    ├── [value][.top][.right][.bottom][.left]
    ├── marks.top
    │   ├── mark
    │   ┊    ├── [label]
    │   ┊    ╰── indicator
    ┊   ┊
    │   ╰── mark
    ├── marks.bottom
    │   ├── mark
    │   ┊    ├── indicator
    │   ┊    ╰── [label]
    ┊   ┊
    │   ╰── mark
    ╰── trough
        ├── [fill]
        ├── [highlight]
        ╰── slider
    ```

    `GtkScale` has a main CSS node with name scale and a subnode for its contents,
    with subnodes named trough and slider.

    The main node gets the style class .fine-tune added when the scale is in
    'fine-tuning' mode.

    If the scale has an origin (see [method@Gtk.Scale.set_has_origin]), there is
    a subnode with name highlight below the trough node that is used for rendering
    the highlighted part of the trough.

    If the scale is showing a fill level (see [method@Gtk.Range.set_show_fill_level]),
    there is a subnode with name fill below the trough node that is used for
    rendering the filled in part of the trough.

    If marks are present, there is a marks subnode before or after the trough
    node, below which each mark gets a node with name mark. The marks nodes get
    either the .top or .bottom style class.

    The mark node has a subnode named indicator. If the mark has text, it also
    has a subnode named label. When the mark is either above or left of the
    scale, the label subnode is the first when present. Otherwise, the indicator
    subnode is the first.

    The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
    added depending on what marks are present.

    If the scale is displaying the value (see [property@Gtk.Scale:draw-value]),
    there is subnode with name value. This node will get the .top or .bottom style
    classes similar to the marks node.

    # Accessibility

    `GtkScale` uses the [enum@Gtk.AccessibleRole.slider] role.
    """

    class Props(Range.Props):
        digits: int
        draw_value: bool  # [draw-value]: changed because contained invalid characters
        has_origin: bool  # [has-origin]: changed because contained invalid characters
        value_pos: PositionType  # [value-pos]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, digits: int = ..., draw_value: bool = ..., has_origin: bool = ..., value_pos: PositionType = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_mark(self, value: float, position: PositionType, markup: str | None = None) -> None: ...
    def clear_marks(self) -> None: ...
    @builtins.property
    def get_digits(self) -> int: ...
    @builtins.property
    def get_draw_value(self) -> bool: ...
    @builtins.property
    def get_has_origin(self) -> bool: ...
    def get_layout(self) -> Pango.Layout | None: ...
    def get_layout_offsets(self) -> tuple[int | None, int | None]: ...
    @builtins.property
    def get_value_pos(self) -> PositionType: ...
    @classmethod
    def new(cls, orientation: Orientation, adjustment: Adjustment | None = None) -> Widget: ...
    @classmethod
    def new_with_range(cls, orientation: Orientation, min: float, max: float, step: float) -> Widget: ...
    def set_digits(self, digits: int) -> None: ...
    def set_draw_value(self, draw_value: bool) -> None: ...
    def set_format_value_func(
        self,
        func: ScaleFormatValueFunc | None = None,
        user_data: object | None = None,
        destroy_notify: GLib.DestroyNotify | None = None,
    ) -> None: ...
    def set_has_origin(self, has_origin: bool) -> None: ...
    def set_value_pos(self, pos: PositionType) -> None: ...

    # python methods (overrides?)
    def do_get_layout_offsets(
        self,
    ) -> tuple:
        """
        get_layout_offsets(self) -> x:int, y:int
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::digits"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::draw_value"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_origin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::value_pos"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ScaleButton(Widget):
    """
    Provides a button which pops up a scale widget.

    This kind of widget is commonly used for volume controls in multimedia
    applications, and GTK provides a [class@Gtk.VolumeButton] subclass that
    is tailored for this use case.

    # Shortcuts and Gestures

    The following signals have default keybindings:

    - [signal@Gtk.ScaleButton::popup]

    # CSS nodes

    ```
    scalebutton.scale
    ╰── button.toggle
        ╰── <icon>
    ```

    `GtkScaleButton` has a single CSS node with name scalebutton and `.scale`
    style class, and contains a `button` node with a `.toggle` style class.
    """

    class Props(Widget.Props):
        active: bool
        adjustment: Adjustment | None
        has_frame: bool  # [has-frame]: changed because contained invalid characters
        icons: list | None
        value: float

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, adjustment: Adjustment | None = ..., has_frame: bool = ..., icons: list | None = ..., value: float = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_active(self) -> bool: ...
    @builtins.property
    def get_adjustment(self) -> Adjustment: ...
    @builtins.property
    def get_has_frame(self) -> bool: ...
    def get_minus_button(self) -> Button: ...
    def get_plus_button(self) -> Button: ...
    def get_popup(self) -> Widget: ...
    @builtins.property
    def get_value(self) -> float: ...
    @classmethod
    def new(cls, min: float, max: float, step: float, icons: list | None = None) -> Widget: ...
    def set_adjustment(self, adjustment: Adjustment) -> None: ...
    def set_has_frame(self, has_frame: bool) -> None: ...
    def set_icons(self, icons: list) -> None: ...
    def set_value(self, value: float) -> None: ...

    # python methods (overrides?)
    def do_value_changed(
        self,
        value: float,
    ) -> None:
        """
        value_changed(self, value:float)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["popdown"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["popup"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["value-changed"],
        handler: typing.Callable[[typing_extensions.Self, float], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::adjustment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_frame"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icons"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::value"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ScaleButtonClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...
    @builtins.property
    def value_changed(self) -> value_changedScaleButtonClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ScaleClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def get_layout_offsets(self) -> get_layout_offsetsScaleClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> RangeClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ScrollInfo(GObject.GBoxed):
    # gi Methods
    def get_enable_horizontal(self) -> bool: ...
    def get_enable_vertical(self) -> bool: ...
    @classmethod
    def new(cls) -> ScrollInfo: ...
    def ref(self) -> ScrollInfo: ...
    def set_enable_horizontal(self, horizontal: bool) -> None: ...
    def set_enable_vertical(self, vertical: bool) -> None: ...
    def unref(self) -> None: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class Scrollable(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        hadjustment: Adjustment | None
        hscroll_policy: ScrollablePolicy  # [hscroll-policy]: changed because contained invalid characters
        vadjustment: Adjustment | None
        vscroll_policy: ScrollablePolicy  # [vscroll-policy]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        hadjustment: Adjustment | None = ...,
        hscroll_policy: ScrollablePolicy = ...,
        vadjustment: Adjustment | None = ...,
        vscroll_policy: ScrollablePolicy = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_border(self) -> tuple[bool, Border]: ...
    @builtins.property
    def get_hadjustment(self) -> Adjustment | None: ...
    @builtins.property
    def get_hscroll_policy(self) -> ScrollablePolicy: ...
    @builtins.property
    def get_vadjustment(self) -> Adjustment | None: ...
    @builtins.property
    def get_vscroll_policy(self) -> ScrollablePolicy: ...
    def set_hadjustment(self, hadjustment: Adjustment | None = None) -> None: ...
    def set_hscroll_policy(self, policy: ScrollablePolicy) -> None: ...
    def set_vadjustment(self, vadjustment: Adjustment | None = None) -> None: ...
    def set_vscroll_policy(self, policy: ScrollablePolicy) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hadjustment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hscroll_policy"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::vadjustment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::vscroll_policy"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ScrollableInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def base_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_border(self) -> get_borderScrollableInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Scrollbar(Widget):
    """
    Shows a horizontal or vertical scrollbar.

    <picture>
      <source srcset="scrollbar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkScrollbar" src="scrollbar.png">
    </picture>

    Its position and movement are controlled by the adjustment that is passed to
    or created by [ctor@Gtk.Scrollbar.new]. See [class@Gtk.Adjustment] for more
    details. The [property@Gtk.Adjustment:value] field sets the position of the
    thumb and must be between [property@Gtk.Adjustment:lower] and
    [property@Gtk.Adjustment:upper] - [property@Gtk.Adjustment:page-size].
    The [property@Gtk.Adjustment:page-size] represents the size of the visible
    scrollable area.

    The fields [property@Gtk.Adjustment:step-increment] and
    [property@Gtk.Adjustment:page-increment] fields are added to or subtracted
    from the [property@Gtk.Adjustment:value] when the user asks to move by a step
    (using e.g. the cursor arrow keys) or by a page (using e.g. the Page Down/Up
    keys).

    # CSS nodes

    ```
    scrollbar
    ╰── range[.fine-tune]
        ╰── trough
            ╰── slider
    ```

    `GtkScrollbar` has a main CSS node with name scrollbar and a subnode for its
    contents. The main node gets the .horizontal or .vertical style classes applied,
    depending on the scrollbar's orientation.

    The range node gets the style class .fine-tune added when the scrollbar is
    in 'fine-tuning' mode.

    Other style classes that may be added to scrollbars inside
    [class@Gtk.ScrolledWindow] include the positional classes (.left, .right,
    .top, .bottom) and style classes related to overlay scrolling (.overlay-indicator,
    .dragging, .hovering).

    # Accessibility

    `GtkScrollbar` uses the [enum@Gtk.AccessibleRole.scrollbar] role.
    """

    class Props(Widget.Props):
        adjustment: Adjustment | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, adjustment: Adjustment | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_adjustment(self) -> Adjustment: ...
    @classmethod
    def new(cls, orientation: Orientation, adjustment: Adjustment | None = None) -> Widget: ...
    def set_adjustment(self, adjustment: Adjustment | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::adjustment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ScrolledWindow(Widget):
    """
    Makes its child scrollable.

    <picture>
      <source srcset="scrolledwindow-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkScrolledWindow" src="scrolledwindow.png">
    </picture>

    It does so using either internally added scrollbars or externally
    associated adjustments, and optionally draws a frame around the child.

    Widgets with native scrolling support, i.e. those whose classes implement
    the [iface@Gtk.Scrollable] interface, are added directly. For other types
    of widget, the class [class@Gtk.Viewport] acts as an adaptor, giving
    scrollability to other widgets. [method@Gtk.ScrolledWindow.set_child]
    intelligently accounts for whether or not the added child is a `GtkScrollable`.
    If it isn’t, then it wraps the child in a `GtkViewport`. Therefore, you can
    just add any child widget and not worry about the details.

    If [method@Gtk.ScrolledWindow.set_child] has added a `GtkViewport` for you,
    it will be automatically removed when you unset the child.
    Unless [property@Gtk.ScrolledWindow:hscrollbar-policy] and
    [property@Gtk.ScrolledWindow:vscrollbar-policy] are %GTK_POLICY_NEVER or
    %GTK_POLICY_EXTERNAL, `GtkScrolledWindow` adds internal `GtkScrollbar` widgets
    around its child. The scroll position of the child, and if applicable the
    scrollbars, is controlled by the [property@Gtk.ScrolledWindow:hadjustment]
    and [property@Gtk.ScrolledWindow:vadjustment] that are associated with the
    `GtkScrolledWindow`. See the docs on [class@Gtk.Scrollbar] for the details,
    but note that the “step_increment” and “page_increment” fields are only
    effective if the policy causes scrollbars to be present.

    If a `GtkScrolledWindow` doesn’t behave quite as you would like, or
    doesn’t have exactly the right layout, it’s very possible to set up
    your own scrolling with `GtkScrollbar` and for example a `GtkGrid`.

    # Touch support

    `GtkScrolledWindow` has built-in support for touch devices. When a
    touchscreen is used, swiping will move the scrolled window, and will
    expose 'kinetic' behavior. This can be turned off with the
    [property@Gtk.ScrolledWindow:kinetic-scrolling] property if it is undesired.

    `GtkScrolledWindow` also displays visual 'overshoot' indication when
    the content is pulled beyond the end, and this situation can be
    captured with the [signal@Gtk.ScrolledWindow::edge-overshot] signal.

    If no mouse device is present, the scrollbars will overlaid as
    narrow, auto-hiding indicators over the content. If traditional
    scrollbars are desired although no mouse is present, this behaviour
    can be turned off with the [property@Gtk.ScrolledWindow:overlay-scrolling]
    property.

    # Shortcuts and Gestures

    The following signals have default keybindings:

    - [signal@Gtk.ScrolledWindow::scroll-child]

    # CSS nodes

    `GtkScrolledWindow` has a main CSS node with name scrolledwindow.
    It gets a .frame style class added when [property@Gtk.ScrolledWindow:has-frame]
    is %TRUE.

    It uses subnodes with names overshoot and undershoot to draw the overflow
    and underflow indications. These nodes get the .left, .right, .top or .bottom
    style class added depending on where the indication is drawn.

    `GtkScrolledWindow` also sets the positional style classes (.left, .right,
    .top, .bottom) and style classes related to overlay scrolling
    (.overlay-indicator, .dragging, .hovering) on its scrollbars.

    If both scrollbars are visible, the area where they meet is drawn
    with a subnode named junction.

    # Accessibility

    Until GTK 4.10, `GtkScrolledWindow` used the [enum@Gtk.AccessibleRole.group] role.

    Starting from GTK 4.12, `GtkScrolledWindow` uses the [enum@Gtk.AccessibleRole.generic]
    role.
    """

    class Props(Widget.Props):
        child: Widget | None
        hadjustment: Adjustment | None
        has_frame: bool  # [has-frame]: changed because contained invalid characters
        hscrollbar_policy: PolicyType  # [hscrollbar-policy]: changed because contained invalid characters
        kinetic_scrolling: bool  # [kinetic-scrolling]: changed because contained invalid characters
        max_content_height: int  # [max-content-height]: changed because contained invalid characters
        max_content_width: int  # [max-content-width]: changed because contained invalid characters
        min_content_height: int  # [min-content-height]: changed because contained invalid characters
        min_content_width: int  # [min-content-width]: changed because contained invalid characters
        overlay_scrolling: bool  # [overlay-scrolling]: changed because contained invalid characters
        propagate_natural_height: bool  # [propagate-natural-height]: changed because contained invalid characters
        propagate_natural_width: bool  # [propagate-natural-width]: changed because contained invalid characters
        vadjustment: Adjustment | None
        vscrollbar_policy: PolicyType  # [vscrollbar-policy]: changed because contained invalid characters
        window_placement: CornerType  # [window-placement]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        child: Widget | None = ...,
        hadjustment: Adjustment | None = ...,
        has_frame: bool = ...,
        hscrollbar_policy: PolicyType = ...,
        kinetic_scrolling: bool = ...,
        max_content_height: int = ...,
        max_content_width: int = ...,
        min_content_height: int = ...,
        min_content_width: int = ...,
        overlay_scrolling: bool = ...,
        propagate_natural_height: bool = ...,
        propagate_natural_width: bool = ...,
        vadjustment: Adjustment | None = ...,
        vscrollbar_policy: PolicyType = ...,
        window_placement: CornerType = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_hadjustment(self) -> Adjustment: ...
    @builtins.property
    def get_has_frame(self) -> bool: ...
    def get_hscrollbar(self) -> Widget: ...
    @builtins.property
    def get_kinetic_scrolling(self) -> bool: ...
    @builtins.property
    def get_max_content_height(self) -> int: ...
    @builtins.property
    def get_max_content_width(self) -> int: ...
    @builtins.property
    def get_min_content_height(self) -> int: ...
    @builtins.property
    def get_min_content_width(self) -> int: ...
    @builtins.property
    def get_overlay_scrolling(self) -> bool: ...
    @builtins.property
    def get_placement(self) -> CornerType: ...
    def get_policy(self) -> tuple[PolicyType | None, PolicyType | None]: ...
    @builtins.property
    def get_propagate_natural_height(self) -> bool: ...
    @builtins.property
    def get_propagate_natural_width(self) -> bool: ...
    @builtins.property
    def get_vadjustment(self) -> Adjustment: ...
    def get_vscrollbar(self) -> Widget: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_hadjustment(self, hadjustment: Adjustment | None = None) -> None: ...
    def set_has_frame(self, has_frame: bool) -> None: ...
    def set_kinetic_scrolling(self, kinetic_scrolling: bool) -> None: ...
    def set_max_content_height(self, height: int) -> None: ...
    def set_max_content_width(self, width: int) -> None: ...
    def set_min_content_height(self, height: int) -> None: ...
    def set_min_content_width(self, width: int) -> None: ...
    def set_overlay_scrolling(self, overlay_scrolling: bool) -> None: ...
    def set_placement(self, window_placement: CornerType) -> None: ...
    def set_policy(self, hscrollbar_policy: PolicyType, vscrollbar_policy: PolicyType) -> None: ...
    def set_propagate_natural_height(self, propagate: bool) -> None: ...
    def set_propagate_natural_width(self, propagate: bool) -> None: ...
    def set_vadjustment(self, vadjustment: Adjustment | None = None) -> None: ...
    def unset_placement(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["edge-overshot"],
        handler: typing.Callable[[typing_extensions.Self, PositionType], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["edge-reached"],
        handler: typing.Callable[[typing_extensions.Self, PositionType], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-focus-out"],
        handler: typing.Callable[[typing_extensions.Self, DirectionType], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["scroll-child"],
        handler: typing.Callable[[typing_extensions.Self, ScrollType, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hadjustment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_frame"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hscrollbar_policy"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::kinetic_scrolling"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_content_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_content_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_content_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_content_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::overlay_scrolling"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::propagate_natural_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::propagate_natural_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::vadjustment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::vscrollbar_policy"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::window_placement"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SearchBar(Widget):
    """
    Reveals a search entry when search is started.

    <picture>
      <source srcset="search-bar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkSearchBar" src="search-bar.png">
    </picture>

    It can also contain additional widgets, such as drop-down menus,
    or buttons.  The search bar would appear when a search is started
    through typing on the keyboard, or the application’s search mode
    is toggled on.

    For keyboard presses to start a search, the search bar must be told
    of a widget to capture key events from through
    [method@Gtk.SearchBar.set_key_capture_widget]. This widget will
    typically be the top-level window, or a parent container of the
    search bar. Common shortcuts such as Ctrl+F should be handled as an
    application action, or through the menu items.

    You will also need to tell the search bar about which entry you
    are using as your search entry using [method@Gtk.SearchBar.connect_entry].

    ## Creating a search bar

    The following example shows you how to create a more complex search
    entry.

    [A simple example](https://gitlab.gnome.org/GNOME/gtk/tree/main/examples/search-bar.c)

    # Shortcuts and Gestures

    `GtkSearchBar` supports the following keyboard shortcuts:

    - <kbd>Escape</kbd> hides the search bar.

    # CSS nodes

    ```
    searchbar
    ╰── revealer
        ╰── box
             ├── [child]
             ╰── [button.close]
    ```

    `GtkSearchBar` has a main CSS node with name searchbar. It has a child
    node with name revealer that contains a node with name box. The box node
    contains both the CSS node of the child widget as well as an optional button
    node which gets the .close style class applied.

    # Accessibility

    `GtkSearchBar` uses the [enum@Gtk.AccessibleRole.search] role.
    """

    class Props(Widget.Props):
        child: Widget | None
        key_capture_widget: Widget | None  # [key-capture-widget]: changed because contained invalid characters
        search_mode_enabled: bool  # [search-mode-enabled]: changed because contained invalid characters
        show_close_button: bool  # [show-close-button]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        child: Widget | None = ...,
        key_capture_widget: Widget | None = ...,
        search_mode_enabled: bool = ...,
        show_close_button: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def connect_entry(self, entry: Editable) -> None: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_key_capture_widget(self) -> Widget | None: ...
    @builtins.property
    def get_search_mode(self) -> bool: ...
    @builtins.property
    def get_show_close_button(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_key_capture_widget(self, widget: Widget | None = None) -> None: ...
    def set_search_mode(self, search_mode: bool) -> None: ...
    def set_show_close_button(self, visible: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::key_capture_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::search_mode_enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_close_button"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SearchEntry(Widget):
    """
    A single-line text entry widget for use as a search entry.

    The main API for interacting with a `GtkSearchEntry` as entry
    is the `GtkEditable` interface.

    <picture>
      <source srcset="search-entry-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkSearchEntry" src="search-entry.png">
    </picture>

    It will show an inactive symbolic “find” icon when the search
    entry is empty, and a symbolic “clear” icon when there is text.
    Clicking on the “clear” icon will empty the search entry.

    To make filtering appear more reactive, it is a good idea to
    not react to every change in the entry text immediately, but
    only after a short delay. To support this, `GtkSearchEntry`
    emits the [signal@Gtk.SearchEntry::search-changed] signal which
    can be used instead of the [signal@Gtk.Editable::changed] signal.

    The [signal@Gtk.SearchEntry::previous-match],
    [signal@Gtk.SearchEntry::next-match] and
    [signal@Gtk.SearchEntry::stop-search] signals can be used to
    implement moving between search results and ending the search.

    Often, `GtkSearchEntry` will be fed events by means of being
    placed inside a [class@Gtk.SearchBar]. If that is not the case,
    you can use [method@Gtk.SearchEntry.set_key_capture_widget] to
    let it capture key input from another widget.

    `GtkSearchEntry` provides only minimal API and should be used with
    the [iface@Gtk.Editable] API.

    ## Shortcuts and Gestures

    The following signals have default keybindings:

    - [signal@Gtk.SearchEntry::activate]
    - [signal@Gtk.SearchEntry::next-match]
    - [signal@Gtk.SearchEntry::previous-match]
    - [signal@Gtk.SearchEntry::stop-search]

    ## CSS Nodes

    ```
    entry.search
    ╰── text
    ```

    `GtkSearchEntry` has a single CSS node with name entry that carries
    a `.search` style class, and the text node is a child of that.

    ## Accessibility

    `GtkSearchEntry` uses the [enum@Gtk.AccessibleRole.search_box] role.
    """

    class Props(Widget.Props):
        activates_default: bool  # [activates-default]: changed because contained invalid characters
        input_hints: InputHints  # [input-hints]: changed because contained invalid characters
        input_purpose: InputPurpose  # [input-purpose]: changed because contained invalid characters
        placeholder_text: str  # [placeholder-text]: changed because contained invalid characters
        search_delay: int  # [search-delay]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        activates_default: bool = ...,
        input_hints: InputHints = ...,
        input_purpose: InputPurpose = ...,
        placeholder_text: str = ...,
        search_delay: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_input_hints(self) -> InputHints: ...
    @builtins.property
    def get_input_purpose(self) -> InputPurpose: ...
    def get_key_capture_widget(self) -> Widget | None: ...
    @builtins.property
    def get_placeholder_text(self) -> str | None: ...
    @builtins.property
    def get_search_delay(self) -> int: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_input_hints(self, hints: InputHints) -> None: ...
    def set_input_purpose(self, purpose: InputPurpose) -> None: ...
    def set_key_capture_widget(self, widget: Widget | None = None) -> None: ...
    def set_placeholder_text(self, text: str | None = None) -> None: ...
    def set_search_delay(self, delay: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["next-match"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["previous-match"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["search-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["search-started"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["stop-search"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activates_default"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_hints"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_purpose"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::placeholder_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::search_delay"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SectionModel(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_section(self, position: int) -> tuple[int, int]: ...
    def sections_changed(self, position: int, n_items: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["sections-changed"],
        handler: typing.Callable[[typing_extensions.Self, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SectionModelInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_section(self) -> get_sectionSectionModelInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SelectionFilterModel(GObject.Object):
    """
    A list model that presents the selection from a `GtkSelectionModel`.
    """

    class Props(GObject.Object.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: SelectionModel | None
        n_items: int  # [n-items]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, model: SelectionModel | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_model(self) -> SelectionModel | None: ...
    @classmethod
    def new(cls, model: SelectionModel | None = None) -> SelectionFilterModel: ...
    def set_model(self, model: SelectionModel | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SelectionFilterModelClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SelectionModel(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_selection(self) -> Bitset: ...
    def get_selection_in_range(self, position: int, n_items: int) -> Bitset: ...
    def is_selected(self, position: int) -> bool: ...
    def select_all(self) -> bool: ...
    def select_item(self, position: int, unselect_rest: bool) -> bool: ...
    def select_range(self, position: int, n_items: int, unselect_rest: bool) -> bool: ...
    def selection_changed(self, position: int, n_items: int) -> None: ...
    def set_selection(self, selected: Bitset, mask: Bitset) -> bool: ...
    def unselect_all(self) -> bool: ...
    def unselect_item(self, position: int) -> bool: ...
    def unselect_range(self, position: int, n_items: int) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["selection-changed"],
        handler: typing.Callable[[typing_extensions.Self, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SelectionModelInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_selection_in_range(self) -> get_selection_in_rangeSelectionModelInterfaceCB: ...
    @builtins.property
    def is_selected(self) -> is_selectedSelectionModelInterfaceCB: ...
    @builtins.property
    def select_all(self) -> select_allSelectionModelInterfaceCB: ...
    @builtins.property
    def select_item(self) -> select_itemSelectionModelInterfaceCB: ...
    @builtins.property
    def select_range(self) -> select_rangeSelectionModelInterfaceCB: ...
    @builtins.property
    def set_selection(self) -> set_selectionSelectionModelInterfaceCB: ...
    @builtins.property
    def unselect_all(self) -> unselect_allSelectionModelInterfaceCB: ...
    @builtins.property
    def unselect_item(self) -> unselect_itemSelectionModelInterfaceCB: ...
    @builtins.property
    def unselect_range(self) -> unselect_rangeSelectionModelInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Separator(Widget):
    """
    Draws a horizontal or vertical line to separate other widgets.

    <picture>
      <source srcset="separator-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkSeparator" src="separator.png">
    </picture>

    A `GtkSeparator` can be used to group the widgets within a window.
    It displays a line with a shadow to make it appear sunken into the
    interface.

    # CSS nodes

    `GtkSeparator` has a single CSS node with name separator. The node
    gets one of the .horizontal or .vertical style classes.

    # Accessibility

    `GtkSeparator` uses the [enum@Gtk.AccessibleRole.separator] role.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, orientation: Orientation) -> Widget: ...

class Settings(GObject.Object):
    """
    Provides a mechanism to share global settings between applications.

    On the X window system, this sharing is realized by an
    [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
    manager that is usually part of the desktop environment, along with
    utilities that let the user change these settings.

    On Wayland, the settings are obtained either via a settings portal,
    or by reading desktop settings from [class@Gio.Settings].

    On macOS, the settings are obtained from `NSUserDefaults`.

    In the absence of these sharing mechanisms, GTK reads default values for
    settings from `settings.ini` files in `/etc/gtk-4.0`, `$XDG_CONFIG_DIRS/gtk-4.0`
    and `$XDG_CONFIG_HOME/gtk-4.0`. These files must be valid key files (see
    `GKeyFile`), and have a section called Settings. Themes can also provide
    default values for settings by installing a `settings.ini` file
    next to their `gtk.css` file.

    Applications can override system-wide settings by setting the property
    of the `GtkSettings` object with g_object_set(). This should be restricted
    to special cases though; `GtkSettings` are not meant as an application
    configuration facility.

    There is one `GtkSettings` instance per display. It can be obtained with
    [func@Gtk.Settings.get_for_display], but in many cases, it is more
    convenient to use [method@Gtk.Widget.get_settings].
    """

    class Props(GObject.Object.Props):
        gtk_alternative_button_order: (
            bool  # [gtk-alternative-button-order]: changed because contained invalid characters
        )
        gtk_alternative_sort_arrows: bool  # [gtk-alternative-sort-arrows]: changed because contained invalid characters
        gtk_application_prefer_dark_theme: (
            bool  # [gtk-application-prefer-dark-theme]: changed because contained invalid characters
        )
        gtk_cursor_aspect_ratio: float  # [gtk-cursor-aspect-ratio]: changed because contained invalid characters
        gtk_cursor_blink: bool  # [gtk-cursor-blink]: changed because contained invalid characters
        gtk_cursor_blink_time: int  # [gtk-cursor-blink-time]: changed because contained invalid characters
        gtk_cursor_blink_timeout: int  # [gtk-cursor-blink-timeout]: changed because contained invalid characters
        gtk_cursor_theme_name: str  # [gtk-cursor-theme-name]: changed because contained invalid characters
        gtk_cursor_theme_size: int  # [gtk-cursor-theme-size]: changed because contained invalid characters
        gtk_decoration_layout: str  # [gtk-decoration-layout]: changed because contained invalid characters
        gtk_dialogs_use_header: bool  # [gtk-dialogs-use-header]: changed because contained invalid characters
        gtk_dnd_drag_threshold: int  # [gtk-dnd-drag-threshold]: changed because contained invalid characters
        gtk_double_click_distance: int  # [gtk-double-click-distance]: changed because contained invalid characters
        gtk_double_click_time: int  # [gtk-double-click-time]: changed because contained invalid characters
        gtk_enable_accels: bool  # [gtk-enable-accels]: changed because contained invalid characters
        gtk_enable_animations: bool  # [gtk-enable-animations]: changed because contained invalid characters
        gtk_enable_event_sounds: bool  # [gtk-enable-event-sounds]: changed because contained invalid characters
        gtk_enable_input_feedback_sounds: (
            bool  # [gtk-enable-input-feedback-sounds]: changed because contained invalid characters
        )
        gtk_enable_primary_paste: bool  # [gtk-enable-primary-paste]: changed because contained invalid characters
        gtk_entry_password_hint_timeout: (
            int  # [gtk-entry-password-hint-timeout]: changed because contained invalid characters
        )
        gtk_entry_select_on_focus: bool  # [gtk-entry-select-on-focus]: changed because contained invalid characters
        gtk_error_bell: bool  # [gtk-error-bell]: changed because contained invalid characters
        gtk_font_name: str  # [gtk-font-name]: changed because contained invalid characters
        gtk_font_rendering: FontRendering  # [gtk-font-rendering]: changed because contained invalid characters
        gtk_fontconfig_timestamp: int  # [gtk-fontconfig-timestamp]: changed because contained invalid characters
        gtk_hint_font_metrics: bool  # [gtk-hint-font-metrics]: changed because contained invalid characters
        gtk_icon_theme_name: str  # [gtk-icon-theme-name]: changed because contained invalid characters
        gtk_im_module: str  # [gtk-im-module]: changed because contained invalid characters
        gtk_keynav_use_caret: bool  # [gtk-keynav-use-caret]: changed because contained invalid characters
        gtk_label_select_on_focus: bool  # [gtk-label-select-on-focus]: changed because contained invalid characters
        gtk_long_press_time: int  # [gtk-long-press-time]: changed because contained invalid characters
        gtk_overlay_scrolling: bool  # [gtk-overlay-scrolling]: changed because contained invalid characters
        gtk_primary_button_warps_slider: (
            bool  # [gtk-primary-button-warps-slider]: changed because contained invalid characters
        )
        gtk_print_backends: str  # [gtk-print-backends]: changed because contained invalid characters
        gtk_print_preview_command: str  # [gtk-print-preview-command]: changed because contained invalid characters
        gtk_recent_files_enabled: bool  # [gtk-recent-files-enabled]: changed because contained invalid characters
        gtk_recent_files_max_age: int  # [gtk-recent-files-max-age]: changed because contained invalid characters
        gtk_shell_shows_app_menu: bool  # [gtk-shell-shows-app-menu]: changed because contained invalid characters
        gtk_shell_shows_desktop: bool  # [gtk-shell-shows-desktop]: changed because contained invalid characters
        gtk_shell_shows_menubar: bool  # [gtk-shell-shows-menubar]: changed because contained invalid characters
        gtk_show_status_shapes: bool  # [gtk-show-status-shapes]: changed because contained invalid characters
        gtk_sound_theme_name: str  # [gtk-sound-theme-name]: changed because contained invalid characters
        gtk_split_cursor: bool  # [gtk-split-cursor]: changed because contained invalid characters
        gtk_theme_name: str  # [gtk-theme-name]: changed because contained invalid characters
        gtk_titlebar_double_click: str  # [gtk-titlebar-double-click]: changed because contained invalid characters
        gtk_titlebar_middle_click: str  # [gtk-titlebar-middle-click]: changed because contained invalid characters
        gtk_titlebar_right_click: str  # [gtk-titlebar-right-click]: changed because contained invalid characters
        gtk_xft_antialias: int  # [gtk-xft-antialias]: changed because contained invalid characters
        gtk_xft_dpi: int  # [gtk-xft-dpi]: changed because contained invalid characters
        gtk_xft_hinting: int  # [gtk-xft-hinting]: changed because contained invalid characters
        gtk_xft_hintstyle: str  # [gtk-xft-hintstyle]: changed because contained invalid characters
        gtk_xft_rgba: str  # [gtk-xft-rgba]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        gtk_alternative_button_order: bool = ...,
        gtk_alternative_sort_arrows: bool = ...,
        gtk_application_prefer_dark_theme: bool = ...,
        gtk_cursor_aspect_ratio: float = ...,
        gtk_cursor_blink: bool = ...,
        gtk_cursor_blink_time: int = ...,
        gtk_cursor_blink_timeout: int = ...,
        gtk_cursor_theme_name: str = ...,
        gtk_cursor_theme_size: int = ...,
        gtk_decoration_layout: str = ...,
        gtk_dialogs_use_header: bool = ...,
        gtk_dnd_drag_threshold: int = ...,
        gtk_double_click_distance: int = ...,
        gtk_double_click_time: int = ...,
        gtk_enable_accels: bool = ...,
        gtk_enable_animations: bool = ...,
        gtk_enable_event_sounds: bool = ...,
        gtk_enable_input_feedback_sounds: bool = ...,
        gtk_enable_primary_paste: bool = ...,
        gtk_entry_password_hint_timeout: int = ...,
        gtk_entry_select_on_focus: bool = ...,
        gtk_error_bell: bool = ...,
        gtk_font_name: str = ...,
        gtk_font_rendering: FontRendering = ...,
        gtk_fontconfig_timestamp: int = ...,
        gtk_hint_font_metrics: bool = ...,
        gtk_icon_theme_name: str = ...,
        gtk_im_module: str = ...,
        gtk_keynav_use_caret: bool = ...,
        gtk_label_select_on_focus: bool = ...,
        gtk_long_press_time: int = ...,
        gtk_overlay_scrolling: bool = ...,
        gtk_primary_button_warps_slider: bool = ...,
        gtk_print_backends: str = ...,
        gtk_print_preview_command: str = ...,
        gtk_recent_files_enabled: bool = ...,
        gtk_recent_files_max_age: int = ...,
        gtk_shell_shows_app_menu: bool = ...,
        gtk_shell_shows_desktop: bool = ...,
        gtk_shell_shows_menubar: bool = ...,
        gtk_show_status_shapes: bool = ...,
        gtk_sound_theme_name: str = ...,
        gtk_split_cursor: bool = ...,
        gtk_theme_name: str = ...,
        gtk_titlebar_double_click: str = ...,
        gtk_titlebar_middle_click: str = ...,
        gtk_titlebar_right_click: str = ...,
        gtk_xft_antialias: int = ...,
        gtk_xft_dpi: int = ...,
        gtk_xft_hinting: int = ...,
        gtk_xft_hintstyle: str = ...,
        gtk_xft_rgba: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_default() -> Settings | None: ...
    @staticmethod
    def get_for_display(display: Gdk.Display) -> Settings: ...
    def reset_property(self, name: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_alternative_button_order"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_alternative_sort_arrows"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_application_prefer_dark_theme"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_cursor_aspect_ratio"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_cursor_blink"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_cursor_blink_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_cursor_blink_timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_cursor_theme_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_cursor_theme_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_decoration_layout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_dialogs_use_header"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_dnd_drag_threshold"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_double_click_distance"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_double_click_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_enable_accels"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_enable_animations"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_enable_event_sounds"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_enable_input_feedback_sounds"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_enable_primary_paste"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_entry_password_hint_timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_entry_select_on_focus"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_error_bell"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_font_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_font_rendering"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_fontconfig_timestamp"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_hint_font_metrics"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_icon_theme_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_im_module"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_keynav_use_caret"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_label_select_on_focus"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_long_press_time"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_overlay_scrolling"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_primary_button_warps_slider"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_print_backends"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_print_preview_command"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_recent_files_enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_recent_files_max_age"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_shell_shows_app_menu"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_shell_shows_desktop"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_shell_shows_menubar"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_show_status_shapes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_sound_theme_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_split_cursor"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_theme_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_titlebar_double_click"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_titlebar_middle_click"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_titlebar_right_click"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_xft_antialias"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_xft_dpi"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_xft_hinting"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_xft_hintstyle"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gtk_xft_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Shortcut(GObject.Object):
    """
    Describes a keyboard shortcut.

    It contains a description of how to trigger the shortcut via a
    [class@Gtk.ShortcutTrigger] and a way to activate the shortcut
    on a widget via a [class@Gtk.ShortcutAction].

    The actual work is usually done via [class@Gtk.ShortcutController],
    which decides if and when to activate a shortcut. Using that controller
    directly however is rarely necessary as various higher level
    convenience APIs exist on `GtkWidget`s that make it easier to use
    shortcuts in GTK.

    `GtkShortcut` does provide functionality to make it easy for users
    to work with shortcuts, either by providing informational strings
    for display purposes or by allowing shortcuts to be configured.
    """

    class Props(GObject.Object.Props):
        action: ShortcutAction | None
        arguments: GLib.Variant | None
        trigger: ShortcutTrigger | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        action: ShortcutAction | None = ...,
        arguments: GLib.Variant | None = ...,
        trigger: ShortcutTrigger | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_action(self) -> ShortcutAction | None: ...
    @builtins.property
    def get_arguments(self) -> GLib.Variant | None: ...
    @builtins.property
    def get_trigger(self) -> ShortcutTrigger | None: ...
    @classmethod
    def new(cls, trigger: ShortcutTrigger | None = None, action: ShortcutAction | None = None) -> Shortcut: ...
    def set_action(self, action: ShortcutAction | None = None) -> None: ...
    def set_arguments(self, args: GLib.Variant | None = None) -> None: ...
    def set_trigger(self, trigger: ShortcutTrigger | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::action"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::arguments"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::trigger"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ShortcutAction(GObject.Object):
    """
    Encodes an action that can be triggered by a keyboard shortcut.

    `GtkShortcutActions` contain functions that allow easy presentation
    to end users as well as being printed for debugging.

    All `GtkShortcutActions` are immutable, you can only specify their
    properties during construction. If you want to change a action, you
    have to replace it with a new one. If you need to pass arguments to
    an action, these are specified by the higher-level `GtkShortcut` object.

    To activate a `GtkShortcutAction` manually, [method@Gtk.ShortcutAction.activate]
    can be called.

    GTK provides various actions:

     - [class@Gtk.MnemonicAction]: a shortcut action that calls
       gtk_widget_mnemonic_activate()
     - [class@Gtk.CallbackAction]: a shortcut action that invokes
       a given callback
     - [class@Gtk.SignalAction]: a shortcut action that emits a
       given signal
     - [class@Gtk.ActivateAction]: a shortcut action that calls
       gtk_widget_activate()
     - [class@Gtk.NamedAction]: a shortcut action that calls
       gtk_widget_activate_action()
     - [class@Gtk.NothingAction]: a shortcut action that does nothing
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def activate(self, flags: ShortcutActionFlags, widget: Widget, args: GLib.Variant | None = None) -> bool: ...
    @classmethod
    def parse_string(cls, string: str) -> ShortcutAction | None: ...
    def print_(self, string: GLib.String) -> None: ...
    def to_string(self) -> str: ...

class ShortcutActionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutController(EventController):
    """
    Manages keyboard shortcuts and their activation.

    Most common shortcuts are using this controller implicitly, e.g. by
    adding a mnemonic underline to a [class@Gtk.Label], or by installing a key
    binding using [method@Gtk.WidgetClass.add_binding], or by adding accelerators
    to global actions using [method@Gtk.Application.set_accels_for_action].

    But it is possible to create your own shortcut controller, and add
    shortcuts to it.

    `GtkShortcutController` implements [iface@Gio.ListModel] for querying the
    shortcuts that have been added to it.

    # GtkShortcutController as GtkBuildable

    `GtkShortcutController`s can be created in [class@Gtk.Builder] ui files, to set up
    shortcuts in the same place as the widgets.

    An example of a UI definition fragment with `GtkShortcutController`:
    ```xml
      <object class='GtkButton'>
        <child>
          <object class='GtkShortcutController'>
            <property name='scope'>managed</property>
            <child>
              <object class='GtkShortcut'>
                <property name='trigger'>&lt;Control&gt;k</property>
                <property name='action'>activate</property>
              </object>
            </child>
          </object>
        </child>
      </object>
    ```

    This example creates a [class@Gtk.ActivateAction] for triggering the
    `activate` signal of the [class@Gtk.Button]. See [ctor@Gtk.ShortcutAction.parse_string]
    for the syntax for other kinds of [class@Gtk.ShortcutAction]. See
    [ctor@Gtk.ShortcutTrigger.parse_string] to learn more about the syntax
    for triggers.
    """

    class Props(EventController.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        mnemonic_modifiers: Gdk.ModifierType  # [mnemonic-modifiers]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters
        scope: ShortcutScope

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, mnemonic_modifiers: Gdk.ModifierType = ..., model: Gio.ListModel | None = ..., scope: ShortcutScope = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_shortcut(self, shortcut: Shortcut) -> None: ...
    @builtins.property
    def get_mnemonics_modifiers(self) -> Gdk.ModifierType: ...
    @builtins.property
    def get_scope(self) -> ShortcutScope: ...
    @classmethod
    def new(cls) -> EventController: ...
    @classmethod
    def new_for_model(cls, model: Gio.ListModel) -> EventController: ...
    def remove_shortcut(self, shortcut: Shortcut) -> None: ...
    def set_mnemonics_modifiers(self, modifiers: Gdk.ModifierType) -> None: ...
    def set_scope(self, scope: ShortcutScope) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mnemonic_modifiers"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scope"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ShortcutControllerClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutLabel(Widget):
    """
    `GtkShortcutLabel` displays a single keyboard shortcut or gesture.

    The main use case for `GtkShortcutLabel` is inside a [class@Gtk.ShortcutsWindow].
    """

    class Props(Widget.Props):
        accelerator: str
        disabled_text: str  # [disabled-text]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, accelerator: str = ..., disabled_text: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_accelerator(self) -> str | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_disabled_text(self) -> str | None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls, accelerator: str) -> Widget: ...
    @deprecated("deprecated")
    def set_accelerator(self, accelerator: str) -> None: ...
    @deprecated("deprecated")
    def set_disabled_text(self, disabled_text: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accelerator"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::disabled_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ShortcutLabelClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutManager(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutManagerInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def add_controller(self) -> add_controllerShortcutManagerInterfaceCB: ...
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def remove_controller(self) -> remove_controllerShortcutManagerInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutTrigger(GObject.Object):
    """
    Tracks how a `GtkShortcut` can be activated.

    To find out if a `GtkShortcutTrigger` triggers, you can call
    [method@Gtk.ShortcutTrigger.trigger] on a `GdkEvent`.

    `GtkShortcutTriggers` contain functions that allow easy presentation
    to end users as well as being printed for debugging.

    All `GtkShortcutTriggers` are immutable, you can only specify their
    properties during construction. If you want to change a trigger, you
    have to replace it with a new one.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def compare(self, trigger2: ShortcutTrigger) -> int: ...
    def equal(self, trigger2: ShortcutTrigger) -> bool: ...
    def hash(self) -> int: ...
    @classmethod
    def parse_string(cls, string: str) -> ShortcutTrigger | None: ...
    def print_(self, string: GLib.String) -> None: ...
    def print_label(self, display: Gdk.Display, string: GLib.String) -> bool: ...
    def to_label(self, display: Gdk.Display) -> str: ...
    def to_string(self) -> str: ...
    def trigger(self, event: Gdk.Event, enable_mnemonics: bool) -> Gdk.KeyMatch: ...

class ShortcutTriggerClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutsGroup(Box):
    """
    A `GtkShortcutsGroup` represents a group of related keyboard shortcuts
    or gestures.

    The group has a title. It may optionally be associated with a view
    of the application, which can be used to show only relevant shortcuts
    depending on the application context.

    This widget is only meant to be used with [class@Gtk.ShortcutsWindow].

    The recommended way to construct a `GtkShortcutsGroup` is with
    [class@Gtk.Builder], by using the `<child>` tag to populate a
    `GtkShortcutsGroup` with one or more [class@Gtk.ShortcutsShortcut]
    instances.

    If you need to add a shortcut programmatically, use
    [method@Gtk.ShortcutsGroup.add_shortcut].
    """

    class Props(Box.Props):
        accel_size_group: SizeGroup | None  # [accel-size-group]: changed because contained invalid characters
        height: int
        title: str
        title_size_group: SizeGroup | None  # [title-size-group]: changed because contained invalid characters
        view: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accel_size_group: SizeGroup | None = ...,
        title: str = ...,
        title_size_group: SizeGroup | None = ...,
        view: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_shortcut(self, shortcut: ShortcutsShortcut) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accel_size_group"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title_size_group"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::view"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ShortcutsGroupClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutsSection(Box):
    """
    A `GtkShortcutsSection` collects all the keyboard shortcuts and gestures
    for a major application mode.

    If your application needs multiple sections, you should give each
    section a unique [property@Gtk.ShortcutsSection:section-name] and
    a [property@Gtk.ShortcutsSection:title] that can be shown in the
    section selector of the [class@Gtk.ShortcutsWindow].

    The [property@Gtk.ShortcutsSection:max-height] property can be used
    to influence how the groups in the section are distributed over pages
    and columns.

    This widget is only meant to be used with [class@Gtk.ShortcutsWindow].

    The recommended way to construct a `GtkShortcutsSection` is with
    [class@Gtk.Builder], by using the `<child>` tag to populate a
    `GtkShortcutsSection` with one or more [class@Gtk.ShortcutsGroup]
    instances, which in turn contain one or more [class@Gtk.ShortcutsShortcut]
    objects.

    If you need to add a group programmatically, use
    [method@Gtk.ShortcutsSection.add_group].

    # Shortcuts and Gestures

    Pan gestures allow to navigate between sections.

    The following signals have default keybindings:

    - [signal@Gtk.ShortcutsSection::change-current-page]
    """

    class Props(Box.Props):
        max_height: int  # [max-height]: changed because contained invalid characters
        section_name: str  # [section-name]: changed because contained invalid characters
        title: str
        view_name: str  # [view-name]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, max_height: int = ..., section_name: str = ..., title: str = ..., view_name: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_group(self, group: ShortcutsGroup) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["change-current-page"],
        handler: typing.Callable[[typing_extensions.Self, int], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::section_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::view_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ShortcutsSectionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutsShortcut(Widget):
    """
    A `GtkShortcutsShortcut` represents a single keyboard shortcut or gesture
    with a short text.

    This widget is only meant to be used with `GtkShortcutsWindow`.
    """

    class Props(Widget.Props):
        accel_size_group: SizeGroup | None  # [accel-size-group]: changed because contained invalid characters
        accelerator: str
        action_name: str  # [action-name]: changed because contained invalid characters
        direction: TextDirection
        icon: Gio.Icon | None
        icon_set: bool  # [icon-set]: changed because contained invalid characters
        shortcut_type: ShortcutType  # [shortcut-type]: changed because contained invalid characters
        subtitle: str
        subtitle_set: bool  # [subtitle-set]: changed because contained invalid characters
        title: str
        title_size_group: SizeGroup | None  # [title-size-group]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accel_size_group: SizeGroup | None = ...,
        accelerator: str = ...,
        action_name: str = ...,
        direction: TextDirection = ...,
        icon: Gio.Icon | None = ...,
        icon_set: bool = ...,
        shortcut_type: ShortcutType = ...,
        subtitle: str = ...,
        subtitle_set: bool = ...,
        title: str = ...,
        title_size_group: SizeGroup | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accel_size_group"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accelerator"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::action_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::direction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::shortcut_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::subtitle"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::subtitle_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title_size_group"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ShortcutsShortcutClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ShortcutsWindow(Window):
    """
    A `GtkShortcutsWindow` shows information about the keyboard shortcuts
    and gestures of an application.

    The shortcuts can be grouped, and you can have multiple sections in this
    window, corresponding to the major modes of your application.

    Additionally, the shortcuts can be filtered by the current view, to avoid
    showing information that is not relevant in the current application context.

    The recommended way to construct a `GtkShortcutsWindow` is with
    [class@Gtk.Builder], by using the `<child>` tag to populate a
    `GtkShortcutsWindow` with one or more [class@Gtk.ShortcutsSection] objects,
    which contain one or more [class@Gtk.ShortcutsGroup] instances, which, in turn,
    contain [class@Gtk.ShortcutsShortcut] instances.

    If you need to add a section programmatically, use [method@Gtk.ShortcutsWindow.add_section]
    instead of [method@Gtk.Window.set_child], as the shortcuts window manages
    its children directly.

    # A simple example:

    <picture>
      <source srcset="gedit-shortcuts-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="A simple example" src="gedit-shortcuts.png">
    </picture>

    This example has as single section. As you can see, the shortcut groups
    are arranged in columns, and spread across several pages if there are too
    many to find on a single page.

    The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/main/demos/gtk-demo/shortcuts-gedit.ui).

    # An example with multiple views:

    <picture>
      <source srcset="clocks-shortcuts-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example with multiple views" src="clocks-shortcuts.png">
    </picture>

    This example shows a `GtkShortcutsWindow` that has been configured to show only
    the shortcuts relevant to the “Stopwatch” view.

    The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/main/demos/gtk-demo/shortcuts-clocks.ui).

    # An example with multiple sections:

    <picture>
      <source srcset="builder-shortcuts-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example with multiple sections" src="builder-shortcuts.png">
    </picture>

    This example shows a `GtkShortcutsWindow` with two sections, “Editor Shortcuts”
    and “Terminal Shortcuts”.

    The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/main/demos/gtk-demo/shortcuts-builder.ui).

    # Shortcuts and Gestures

    The following signals have default keybindings:

    - [signal@Gtk.ShortcutsWindow::close]
    - [signal@Gtk.ShortcutsWindow::search]

    # CSS nodes

    `GtkShortcutsWindow` has a single CSS node with the name `window` and style
    class `.shortcuts`.
    """

    class Props(Window.Props):
        section_name: str  # [section-name]: changed because contained invalid characters
        view_name: str  # [view-name]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, section_name: str = ..., view_name: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_section(self, section: ShortcutsSection) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["close"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["search"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::section_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::view_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SignalAction(ShortcutAction):
    """
    Emits a signal on a widget.

    Signals that are used in this way are referred to as keybinding signals,
    and they are expected to be defined with the `G_SIGNAL_ACTION` flag.
    """

    class Props(ShortcutAction.Props):
        signal_name: str  # [signal-name]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, signal_name: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_signal_name(self) -> str: ...
    @classmethod
    def new(cls, signal_name: str) -> SignalAction: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::signal_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SignalActionClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SignalListItemFactory(ListItemFactory):
    """
    Emits signals to manage listitems.

    Signals are emitted for every listitem in the same order:

     1. [signal@Gtk.SignalListItemFactory::setup] is emitted to set up permanent
     things on the listitem. This usually means constructing the widgets used in
     the row and adding them to the listitem.

     2. [signal@Gtk.SignalListItemFactory::bind] is emitted to bind the item passed
     via [property@Gtk.ListItem:item] to the widgets that have been created in
     step 1 or to add item-specific widgets. Signals are connected to listen to
     changes - both to changes in the item to update the widgets or to changes
     in the widgets to update the item. After this signal has been called, the
     listitem may be shown in a list widget.

     3. [signal@Gtk.SignalListItemFactory::unbind] is emitted to undo everything
     done in step 2. Usually this means disconnecting signal handlers. Once this
     signal has been called, the listitem will no longer be used in a list
     widget.

     4. [signal@Gtk.SignalListItemFactory::bind] and
     [signal@Gtk.SignalListItemFactory::unbind] may be emitted multiple times
     again to bind the listitem for use with new items. By reusing listitems,
     potentially costly setup can be avoided. However, it means code needs to
     make sure to properly clean up the listitem in step 3 so that no information
     from the previous use leaks into the next one.

     5. [signal@Gtk.SignalListItemFactory::teardown] is emitted to allow undoing
     the effects of [signal@Gtk.SignalListItemFactory::setup]. After this signal
     was emitted on a listitem, the listitem will be destroyed and not be used again.

    Note that during the signal emissions, changing properties on the listitems
    passed will not trigger notify signals as the listitem's notifications are
    frozen. See [method@GObject.Object.freeze_notify()] for details.

    For tracking changes in other properties in the listitem, the
    ::notify signal is recommended. The signal can be connected in the
    [signal@Gtk.SignalListItemFactory::setup] signal and removed again during
    [signal@Gtk.SignalListItemFactory::teardown].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls) -> ListItemFactory: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["bind"],
        handler: typing.Callable[[typing_extensions.Self, GObject.Object], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["setup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.Object], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["teardown"],
        handler: typing.Callable[[typing_extensions.Self, GObject.Object], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["unbind"],
        handler: typing.Callable[[typing_extensions.Self, GObject.Object], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SignalListItemFactoryClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SingleSelection(GObject.Object):
    """
    A selection model that allows selecting a single item.

    Note that the selection is *persistent* -- if the selected item is removed
    and re-added in the same [signal@Gio.ListModel::items-changed] emission, it
    stays selected. In particular, this means that changing the sort order of an
    underlying sort model will preserve the selection.
    """

    class Props(GObject.Object.Props):
        autoselect: bool
        can_unselect: bool  # [can-unselect]: changed because contained invalid characters
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters
        selected: int
        selected_item: GObject.Object | None  # [selected-item]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, autoselect: bool = ..., can_unselect: bool = ..., model: Gio.ListModel | None = ..., selected: int = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_autoselect(self) -> bool: ...
    @builtins.property
    def get_can_unselect(self) -> bool: ...
    @builtins.property
    def get_model(self) -> Gio.ListModel | None: ...
    @builtins.property
    def get_selected(self) -> int: ...
    @builtins.property
    def get_selected_item(self) -> GObject.Object | None: ...
    @classmethod
    def new(cls, model: Gio.ListModel | None = None) -> SingleSelection: ...
    def set_autoselect(self, autoselect: bool) -> None: ...
    def set_can_unselect(self, can_unselect: bool) -> None: ...
    def set_model(self, model: Gio.ListModel | None = None) -> None: ...
    def set_selected(self, position: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::autoselect"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_unselect"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selected"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::selected_item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SingleSelectionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SizeGroup(GObject.Object):
    """
    Groups widgets together so they all request the same size.

    This is typically useful when you want a column of widgets to have
    the same size, but you can’t use a [class@Gtk.Grid] or [class@Gtk.Box].

    In detail, the size requested for each widget in a `GtkSizeGroup` is
    the maximum of the sizes that would have been requested for each
    widget in the size group if they were not in the size group. The
    [mode][method@Gtk.SizeGroup.set_mode] of the size group determines
    whether this applies to the horizontal size, the vertical size, or
    both sizes.

    Note that size groups only affect the amount of space requested, not
    the size that the widgets finally receive. If you want the widgets in
    a `GtkSizeGroup` to actually be the same size, you need to pack them in
    such a way that they get the size they request and not more. In
    particular it doesn't make a lot of sense to set
    [the expand flags][method@Gtk.Widget.set_hexpand] on the widgets that
    are members of a size group.

    `GtkSizeGroup` objects are referenced by each widget in the size group,
    so once you have added all widgets to a `GtkSizeGroup`, you can drop
    the initial reference to the size group with
    [method@GObject.Object.unref]. If the widgets in the size group are
    subsequently destroyed, then they will be removed from the size group
    and drop their references on the size group; when all widgets have been
    removed, the size group will be freed.

    Widgets can be part of multiple size groups; GTK will compute the
    horizontal size of a widget from the horizontal requisition of all widgets
    that can be reached from the widget by a chain of size groups with mode
    [enum@Gtk.SizeGroupMode.HORIZONTAL] or [enum@Gtk.SizeGroupMode.BOTH], and
    the vertical size from the vertical requisition of all widgets that can be
    reached from the widget by a chain of size groups with mode
    [enum@Gtk.SizeGroupMode.VERTICAL] or [enum@Gtk.SizeGroupMode.BOTH].

    # Size groups and trading height-for-width

    ::: warning
        Generally, size groups don't interact well with widgets that
        trade height for width (or width for height), such as wrappable
        labels. Avoid using size groups with such widgets.

    A size group with mode [enum@Gtk.SizeGroupMode.HORIZONTAL] or
    [enum@Gtk.SizeGroupMode.VERTICAL] only consults non-contextual sizes
    of widgets other than the one being measured, since it has no
    knowledge of what size a widget will get allocated in the other
    orientation. This can lead to widgets in a group actually requesting
    different contextual sizes, contrary to the purpose of
    `GtkSizeGroup`.

    In contrast, a size group with mode [enum@Gtk.SizeGroupMode.BOTH] can
    properly propagate the available size in the opposite orientation
    when measuring widgets in the group, which results in consistent and
    accurate measurements.

    In case some mechanism other than a size group is already used to
    ensure that widgets in a group all get the same size in one
    orientation (for example, some common ancestor is known to allocate
    the same width to all its children), and the size group is only
    really needed to also make the widgets request the same size in the
    other orientation, it is beneficial to still set the group's mode to
    [enum@Gtk.SizeGroupMode.BOTH]. This lets the group assume and count
    on sizes of the widgets in the former orientation being the same,
    which enables it to propagate the available size as described above.

    # Alternatives to size groups

    Size groups have many limitations, such as only influencing size
    requests but not allocations, and poor height-for-width support. When
    possible, prefer using dedicated mechanisms that can properly ensure
    that the widgets get the same size.

    Various container widgets and layout managers support a homogeneous
    layout mode, where they will explicitly give the same size to their
    children (see [property@Gtk.Box:homogeneous]). Using homogeneous mode
    can also have large performance benefits compared to either the same
    container in non-homogeneous mode, or to size groups.

    [class@Gtk.Grid] can be used to position widgets into rows and
    columns. Members of each column will have the same width among them;
    likewise, members of each row will have the same height. On top of
    that, the heights can be made equal between all rows with
    [property@Gtk.Grid:row-homogeneous], and the widths can be made equal
    between all columns with [property@Gtk.Grid:column-homogeneous].

    # GtkSizeGroup as GtkBuildable

    Size groups can be specified in a UI definition by placing an `<object>`
    element with `class="GtkSizeGroup"` somewhere in the UI definition. The
    widgets that belong to the size group are specified by a `<widgets>` element
    that may contain multiple `<widget>` elements, one for each member of the
    size group. The ”name” attribute gives the id of the widget.

    An example of a UI definition fragment with `GtkSizeGroup`:
    ```xml
    <object class="GtkSizeGroup">
      <property name="mode">horizontal</property>
      <widgets>
        <widget name="radio1"/>
        <widget name="radio2"/>
      </widgets>
    </object>
    ```
    """

    class Props(GObject.Object.Props):
        mode: SizeGroupMode

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, mode: SizeGroupMode = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_widget(self, widget: Widget) -> None: ...
    @builtins.property
    def get_mode(self) -> SizeGroupMode: ...
    def get_widgets(self) -> list: ...
    @classmethod
    def new(cls, mode: SizeGroupMode) -> SizeGroup: ...
    def remove_widget(self, widget: Widget) -> None: ...
    def set_mode(self, mode: SizeGroupMode) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SliceListModel(GObject.Object):
    """
    A list model that presents a slice of another model.

    This is useful when implementing paging by setting the size to the number
    of elements per page and updating the offset whenever a different page is
    opened.

    `GtkSliceListModel` passes through sections from the underlying model.
    """

    class Props(GObject.Object.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters
        offset: int
        size: int

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, model: Gio.ListModel | None = ..., offset: int = ..., size: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_model(self) -> Gio.ListModel | None: ...
    @builtins.property
    def get_offset(self) -> int: ...
    @builtins.property
    def get_size(self) -> int: ...
    @classmethod
    def new(cls, model: Gio.ListModel | None, offset: int, size: int) -> SliceListModel: ...
    def set_model(self, model: Gio.ListModel | None = None) -> None: ...
    def set_offset(self, offset: int) -> None: ...
    def set_size(self, size: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::offset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SliceListModelClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Snapshot(GObject.Object):
    """
    Assists in creating [class@Gsk.RenderNode]s for widgets.

    It functions in a similar way to a cairo context, and maintains a stack
    of render nodes and their associated transformations.

    The node at the top of the stack is the one that `gtk_snapshot_append_…()`
    functions operate on. Use the `gtk_snapshot_push_…()` functions and
    [method@Snapshot.pop] to change the current node.

    The typical way to obtain a `GtkSnapshot` object is as an argument to
    the [vfunc@Gtk.Widget.snapshot] vfunc. If you need to create your own
    `GtkSnapshot`, use [ctor@Gtk.Snapshot.new].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append_border(self, outline: Gsk.RoundedRect, border_width: list, border_color: list) -> None: ...
    def append_cairo(self, bounds: Graphene.Rect) -> cairo.Context: ...
    def append_color(self, color: Gdk.RGBA, bounds: Graphene.Rect) -> None: ...
    def append_conic_gradient(
        self, bounds: Graphene.Rect, center: Graphene.Point, rotation: float, stops: list, n_stops: int
    ) -> None: ...
    def append_fill(self, path: Gsk.Path, fill_rule: Gsk.FillRule, color: Gdk.RGBA) -> None: ...
    def append_inset_shadow(
        self, outline: Gsk.RoundedRect, color: Gdk.RGBA, dx: float, dy: float, spread: float, blur_radius: float
    ) -> None: ...
    def append_layout(self, layout: Pango.Layout, color: Gdk.RGBA) -> None: ...
    def append_linear_gradient(
        self, bounds: Graphene.Rect, start_point: Graphene.Point, end_point: Graphene.Point, stops: list, n_stops: int
    ) -> None: ...
    def append_node(self, node: Gsk.RenderNode) -> None: ...
    def append_outset_shadow(
        self, outline: Gsk.RoundedRect, color: Gdk.RGBA, dx: float, dy: float, spread: float, blur_radius: float
    ) -> None: ...
    def append_radial_gradient(
        self,
        bounds: Graphene.Rect,
        center: Graphene.Point,
        hradius: float,
        vradius: float,
        start: float,
        end: float,
        stops: list,
        n_stops: int,
    ) -> None: ...
    def append_repeating_linear_gradient(
        self, bounds: Graphene.Rect, start_point: Graphene.Point, end_point: Graphene.Point, stops: list, n_stops: int
    ) -> None: ...
    def append_repeating_radial_gradient(
        self,
        bounds: Graphene.Rect,
        center: Graphene.Point,
        hradius: float,
        vradius: float,
        start: float,
        end: float,
        stops: list,
        n_stops: int,
    ) -> None: ...
    def append_scaled_texture(self, texture: Gdk.Texture, filter: Gsk.ScalingFilter, bounds: Graphene.Rect) -> None: ...
    def append_stroke(self, path: Gsk.Path, stroke: Gsk.Stroke, color: Gdk.RGBA) -> None: ...
    def append_texture(self, texture: Gdk.Texture, bounds: Graphene.Rect) -> None: ...
    @deprecated("deprecated")
    def gl_shader_pop_texture(self) -> None: ...
    @classmethod
    def new(cls) -> Snapshot: ...
    def perspective(self, depth: float) -> None: ...
    def pop(self) -> None: ...
    def push_blend(self, blend_mode: Gsk.BlendMode) -> None: ...
    def push_blur(self, radius: float) -> None: ...
    def push_clip(self, bounds: Graphene.Rect) -> None: ...
    def push_color_matrix(self, color_matrix: Graphene.Matrix, color_offset: Graphene.Vec4) -> None: ...
    def push_cross_fade(self, progress: float) -> None: ...
    def push_fill(self, path: Gsk.Path, fill_rule: Gsk.FillRule) -> None: ...
    @deprecated("deprecated")
    def push_gl_shader(self, shader: Gsk.GLShader, bounds: Graphene.Rect, take_args: GLib.Bytes) -> None: ...
    def push_mask(self, mask_mode: Gsk.MaskMode) -> None: ...
    def push_opacity(self, opacity: float) -> None: ...
    def push_repeat(self, bounds: Graphene.Rect, child_bounds: Graphene.Rect | None = None) -> None: ...
    def push_rounded_clip(self, bounds: Gsk.RoundedRect) -> None: ...
    def push_shadow(self, shadow: list, n_shadows: int) -> None: ...
    def push_stroke(self, path: Gsk.Path, stroke: Gsk.Stroke) -> None: ...
    @deprecated("deprecated")
    def render_background(self, context: StyleContext, x: float, y: float, width: float, height: float) -> None: ...
    @deprecated("deprecated")
    def render_focus(self, context: StyleContext, x: float, y: float, width: float, height: float) -> None: ...
    @deprecated("deprecated")
    def render_frame(self, context: StyleContext, x: float, y: float, width: float, height: float) -> None: ...
    @deprecated("deprecated")
    def render_insertion_cursor(
        self, context: StyleContext, x: float, y: float, layout: Pango.Layout, index: int, direction: Pango.Direction
    ) -> None: ...
    @deprecated("deprecated")
    def render_layout(self, context: StyleContext, x: float, y: float, layout: Pango.Layout) -> None: ...
    def restore(self) -> None: ...
    def rotate(self, angle: float) -> None: ...
    def rotate_3d(self, angle: float, axis: Graphene.Vec3) -> None: ...
    def save(self) -> None: ...
    def scale(self, factor_x: float, factor_y: float) -> None: ...
    def scale_3d(self, factor_x: float, factor_y: float, factor_z: float) -> None: ...
    def to_node(self) -> Gsk.RenderNode | None: ...
    def to_paintable(self, size: Graphene.Size | None = None) -> Gdk.Paintable | None: ...
    def transform(self, transform: Gsk.Transform | None = None) -> None: ...
    def transform_matrix(self, matrix: Graphene.Matrix) -> None: ...
    def translate(self, point: Graphene.Point) -> None: ...
    def translate_3d(self, point: Graphene.Point3D) -> None: ...

class SnapshotClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SortListModel(GObject.Object):
    """
    A list model that sorts the elements of another model.

    The elements are sorted according to a `GtkSorter`.

    The model is a stable sort. If two items compare equal according
    to the sorter, the one that appears first in the original model will
    also appear first after sorting.

    Note that if you change the sorter, the previous order will have no
    influence on the new order. If you want that, consider using a
    `GtkMultiSorter` and appending the previous sorter to it.

    The model can be set up to do incremental sorting, so that
    sorting long lists doesn't block the UI. See
    [method@Gtk.SortListModel.set_incremental] for details.

    `GtkSortListModel` is a generic model and because of that it
    cannot take advantage of any external knowledge when sorting.
    If you run into performance issues with `GtkSortListModel`,
    it is strongly recommended that you write your own sorting list
    model.

    `GtkSortListModel` allows sorting the items into sections. It
    implements `GtkSectionModel` and when [property@Gtk.SortListModel:section-sorter]
    is set, it will sort all items with that sorter and items comparing
    equal with it will be put into the same section.
    The [property@Gtk.SortListModel:sorter] will then be used to sort items
    inside their sections.
    """

    class Props(GObject.Object.Props):
        incremental: bool
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters
        pending: int
        section_sorter: Sorter | None  # [section-sorter]: changed because contained invalid characters
        sorter: Sorter | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        incremental: bool = ...,
        model: Gio.ListModel | None = ...,
        section_sorter: Sorter | None = ...,
        sorter: Sorter | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_incremental(self) -> bool: ...
    @builtins.property
    def get_model(self) -> Gio.ListModel | None: ...
    @builtins.property
    def get_pending(self) -> int: ...
    @builtins.property
    def get_section_sorter(self) -> Sorter | None: ...
    @builtins.property
    def get_sorter(self) -> Sorter | None: ...
    @classmethod
    def new(cls, model: Gio.ListModel | None = None, sorter: Sorter | None = None) -> SortListModel: ...
    def set_incremental(self, incremental: bool) -> None: ...
    def set_model(self, model: Gio.ListModel | None = None) -> None: ...
    def set_section_sorter(self, sorter: Sorter | None = None) -> None: ...
    def set_sorter(self, sorter: Sorter | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::incremental"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pending"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::section_sorter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sorter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SortListModelClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Sorter(GObject.Object):
    """
    Describes sorting criteria for a [class@Gtk.SortListModel].

    Its primary user is [class@Gtk.SortListModel]

    The model will use a sorter to determine the order in which
    its items should appear by calling [method@Gtk.Sorter.compare]
    for pairs of items.

    Sorters may change their sorting behavior through their lifetime.
    In that case, they will emit the [signal@Gtk.Sorter::changed] signal
    to notify that the sort order is no longer valid and should be updated
    by calling gtk_sorter_compare() again.

    GTK provides various pre-made sorter implementations for common sorting
    operations. [class@Gtk.ColumnView] has built-in support for sorting lists
    via the [property@Gtk.ColumnViewColumn:sorter] property, where the user can
    change the sorting by clicking on list headers.

    Of course, in particular for large lists, it is also possible to subclass
    `GtkSorter` and provide one's own sorter.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def changed(self, change: SorterChange) -> None: ...
    def compare(self, item1: GObject.Object, item2: GObject.Object) -> Ordering: ...
    def get_order(self) -> SorterOrder: ...

    # python methods (overrides?)
    def do_compare(
        self,
        item1: GObject.Object | None = None,
        item2: GObject.Object | None = None,
    ) -> Ordering:
        """
        compare(self, item1:GObject.Object=None, item2:GObject.Object=None) -> Gtk.Ordering
        """
    def do_get_order(
        self,
    ) -> SorterOrder:
        """
        get_order(self) -> Gtk.SorterOrder
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["changed"],
        handler: typing.Callable[[typing_extensions.Self, SorterChange], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SorterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def compare(self) -> compareSorterClassCB: ...
    @builtins.property
    def get_order(self) -> get_orderSorterClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SpinButton(Widget):
    """
    Allows to enter or change numeric values.

    <picture>
      <source srcset="spinbutton-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkSpinButton" src="spinbutton.png">
    </picture>

    Rather than having to directly type a number into a `GtkEntry`,
    `GtkSpinButton` allows the user to click on one of two arrows
    to increment or decrement the displayed value. A value can still be
    typed in, with the bonus that it can be checked to ensure it is in a
    given range.

    The main properties of a `GtkSpinButton` are through an adjustment.
    See the [class@Gtk.Adjustment] documentation for more details about
    an adjustment's properties.

    Note that `GtkSpinButton` will by default make its entry large enough
    to accommodate the lower and upper bounds of the adjustment. If this
    is not desired, the automatic sizing can be turned off by explicitly
    setting [property@Gtk.Editable:width-chars] to a value != -1.

    ## Using a GtkSpinButton to get an integer

    ```c
    // Provides a function to retrieve an integer value from a GtkSpinButton
    // and creates a spin button to model percentage values.

    int
    grab_int_value (GtkSpinButton *button,
                    gpointer       user_data)
    {
      return gtk_spin_button_get_value_as_int (button);
    }

    void
    create_integer_spin_button (void)
    {

      GtkWidget *window, *button;
      GtkAdjustment *adjustment;

      adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);

      window = gtk_window_new ();

      // creates the spinbutton, with no decimal places
      button = gtk_spin_button_new (adjustment, 1.0, 0);
      gtk_window_set_child (GTK_WINDOW (window), button);

      gtk_window_present (GTK_WINDOW (window));
    }
    ```

    ## Using a GtkSpinButton to get a floating point value

    ```c
    // Provides a function to retrieve a floating point value from a
    // GtkSpinButton, and creates a high precision spin button.

    float
    grab_float_value (GtkSpinButton *button,
                      gpointer       user_data)
    {
      return gtk_spin_button_get_value (button);
    }

    void
    create_floating_spin_button (void)
    {
      GtkWidget *window, *button;
      GtkAdjustment *adjustment;

      adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);

      window = gtk_window_new ();

      // creates the spinbutton, with three decimal places
      button = gtk_spin_button_new (adjustment, 0.001, 3);
      gtk_window_set_child (GTK_WINDOW (window), button);

      gtk_window_present (GTK_WINDOW (window));
    }
    ```

    # Shortcuts and Gestures

    The following signals have default keybindings:

    - [signal@Gtk.SpinButton::change-value]

    # CSS nodes

    ```
    spinbutton.horizontal
    ├── text
    │    ├── undershoot.left
    │    ╰── undershoot.right
    ├── button.down
    ╰── button.up
    ```

    ```
    spinbutton.vertical
    ├── button.up
    ├── text
    │    ├── undershoot.left
    │    ╰── undershoot.right
    ╰── button.down
    ```

    `GtkSpinButton`s main CSS node has the name spinbutton. It creates subnodes
    for the entry and the two buttons, with these names. The button nodes have
    the style classes .up and .down. The `GtkText` subnodes (if present) are put
    below the text node. The orientation of the spin button is reflected in
    the .vertical or .horizontal style class on the main node.

    # Accessibility

    `GtkSpinButton` uses the [enum@Gtk.AccessibleRole.spin_button] role.
    """

    class Props(Widget.Props):
        activates_default: bool  # [activates-default]: changed because contained invalid characters
        adjustment: Adjustment | None
        climb_rate: float  # [climb-rate]: changed because contained invalid characters
        digits: int
        numeric: bool
        snap_to_ticks: bool  # [snap-to-ticks]: changed because contained invalid characters
        update_policy: SpinButtonUpdatePolicy  # [update-policy]: changed because contained invalid characters
        value: float
        wrap: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        activates_default: bool = ...,
        adjustment: Adjustment | None = ...,
        climb_rate: float = ...,
        digits: int = ...,
        numeric: bool = ...,
        snap_to_ticks: bool = ...,
        update_policy: SpinButtonUpdatePolicy = ...,
        value: float = ...,
        wrap: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def configure(self, adjustment: Adjustment | None, climb_rate: float, digits: int) -> None: ...
    @builtins.property
    def get_activates_default(self) -> bool: ...
    @builtins.property
    def get_adjustment(self) -> Adjustment: ...
    @builtins.property
    def get_climb_rate(self) -> float: ...
    @builtins.property
    def get_digits(self) -> int: ...
    def get_increments(self) -> tuple[float | None, float | None]: ...
    @builtins.property
    def get_numeric(self) -> bool: ...
    def get_range(self) -> tuple[float | None, float | None]: ...
    @builtins.property
    def get_snap_to_ticks(self) -> bool: ...
    @builtins.property
    def get_update_policy(self) -> SpinButtonUpdatePolicy: ...
    @builtins.property
    def get_value(self) -> float: ...
    def get_value_as_int(self) -> int: ...
    @builtins.property
    def get_wrap(self) -> bool: ...
    @classmethod
    def new(cls, adjustment: Adjustment | None, climb_rate: float, digits: int) -> Widget: ...
    @classmethod
    def new_with_range(cls, min: float, max: float, step: float) -> Widget: ...
    def set_activates_default(self, activates_default: bool) -> None: ...
    def set_adjustment(self, adjustment: Adjustment) -> None: ...
    def set_climb_rate(self, climb_rate: float) -> None: ...
    def set_digits(self, digits: int) -> None: ...
    def set_increments(self, step: float, page: float) -> None: ...
    def set_numeric(self, numeric: bool) -> None: ...
    def set_range(self, min: float, max: float) -> None: ...
    def set_snap_to_ticks(self, snap_to_ticks: bool) -> None: ...
    def set_update_policy(self, policy: SpinButtonUpdatePolicy) -> None: ...
    def set_value(self, value: float) -> None: ...
    def set_wrap(self, wrap: bool) -> None: ...
    def spin(self, direction: SpinType, increment: float) -> None: ...
    def update(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["change-value"],
        handler: typing.Callable[[typing_extensions.Self, ScrollType], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["input"],
        handler: typing.Callable[..., tuple[int, float]],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["output"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["value-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["wrapped"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activates_default"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::adjustment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::climb_rate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::digits"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::numeric"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::snap_to_ticks"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::update_policy"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::value"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Spinner(Widget):
    """
    Displays an icon-size spinning animation.

    It is often used as an alternative to a [class@Gtk.ProgressBar]
    for displaying indefinite activity, instead of actual progress.

    <picture>
      <source srcset="spinner-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkSpinner" src="spinner.png">
    </picture>

    To start the animation, use [method@Gtk.Spinner.start], to stop it
    use [method@Gtk.Spinner.stop].

    # CSS nodes

    `GtkSpinner` has a single CSS node with the name spinner.
    When the animation is active, the :checked pseudoclass is
    added to this node.
    """

    class Props(Widget.Props):
        spinning: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, spinning: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_spinning(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_spinning(self, spinning: bool) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::spinning"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Stack(Widget):
    """
    Shows one of its children at a time.

    <picture>
      <source srcset="stack-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkStack" src="stack.png">
    </picture>

    In contrast to `GtkNotebook`, `GtkStack` does not provide a means
    for users to change the visible child. Instead, a separate widget
    such as [class@Gtk.StackSwitcher] or [class@Gtk.StackSidebar] can
    be used with `GtkStack` to provide this functionality.

    Transitions between pages can be animated as slides or fades. This
    can be controlled with [method@Gtk.Stack.set_transition_type].
    These animations respect the [property@Gtk.Settings:gtk-enable-animations]
    setting.

    `GtkStack` maintains a [class@Gtk.StackPage] object for each added
    child, which holds additional per-child properties. You
    obtain the `GtkStackPage` for a child with [method@Gtk.Stack.get_page]
    and you can obtain a `GtkSelectionModel` containing all the pages
    with [method@Gtk.Stack.get_pages].

    # GtkStack as GtkBuildable

    To set child-specific properties in a .ui file, create `GtkStackPage`
    objects explicitly, and set the child widget as a property on it:

    ```xml
      <object class="GtkStack" id="stack">
        <child>
          <object class="GtkStackPage">
            <property name="name">page1</property>
            <property name="title">In the beginning…</property>
            <property name="child">
              <object class="GtkLabel">
                <property name="label">It was dark</property>
              </object>
            </property>
          </object>
        </child>
    ```

    # CSS nodes

    `GtkStack` has a single CSS node named stack.

    # Accessibility

    `GtkStack` uses the [enum@Gtk.AccessibleRole.tab_panel] role for the stack
    pages, which are the accessible parent objects of the child widgets.
    """

    class Props(Widget.Props):
        hhomogeneous: bool
        interpolate_size: bool  # [interpolate-size]: changed because contained invalid characters
        pages: SelectionModel | None
        transition_duration: int  # [transition-duration]: changed because contained invalid characters
        transition_running: bool  # [transition-running]: changed because contained invalid characters
        transition_type: StackTransitionType  # [transition-type]: changed because contained invalid characters
        vhomogeneous: bool
        visible_child: Widget | None  # [visible-child]: changed because contained invalid characters
        visible_child_name: str  # [visible-child-name]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        hhomogeneous: bool = ...,
        interpolate_size: bool = ...,
        transition_duration: int = ...,
        transition_type: StackTransitionType = ...,
        vhomogeneous: bool = ...,
        visible_child: Widget | None = ...,
        visible_child_name: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_child(self, child: Widget) -> StackPage: ...
    def add_named(self, child: Widget, name: str | None = None) -> StackPage: ...
    def add_titled(self, child: Widget, name: str | None, title: str) -> StackPage: ...
    def get_child_by_name(self, name: str) -> Widget | None: ...
    @builtins.property
    def get_hhomogeneous(self) -> bool: ...
    @builtins.property
    def get_interpolate_size(self) -> bool: ...
    def get_page(self, child: Widget) -> StackPage: ...
    @builtins.property
    def get_pages(self) -> SelectionModel: ...
    @builtins.property
    def get_transition_duration(self) -> int: ...
    @builtins.property
    def get_transition_running(self) -> bool: ...
    @builtins.property
    def get_transition_type(self) -> StackTransitionType: ...
    @builtins.property
    def get_vhomogeneous(self) -> bool: ...
    @builtins.property
    def get_visible_child(self) -> Widget | None: ...
    @builtins.property
    def get_visible_child_name(self) -> str | None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def remove(self, child: Widget) -> None: ...
    def set_hhomogeneous(self, hhomogeneous: bool) -> None: ...
    def set_interpolate_size(self, interpolate_size: bool) -> None: ...
    def set_transition_duration(self, duration: int) -> None: ...
    def set_transition_type(self, transition: StackTransitionType) -> None: ...
    def set_vhomogeneous(self, vhomogeneous: bool) -> None: ...
    def set_visible_child(self, child: Widget) -> None: ...
    def set_visible_child_full(self, name: str, transition: StackTransitionType) -> None: ...
    def set_visible_child_name(self, name: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hhomogeneous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::interpolate_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pages"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::transition_duration"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::transition_running"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::transition_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::vhomogeneous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visible_child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visible_child_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StackPage(GObject.Object):
    """
    An auxiliary class used by `GtkStack`.
    """

    class Props(GObject.Object.Props):
        child: Widget | None
        icon_name: str  # [icon-name]: changed because contained invalid characters
        name: str
        needs_attention: bool  # [needs-attention]: changed because contained invalid characters
        title: str
        use_underline: bool  # [use-underline]: changed because contained invalid characters
        visible: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        child: Widget | None = ...,
        icon_name: str = ...,
        name: str = ...,
        needs_attention: bool = ...,
        title: str = ...,
        use_underline: bool = ...,
        visible: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget: ...
    @builtins.property
    def get_icon_name(self) -> str | None: ...
    @builtins.property
    def get_name(self) -> str | None: ...
    @builtins.property
    def get_needs_attention(self) -> bool: ...
    @builtins.property
    def get_title(self) -> str | None: ...
    @builtins.property
    def get_use_underline(self) -> bool: ...
    @builtins.property
    def get_visible(self) -> bool: ...
    def set_icon_name(self, setting: str) -> None: ...
    def set_name(self, setting: str) -> None: ...
    def set_needs_attention(self, setting: bool) -> None: ...
    def set_title(self, setting: str) -> None: ...
    def set_use_underline(self, setting: bool) -> None: ...
    def set_visible(self, visible: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::needs_attention"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_underline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StackSidebar(Widget):
    """
    Uses a sidebar to switch between `GtkStack` pages.

    <picture>
      <source srcset="sidebar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkStackSidebar" src="sidebar.png">
    </picture>

    In order to use a `GtkStackSidebar`, you simply use a `GtkStack` to
    organize your UI flow, and add the sidebar to your sidebar area. You
    can use [method@Gtk.StackSidebar.set_stack] to connect the `GtkStackSidebar`
    to the `GtkStack`.

    # CSS nodes

    `GtkStackSidebar` has a single CSS node with name stacksidebar and
    style class .sidebar.

    When circumstances require it, `GtkStackSidebar` adds the
    .needs-attention style class to the widgets representing the stack
    pages.
    """

    class Props(Widget.Props):
        stack: Stack | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, stack: Stack | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_stack(self) -> Stack | None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_stack(self, stack: Stack) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stack"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StackSwitcher(Widget):
    """
    Shows a row of buttons to switch between `GtkStack` pages.

    <picture>
      <source srcset="stackswitcher-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkStackSwitcher" src="stackswitcher.png">
    </picture>

    It acts as a controller for the associated `GtkStack`.

    All the content for the buttons comes from the properties of the stacks
    [class@Gtk.StackPage] objects; the button visibility in a `GtkStackSwitcher`
    widget is controlled by the visibility of the child in the `GtkStack`.

    It is possible to associate multiple `GtkStackSwitcher` widgets
    with the same `GtkStack` widget.

    # CSS nodes

    `GtkStackSwitcher` has a single CSS node named stackswitcher and
    style class .stack-switcher.

    When circumstances require it, `GtkStackSwitcher` adds the
    .needs-attention style class to the widgets representing the
    stack pages.

    # Accessibility

    `GtkStackSwitcher` uses the [enum@Gtk.AccessibleRole.tab_list] role
    and uses the [enum@Gtk.AccessibleRole.tab] role for its buttons.

    # Orientable

    Since GTK 4.4, `GtkStackSwitcher` implements `GtkOrientable` allowing
    the stack switcher to be made vertical with
    `gtk_orientable_set_orientation()`.
    """

    class Props(Widget.Props):
        stack: Stack | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, stack: Stack | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_stack(self) -> Stack | None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_stack(self, stack: Stack | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stack"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Statusbar(Widget):
    """
    A `GtkStatusbar` widget is usually placed along the bottom of an application's
    main [class@Gtk.Window].

    picture>
      <source srcset="statusbar-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkStatusbar" src="statusbar.png">
    </picture>

    A `GtkStatusBar` may provide a regular commentary of the application's
    status (as is usually the case in a web browser, for example), or may be
    used to simply output a message when the status changes, (when an upload
    is complete in an FTP client, for example).

    Status bars in GTK maintain a stack of messages. The message at
    the top of the each bar’s stack is the one that will currently be displayed.

    Any messages added to a statusbar’s stack must specify a context id that
    is used to uniquely identify the source of a message. This context id can
    be generated by [method@Gtk.Statusbar.get_context_id], given a message and
    the statusbar that it will be added to. Note that messages are stored in a
    stack, and when choosing which message to display, the stack structure is
    adhered to, regardless of the context identifier of a message.

    One could say that a statusbar maintains one stack of messages for
    display purposes, but allows multiple message producers to maintain
    sub-stacks of the messages they produced (via context ids).

    Status bars are created using [ctor@Gtk.Statusbar.new].

    Messages are added to the bar’s stack with [method@Gtk.Statusbar.push].

    The message at the top of the stack can be removed using
    [method@Gtk.Statusbar.pop]. A message can be removed from anywhere in the
    stack if its message id was recorded at the time it was added. This is done
    using [method@Gtk.Statusbar.remove].

    ## CSS node

    `GtkStatusbar` has a single CSS node with name `statusbar`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def get_context_id(self, context_description: str) -> int: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    def pop(self, context_id: int) -> None: ...
    @deprecated("deprecated")
    def push(self, context_id: int, text: str) -> int: ...
    @deprecated("deprecated")
    def remove(self, context_id: int, message_id: int) -> None: ...
    @deprecated("deprecated")
    def remove_all(self, context_id: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["text-popped"],
        handler: typing.Callable[[typing_extensions.Self, int, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["text-pushed"],
        handler: typing.Callable[[typing_extensions.Self, int, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StringFilter(Filter):
    """
    Determines whether to include items by comparing strings to a fixed search term.

    The strings are obtained from the items by evaluating an expression
    set with [method@Gtk.StringFilter.set_expression], and they are
    compared against a search term set with [method@Gtk.StringFilter.set_search].

    `GtkStringFilter` has several different modes of comparison - it
    can match the whole string, just a prefix, or any substring. Use
    [method@Gtk.StringFilter.set_match_mode] choose a mode.

    It is also possible to make case-insensitive comparisons, with
    [method@Gtk.StringFilter.set_ignore_case].
    """

    class Props(Filter.Props):
        expression: Expression | None
        ignore_case: bool  # [ignore-case]: changed because contained invalid characters
        match_mode: StringFilterMatchMode  # [match-mode]: changed because contained invalid characters
        search: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        expression: Expression | None = ...,
        ignore_case: bool = ...,
        match_mode: StringFilterMatchMode = ...,
        search: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_expression(self) -> Expression | None: ...
    @builtins.property
    def get_ignore_case(self) -> bool: ...
    @builtins.property
    def get_match_mode(self) -> StringFilterMatchMode: ...
    @builtins.property
    def get_search(self) -> str | None: ...
    @classmethod
    def new(cls, expression: Expression | None = None) -> StringFilter: ...
    def set_expression(self, expression: Expression | None = None) -> None: ...
    def set_ignore_case(self, ignore_case: bool) -> None: ...
    def set_match_mode(self, mode: StringFilterMatchMode) -> None: ...
    def set_search(self, search: str | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expression"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ignore_case"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::match_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::search"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StringFilterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> FilterClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class StringList(GObject.Object):
    """
    A list model that wraps an array of strings.

    The objects in the model are of type [class@Gtk.StringObject] and have
    a "string" property that can be used inside expressions.

    `GtkStringList` is well-suited for any place where you would
    typically use a `char*[]`, but need a list model.

    ## GtkStringList as GtkBuildable

    The `GtkStringList` implementation of the `GtkBuildable` interface
    supports adding items directly using the `<items>` element and
    specifying `<item>` elements for each item. Each `<item>` element
    supports the regular translation attributes “translatable”,
    “context” and “comments”.

    Here is a UI definition fragment specifying a `GtkStringList`

    ```xml
    <object class="GtkStringList">
      <items>
        <item translatable="yes">Factory</item>
        <item translatable="yes">Home</item>
        <item translatable="yes">Subway</item>
      </items>
    </object>
    ```
    """

    class Props(GObject.Object.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        n_items: int  # [n-items]: changed because contained invalid characters
        strings: list | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, strings: list | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, string: str) -> None: ...
    def find(self, string: str) -> int: ...
    def get_string(self, position: int) -> str | None: ...
    @classmethod
    def new(cls, strings: list | None = None) -> StringList: ...
    def remove(self, position: int) -> None: ...
    def splice(self, position: int, n_removals: int, additions: list | None = None) -> None: ...
    def take(self, string: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::strings"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StringListClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class StringObject(GObject.Object):
    """
    The type of items in a `GtkStringList`.

    A `GtkStringObject` is a wrapper around a `const char*`; it has
    a [property@Gtk.StringObject:string] property that can be used
    for property bindings and expressions.
    """

    class Props(GObject.Object.Props):
        string: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_string(self) -> str: ...
    @classmethod
    def new(cls, string: str) -> StringObject: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::string"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StringObjectClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class StringSorter(Sorter):
    """
    Sorts items by comparing strings.

    To obtain the strings to compare, this sorter evaluates a
    [class@Gtk.Expression].

    It does the comparison in a linguistically correct way using the
    current locale by normalizing Unicode strings and possibly case-folding
    them before performing the comparison.
    """

    class Props(Sorter.Props):
        collation: Collation
        expression: Expression | None
        ignore_case: bool  # [ignore-case]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, collation: Collation = ..., expression: Expression | None = ..., ignore_case: bool = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_collation(self) -> Collation: ...
    @builtins.property
    def get_expression(self) -> Expression | None: ...
    @builtins.property
    def get_ignore_case(self) -> bool: ...
    @classmethod
    def new(cls, expression: Expression | None = None) -> StringSorter: ...
    def set_collation(self, collation: Collation) -> None: ...
    def set_expression(self, expression: Expression | None = None) -> None: ...
    def set_ignore_case(self, ignore_case: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::collation"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expression"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ignore_case"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StringSorterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SorterClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class StyleContext(GObject.Object):
    """
    `GtkStyleContext` stores styling information affecting a widget.

    In order to construct the final style information, `GtkStyleContext`
    queries information from all attached `GtkStyleProviders`. Style
    providers can be either attached explicitly to the context through
    [method@Gtk.StyleContext.add_provider], or to the display through
    [func@Gtk.StyleContext.add_provider_for_display]. The resulting
    style is a combination of all providers’ information in priority order.

    For GTK widgets, any `GtkStyleContext` returned by
    [method@Gtk.Widget.get_style_context] will already have a `GdkDisplay`
    and RTL/LTR information set. The style context will also be updated
    automatically if any of these settings change on the widget.

    ## Style Classes

    Widgets can add style classes to their context, which can be used to associate
    different styles by class. The documentation for individual widgets lists
    which style classes it uses itself, and which style classes may be added by
    applications to affect their appearance.

    # Custom styling in UI libraries and applications

    If you are developing a library with custom widgets that render differently
    than standard components, you may need to add a `GtkStyleProvider` yourself
    with the %GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either a
    `GtkCssProvider` or a custom object implementing the `GtkStyleProvider`
    interface. This way themes may still attempt to style your UI elements in
    a different way if needed so.

    If you are using custom styling on an applications, you probably want then
    to make your style information prevail to the theme’s, so you must use
    a `GtkStyleProvider` with the %GTK_STYLE_PROVIDER_PRIORITY_APPLICATION
    priority, keep in mind that the user settings in
    `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
    still take precedence over your changes, as it uses the
    %GTK_STYLE_PROVIDER_PRIORITY_USER priority.
    """

    class Props(GObject.Object.Props):
        display: Gdk.Display | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_object(self) -> GObject.Object | None: ...

    # gi Methods
    def __init__(self, display: Gdk.Display | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_class(self, class_name: str) -> None: ...
    @deprecated("deprecated")
    def add_provider(self, provider: StyleProvider, priority: int) -> None: ...
    @staticmethod
    def add_provider_for_display(display: Gdk.Display, provider: StyleProvider, priority: int) -> None: ...
    @deprecated("deprecated")
    def get_border(self) -> Border: ...
    @deprecated("deprecated")
    def get_color(self) -> Gdk.RGBA: ...
    @deprecated("deprecated")
    @builtins.property
    def get_display(self) -> Gdk.Display: ...
    @deprecated("deprecated")
    def get_margin(self) -> Border: ...
    @deprecated("deprecated")
    def get_padding(self) -> Border: ...
    @deprecated("deprecated")
    def get_scale(self) -> int: ...
    @deprecated("deprecated")
    def get_state(self) -> StateFlags: ...
    @deprecated("deprecated")
    def has_class(self, class_name: str) -> bool: ...
    @deprecated("deprecated")
    def lookup_color(self, color_name: str) -> tuple[bool, Gdk.RGBA]: ...
    @deprecated("deprecated")
    def remove_class(self, class_name: str) -> None: ...
    @deprecated("deprecated")
    def remove_provider(self, provider: StyleProvider) -> None: ...
    @staticmethod
    def remove_provider_for_display(display: Gdk.Display, provider: StyleProvider) -> None: ...
    @deprecated("deprecated")
    def restore(self) -> None: ...
    @deprecated("deprecated")
    def save(self) -> None: ...
    @deprecated("deprecated")
    def set_display(self, display: Gdk.Display) -> None: ...
    @deprecated("deprecated")
    def set_scale(self, scale: int) -> None: ...
    @deprecated("deprecated")
    def set_state(self, flags: StateFlags) -> None: ...
    @deprecated("deprecated")
    def to_string(self, flags: StyleContextPrintFlags) -> str: ...

    # python methods (overrides?)
    def do_changed(
        self,
    ) -> None:
        """
        changed(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::display"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class StyleContextClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def changed(self) -> changedStyleContextClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class StyleProvider(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["gtk-private-changed"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Switch(Widget):
    """
    Shows a "light switch" that has two states: on or off.

    <picture>
      <source srcset="switch-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkSwitch" src="switch.png">
    </picture>

    The user can control which state should be active by clicking the
    empty area, or by dragging the slider.

    `GtkSwitch` can also express situations where the underlying state changes
    with a delay. In this case, the slider position indicates the user's recent
    change (represented by the [property@Gtk.Switch:active] property), while the
    trough color indicates the present underlying state (represented by the
    [property@Gtk.Switch:state] property).

    <picture>
      <source srcset="switch-state-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="GtkSwitch with delayed state change" src="switch-state.png">
    </picture>

    See [signal@Gtk.Switch::state-set] for details.

    # Shortcuts and Gestures

    `GtkSwitch` supports pan and drag gestures to move the slider.

    # CSS nodes

    ```
    switch
    ├── image
    ├── image
    ╰── slider
    ```

    `GtkSwitch` has four css nodes, the main node with the name switch and
    subnodes for the slider and the on and off images. Neither of them is
    using any style classes.

    # Accessibility

    `GtkSwitch` uses the [enum@Gtk.AccessibleRole.switch] role.
    """

    class Props(Widget.Props):
        active: bool
        state: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, active: bool = ..., state: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_active(self) -> bool: ...
    @builtins.property
    def get_state(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_active(self, is_active: bool) -> None: ...
    def set_state(self, state: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["state-set"],
        handler: typing.Callable[[typing_extensions.Self, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SymbolicPaintable(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def snapshot_symbolic(
        self, snapshot: Gdk.Snapshot, width: float, height: float, colors: list, n_colors: int
    ) -> None: ...

class SymbolicPaintableInterface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def snapshot_symbolic(self) -> snapshot_symbolicSymbolicPaintableInterfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Text(Widget):
    """
    A single-line text entry.

    `GtkText` is the common implementation of single-line text editing
    that is shared between [class@Gtk.Entry], [class@Gtk.PasswordEntry],
    [class@Gtk.SpinButton], and other widgets. In all of these, a `GtkText`
    instance is used as the delegate for the [iface@Gtk.Editable] implementation.

    A large number of key bindings s supported by default. If the entered
    text is longer than the allocation of the widget, the widget will scroll
    so that the cursor position is visible.

    When using an entry for passwords and other sensitive information,
    it can be put into “password mode” using [method@Gtk.Text.set_visibility].
    In this mode, entered text is displayed using an “invisible” character.
    By default, GTK picks the best invisible character that is available
    in the current font, but it can be changed with
    [method@Gtk.Text.set_invisible_char].

    If you want to add icons or progress display in an entry, look at
    [class@Gtk.Entry]. There are other alternatives for more specialized
    use cases, such as [class@Gtk.SearchEntry].

    If you need multi-line editable text, use [class@Gtk.TextView].

    # Shortcuts and Gestures

    `GtkText` supports the following keyboard shortcuts:

    - <kbd>Shift</kbd>+<kbd>F10</kbd> or <kbd>Menu</kbd> opens the context menu.
    - <kbd>Ctrl</kbd>+<kbd>A</kbd> or <kbd>Ctrl</kbd>+<kbd>&sol;</kbd>
      selects all the text.
    - <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>A</kbd> or
      <kbd>Ctrl</kbd>+<kbd>&bsol;</kbd> unselects all.
    - <kbd>Ctrl</kbd>+<kbd>Z</kbd> undoes the last modification.
    - <kbd>Ctrl</kbd>+<kbd>Y</kbd> or <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Z</kbd>
      redoes the last undone modification.
    - <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>T</kbd> toggles the text direction.

    Additionally, the following signals have default keybindings:

    - [signal@Gtk.Text::activate]
    - [signal@Gtk.Text::backspace]
    - [signal@Gtk.Text::copy-clipboard]
    - [signal@Gtk.Text::cut-clipboard]
    - [signal@Gtk.Text::delete-from-cursor]
    - [signal@Gtk.Text::insert-emoji]
    - [signal@Gtk.Text::move-cursor]
    - [signal@Gtk.Text::paste-clipboard]
    - [signal@Gtk.Text::toggle-overwrite]

    # Actions

    `GtkText` defines a set of built-in actions:

    - `clipboard.copy` copies the contents to the clipboard.
    - `clipboard.cut` copies the contents to the clipboard and deletes it from
      the widget.
    - `clipboard.paste` inserts the contents of the clipboard into the widget.
    - `menu.popup` opens the context menu.
    - `misc.insert-emoji` opens the Emoji chooser.
    - `misc.toggle-visibility` toggles the `GtkText`:visibility property.
    - `misc.toggle-direction` toggles the text direction.
    - `selection.delete` deletes the current selection.
    - `selection.select-all` selects all of the widgets content.
    - `text.redo` redoes the last change to the contents.
    - `text.undo` undoes the last change to the contents.

    # CSS nodes

    ```
    text[.read-only]
    ├── placeholder
    ├── undershoot.left
    ├── undershoot.right
    ├── [selection]
    ├── [cursor-handle[.top]
    ├── [cursor-handle.bottom]
    ├── [block-cursor]
    ├── [cursor-handle[.top/.bottom][.insertion-cursor]]
    ╰── [window.popup]
    ```

    `GtkText` has a main node with the name `text`. Depending on the properties
    of the widget, the `.read-only` style class may appear.

    When the entry has a selection, it adds a subnode with the name `selection`.

    When the entry is in overwrite mode, it adds a subnode with the name
    `block-cursor` that determines how the block cursor is drawn.

    The CSS node for a context menu is added as a subnode with the name `popup`.

    The `undershoot` nodes are used to draw the underflow indication when content
    is scrolled out of view. These nodes get the `.left` or `.right` style class
    added depending on where the indication is drawn.

    When touch is used and touch selection handles are shown, they are using
    CSS nodes with name `cursor-handle`. They get the `.top` or `.bottom` style
    class depending on where they are shown in relation to the selection. If
    there is just a single handle for the text cursor, it gets the style class
    `.insertion-cursor`.

    # Accessibility

    `GtkText` uses the [enum@Gtk.AccessibleRole.none] role, which causes it to be
    skipped for accessibility. This is because `GtkText` is expected to be used
    as a delegate for a `GtkEditable` implementation that will be represented
    to accessibility.
    """

    class Props(Widget.Props):
        activates_default: bool  # [activates-default]: changed because contained invalid characters
        attributes: Pango.AttrList | None
        buffer: EntryBuffer | None
        enable_emoji_completion: bool  # [enable-emoji-completion]: changed because contained invalid characters
        extra_menu: Gio.MenuModel | None  # [extra-menu]: changed because contained invalid characters
        im_module: str  # [im-module]: changed because contained invalid characters
        input_hints: InputHints  # [input-hints]: changed because contained invalid characters
        input_purpose: InputPurpose  # [input-purpose]: changed because contained invalid characters
        invisible_char: int  # [invisible-char]: changed because contained invalid characters
        invisible_char_set: bool  # [invisible-char-set]: changed because contained invalid characters
        max_length: int  # [max-length]: changed because contained invalid characters
        overwrite_mode: bool  # [overwrite-mode]: changed because contained invalid characters
        placeholder_text: str  # [placeholder-text]: changed because contained invalid characters
        propagate_text_width: bool  # [propagate-text-width]: changed because contained invalid characters
        scroll_offset: int  # [scroll-offset]: changed because contained invalid characters
        tabs: Pango.TabArray | None
        truncate_multiline: bool  # [truncate-multiline]: changed because contained invalid characters
        visibility: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        activates_default: bool = ...,
        attributes: Pango.AttrList | None = ...,
        buffer: EntryBuffer | None = ...,
        enable_emoji_completion: bool = ...,
        extra_menu: Gio.MenuModel | None = ...,
        im_module: str = ...,
        input_hints: InputHints = ...,
        input_purpose: InputPurpose = ...,
        invisible_char: int = ...,
        invisible_char_set: bool = ...,
        max_length: int = ...,
        overwrite_mode: bool = ...,
        placeholder_text: str = ...,
        propagate_text_width: bool = ...,
        tabs: Pango.TabArray | None = ...,
        truncate_multiline: bool = ...,
        visibility: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def compute_cursor_extents(self, position: int) -> tuple[Graphene.Rect | None, Graphene.Rect | None]: ...
    @builtins.property
    def get_activates_default(self) -> bool: ...
    @builtins.property
    def get_attributes(self) -> Pango.AttrList | None: ...
    @builtins.property
    def get_buffer(self) -> EntryBuffer: ...
    @builtins.property
    def get_enable_emoji_completion(self) -> bool: ...
    @builtins.property
    def get_extra_menu(self) -> Gio.MenuModel | None: ...
    @builtins.property
    def get_input_hints(self) -> InputHints: ...
    @builtins.property
    def get_input_purpose(self) -> InputPurpose: ...
    @builtins.property
    def get_invisible_char(self) -> str: ...
    @builtins.property
    def get_max_length(self) -> int: ...
    @builtins.property
    def get_overwrite_mode(self) -> bool: ...
    @builtins.property
    def get_placeholder_text(self) -> str | None: ...
    @builtins.property
    def get_propagate_text_width(self) -> bool: ...
    @builtins.property
    def get_tabs(self) -> Pango.TabArray | None: ...
    def get_text_length(self) -> int: ...
    @builtins.property
    def get_truncate_multiline(self) -> bool: ...
    @builtins.property
    def get_visibility(self) -> bool: ...
    def grab_focus_without_selecting(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_with_buffer(cls, buffer: EntryBuffer) -> Widget: ...
    def set_activates_default(self, activates: bool) -> None: ...
    def set_attributes(self, attrs: Pango.AttrList | None = None) -> None: ...
    def set_buffer(self, buffer: EntryBuffer) -> None: ...
    def set_enable_emoji_completion(self, enable_emoji_completion: bool) -> None: ...
    def set_extra_menu(self, model: Gio.MenuModel | None = None) -> None: ...
    def set_input_hints(self, hints: InputHints) -> None: ...
    def set_input_purpose(self, purpose: InputPurpose) -> None: ...
    def set_invisible_char(self, ch: str) -> None: ...
    def set_max_length(self, length: int) -> None: ...
    def set_overwrite_mode(self, overwrite: bool) -> None: ...
    def set_placeholder_text(self, text: str | None = None) -> None: ...
    def set_propagate_text_width(self, propagate_text_width: bool) -> None: ...
    def set_tabs(self, tabs: Pango.TabArray | None = None) -> None: ...
    def set_truncate_multiline(self, truncate_multiline: bool) -> None: ...
    def set_visibility(self, visible: bool) -> None: ...
    def unset_invisible_char(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["backspace"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["copy-clipboard"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["cut-clipboard"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["delete-from-cursor"],
        handler: typing.Callable[[typing_extensions.Self, DeleteType, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["insert-at-cursor"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["insert-emoji"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-cursor"],
        handler: typing.Callable[[typing_extensions.Self, MovementStep, int, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["paste-clipboard"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["preedit-changed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["toggle-overwrite"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activates_default"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::attributes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_emoji_completion"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::extra_menu"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::im_module"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_hints"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_purpose"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::invisible_char"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::invisible_char_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_length"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::overwrite_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::placeholder_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::propagate_text_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scroll_offset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tabs"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::truncate_multiline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visibility"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TextBuffer(GObject.Object):
    """
    Stores text and attributes for display in a `GtkTextView`.

    You may wish to begin by reading the
    [text widget conceptual overview](section-text-widget.html),
    which gives an overview of all the objects and data types
    related to the text widget and how they work together.

    GtkTextBuffer can support undoing changes to the buffer
    content, see [method@Gtk.TextBuffer.set_enable_undo].
    """

    class Props(GObject.Object.Props):
        can_redo: bool  # [can-redo]: changed because contained invalid characters
        can_undo: bool  # [can-undo]: changed because contained invalid characters
        cursor_position: int  # [cursor-position]: changed because contained invalid characters
        enable_undo: bool  # [enable-undo]: changed because contained invalid characters
        has_selection: bool  # [has-selection]: changed because contained invalid characters
        tag_table: TextTagTable | None  # [tag-table]: changed because contained invalid characters
        text: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, enable_undo: bool = ..., tag_table: TextTagTable | None = ..., text: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_commit_notify(
        self,
        flags: TextBufferNotifyFlags,
        commit_notify: TextBufferCommitNotify,
        user_data: object | None,
        destroy: GLib.DestroyNotify,
    ) -> int: ...
    def add_mark(self, mark: TextMark, where: TextIter) -> None: ...
    def add_selection_clipboard(self, clipboard: Gdk.Clipboard) -> None: ...
    def apply_tag(self, tag: TextTag, start: TextIter, end: TextIter) -> None: ...
    def apply_tag_by_name(self, name: str, start: TextIter, end: TextIter) -> None: ...
    def backspace(self, iter: TextIter, interactive: bool, default_editable: bool) -> bool: ...
    def begin_irreversible_action(self) -> None: ...
    def begin_user_action(self) -> None: ...
    def copy_clipboard(self, clipboard: Gdk.Clipboard) -> None: ...
    def create_child_anchor(self, iter: TextIter) -> TextChildAnchor: ...
    def create_mark(self, mark_name: str | None, where: TextIter, left_gravity: bool) -> TextMark: ...
    def cut_clipboard(self, clipboard: Gdk.Clipboard, default_editable: bool) -> None: ...
    def delete(self, start: TextIter, end: TextIter) -> None: ...
    def delete_interactive(self, start_iter: TextIter, end_iter: TextIter, default_editable: bool) -> bool: ...
    def delete_mark(self, mark: TextMark) -> None: ...
    def delete_mark_by_name(self, name: str) -> None: ...
    def delete_selection(self, interactive: bool, default_editable: bool) -> bool: ...
    def end_irreversible_action(self) -> None: ...
    def end_user_action(self) -> None: ...
    def get_bounds(self) -> tuple[TextIter, TextIter]: ...
    @builtins.property
    def get_can_redo(self) -> bool: ...
    @builtins.property
    def get_can_undo(self) -> bool: ...
    def get_char_count(self) -> int: ...
    @builtins.property
    def get_enable_undo(self) -> bool: ...
    def get_end_iter(self) -> TextIter: ...
    @builtins.property
    def get_has_selection(self) -> bool: ...
    def get_insert(self) -> TextMark: ...
    def get_iter_at_child_anchor(self, anchor: TextChildAnchor) -> TextIter: ...
    def get_iter_at_line(self, line_number: int) -> tuple[bool, TextIter]: ...
    def get_iter_at_line_index(self, line_number: int, byte_index: int) -> tuple[bool, TextIter]: ...
    def get_iter_at_line_offset(self, line_number: int, char_offset: int) -> tuple[bool, TextIter]: ...
    def get_iter_at_mark(self, mark: TextMark) -> TextIter: ...
    def get_iter_at_offset(self, char_offset: int) -> TextIter: ...
    def get_line_count(self) -> int: ...
    def get_mark(self, name: str) -> TextMark | None: ...
    def get_max_undo_levels(self) -> int: ...
    def get_modified(self) -> bool: ...
    def get_selection_bound(self) -> TextMark: ...
    def get_selection_bounds(self) -> tuple[bool, TextIter, TextIter]: ...
    def get_selection_content(self) -> Gdk.ContentProvider: ...
    def get_slice(self, start: TextIter, end: TextIter, include_hidden_chars: bool) -> str: ...
    def get_start_iter(self) -> TextIter: ...
    @builtins.property
    def get_tag_table(self) -> TextTagTable: ...
    def get_text(self, start: TextIter, end: TextIter, include_hidden_chars: bool) -> str: ...
    def insert(self, iter: TextIter, text: str, len: int) -> None: ...
    def insert_at_cursor(self, text: str, len: int) -> None: ...
    def insert_child_anchor(self, iter: TextIter, anchor: TextChildAnchor) -> None: ...
    def insert_interactive(self, iter: TextIter, text: str, len: int, default_editable: bool) -> bool: ...
    def insert_interactive_at_cursor(self, text: str, len: int, default_editable: bool) -> bool: ...
    def insert_markup(self, iter: TextIter, markup: str, len: int) -> None: ...
    def insert_paintable(self, iter: TextIter, paintable: Gdk.Paintable) -> None: ...
    def insert_range(self, iter: TextIter, start: TextIter, end: TextIter) -> None: ...
    def insert_range_interactive(
        self, iter: TextIter, start: TextIter, end: TextIter, default_editable: bool
    ) -> bool: ...
    def move_mark(self, mark: TextMark, where: TextIter) -> None: ...
    def move_mark_by_name(self, name: str, where: TextIter) -> None: ...
    @classmethod
    def new(cls, table: TextTagTable | None = None) -> TextBuffer: ...
    def paste_clipboard(
        self, clipboard: Gdk.Clipboard, override_location: TextIter | None, default_editable: bool
    ) -> None: ...
    def place_cursor(self, where: TextIter) -> None: ...
    def redo(self) -> None: ...
    def remove_all_tags(self, start: TextIter, end: TextIter) -> None: ...
    def remove_commit_notify(self, commit_notify_handler: int) -> None: ...
    def remove_selection_clipboard(self, clipboard: Gdk.Clipboard) -> None: ...
    def remove_tag(self, tag: TextTag, start: TextIter, end: TextIter) -> None: ...
    def remove_tag_by_name(self, name: str, start: TextIter, end: TextIter) -> None: ...
    def select_range(self, ins: TextIter, bound: TextIter) -> None: ...
    def set_enable_undo(self, enable_undo: bool) -> None: ...
    def set_max_undo_levels(self, max_undo_levels: int) -> None: ...
    def set_modified(self, setting: bool) -> None: ...
    def set_text(self, text: str, len: int) -> None: ...
    def undo(self) -> None: ...

    # python methods (overrides?)
    def create_tag(
        self,
        tag_name: typing.Any = None,
        **properties: typing.Any,
    ) -> typing.Any:
        """
        Creates a tag and adds it to the tag table of the TextBuffer.

        :param str tag_name:
            Name of the new tag, or None
        :param **properties:
            Keyword list of properties and their values

        This is equivalent to creating a Gtk.TextTag and then adding the
        tag to the buffer's tag table. The returned tag is owned by
        the buffer's tag table.

        If ``tag_name`` is None, the tag is anonymous.

        If ``tag_name`` is not None, a tag called ``tag_name`` must not already
        exist in the tag table for this buffer.

        Properties are passed as a keyword list of names and values (e.g.
        foreground='DodgerBlue', weight=Pango.Weight.BOLD)

        :returns:
            A new tag.
        """
    def insert_with_tags(
        self,
        iter: typing.Any,
        text: typing.Any,
        *tags: typing.Any,
    ) -> typing.Any: ...
    def insert_with_tags_by_name(
        self,
        iter: typing.Any,
        text: typing.Any,
        *tags: typing.Any,
    ) -> typing.Any: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["apply-tag"],
        handler: typing.Callable[[typing_extensions.Self, TextTag, TextIter, TextIter], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["begin-user-action"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["delete-range"],
        handler: typing.Callable[[typing_extensions.Self, TextIter, TextIter], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["end-user-action"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["insert-child-anchor"],
        handler: typing.Callable[[typing_extensions.Self, TextIter, TextChildAnchor], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["insert-paintable"],
        handler: typing.Callable[[typing_extensions.Self, TextIter, Gdk.Paintable], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["insert-text"],
        handler: typing.Callable[[typing_extensions.Self, TextIter, str, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mark-deleted"],
        handler: typing.Callable[[typing_extensions.Self, TextMark], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mark-set"],
        handler: typing.Callable[[typing_extensions.Self, TextIter, TextMark], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["modified-changed"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["paste-done"],
        handler: typing.Callable[[typing_extensions.Self, Gdk.Clipboard], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["redo"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["remove-tag"],
        handler: typing.Callable[[typing_extensions.Self, TextTag, TextIter, TextIter], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["undo"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_redo"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_undo"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cursor_position"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_undo"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_selection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tag_table"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TextBufferClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def apply_tag(self) -> apply_tagTextBufferClassCB: ...
    @builtins.property
    def begin_user_action(self) -> begin_user_actionTextBufferClassCB: ...
    @builtins.property
    def changed(self) -> changedTextBufferClassCB: ...
    @builtins.property
    def delete_range(self) -> delete_rangeTextBufferClassCB: ...
    @builtins.property
    def end_user_action(self) -> end_user_actionTextBufferClassCB: ...
    @builtins.property
    def insert_child_anchor(self) -> insert_child_anchorTextBufferClassCB: ...
    @builtins.property
    def insert_paintable(self) -> insert_paintableTextBufferClassCB: ...
    @builtins.property
    def insert_text(self) -> insert_textTextBufferClassCB: ...
    @builtins.property
    def mark_deleted(self) -> mark_deletedTextBufferClassCB: ...
    @builtins.property
    def mark_set(self) -> mark_setTextBufferClassCB: ...
    @builtins.property
    def modified_changed(self) -> modified_changedTextBufferClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def paste_done(self) -> paste_doneTextBufferClassCB: ...
    @builtins.property
    def redo(self) -> redoTextBufferClassCB: ...
    @builtins.property
    def remove_tag(self) -> remove_tagTextBufferClassCB: ...
    @builtins.property
    def undo(self) -> undoTextBufferClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TextBufferPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TextChildAnchor(GObject.Object):
    """
    Marks a spot in a `GtkTextBuffer` where child widgets can be “anchored”.

    The anchor can have multiple widgets anchored, to allow for multiple views.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_deleted(self) -> bool: ...
    def get_widgets(self) -> tuple[list, int]: ...
    @classmethod
    def new(cls) -> TextChildAnchor: ...
    @classmethod
    def new_with_replacement(cls, character: str) -> TextChildAnchor: ...

class TextChildAnchorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TextIter(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def assign(self, other: TextIter) -> None: ...
    def backward_char(self) -> bool: ...
    def backward_chars(self, count: int) -> bool: ...
    def backward_cursor_position(self) -> bool: ...
    def backward_cursor_positions(self, count: int) -> bool: ...
    def backward_find_char(
        self, pred: TextCharPredicate, user_data: object | None = None, limit: TextIter | None = None
    ) -> bool: ...
    def backward_line(self) -> bool: ...
    def backward_lines(self, count: int) -> bool: ...
    def backward_search(
        self, str: str, flags: TextSearchFlags, limit: TextIter | None = None
    ) -> tuple[bool, TextIter | None, TextIter | None]: ...
    def backward_sentence_start(self) -> bool: ...
    def backward_sentence_starts(self, count: int) -> bool: ...
    def backward_to_tag_toggle(self, tag: TextTag | None = None) -> bool: ...
    def backward_visible_cursor_position(self) -> bool: ...
    def backward_visible_cursor_positions(self, count: int) -> bool: ...
    def backward_visible_line(self) -> bool: ...
    def backward_visible_lines(self, count: int) -> bool: ...
    def backward_visible_word_start(self) -> bool: ...
    def backward_visible_word_starts(self, count: int) -> bool: ...
    def backward_word_start(self) -> bool: ...
    def backward_word_starts(self, count: int) -> bool: ...
    def can_insert(self, default_editability: bool) -> bool: ...
    def compare(self, rhs: TextIter) -> int: ...
    def copy(self) -> TextIter: ...
    def editable(self, default_setting: bool) -> bool: ...
    def ends_line(self) -> bool: ...
    def ends_sentence(self) -> bool: ...
    def ends_tag(self, tag: TextTag | None = None) -> bool: ...
    def ends_word(self) -> bool: ...
    def equal(self, rhs: TextIter) -> bool: ...
    def forward_char(self) -> bool: ...
    def forward_chars(self, count: int) -> bool: ...
    def forward_cursor_position(self) -> bool: ...
    def forward_cursor_positions(self, count: int) -> bool: ...
    def forward_find_char(
        self, pred: TextCharPredicate, user_data: object | None = None, limit: TextIter | None = None
    ) -> bool: ...
    def forward_line(self) -> bool: ...
    def forward_lines(self, count: int) -> bool: ...
    def forward_search(
        self, str: str, flags: TextSearchFlags, limit: TextIter | None = None
    ) -> tuple[bool, TextIter | None, TextIter | None]: ...
    def forward_sentence_end(self) -> bool: ...
    def forward_sentence_ends(self, count: int) -> bool: ...
    def forward_to_end(self) -> None: ...
    def forward_to_line_end(self) -> bool: ...
    def forward_to_tag_toggle(self, tag: TextTag | None = None) -> bool: ...
    def forward_visible_cursor_position(self) -> bool: ...
    def forward_visible_cursor_positions(self, count: int) -> bool: ...
    def forward_visible_line(self) -> bool: ...
    def forward_visible_lines(self, count: int) -> bool: ...
    def forward_visible_word_end(self) -> bool: ...
    def forward_visible_word_ends(self, count: int) -> bool: ...
    def forward_word_end(self) -> bool: ...
    def forward_word_ends(self, count: int) -> bool: ...
    def free(self) -> None: ...
    def get_buffer(self) -> TextBuffer: ...
    def get_bytes_in_line(self) -> int: ...
    def get_char(self) -> str: ...
    def get_chars_in_line(self) -> int: ...
    def get_child_anchor(self) -> TextChildAnchor | None: ...
    def get_language(self) -> Pango.Language: ...
    def get_line(self) -> int: ...
    def get_line_index(self) -> int: ...
    def get_line_offset(self) -> int: ...
    def get_marks(self) -> list: ...
    def get_offset(self) -> int: ...
    def get_paintable(self) -> Gdk.Paintable | None: ...
    def get_slice(self, end: TextIter) -> str: ...
    def get_tags(self) -> list: ...
    def get_text(self, end: TextIter) -> str: ...
    def get_toggled_tags(self, toggled_on: bool) -> list: ...
    def get_visible_line_index(self) -> int: ...
    def get_visible_line_offset(self) -> int: ...
    def get_visible_slice(self, end: TextIter) -> str: ...
    def get_visible_text(self, end: TextIter) -> str: ...
    def has_tag(self, tag: TextTag) -> bool: ...
    def in_range(self, start: TextIter, end: TextIter) -> bool: ...
    def inside_sentence(self) -> bool: ...
    def inside_word(self) -> bool: ...
    def is_cursor_position(self) -> bool: ...
    def is_end(self) -> bool: ...
    def is_start(self) -> bool: ...
    def order(self, second: TextIter) -> None: ...
    def set_line(self, line_number: int) -> None: ...
    def set_line_index(self, byte_on_line: int) -> None: ...
    def set_line_offset(self, char_on_line: int) -> None: ...
    def set_offset(self, char_offset: int) -> None: ...
    def set_visible_line_index(self, byte_on_line: int) -> None: ...
    def set_visible_line_offset(self, char_on_line: int) -> None: ...
    def starts_line(self) -> bool: ...
    def starts_sentence(self) -> bool: ...
    def starts_tag(self, tag: TextTag | None = None) -> bool: ...
    def starts_word(self) -> bool: ...
    def toggles_tag(self, tag: TextTag | None = None) -> bool: ...

class TextMark(GObject.Object):
    """
    Marks a position in a `GtkTextbuffer` that is preserved
    across modifications.

    You may wish to begin by reading the
    [text widget conceptual overview](section-text-widget.html),
    which gives an overview of all the objects and data types
    related to the text widget and how they work together.

    A `GtkTextMark` is like a bookmark in a text buffer; it preserves
    a position in the text. You can convert the mark to an iterator using
    [method@Gtk.TextBuffer.get_iter_at_mark]. Unlike iterators, marks remain
    valid across buffer mutations, because their behavior is defined when
    text is inserted or deleted. When text containing a mark is deleted,
    the mark remains in the position originally occupied by the deleted
    text. When text is inserted at a mark, a mark with “left gravity” will
    be moved to the beginning of the newly-inserted text, and a mark with
    “right gravity” will be moved to the end.

    Note that “left” and “right” here refer to logical direction (left
    is the toward the start of the buffer); in some languages such as
    Hebrew the logically-leftmost text is not actually on the left when
    displayed.

    Marks are reference counted, but the reference count only controls
    the validity of the memory; marks can be deleted from the buffer at
    any time with [method@Gtk.TextBuffer.delete_mark]. Once deleted from
    the buffer, a mark is essentially useless.

    Marks optionally have names; these can be convenient to avoid passing
    the `GtkTextMark` object around.

    Marks are typically created using the [method@Gtk.TextBuffer.create_mark]
    function.
    """

    class Props(GObject.Object.Props):
        left_gravity: bool  # [left-gravity]: changed because contained invalid characters
        name: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, left_gravity: bool = ..., name: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_buffer(self) -> TextBuffer | None: ...
    def get_deleted(self) -> bool: ...
    @builtins.property
    def get_left_gravity(self) -> bool: ...
    @builtins.property
    def get_name(self) -> str | None: ...
    def get_visible(self) -> bool: ...
    @classmethod
    def new(cls, name: str | None, left_gravity: bool) -> TextMark: ...
    def set_visible(self, setting: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::left_gravity"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TextMarkClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TextTag(GObject.Object):
    """
    Can be applied to text contained in a `GtkTextBuffer`.

    You may wish to begin by reading the
    [text widget conceptual overview](section-text-widget.html),
    which gives an overview of all the objects and data types
    related to the text widget and how they work together.

    Tags should be in the [class@Gtk.TextTagTable] for a given
    `GtkTextBuffer` before using them with that buffer.

    [method@Gtk.TextBuffer.create_tag] is the best way to create tags.
    See “gtk4-demo” for numerous examples.

    For each property of `GtkTextTag`, there is a “set” property, e.g.
    “font-set” corresponds to “font”. These “set” properties reflect
    whether a property has been set or not.

    They are maintained by GTK and you should not set them independently.
    """

    class Props(GObject.Object.Props):
        accumulative_margin: bool  # [accumulative-margin]: changed because contained invalid characters
        allow_breaks: bool  # [allow-breaks]: changed because contained invalid characters
        allow_breaks_set: bool  # [allow-breaks-set]: changed because contained invalid characters
        background: str
        background_full_height: bool  # [background-full-height]: changed because contained invalid characters
        background_full_height_set: bool  # [background-full-height-set]: changed because contained invalid characters
        background_rgba: Gdk.RGBA | None  # [background-rgba]: changed because contained invalid characters
        background_set: bool  # [background-set]: changed because contained invalid characters
        direction: TextDirection
        editable: bool
        editable_set: bool  # [editable-set]: changed because contained invalid characters
        fallback: bool
        fallback_set: bool  # [fallback-set]: changed because contained invalid characters
        family: str
        family_set: bool  # [family-set]: changed because contained invalid characters
        font: str
        font_desc: Pango.FontDescription | None  # [font-desc]: changed because contained invalid characters
        font_features: str  # [font-features]: changed because contained invalid characters
        font_features_set: bool  # [font-features-set]: changed because contained invalid characters
        foreground: str
        foreground_rgba: Gdk.RGBA | None  # [foreground-rgba]: changed because contained invalid characters
        foreground_set: bool  # [foreground-set]: changed because contained invalid characters
        indent: int
        indent_set: bool  # [indent-set]: changed because contained invalid characters
        insert_hyphens: bool  # [insert-hyphens]: changed because contained invalid characters
        insert_hyphens_set: bool  # [insert-hyphens-set]: changed because contained invalid characters
        invisible: bool
        invisible_set: bool  # [invisible-set]: changed because contained invalid characters
        justification: Justification
        justification_set: bool  # [justification-set]: changed because contained invalid characters
        language: str
        language_set: bool  # [language-set]: changed because contained invalid characters
        left_margin: int  # [left-margin]: changed because contained invalid characters
        left_margin_set: bool  # [left-margin-set]: changed because contained invalid characters
        letter_spacing: int  # [letter-spacing]: changed because contained invalid characters
        letter_spacing_set: bool  # [letter-spacing-set]: changed because contained invalid characters
        line_height: float  # [line-height]: changed because contained invalid characters
        line_height_set: bool  # [line-height-set]: changed because contained invalid characters
        name: str
        overline: Pango.Overline
        overline_rgba: Gdk.RGBA | None  # [overline-rgba]: changed because contained invalid characters
        overline_rgba_set: bool  # [overline-rgba-set]: changed because contained invalid characters
        overline_set: bool  # [overline-set]: changed because contained invalid characters
        paragraph_background: str  # [paragraph-background]: changed because contained invalid characters
        paragraph_background_rgba: (
            Gdk.RGBA | None
        )  # [paragraph-background-rgba]: changed because contained invalid characters
        paragraph_background_set: bool  # [paragraph-background-set]: changed because contained invalid characters
        pixels_above_lines: int  # [pixels-above-lines]: changed because contained invalid characters
        pixels_above_lines_set: bool  # [pixels-above-lines-set]: changed because contained invalid characters
        pixels_below_lines: int  # [pixels-below-lines]: changed because contained invalid characters
        pixels_below_lines_set: bool  # [pixels-below-lines-set]: changed because contained invalid characters
        pixels_inside_wrap: int  # [pixels-inside-wrap]: changed because contained invalid characters
        pixels_inside_wrap_set: bool  # [pixels-inside-wrap-set]: changed because contained invalid characters
        right_margin: int  # [right-margin]: changed because contained invalid characters
        right_margin_set: bool  # [right-margin-set]: changed because contained invalid characters
        rise: int
        rise_set: bool  # [rise-set]: changed because contained invalid characters
        scale: float
        scale_set: bool  # [scale-set]: changed because contained invalid characters
        sentence: bool
        sentence_set: bool  # [sentence-set]: changed because contained invalid characters
        show_spaces: Pango.ShowFlags  # [show-spaces]: changed because contained invalid characters
        show_spaces_set: bool  # [show-spaces-set]: changed because contained invalid characters
        size: int
        size_points: float  # [size-points]: changed because contained invalid characters
        size_set: bool  # [size-set]: changed because contained invalid characters
        stretch: Pango.Stretch
        stretch_set: bool  # [stretch-set]: changed because contained invalid characters
        strikethrough: bool
        strikethrough_rgba: Gdk.RGBA | None  # [strikethrough-rgba]: changed because contained invalid characters
        strikethrough_rgba_set: bool  # [strikethrough-rgba-set]: changed because contained invalid characters
        strikethrough_set: bool  # [strikethrough-set]: changed because contained invalid characters
        style: Pango.Style
        style_set: bool  # [style-set]: changed because contained invalid characters
        tabs: Pango.TabArray | None
        tabs_set: bool  # [tabs-set]: changed because contained invalid characters
        text_transform: Pango.TextTransform  # [text-transform]: changed because contained invalid characters
        text_transform_set: bool  # [text-transform-set]: changed because contained invalid characters
        underline: Pango.Underline
        underline_rgba: Gdk.RGBA | None  # [underline-rgba]: changed because contained invalid characters
        underline_rgba_set: bool  # [underline-rgba-set]: changed because contained invalid characters
        underline_set: bool  # [underline-set]: changed because contained invalid characters
        variant: Pango.Variant
        variant_set: bool  # [variant-set]: changed because contained invalid characters
        weight: int
        weight_set: bool  # [weight-set]: changed because contained invalid characters
        word: bool
        word_set: bool  # [word-set]: changed because contained invalid characters
        wrap_mode: WrapMode  # [wrap-mode]: changed because contained invalid characters
        wrap_mode_set: bool  # [wrap-mode-set]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accumulative_margin: bool = ...,
        allow_breaks: bool = ...,
        allow_breaks_set: bool = ...,
        background: str = ...,
        background_full_height: bool = ...,
        background_full_height_set: bool = ...,
        background_rgba: Gdk.RGBA | None = ...,
        background_set: bool = ...,
        direction: TextDirection = ...,
        editable: bool = ...,
        editable_set: bool = ...,
        fallback: bool = ...,
        fallback_set: bool = ...,
        family: str = ...,
        family_set: bool = ...,
        font: str = ...,
        font_desc: Pango.FontDescription | None = ...,
        font_features: str = ...,
        font_features_set: bool = ...,
        foreground: str = ...,
        foreground_rgba: Gdk.RGBA | None = ...,
        foreground_set: bool = ...,
        indent: int = ...,
        indent_set: bool = ...,
        insert_hyphens: bool = ...,
        insert_hyphens_set: bool = ...,
        invisible: bool = ...,
        invisible_set: bool = ...,
        justification: Justification = ...,
        justification_set: bool = ...,
        language: str = ...,
        language_set: bool = ...,
        left_margin: int = ...,
        left_margin_set: bool = ...,
        letter_spacing: int = ...,
        letter_spacing_set: bool = ...,
        line_height: float = ...,
        line_height_set: bool = ...,
        name: str = ...,
        overline: Pango.Overline = ...,
        overline_rgba: Gdk.RGBA | None = ...,
        overline_rgba_set: bool = ...,
        overline_set: bool = ...,
        paragraph_background: str = ...,
        paragraph_background_rgba: Gdk.RGBA | None = ...,
        paragraph_background_set: bool = ...,
        pixels_above_lines: int = ...,
        pixels_above_lines_set: bool = ...,
        pixels_below_lines: int = ...,
        pixels_below_lines_set: bool = ...,
        pixels_inside_wrap: int = ...,
        pixels_inside_wrap_set: bool = ...,
        right_margin: int = ...,
        right_margin_set: bool = ...,
        rise: int = ...,
        rise_set: bool = ...,
        scale: float = ...,
        scale_set: bool = ...,
        sentence: bool = ...,
        sentence_set: bool = ...,
        show_spaces: Pango.ShowFlags = ...,
        show_spaces_set: bool = ...,
        size: int = ...,
        size_points: float = ...,
        size_set: bool = ...,
        stretch: Pango.Stretch = ...,
        stretch_set: bool = ...,
        strikethrough: bool = ...,
        strikethrough_rgba: Gdk.RGBA | None = ...,
        strikethrough_rgba_set: bool = ...,
        strikethrough_set: bool = ...,
        style: Pango.Style = ...,
        style_set: bool = ...,
        tabs: Pango.TabArray | None = ...,
        tabs_set: bool = ...,
        text_transform: Pango.TextTransform = ...,
        text_transform_set: bool = ...,
        underline: Pango.Underline = ...,
        underline_rgba: Gdk.RGBA | None = ...,
        underline_rgba_set: bool = ...,
        underline_set: bool = ...,
        variant: Pango.Variant = ...,
        variant_set: bool = ...,
        weight: int = ...,
        weight_set: bool = ...,
        word: bool = ...,
        word_set: bool = ...,
        wrap_mode: WrapMode = ...,
        wrap_mode_set: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def changed(self, size_changed: bool) -> None: ...
    def get_priority(self) -> int: ...
    @classmethod
    def new(cls, name: str | None = None) -> TextTag: ...
    def set_priority(self, priority: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accumulative_margin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::allow_breaks"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::allow_breaks_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::background"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::background_full_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::background_full_height_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::background_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::background_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::direction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::editable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::editable_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::fallback"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::fallback_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font_desc"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font_features"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::font_features_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::foreground"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::foreground_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::foreground_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::indent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::indent_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::insert_hyphens"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::insert_hyphens_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::invisible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::invisible_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::justification"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::justification_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::language"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::language_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::left_margin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::left_margin_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::letter_spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::letter_spacing_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::line_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::line_height_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::overline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::overline_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::overline_rgba_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::overline_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::paragraph_background"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::paragraph_background_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::paragraph_background_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels_above_lines"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels_above_lines_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels_below_lines"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels_below_lines_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels_inside_wrap"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels_inside_wrap_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::right_margin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::right_margin_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rise"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rise_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scale"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scale_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sentence"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sentence_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_spaces"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_spaces_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size_points"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stretch"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stretch_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::strikethrough"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::strikethrough_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::strikethrough_rgba_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::strikethrough_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::style"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::style_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tabs"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tabs_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_transform"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::text_transform_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::underline"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::underline_rgba"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::underline_rgba_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::underline_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::variant"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::variant_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::weight"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::weight_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::word"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::word_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap_mode_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TextTagClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TextTagPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TextTagTable(GObject.Object):
    """
    Collects the tags in a `GtkTextBuffer`.

    You may wish to begin by reading the
    [text widget conceptual overview](section-text-widget.html),
    which gives an overview of all the objects and data types
    related to the text widget and how they work together.

    # GtkTextTagTables as GtkBuildable

    The `GtkTextTagTable` implementation of the `GtkBuildable` interface
    supports adding tags by specifying “tag” as the “type” attribute
    of a `<child>` element.

    An example of a UI definition fragment specifying tags:
    ```xml
    <object class="GtkTextTagTable">
     <child type="tag">
       <object class="GtkTextTag"/>
     </child>
    </object>
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add(self, tag: TextTag) -> bool: ...
    def foreach(self, func: TextTagTableForeach, data: object | None = None) -> None: ...
    def get_size(self) -> int: ...
    def lookup(self, name: str) -> TextTag | None: ...
    @classmethod
    def new(cls) -> TextTagTable: ...
    def remove(self, tag: TextTag) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["tag-added"],
        handler: typing.Callable[[typing_extensions.Self, TextTag], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["tag-changed"],
        handler: typing.Callable[[typing_extensions.Self, TextTag, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["tag-removed"],
        handler: typing.Callable[[typing_extensions.Self, TextTag], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TextView(Widget):
    """
    Displays the contents of a [class@Gtk.TextBuffer].

    <picture>
      <source srcset="multiline-text-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkTextView" src="multiline-text.png">
    </picture>

    You may wish to begin by reading the [conceptual overview](section-text-widget.html),
    which gives an overview of all the objects and data types related to the
    text widget and how they work together.

    ## Shortcuts and Gestures

    `GtkTextView` supports the following keyboard shortcuts:

    - <kbd>Shift</kbd>+<kbd>F10</kbd> or <kbd>Menu</kbd> opens the context menu.
    - <kbd>Ctrl</kbd>+<kbd>Z</kbd> undoes the last modification.
    - <kbd>Ctrl</kbd>+<kbd>Y</kbd> or <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Z</kbd>
      redoes the last undone modification.

    Additionally, the following signals have default keybindings:

    - [signal@Gtk.TextView::backspace]
    - [signal@Gtk.TextView::copy-clipboard]
    - [signal@Gtk.TextView::cut-clipboard]
    - [signal@Gtk.TextView::delete-from-cursor]
    - [signal@Gtk.TextView::insert-emoji]
    - [signal@Gtk.TextView::move-cursor]
    - [signal@Gtk.TextView::paste-clipboard]
    - [signal@Gtk.TextView::select-all]
    - [signal@Gtk.TextView::toggle-cursor-visible]
    - [signal@Gtk.TextView::toggle-overwrite]

    ## Actions

    `GtkTextView` defines a set of built-in actions:

    - `clipboard.copy` copies the contents to the clipboard.
    - `clipboard.cut` copies the contents to the clipboard and deletes it from
      the widget.
    - `clipboard.paste` inserts the contents of the clipboard into the widget.
    - `menu.popup` opens the context menu.
    - `misc.insert-emoji` opens the Emoji chooser.
    - `selection.delete` deletes the current selection.
    - `selection.select-all` selects all of the widgets content.
    - `text.redo` redoes the last change to the contents.
    - `text.undo` undoes the last change to the contents.

    ## CSS nodes

    ```
    textview.view
    ├── border.top
    ├── border.left
    ├── text
    │   ╰── [selection]
    ├── border.right
    ├── border.bottom
    ╰── [window.popup]
    ```

    `GtkTextView` has a main css node with name textview and style class .view,
    and subnodes for each of the border windows, and the main text area,
    with names border and text, respectively. The border nodes each get
    one of the style classes .left, .right, .top or .bottom.

    A node representing the selection will appear below the text node.

    If a context menu is opened, the window node will appear as a subnode
    of the main node.

    ## Accessibility

    `GtkTextView` uses the [enum@Gtk.AccessibleRole.text_box] role.
    """

    class Props(Widget.Props):
        accepts_tab: bool  # [accepts-tab]: changed because contained invalid characters
        bottom_margin: int  # [bottom-margin]: changed because contained invalid characters
        buffer: TextBuffer | None
        cursor_visible: bool  # [cursor-visible]: changed because contained invalid characters
        editable: bool
        extra_menu: Gio.MenuModel | None  # [extra-menu]: changed because contained invalid characters
        im_module: str  # [im-module]: changed because contained invalid characters
        indent: int
        input_hints: InputHints  # [input-hints]: changed because contained invalid characters
        input_purpose: InputPurpose  # [input-purpose]: changed because contained invalid characters
        justification: Justification
        left_margin: int  # [left-margin]: changed because contained invalid characters
        monospace: bool
        overwrite: bool
        pixels_above_lines: int  # [pixels-above-lines]: changed because contained invalid characters
        pixels_below_lines: int  # [pixels-below-lines]: changed because contained invalid characters
        pixels_inside_wrap: int  # [pixels-inside-wrap]: changed because contained invalid characters
        right_margin: int  # [right-margin]: changed because contained invalid characters
        tabs: Pango.TabArray | None
        top_margin: int  # [top-margin]: changed because contained invalid characters
        wrap_mode: WrapMode  # [wrap-mode]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        accepts_tab: bool = ...,
        bottom_margin: int = ...,
        buffer: TextBuffer | None = ...,
        cursor_visible: bool = ...,
        editable: bool = ...,
        extra_menu: Gio.MenuModel | None = ...,
        im_module: str = ...,
        indent: int = ...,
        input_hints: InputHints = ...,
        input_purpose: InputPurpose = ...,
        justification: Justification = ...,
        left_margin: int = ...,
        monospace: bool = ...,
        overwrite: bool = ...,
        pixels_above_lines: int = ...,
        pixels_below_lines: int = ...,
        pixels_inside_wrap: int = ...,
        right_margin: int = ...,
        tabs: Pango.TabArray | None = ...,
        top_margin: int = ...,
        wrap_mode: WrapMode = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_child_at_anchor(self, child: Widget, anchor: TextChildAnchor) -> None: ...
    def add_overlay(self, child: Widget, xpos: int, ypos: int) -> None: ...
    def backward_display_line(self, iter: TextIter) -> bool: ...
    def backward_display_line_start(self, iter: TextIter) -> bool: ...
    def buffer_to_window_coords(
        self, win: TextWindowType, buffer_x: int, buffer_y: int
    ) -> tuple[int | None, int | None]: ...
    def forward_display_line(self, iter: TextIter) -> bool: ...
    def forward_display_line_end(self, iter: TextIter) -> bool: ...
    @builtins.property
    def get_accepts_tab(self) -> bool: ...
    @builtins.property
    def get_bottom_margin(self) -> int: ...
    @builtins.property
    def get_buffer(self) -> TextBuffer: ...
    def get_cursor_locations(
        self, iter: TextIter | None = None
    ) -> tuple[Gdk.Rectangle | None, Gdk.Rectangle | None]: ...
    @builtins.property
    def get_cursor_visible(self) -> bool: ...
    @builtins.property
    def get_editable(self) -> bool: ...
    @builtins.property
    def get_extra_menu(self) -> Gio.MenuModel: ...
    def get_gutter(self, win: TextWindowType) -> Widget | None: ...
    @builtins.property
    def get_indent(self) -> int: ...
    @builtins.property
    def get_input_hints(self) -> InputHints: ...
    @builtins.property
    def get_input_purpose(self) -> InputPurpose: ...
    def get_iter_at_location(self, x: int, y: int) -> tuple[bool, TextIter]: ...
    def get_iter_at_position(self, x: int, y: int) -> tuple[bool, TextIter, int | None]: ...
    def get_iter_location(self, iter: TextIter) -> Gdk.Rectangle: ...
    @builtins.property
    def get_justification(self) -> Justification: ...
    @builtins.property
    def get_left_margin(self) -> int: ...
    def get_line_at_y(self, y: int) -> tuple[TextIter, int]: ...
    def get_line_yrange(self, iter: TextIter) -> tuple[int, int]: ...
    def get_ltr_context(self) -> Pango.Context: ...
    @builtins.property
    def get_monospace(self) -> bool: ...
    @builtins.property
    def get_overwrite(self) -> bool: ...
    @builtins.property
    def get_pixels_above_lines(self) -> int: ...
    @builtins.property
    def get_pixels_below_lines(self) -> int: ...
    @builtins.property
    def get_pixels_inside_wrap(self) -> int: ...
    @builtins.property
    def get_right_margin(self) -> int: ...
    def get_rtl_context(self) -> Pango.Context: ...
    @builtins.property
    def get_tabs(self) -> Pango.TabArray | None: ...
    @builtins.property
    def get_top_margin(self) -> int: ...
    def get_visible_offset(self) -> tuple[float | None, float | None]: ...
    def get_visible_rect(self) -> Gdk.Rectangle: ...
    @builtins.property
    def get_wrap_mode(self) -> WrapMode: ...
    def im_context_filter_keypress(self, event: Gdk.Event) -> bool: ...
    def move_mark_onscreen(self, mark: TextMark) -> bool: ...
    def move_overlay(self, child: Widget, xpos: int, ypos: int) -> None: ...
    def move_visually(self, iter: TextIter, count: int) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_with_buffer(cls, buffer: TextBuffer) -> Widget: ...
    def place_cursor_onscreen(self) -> bool: ...
    def remove(self, child: Widget) -> None: ...
    def reset_cursor_blink(self) -> None: ...
    def reset_im_context(self) -> None: ...
    def scroll_mark_onscreen(self, mark: TextMark) -> None: ...
    def scroll_to_iter(
        self, iter: TextIter, within_margin: float, use_align: bool, xalign: float, yalign: float
    ) -> bool: ...
    def scroll_to_mark(
        self, mark: TextMark, within_margin: float, use_align: bool, xalign: float, yalign: float
    ) -> None: ...
    def set_accepts_tab(self, accepts_tab: bool) -> None: ...
    def set_bottom_margin(self, bottom_margin: int) -> None: ...
    def set_buffer(self, buffer: TextBuffer | None = None) -> None: ...
    def set_cursor_visible(self, setting: bool) -> None: ...
    def set_editable(self, setting: bool) -> None: ...
    def set_extra_menu(self, model: Gio.MenuModel | None = None) -> None: ...
    def set_gutter(self, win: TextWindowType, widget: Widget | None = None) -> None: ...
    def set_indent(self, indent: int) -> None: ...
    def set_input_hints(self, hints: InputHints) -> None: ...
    def set_input_purpose(self, purpose: InputPurpose) -> None: ...
    def set_justification(self, justification: Justification) -> None: ...
    def set_left_margin(self, left_margin: int) -> None: ...
    def set_monospace(self, monospace: bool) -> None: ...
    def set_overwrite(self, overwrite: bool) -> None: ...
    def set_pixels_above_lines(self, pixels_above_lines: int) -> None: ...
    def set_pixels_below_lines(self, pixels_below_lines: int) -> None: ...
    def set_pixels_inside_wrap(self, pixels_inside_wrap: int) -> None: ...
    def set_right_margin(self, right_margin: int) -> None: ...
    def set_tabs(self, tabs: Pango.TabArray) -> None: ...
    def set_top_margin(self, top_margin: int) -> None: ...
    def set_wrap_mode(self, wrap_mode: WrapMode) -> None: ...
    def starts_display_line(self, iter: TextIter) -> bool: ...
    def window_to_buffer_coords(
        self, win: TextWindowType, window_x: int, window_y: int
    ) -> tuple[int | None, int | None]: ...

    # python methods (overrides?)
    def do_backspace(
        self,
    ) -> None:
        """
        backspace(self)
        """
    def do_copy_clipboard(
        self,
    ) -> None:
        """
        copy_clipboard(self)
        """
    def do_cut_clipboard(
        self,
    ) -> None:
        """
        cut_clipboard(self)
        """
    def do_delete_from_cursor(
        self,
        type: DeleteType,
        count: int,
    ) -> None:
        """
        delete_from_cursor(self, type:Gtk.DeleteType, count:int)
        """
    def do_extend_selection(
        self,
        granularity: TextExtendSelection,
        location: TextIter,
        start: TextIter,
        end: TextIter,
    ) -> bool:
        """
        extend_selection(self, granularity:Gtk.TextExtendSelection, location:Gtk.TextIter, start:Gtk.TextIter, end:Gtk.TextIter) -> bool
        """
    def do_insert_at_cursor(
        self,
        str: str,
    ) -> None:
        """
        insert_at_cursor(self, str:str)
        """
    def do_insert_emoji(
        self,
    ) -> None:
        """
        insert_emoji(self)
        """
    def do_move_cursor(
        self,
        step: MovementStep,
        count: int,
        extend_selection: bool,
    ) -> None:
        """
        move_cursor(self, step:Gtk.MovementStep, count:int, extend_selection:bool)
        """
    def do_paste_clipboard(
        self,
    ) -> None:
        """
        paste_clipboard(self)
        """
    def do_set_anchor(
        self,
    ) -> None:
        """
        set_anchor(self)
        """
    def do_snapshot_layer(
        self,
        layer: TextViewLayer,
        snapshot: Snapshot,
    ) -> None:
        """
        snapshot_layer(self, layer:Gtk.TextViewLayer, snapshot:Gtk.Snapshot)
        """
    def do_toggle_overwrite(
        self,
    ) -> None:
        """
        toggle_overwrite(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["backspace"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["copy-clipboard"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["cut-clipboard"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["delete-from-cursor"],
        handler: typing.Callable[[typing_extensions.Self, DeleteType, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["extend-selection"],
        handler: typing.Callable[[typing_extensions.Self, TextExtendSelection, TextIter, TextIter, TextIter], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["insert-at-cursor"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["insert-emoji"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-cursor"],
        handler: typing.Callable[[typing_extensions.Self, MovementStep, int, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-viewport"],
        handler: typing.Callable[[typing_extensions.Self, ScrollStep, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["paste-clipboard"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["preedit-changed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["select-all"],
        handler: typing.Callable[[typing_extensions.Self, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["set-anchor"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["toggle-cursor-visible"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["toggle-overwrite"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accepts_tab"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::bottom_margin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cursor_visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::editable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::extra_menu"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::im_module"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::indent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_hints"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_purpose"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::justification"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::left_margin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::monospace"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::overwrite"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels_above_lines"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels_below_lines"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels_inside_wrap"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::right_margin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tabs"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::top_margin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::wrap_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TextViewClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def backspace(self) -> backspaceTextViewClassCB: ...
    @builtins.property
    def copy_clipboard(self) -> copy_clipboardTextViewClassCB: ...
    @builtins.property
    def cut_clipboard(self) -> cut_clipboardTextViewClassCB: ...
    @builtins.property
    def delete_from_cursor(self) -> delete_from_cursorTextViewClassCB: ...
    @builtins.property
    def extend_selection(self) -> extend_selectionTextViewClassCB: ...
    @builtins.property
    def insert_at_cursor(self) -> insert_at_cursorTextViewClassCB: ...
    @builtins.property
    def insert_emoji(self) -> insert_emojiTextViewClassCB: ...
    @builtins.property
    def move_cursor(self) -> move_cursorTextViewClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...
    @builtins.property
    def paste_clipboard(self) -> paste_clipboardTextViewClassCB: ...
    @builtins.property
    def set_anchor(self) -> set_anchorTextViewClassCB: ...
    @builtins.property
    def snapshot_layer(self) -> snapshot_layerTextViewClassCB: ...
    @builtins.property
    def toggle_overwrite(self) -> toggle_overwriteTextViewClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TextViewPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ToggleButton(Button):
    """
    Shows a button which remains “pressed-in” when clicked.

    <picture>
      <source srcset="toggle-button-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="Example GtkToggleButtons" src="toggle-button.png">
    </picture>

    Clicking again will cause the toggle button to return to its normal state.

    A toggle button is created by calling either [ctor@Gtk.ToggleButton.new] or
    [ctor@Gtk.ToggleButton.new_with_label]. If using the former, it is advisable
    to pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
    button’s container. (See [class@Gtk.Button] for more information).

    The state of a `GtkToggleButton` can be set specifically using
    [method@Gtk.ToggleButton.set_active], and retrieved using
    [method@Gtk.ToggleButton.get_active].

    ## Grouping

    Toggle buttons can be grouped together, to form mutually exclusive
    groups - only one of the buttons can be toggled at a time, and toggling
    another one will switch the currently toggled one off.

    To add a `GtkToggleButton` to a group, use [method@Gtk.ToggleButton.set_group].

    ## CSS nodes

    `GtkToggleButton` has a single CSS node with name button. To differentiate
    it from a plain `GtkButton`, it gets the `.toggle` style class.

    ## Accessibility

    `GtkToggleButton` uses the [enum@Gtk.AccessibleRole.toggle_button] role.

    ## Creating two `GtkToggleButton` widgets.

    ```c
    static void
    output_state (GtkToggleButton *source,
                  gpointer         user_data)
    {
      g_print ("Toggle button "%s" is active: %s",
               gtk_button_get_label (GTK_BUTTON (source)),
               gtk_toggle_button_get_active (source) ? "Yes" : "No");
    }

    static void
    make_toggles (void)
    {
      GtkWidget *window, *toggle1, *toggle2;
      GtkWidget *box;
      const char *text;

      window = gtk_window_new ();
      box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);

      text = "Hi, I’m toggle button one";
      toggle1 = gtk_toggle_button_new_with_label (text);

      g_signal_connect (toggle1, "toggled",
                        G_CALLBACK (output_state),
                        NULL);
      gtk_box_append (GTK_BOX (box), toggle1);

      text = "Hi, I’m toggle button two";
      toggle2 = gtk_toggle_button_new_with_label (text);
      g_signal_connect (toggle2, "toggled",
                        G_CALLBACK (output_state),
                        NULL);
      gtk_box_append (GTK_BOX (box), toggle2);

      gtk_window_set_child (GTK_WINDOW (window), box);
      gtk_window_present (GTK_WINDOW (window));
    }
    ```
    """

    class Props(Button.Props):
        active: bool
        group: ToggleButton | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def button(self) -> Button | None: ...

    # gi Methods
    def __init__(self, active: bool = ..., group: ToggleButton | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_active(self) -> bool: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_with_label(cls, label: str) -> Widget: ...
    @classmethod
    def new_with_mnemonic(cls, label: str) -> Widget: ...
    def set_active(self, is_active: bool) -> None: ...
    def set_group(self, group: ToggleButton | None = None) -> None: ...
    @deprecated("deprecated")
    def toggled(self) -> None: ...

    # python methods (overrides?)
    def do_toggled(
        self,
    ) -> None:
        """
        toggled(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["toggled"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::group"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ToggleButtonClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> ButtonClass | None: ...
    @builtins.property
    def toggled(self) -> toggledToggleButtonClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Tooltip(GObject.Object):
    """
    Represents a widget tooltip.

    Basic tooltips can be realized simply by using
    [method@Gtk.Widget.set_tooltip_text] or
    [method@Gtk.Widget.set_tooltip_markup] without
    any explicit tooltip object.

    When you need a tooltip with a little more fancy contents,
    like adding an image, or you want the tooltip to have different
    contents per `GtkTreeView` row or cell, you will have to do a
    little more work:

    - Set the [property@Gtk.Widget:has-tooltip] property to %TRUE.
      This will make GTK monitor the widget for motion and related events
      which are needed to determine when and where to show a tooltip.

    - Connect to the [signal@Gtk.Widget::query-tooltip] signal.
      This signal will be emitted when a tooltip is supposed to be shown.
      One of the arguments passed to the signal handler is a `GtkTooltip`
      object. This is the object that we are about to display as a tooltip,
      and can be manipulated in your callback using functions like
      [method@Gtk.Tooltip.set_icon]. There are functions for setting
      the tooltip’s markup, setting an image from a named icon, or even
      putting in a custom widget.

    - Return %TRUE from your ::query-tooltip handler. This causes the tooltip
      to be show. If you return %FALSE, it will not be shown.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def set_custom(self, custom_widget: Widget | None = None) -> None: ...
    def set_icon(self, paintable: Gdk.Paintable | None = None) -> None: ...
    def set_icon_from_gicon(self, gicon: Gio.Icon | None = None) -> None: ...
    def set_icon_from_icon_name(self, icon_name: str | None = None) -> None: ...
    def set_markup(self, markup: str | None = None) -> None: ...
    def set_text(self, text: str | None = None) -> None: ...
    def set_tip_area(self, rect: Gdk.Rectangle) -> None: ...

class TreeDragDest(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def drag_data_received(self, dest: TreePath, value: GObject.Value) -> bool: ...
    @deprecated("deprecated")
    def row_drop_possible(self, dest_path: TreePath, value: GObject.Value) -> bool: ...

class TreeDragDestIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def drag_data_received(self) -> drag_data_receivedTreeDragDestIfaceCB: ...
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def row_drop_possible(self) -> row_drop_possibleTreeDragDestIfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeDragSource(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def drag_data_delete(self, path: TreePath) -> bool: ...
    @deprecated("deprecated")
    def drag_data_get(self, path: TreePath) -> Gdk.ContentProvider | None: ...
    @deprecated("deprecated")
    def row_draggable(self, path: TreePath) -> bool: ...

class TreeDragSourceIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def drag_data_delete(self) -> drag_data_deleteTreeDragSourceIfaceCB: ...
    @builtins.property
    def drag_data_get(self) -> drag_data_getTreeDragSourceIfaceCB | None: ...
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def row_draggable(self) -> row_draggableTreeDragSourceIfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeExpander(Widget):
    """
    Provides an expander for a tree-like list.

    It is typically placed as a bottommost child into a `GtkListView`
    to allow users to expand and collapse children in a list with a
    [class@Gtk.TreeListModel]. `GtkTreeExpander` provides the common UI
    elements, gestures and keybindings for this purpose.

    On top of this, the "listitem.expand", "listitem.collapse" and
    "listitem.toggle-expand" actions are provided to allow adding custom
    UI for managing expanded state.

    It is important to mention that you want to set the
    [property@Gtk.ListItem:focusable] property to FALSE when using this
    widget, as you want the keyboard focus to be in the treexpander, and not
    inside the list to make use of the keybindings.

    The `GtkTreeListModel` must be set to not be passthrough. Then it
    will provide [class@Gtk.TreeListRow] items which can be set via
    [method@Gtk.TreeExpander.set_list_row] on the expander.
    The expander will then watch that row item automatically.
    [method@Gtk.TreeExpander.set_child] sets the widget that displays
    the actual row contents.

    `GtkTreeExpander` can be modified with properties such as
    [property@Gtk.TreeExpander:indent-for-icon],
    [property@Gtk.TreeExpander:indent-for-depth], and
    [property@Gtk.TreeExpander:hide-expander] to achieve a different appearance.
    This can even be done to influence individual rows, for example by binding
    the [property@Gtk.TreeExpander:hide-expander] property to the item count of
    the model of the treelistrow, to hide the expander for rows without children,
    even if the row is expandable.

    ## Shortcuts and Gestures

    `GtkTreeExpander` supports the following keyboard shortcuts:

    - <kbd>+</kbd> or <kbd>*</kbd> expands the expander.
    - <kbd>-</kbd> or <kbd>/</kbd> collapses the expander.
    - Left and right arrow keys, when combined with <kbd>Shift</kbd> or
      <kbd>Ctrl</kbd>+<kbd>Shift</kbd>, will expand or collapse, depending on
      the locale's text direction.
    - <kbd>Ctrl</kbd>+<kbd>␣</kbd> toggles the expander state.

    The row can also expand on drag gestures.

    ## Actions

    `GtkTreeExpander` defines a set of built-in actions:

    - `listitem.expand` expands the expander if it can be expanded.
    - `listitem.collapse` collapses the expander.
    - `listitem.toggle-expand` tries to expand the expander if it was collapsed
      or collapses it if it was expanded.

    ## CSS nodes

    ```
    treeexpander
    ├── [indent]*
    ├── [expander]
    ╰── <child>
    ```

    `GtkTreeExpander` has zero or one CSS nodes with the name "expander" that
    should display the expander icon. The node will be `:checked` when it
    is expanded. If the node is not expandable, an "indent" node will be
    displayed instead.

    For every level of depth, another "indent" node is prepended.

    ## Accessibility

    Until GTK 4.10, `GtkTreeExpander` used the [enum@Gtk.AccessibleRole.group] role.

    Since GTK 4.12, `GtkTreeExpander` uses the [enum@Gtk.AccessibleRole.button] role.
    Toggling it will change the `GTK_ACCESSIBLE_STATE_EXPANDED` state.
    """

    class Props(Widget.Props):
        child: Widget | None
        hide_expander: bool  # [hide-expander]: changed because contained invalid characters
        indent_for_depth: bool  # [indent-for-depth]: changed because contained invalid characters
        indent_for_icon: bool  # [indent-for-icon]: changed because contained invalid characters
        item: GObject.Object | None
        list_row: TreeListRow | None  # [list-row]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        child: Widget | None = ...,
        hide_expander: bool = ...,
        indent_for_depth: bool = ...,
        indent_for_icon: bool = ...,
        list_row: TreeListRow | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_hide_expander(self) -> bool: ...
    @builtins.property
    def get_indent_for_depth(self) -> bool: ...
    @builtins.property
    def get_indent_for_icon(self) -> bool: ...
    @builtins.property
    def get_item(self) -> GObject.Object | None: ...
    @builtins.property
    def get_list_row(self) -> TreeListRow | None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_hide_expander(self, hide_expander: bool) -> None: ...
    def set_indent_for_depth(self, indent_for_depth: bool) -> None: ...
    def set_indent_for_icon(self, indent_for_icon: bool) -> None: ...
    def set_list_row(self, list_row: TreeListRow | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hide_expander"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::indent_for_depth"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::indent_for_icon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::list_row"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeExpanderClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeIter(GObject.GBoxed):
    # gi Fields
    stamp: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def copy(self) -> TreeIter: ...
    @deprecated("deprecated")
    def free(self) -> None: ...

class TreeListModel(GObject.Object):
    """
    A list model that can create child models on demand.
    """

    class Props(GObject.Object.Props):
        autoexpand: bool
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        model: Gio.ListModel | None
        n_items: int  # [n-items]: changed because contained invalid characters
        passthrough: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, autoexpand: bool = ..., passthrough: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_autoexpand(self) -> bool: ...
    def get_child_row(self, position: int) -> TreeListRow | None: ...
    @builtins.property
    def get_model(self) -> Gio.ListModel: ...
    @builtins.property
    def get_passthrough(self) -> bool: ...
    def get_row(self, position: int) -> TreeListRow | None: ...
    @classmethod
    def new(
        cls,
        root: Gio.ListModel,
        passthrough: bool,
        autoexpand: bool,
        create_func: TreeListModelCreateModelFunc,
        user_data: object | None,
        user_destroy: GLib.DestroyNotify,
    ) -> TreeListModel: ...
    def set_autoexpand(self, autoexpand: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::autoexpand"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::passthrough"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeListModelClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeListRow(GObject.Object):
    """
    The type of item used by `GtkTreeListModel`.

    It allows navigating the model as a tree and modify the state of rows.

    `GtkTreeListRow` instances are created by a `GtkTreeListModel` only
    when the [property@Gtk.TreeListModel:passthrough] property is not set.

    There are various support objects that can make use of `GtkTreeListRow`
    objects, such as the [class@Gtk.TreeExpander] widget that allows displaying
    an icon to expand or collapse a row or [class@Gtk.TreeListRowSorter] that
    makes it possible to sort trees properly.
    """

    class Props(GObject.Object.Props):
        children: Gio.ListModel | None
        depth: int
        expandable: bool
        expanded: bool
        item: GObject.Object | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, expanded: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_child_row(self, position: int) -> TreeListRow | None: ...
    @builtins.property
    def get_children(self) -> Gio.ListModel | None: ...
    @builtins.property
    def get_depth(self) -> int: ...
    @builtins.property
    def get_expanded(self) -> bool: ...
    @builtins.property
    def get_item(self) -> GObject.Object | None: ...
    def get_parent(self) -> TreeListRow | None: ...
    def get_position(self) -> int: ...
    @builtins.property
    def is_expandable(self) -> bool: ...
    def set_expanded(self, expanded: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::children"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::depth"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expandable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expanded"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeListRowClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeListRowSorter(Sorter):
    """
    Applies a gives sorter to the levels in a tree.

    Here is an example for setting up a column view with a tree model and
    a `GtkTreeListSorter`:

    ```c
    column_sorter = gtk_column_view_get_sorter (view);
    sorter = gtk_tree_list_row_sorter_new (g_object_ref (column_sorter));
    sort_model = gtk_sort_list_model_new (tree_model, sorter);
    selection = gtk_single_selection_new (sort_model);
    gtk_column_view_set_model (view, G_LIST_MODEL (selection));
    ```
    """

    class Props(Sorter.Props):
        sorter: Sorter | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, sorter: Sorter | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_sorter(self) -> Sorter | None: ...
    @classmethod
    def new(cls, sorter: Sorter | None = None) -> TreeListRowSorter: ...
    def set_sorter(self, sorter: Sorter | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sorter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeListRowSorterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SorterClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeModel(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def filter_new(self, root: TreePath | None = None) -> TreeModel: ...
    @deprecated("deprecated")
    def foreach(self, func: TreeModelForeachFunc, user_data: object | None = None) -> None: ...
    @deprecated("deprecated")
    def get_column_type(self, index_: int) -> GObject.GType: ...
    @deprecated("deprecated")
    def get_flags(self) -> TreeModelFlags: ...
    @deprecated("deprecated")
    def get_iter(self, path: TreePath) -> tuple[bool, TreeIter]: ...
    @deprecated("deprecated")
    def get_iter_first(self) -> tuple[bool, TreeIter]: ...
    @deprecated("deprecated")
    def get_iter_from_string(self, path_string: str) -> tuple[bool, TreeIter]: ...
    @deprecated("deprecated")
    def get_n_columns(self) -> int: ...
    @deprecated("deprecated")
    def get_path(self, iter: TreeIter) -> TreePath: ...
    @deprecated("deprecated")
    def get_string_from_iter(self, iter: TreeIter) -> str | None: ...
    @deprecated("deprecated")
    def get_value(self, iter: TreeIter, column: int) -> GObject.Value: ...
    @deprecated("deprecated")
    def iter_children(self, parent: TreeIter | None = None) -> tuple[bool, TreeIter]: ...
    @deprecated("deprecated")
    def iter_has_child(self, iter: TreeIter) -> bool: ...
    @deprecated("deprecated")
    def iter_n_children(self, iter: TreeIter | None = None) -> int: ...
    @deprecated("deprecated")
    def iter_next(self, iter: TreeIter) -> bool: ...
    @deprecated("deprecated")
    def iter_nth_child(self, parent: TreeIter | None, n: int) -> tuple[bool, TreeIter]: ...
    @deprecated("deprecated")
    def iter_parent(self, child: TreeIter) -> tuple[bool, TreeIter]: ...
    @deprecated("deprecated")
    def iter_previous(self, iter: TreeIter) -> bool: ...
    @deprecated("deprecated")
    def ref_node(self, iter: TreeIter) -> None: ...
    @deprecated("deprecated")
    def row_changed(self, path: TreePath, iter: TreeIter) -> None: ...
    @deprecated("deprecated")
    def row_deleted(self, path: TreePath) -> None: ...
    @deprecated("deprecated")
    def row_has_child_toggled(self, path: TreePath, iter: TreeIter) -> None: ...
    @deprecated("deprecated")
    def row_inserted(self, path: TreePath, iter: TreeIter) -> None: ...
    @deprecated("deprecated")
    def rows_reordered(self, path: TreePath, iter: TreeIter | None, new_order: list, length: int) -> None: ...
    @deprecated("deprecated")
    def unref_node(self, iter: TreeIter) -> None: ...

    # python methods (overrides?)
    def get(
        self,
        treeiter: typing.Any,
        *columns: typing.Any,
    ) -> typing.Any: ...
    def set_row(
        self,
        treeiter: typing.Any,
        row: typing.Any,
    ) -> typing.Any: ...
    def sort_new_with_model(
        self,
    ) -> typing.Any: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["row-changed"],
        handler: typing.Callable[[typing_extensions.Self, TreePath, TreeIter], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["row-deleted"],
        handler: typing.Callable[[typing_extensions.Self, TreePath], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["row-has-child-toggled"],
        handler: typing.Callable[[typing_extensions.Self, TreePath, TreeIter], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["row-inserted"],
        handler: typing.Callable[[typing_extensions.Self, TreePath, TreeIter], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeModelFilter(GObject.Object):
    """
    A `GtkTreeModel` which hides parts of an underlying tree model

    A `GtkTreeModelFilter` is a tree model which wraps another tree model,
    and can do the following things:

    - Filter specific rows, based on data from a “visible column”, a column
      storing booleans indicating whether the row should be filtered or not,
      or based on the return value of a “visible function”, which gets a
      model, iter and user_data and returns a boolean indicating whether the
      row should be filtered or not.

    - Modify the “appearance” of the model, using a modify function.
      This is extremely powerful and allows for just changing some
      values and also for creating a completely different model based
      on the given child model.

    - Set a different root node, also known as a “virtual root”. You can pass
      in a `GtkTreePath` indicating the root node for the filter at construction
      time.

    The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
    see the section on `GtkTreeModelSort`.

    When using `GtkTreeModelFilter`, it is important to realize that
    `GtkTreeModelFilter` maintains an internal cache of all nodes which are
    visible in its clients. The cache is likely to be a subtree of the tree
    exposed by the child model. `GtkTreeModelFilter` will not cache the entire
    child model when unnecessary to not compromise the caching mechanism
    that is exposed by the reference counting scheme. If the child model
    implements reference counting, unnecessary signals may not be emitted
    because of reference counting rule 3, see the `GtkTreeModel`
    documentation. (Note that e.g. `GtkTreeStore` does not implement
    reference counting and will always emit all signals, even when
    the receiving node is not visible).

    Because of this, limitations for possible visible functions do apply.
    In general, visible functions should only use data or properties from
    the node for which the visibility state must be determined, its siblings
    or its parents. Usually, having a dependency on the state of any child
    node is not possible, unless references are taken on these explicitly.
    When no such reference exists, no signals may be received for these child
    nodes (see reference counting rule number 3 in the `GtkTreeModel` section).

    Determining the visibility state of a given node based on the state
    of its child nodes is a frequently occurring use case. Therefore,
    `GtkTreeModelFilter` explicitly supports this. For example, when a node
    does not have any children, you might not want the node to be visible.
    As soon as the first row is added to the node’s child level (or the
    last row removed), the node’s visibility should be updated.

    This introduces a dependency from the node on its child nodes. In order
    to accommodate this, `GtkTreeModelFilter` must make sure the necessary
    signals are received from the child model. This is achieved by building,
    for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
    clients, the child level (if any) and take a reference on the first node
    in this level. Furthermore, for every row-inserted, row-changed or
    row-deleted signal (also these which were not handled because the node
    was not cached), `GtkTreeModelFilter` will check if the visibility state
    of any parent node has changed.

    Beware, however, that this explicit support is limited to these two
    cases. For example, if you want a node to be visible only if two nodes
    in a child’s child level (2 levels deeper) are visible, you are on your
    own. In this case, either rely on `GtkTreeStore` to emit all signals
    because it does not implement reference counting, or for models that
    do implement reference counting, obtain references on these child levels
    yourself.
    """

    class Props(GObject.Object.Props):
        child_model: TreeModel | None  # [child-model]: changed because contained invalid characters
        virtual_root: TreePath | None  # [virtual-root]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, child_model: TreeModel | None = ..., virtual_root: TreePath | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def clear_cache(self) -> None: ...
    @deprecated("deprecated")
    def convert_child_iter_to_iter(self, child_iter: TreeIter) -> tuple[bool, TreeIter]: ...
    @deprecated("deprecated")
    def convert_child_path_to_path(self, child_path: TreePath) -> TreePath | None: ...
    @deprecated("deprecated")
    def convert_iter_to_child_iter(self, filter_iter: TreeIter) -> TreeIter: ...
    @deprecated("deprecated")
    def convert_path_to_child_path(self, filter_path: TreePath) -> TreePath | None: ...
    @deprecated("deprecated")
    def get_model(self) -> TreeModel: ...
    @deprecated("deprecated")
    def refilter(self) -> None: ...
    @deprecated("deprecated")
    def set_modify_func(
        self,
        n_columns: int,
        types: list,
        func: TreeModelFilterModifyFunc,
        data: object | None = None,
        destroy: GLib.DestroyNotify | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def set_visible_column(self, column: int) -> None: ...
    @deprecated("deprecated")
    def set_visible_func(
        self, func: TreeModelFilterVisibleFunc, data: object | None = None, destroy: GLib.DestroyNotify | None = None
    ) -> None: ...

    # python methods (overrides?)
    def set_value(
        self,
        iter: typing.Any,
        column: typing.Any,
        value: typing.Any,
    ) -> typing.Any: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child_model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::virtual_root"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeModelFilterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def modify(self) -> modifyTreeModelFilterClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def visible(self) -> visibleTreeModelFilterClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeModelFilterPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeModelIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_column_type(self) -> get_column_typeTreeModelIfaceCB: ...
    @builtins.property
    def get_flags(self) -> get_flagsTreeModelIfaceCB: ...
    @builtins.property
    def get_iter(self) -> get_iterTreeModelIfaceCB: ...
    @builtins.property
    def get_n_columns(self) -> get_n_columnsTreeModelIfaceCB: ...
    @builtins.property
    def get_path(self) -> get_pathTreeModelIfaceCB: ...
    @builtins.property
    def get_value(self) -> get_valueTreeModelIfaceCB: ...
    @builtins.property
    def iter_children(self) -> iter_childrenTreeModelIfaceCB: ...
    @builtins.property
    def iter_has_child(self) -> iter_has_childTreeModelIfaceCB: ...
    @builtins.property
    def iter_n_children(self) -> iter_n_childrenTreeModelIfaceCB: ...
    @builtins.property
    def iter_next(self) -> iter_nextTreeModelIfaceCB: ...
    @builtins.property
    def iter_nth_child(self) -> iter_nth_childTreeModelIfaceCB: ...
    @builtins.property
    def iter_parent(self) -> iter_parentTreeModelIfaceCB: ...
    @builtins.property
    def iter_previous(self) -> iter_previousTreeModelIfaceCB: ...
    @builtins.property
    def ref_node(self) -> ref_nodeTreeModelIfaceCB: ...
    @builtins.property
    def row_changed(self) -> row_changedTreeModelIfaceCB: ...
    @builtins.property
    def row_deleted(self) -> row_deletedTreeModelIfaceCB: ...
    @builtins.property
    def row_has_child_toggled(self) -> row_has_child_toggledTreeModelIfaceCB: ...
    @builtins.property
    def row_inserted(self) -> row_insertedTreeModelIfaceCB: ...
    @builtins.property
    def rows_reordered(self) -> rows_reorderedTreeModelIfaceCB: ...
    @builtins.property
    def unref_node(self) -> unref_nodeTreeModelIfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeModelRow(object):
    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # python methods (overrides?)
    def __init__(
        self,
        model: typing.Any,
        iter_or_path: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    def get_next(
        self,
    ) -> typing.Any: ...
    def get_parent(
        self,
    ) -> typing.Any: ...
    def get_previous(
        self,
    ) -> typing.Any: ...
    def iterchildren(
        self,
    ) -> typing.Any: ...

class TreeModelRowIter(object):
    class Props: ...

    @builtins.property
    def props(self) -> Props: ...

    # python methods (overrides?)
    def __init__(
        self,
        model: typing.Any,
        aiter: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class TreeModelSort(GObject.Object):
    """
    A GtkTreeModel which makes an underlying tree model sortable

    The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
    interface.  It does not hold any data itself, but rather is created with
    a child model and proxies its data.  It has identical column types to
    this child model, and the changes in the child are propagated.  The
    primary purpose of this model is to provide a way to sort a different
    model without modifying it. Note that the sort function used by
    `GtkTreeModelSort` is not guaranteed to be stable.

    The use of this is best demonstrated through an example.  In the
    following sample code we create two `GtkTreeView` widgets each with a
    view of the same data.  As the model is wrapped here by a
    `GtkTreeModelSort`, the two `GtkTreeView`s can each sort their
    view of the data without affecting the other.  By contrast, if we
    simply put the same model in each widget, then sorting the first would
    sort the second.

    ## Using a `GtkTreeModelSort`

    ```c
    {
      GtkTreeView *tree_view1;
      GtkTreeView *tree_view2;
      GtkTreeModel *sort_model1;
      GtkTreeModel *sort_model2;
      GtkTreeModel *child_model;

      // get the child model
      child_model = get_my_model ();

      // Create the first tree
      sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
      tree_view1 = gtk_tree_view_new_with_model (sort_model1);

      // Create the second tree
      sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
      tree_view2 = gtk_tree_view_new_with_model (sort_model2);

      // Now we can sort the two models independently
      gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
                                            COLUMN_1, GTK_SORT_ASCENDING);
      gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
                                            COLUMN_1, GTK_SORT_DESCENDING);
    }
    ```

    To demonstrate how to access the underlying child model from the sort
    model, the next example will be a callback for the `GtkTreeSelection`
    `GtkTreeSelection::changed` signal.  In this callback, we get a string
    from COLUMN_1 of the model.  We then modify the string, find the same
    selected row on the child model, and change the row there.

    ## Accessing the child model of in a selection changed callback

    ```c
    void
    selection_changed (GtkTreeSelection *selection, gpointer data)
    {
      GtkTreeModel *sort_model = NULL;
      GtkTreeModel *child_model;
      GtkTreeIter sort_iter;
      GtkTreeIter child_iter;
      char *some_data = NULL;
      char *modified_data;

      // Get the current selected row and the model.
      if (! gtk_tree_selection_get_selected (selection,
                                             &sort_model,
                                             &sort_iter))
        return;

      // Look up the current value on the selected row and get
      // a new value to change it to.
      gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
                          COLUMN_1, &some_data,
                          -1);

      modified_data = change_the_data (some_data);
      g_free (some_data);

      // Get an iterator on the child model, instead of the sort model.
      gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
                                                      &child_iter,
                                                      &sort_iter);

      // Get the child model and change the value of the row. In this
      // example, the child model is a GtkListStore. It could be any other
      // type of model, though.
      child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
      gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
                          COLUMN_1, &modified_data,
                          -1);
      g_free (modified_data);
    }
    ```
    """

    class Props(GObject.Object.Props):
        model: TreeModel | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, model: TreeModel | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def clear_cache(self) -> None: ...
    @deprecated("deprecated")
    def convert_child_iter_to_iter(self, child_iter: TreeIter) -> tuple[bool, TreeIter]: ...
    @deprecated("deprecated")
    def convert_child_path_to_path(self, child_path: TreePath) -> TreePath | None: ...
    @deprecated("deprecated")
    def convert_iter_to_child_iter(self, sorted_iter: TreeIter) -> TreeIter: ...
    @deprecated("deprecated")
    def convert_path_to_child_path(self, sorted_path: TreePath) -> TreePath | None: ...
    @builtins.property
    def get_model(self) -> TreeModel: ...
    @deprecated("deprecated")
    def iter_is_valid(self, iter: TreeIter) -> bool: ...
    @classmethod
    def new_with_model(cls, child_model: TreeModel) -> TreeModelSort: ...
    @deprecated("deprecated")
    def reset_default_sort_func(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeModelSortClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeModelSortPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreePath(GObject.GBoxed):
    # gi Methods
    @deprecated("deprecated")
    def append_index(self, index_: int) -> None: ...
    @deprecated("deprecated")
    def compare(self, b: TreePath) -> int: ...
    @deprecated("deprecated")
    def copy(self) -> TreePath: ...
    @deprecated("deprecated")
    def down(self) -> None: ...
    @deprecated("deprecated")
    def free(self) -> None: ...
    @deprecated("deprecated")
    def get_depth(self) -> int: ...
    @deprecated("deprecated")
    def get_indices(self) -> tuple[list | None, int | None]: ...
    @deprecated("deprecated")
    def is_ancestor(self, descendant: TreePath) -> bool: ...
    @deprecated("deprecated")
    def is_descendant(self, ancestor: TreePath) -> bool: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> TreePath: ...
    @deprecated("deprecated")
    @classmethod
    def new_first(cls) -> TreePath: ...
    @deprecated("deprecated")
    @classmethod
    def new_from_indices(cls, indices: list, length: int) -> TreePath: ...
    @deprecated("deprecated")
    @classmethod
    def new_from_string(cls, path: str) -> TreePath | None: ...
    @deprecated("deprecated")
    def next(self) -> None: ...
    @deprecated("deprecated")
    def prepend_index(self, index_: int) -> None: ...
    @deprecated("deprecated")
    def prev(self) -> bool: ...
    @deprecated("deprecated")
    def to_string(self) -> str | None: ...
    @deprecated("deprecated")
    def up(self) -> bool: ...

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class TreeRowData(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeRowReference(GObject.GBoxed):
    # gi Methods
    @deprecated("deprecated")
    def copy(self) -> TreeRowReference: ...
    @deprecated("deprecated")
    @staticmethod
    def deleted(proxy: GObject.Object, path: TreePath) -> None: ...
    @deprecated("deprecated")
    def free(self) -> None: ...
    @deprecated("deprecated")
    def get_model(self) -> TreeModel: ...
    @deprecated("deprecated")
    def get_path(self) -> TreePath | None: ...
    @deprecated("deprecated")
    @staticmethod
    def inserted(proxy: GObject.Object, path: TreePath) -> None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls, model: TreeModel, path: TreePath) -> TreeRowReference | None: ...
    @deprecated("deprecated")
    @classmethod
    def new_proxy(cls, proxy: GObject.Object, model: TreeModel, path: TreePath) -> TreeRowReference | None: ...
    @deprecated("deprecated")
    def valid(self) -> bool: ...

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class TreeSelection(GObject.Object):
    """
    The selection object for GtkTreeView

    The `GtkTreeSelection` object is a helper object to manage the selection
    for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
    automatically created when a new `GtkTreeView` widget is created, and
    cannot exist independently of this widget.  The primary reason the
    `GtkTreeSelection` objects exists is for cleanliness of code and API.
    That is, there is no conceptual reason all these functions could not be
    methods on the `GtkTreeView` widget instead of a separate function.

    The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
    gtk_tree_view_get_selection().  It can be manipulated to check the
    selection status of the tree, as well as select and deselect individual
    rows.  Selection is done completely view side.  As a result, multiple
    views of the same model can have completely different selections.
    Additionally, you cannot change the selection of a row on the model that
    is not currently displayed by the view without expanding its parents
    first.

    One of the important things to remember when monitoring the selection of
    a view is that the `GtkTreeSelection`::changed signal is mostly a hint.
    That is, it may only emit one signal when a range of rows is selected.
    Additionally, it may on occasion emit a `GtkTreeSelection`::changed signal
    when nothing has happened (mostly as a result of programmers calling
    select_row on an already selected row).
    """

    class Props(GObject.Object.Props):
        mode: SelectionMode

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, mode: SelectionMode = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def count_selected_rows(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_mode(self) -> SelectionMode: ...
    @deprecated("deprecated")
    def get_selected(self) -> tuple[bool, TreeModel | None, TreeIter | None]: ...
    @deprecated("deprecated")
    def get_selected_rows(self) -> tuple[list, TreeModel | None]: ...
    @deprecated("deprecated")
    def get_tree_view(self) -> TreeView: ...
    @deprecated("deprecated")
    def iter_is_selected(self, iter: TreeIter) -> bool: ...
    @deprecated("deprecated")
    def path_is_selected(self, path: TreePath) -> bool: ...
    @deprecated("deprecated")
    def select_all(self) -> None: ...
    @deprecated("deprecated")
    def select_iter(self, iter: TreeIter) -> None: ...
    @deprecated("deprecated")
    def select_path(self, path: TreePath) -> None: ...
    @deprecated("deprecated")
    def select_range(self, start_path: TreePath, end_path: TreePath) -> None: ...
    @deprecated("deprecated")
    def selected_foreach(self, func: TreeSelectionForeachFunc, data: object | None = None) -> None: ...
    @deprecated("deprecated")
    def set_mode(self, type: SelectionMode) -> None: ...
    @deprecated("deprecated")
    def set_select_function(
        self, func: TreeSelectionFunc | None, data: object | None, destroy: GLib.DestroyNotify
    ) -> None: ...
    @deprecated("deprecated")
    def unselect_all(self) -> None: ...
    @deprecated("deprecated")
    def unselect_iter(self, iter: TreeIter) -> None: ...
    @deprecated("deprecated")
    def unselect_path(self, path: TreePath) -> None: ...
    @deprecated("deprecated")
    def unselect_range(self, start_path: TreePath, end_path: TreePath) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeSortable(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def get_sort_column_id(self) -> tuple[bool, int, SortType]: ...
    @deprecated("deprecated")
    def has_default_sort_func(self) -> bool: ...
    @deprecated("deprecated")
    def set_default_sort_func(
        self, sort_func: TreeIterCompareFunc, user_data: object | None = None, destroy: GLib.DestroyNotify | None = None
    ) -> None: ...
    @deprecated("deprecated")
    def set_sort_column_id(self, sort_column_id: int, order: SortType) -> None: ...
    @deprecated("deprecated")
    def set_sort_func(
        self,
        sort_column_id: int,
        sort_func: TreeIterCompareFunc,
        user_data: object | None = None,
        destroy: GLib.DestroyNotify | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def sort_column_changed(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["sort-column-changed"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeSortableIface(GObject.GPointer):
    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_sort_column_id(self) -> get_sort_column_idTreeSortableIfaceCB: ...
    @builtins.property
    def has_default_sort_func(self) -> has_default_sort_funcTreeSortableIfaceCB: ...
    @builtins.property
    def set_default_sort_func(self) -> set_default_sort_funcTreeSortableIfaceCB: ...
    @builtins.property
    def set_sort_column_id(self) -> set_sort_column_idTreeSortableIfaceCB: ...
    @builtins.property
    def set_sort_func(self) -> set_sort_funcTreeSortableIfaceCB: ...
    @builtins.property
    def sort_column_changed(self) -> sort_column_changedTreeSortableIfaceCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeStore(GObject.Object):
    """
    A tree-like data structure that can be used with the [class@Gtk.TreeView].

    The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
    widget. It implements the [iface@Gtk.TreeModel] interface, and consequently,
    can use all of the methods available there. It also implements the
    [iface@Gtk.TreeSortable] interface so it can be sorted by the view.
    Finally, it also implements the tree [drag][iface@Gtk.TreeDragSource]
    and [drop][iface@Gtk.TreeDragDest] interfaces.

    `GtkTreeStore` is deprecated since GTK 4.10, and should not be used in newly
    written code. You should use [class@Gtk.TreeListModel] for a tree-like model
    object.

    ## GtkTreeStore as GtkBuildable

    The GtkTreeStore implementation of the `GtkBuildable` interface allows
    to specify the model columns with a `<columns>` element that may contain
    multiple `<column>` elements, each specifying one model column. The “type”
    attribute specifies the data type for the column.

    An example of a UI Definition fragment for a tree store:

    ```xml
    <object class="GtkTreeStore">
      <columns>
        <column type="gchararray"/>
        <column type="gchararray"/>
        <column type="gint"/>
      </columns>
    </object>
    ```
    """

    # gi Methods
    @deprecated("deprecated")
    def append(self, parent: TreeIter | None = None) -> TreeIter: ...
    @deprecated("deprecated")
    def clear(self) -> None: ...
    @deprecated("deprecated")
    def insert(self, parent: TreeIter | None, position: int) -> TreeIter: ...
    @deprecated("deprecated")
    def insert_after(self, parent: TreeIter | None = None, sibling: TreeIter | None = None) -> TreeIter: ...
    @deprecated("deprecated")
    def insert_before(self, parent: TreeIter | None = None, sibling: TreeIter | None = None) -> TreeIter: ...
    @deprecated("deprecated")
    def insert_with_values(
        self, parent: TreeIter | None, position: int, columns: list, values: list, n_values: int
    ) -> TreeIter | None: ...
    @deprecated("deprecated")
    def is_ancestor(self, iter: TreeIter, descendant: TreeIter) -> bool: ...
    @deprecated("deprecated")
    def iter_depth(self, iter: TreeIter) -> int: ...
    @deprecated("deprecated")
    def iter_is_valid(self, iter: TreeIter) -> bool: ...
    @deprecated("deprecated")
    def move_after(self, iter: TreeIter, position: TreeIter | None = None) -> None: ...
    @deprecated("deprecated")
    def move_before(self, iter: TreeIter, position: TreeIter | None = None) -> None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls, n_columns: int, types: list) -> TreeStore: ...
    @deprecated("deprecated")
    def prepend(self, parent: TreeIter | None = None) -> TreeIter: ...
    @deprecated("deprecated")
    def remove(self, iter: TreeIter) -> bool: ...
    @deprecated("deprecated")
    def set(self, iter: TreeIter, columns: list, values: list, n_values: int) -> None: ...
    @deprecated("deprecated")
    def set_column_types(self, n_columns: int, types: list) -> None: ...
    @deprecated("deprecated")
    def set_value(self, iter: TreeIter, column: int, value: GObject.Value) -> None: ...
    @deprecated("deprecated")
    def swap(self, a: TreeIter, b: TreeIter) -> None: ...

    # python methods (overrides?)
    def __init__(
        self,
        *column_types: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

class TreeStoreClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeStorePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeView(Widget):
    """
    A widget for displaying both trees and lists

    <picture>
      <source srcset="list-and-tree-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkTreeView" src="list-and-tree.png">
    </picture>

    Widget that displays any object that implements the [iface@Gtk.TreeModel] interface.

    Please refer to the [tree widget conceptual overview](section-tree-widget.html)
    for an overview of all the objects and data types related to the tree
    widget and how they work together.

    ## Coordinate systems in GtkTreeView API

    Several different coordinate systems are exposed in the `GtkTreeView` API.
    These are:

    ![](tree-view-coordinates.png)

    - Widget coordinates: Coordinates relative to the widget (usually `widget->window`).

    - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.

    - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
      coordinates start at (0, 0) for row 0 of the tree.

    Several functions are available for converting between the different
    coordinate systems.  The most common translations are between widget and bin
    window coordinates and between bin window and tree coordinates. For the
    former you can use [method@Gtk.TreeView.convert_widget_to_bin_window_coords]
    (and vice versa), for the latter [method@Gtk.TreeView.convert_bin_window_to_tree_coords]
    (and vice versa).

    ## `GtkTreeView` as `GtkBuildable`

    The `GtkTreeView` implementation of the `GtkBuildable` interface accepts
    [class@Gtk.TreeViewColumn] objects as `<child>` elements and exposes the
    internal [class@Gtk.TreeSelection] in UI definitions.

    An example of a UI definition fragment with `GtkTreeView`:

    ```xml
    <object class="GtkTreeView" id="treeview">
      <property name="model">liststore1</property>
      <child>
        <object class="GtkTreeViewColumn" id="test-column">
          <property name="title">Test</property>
          <child>
            <object class="GtkCellRendererText" id="test-renderer"/>
            <attributes>
              <attribute name="text">1</attribute>
            </attributes>
          </child>
        </object>
      </child>
      <child internal-child="selection">
        <object class="GtkTreeSelection" id="selection">
          <signal name="changed" handler="on_treeview_selection_changed"/>
        </object>
      </child>
    </object>
    ```

    ## CSS nodes

    ```
    treeview.view
    ├── header
    │   ├── button
    │   │   ╰── [sort-indicator]
    ┊   ┊
    │   ╰── button
    │       ╰── [sort-indicator]
    │
    ├── [rubberband]
    ╰── [dndtarget]
    ```

    `GtkTreeView` has a main CSS node with name `treeview` and style class `.view`.
    It has a subnode with name `header`, which is the parent for all the column
    header widgets' CSS nodes.

    Each column header consists of a `button`, which among other content, has a
    child with name `sort-indicator`, which carries the `.ascending` or `.descending`
    style classes when the column header should show a sort indicator. The CSS
    is expected to provide a suitable image using the `-gtk-icon-source` property.

    For rubberband selection, a subnode with name `rubberband` is used.

    For the drop target location during DND, a subnode with name `dndtarget` is used.
    """

    class Props(Widget.Props):
        activate_on_single_click: bool  # [activate-on-single-click]: changed because contained invalid characters
        enable_grid_lines: TreeViewGridLines  # [enable-grid-lines]: changed because contained invalid characters
        enable_search: bool  # [enable-search]: changed because contained invalid characters
        enable_tree_lines: bool  # [enable-tree-lines]: changed because contained invalid characters
        expander_column: TreeViewColumn | None  # [expander-column]: changed because contained invalid characters
        fixed_height_mode: bool  # [fixed-height-mode]: changed because contained invalid characters
        headers_clickable: bool  # [headers-clickable]: changed because contained invalid characters
        headers_visible: bool  # [headers-visible]: changed because contained invalid characters
        hover_expand: bool  # [hover-expand]: changed because contained invalid characters
        hover_selection: bool  # [hover-selection]: changed because contained invalid characters
        level_indentation: int  # [level-indentation]: changed because contained invalid characters
        model: TreeModel | None
        reorderable: bool
        rubber_banding: bool  # [rubber-banding]: changed because contained invalid characters
        search_column: int  # [search-column]: changed because contained invalid characters
        show_expanders: bool  # [show-expanders]: changed because contained invalid characters
        tooltip_column: int  # [tooltip-column]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        activate_on_single_click: bool = ...,
        enable_grid_lines: TreeViewGridLines = ...,
        enable_search: bool = ...,
        enable_tree_lines: bool = ...,
        expander_column: TreeViewColumn | None = ...,
        fixed_height_mode: bool = ...,
        headers_clickable: bool = ...,
        headers_visible: bool = ...,
        hover_expand: bool = ...,
        hover_selection: bool = ...,
        level_indentation: int = ...,
        model: TreeModel | None = ...,
        reorderable: bool = ...,
        rubber_banding: bool = ...,
        search_column: int = ...,
        show_expanders: bool = ...,
        tooltip_column: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def append_column(self, column: TreeViewColumn) -> int: ...
    @deprecated("deprecated")
    def collapse_all(self) -> None: ...
    @deprecated("deprecated")
    def collapse_row(self, path: TreePath) -> bool: ...
    @deprecated("deprecated")
    def columns_autosize(self) -> None: ...
    @deprecated("deprecated")
    def convert_bin_window_to_tree_coords(self, bx: int, by: int) -> tuple[int, int]: ...
    @deprecated("deprecated")
    def convert_bin_window_to_widget_coords(self, bx: int, by: int) -> tuple[int, int]: ...
    @deprecated("deprecated")
    def convert_tree_to_bin_window_coords(self, tx: int, ty: int) -> tuple[int, int]: ...
    @deprecated("deprecated")
    def convert_tree_to_widget_coords(self, tx: int, ty: int) -> tuple[int, int]: ...
    @deprecated("deprecated")
    def convert_widget_to_bin_window_coords(self, wx: int, wy: int) -> tuple[int, int]: ...
    @deprecated("deprecated")
    def convert_widget_to_tree_coords(self, wx: int, wy: int) -> tuple[int, int]: ...
    @deprecated("deprecated")
    def create_row_drag_icon(self, path: TreePath) -> Gdk.Paintable | None: ...
    @deprecated("deprecated")
    def enable_model_drag_dest(self, formats: Gdk.ContentFormats, actions: Gdk.DragAction) -> None: ...
    @deprecated("deprecated")
    def enable_model_drag_source(
        self, start_button_mask: Gdk.ModifierType, formats: Gdk.ContentFormats, actions: Gdk.DragAction
    ) -> None: ...
    @deprecated("deprecated")
    def expand_all(self) -> None: ...
    @deprecated("deprecated")
    def expand_row(self, path: TreePath, open_all: bool) -> bool: ...
    @deprecated("deprecated")
    def expand_to_path(self, path: TreePath) -> None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_activate_on_single_click(self) -> bool: ...
    @deprecated("deprecated")
    def get_background_area(
        self, path: TreePath | None = None, column: TreeViewColumn | None = None
    ) -> Gdk.Rectangle: ...
    @deprecated("deprecated")
    def get_cell_area(self, path: TreePath | None = None, column: TreeViewColumn | None = None) -> Gdk.Rectangle: ...
    @deprecated("deprecated")
    def get_column(self, n: int) -> TreeViewColumn | None: ...
    @deprecated("deprecated")
    def get_columns(self) -> list: ...
    @deprecated("deprecated")
    def get_cursor(self) -> tuple[TreePath | None, TreeViewColumn | None]: ...
    @deprecated("deprecated")
    def get_dest_row_at_pos(
        self, drag_x: int, drag_y: int
    ) -> tuple[bool, TreePath | None, TreeViewDropPosition | None]: ...
    @deprecated("deprecated")
    def get_drag_dest_row(self) -> tuple[TreePath | None, TreeViewDropPosition | None]: ...
    @deprecated("deprecated")
    @builtins.property
    def get_enable_search(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_enable_tree_lines(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_expander_column(self) -> TreeViewColumn | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_fixed_height_mode(self) -> bool: ...
    @deprecated("deprecated")
    def get_grid_lines(self) -> TreeViewGridLines: ...
    @deprecated("deprecated")
    @builtins.property
    def get_headers_clickable(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_headers_visible(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_hover_expand(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_hover_selection(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_level_indentation(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_model(self) -> TreeModel | None: ...
    @deprecated("deprecated")
    def get_n_columns(self) -> int: ...
    @deprecated("deprecated")
    def get_path_at_pos(
        self, x: int, y: int
    ) -> tuple[bool, TreePath | None, TreeViewColumn | None, int | None, int | None]: ...
    @deprecated("deprecated")
    @builtins.property
    def get_reorderable(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_rubber_banding(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_search_column(self) -> int: ...
    @deprecated("deprecated")
    def get_search_entry(self) -> Editable | None: ...
    @deprecated("deprecated")
    def get_selection(self) -> TreeSelection: ...
    @deprecated("deprecated")
    @builtins.property
    def get_show_expanders(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_tooltip_column(self) -> int: ...
    @deprecated("deprecated")
    def get_tooltip_context(
        self, x: int, y: int, keyboard_tip: bool
    ) -> tuple[bool, TreeModel | None, TreePath | None, TreeIter | None]: ...
    @deprecated("deprecated")
    def get_visible_range(self) -> tuple[bool, TreePath | None, TreePath | None]: ...
    @deprecated("deprecated")
    def get_visible_rect(self) -> Gdk.Rectangle: ...
    @deprecated("deprecated")
    def insert_column(self, column: TreeViewColumn, position: int) -> int: ...
    @deprecated("deprecated")
    def insert_column_with_data_func(
        self,
        position: int,
        title: str,
        cell: CellRenderer,
        func: TreeCellDataFunc,
        data: object | None,
        dnotify: GLib.DestroyNotify,
    ) -> int: ...
    @deprecated("deprecated")
    def is_blank_at_pos(
        self, x: int, y: int
    ) -> tuple[bool, TreePath | None, TreeViewColumn | None, int | None, int | None]: ...
    @deprecated("deprecated")
    def is_rubber_banding_active(self) -> bool: ...
    @deprecated("deprecated")
    def map_expanded_rows(self, func: TreeViewMappingFunc, data: object | None = None) -> None: ...
    @deprecated("deprecated")
    def move_column_after(self, column: TreeViewColumn, base_column: TreeViewColumn | None = None) -> None: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_model(cls, model: TreeModel) -> Widget: ...
    @deprecated("deprecated")
    def remove_column(self, column: TreeViewColumn) -> int: ...
    @deprecated("deprecated")
    def row_activated(self, path: TreePath, column: TreeViewColumn | None = None) -> None: ...
    @deprecated("deprecated")
    def row_expanded(self, path: TreePath) -> bool: ...
    @deprecated("deprecated")
    def scroll_to_cell(
        self, path: TreePath | None, column: TreeViewColumn | None, use_align: bool, row_align: float, col_align: float
    ) -> None: ...
    @deprecated("deprecated")
    def scroll_to_point(self, tree_x: int, tree_y: int) -> None: ...
    @deprecated("deprecated")
    def set_activate_on_single_click(self, single: bool) -> None: ...
    @deprecated("deprecated")
    def set_column_drag_function(
        self,
        func: TreeViewColumnDropFunc | None = None,
        user_data: object | None = None,
        destroy: GLib.DestroyNotify | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def set_cursor(self, path: TreePath, focus_column: TreeViewColumn | None, start_editing: bool) -> None: ...
    @deprecated("deprecated")
    def set_cursor_on_cell(
        self, path: TreePath, focus_column: TreeViewColumn | None, focus_cell: CellRenderer | None, start_editing: bool
    ) -> None: ...
    @deprecated("deprecated")
    def set_drag_dest_row(self, path: TreePath | None, pos: TreeViewDropPosition) -> None: ...
    @deprecated("deprecated")
    def set_enable_search(self, enable_search: bool) -> None: ...
    @deprecated("deprecated")
    def set_enable_tree_lines(self, enabled: bool) -> None: ...
    @deprecated("deprecated")
    def set_expander_column(self, column: TreeViewColumn | None = None) -> None: ...
    @deprecated("deprecated")
    def set_fixed_height_mode(self, enable: bool) -> None: ...
    @deprecated("deprecated")
    def set_grid_lines(self, grid_lines: TreeViewGridLines) -> None: ...
    @deprecated("deprecated")
    def set_headers_clickable(self, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_headers_visible(self, headers_visible: bool) -> None: ...
    @deprecated("deprecated")
    def set_hover_expand(self, expand: bool) -> None: ...
    @deprecated("deprecated")
    def set_hover_selection(self, hover: bool) -> None: ...
    @deprecated("deprecated")
    def set_level_indentation(self, indentation: int) -> None: ...
    @deprecated("deprecated")
    def set_model(self, model: TreeModel | None = None) -> None: ...
    @deprecated("deprecated")
    def set_reorderable(self, reorderable: bool) -> None: ...
    @deprecated("deprecated")
    def set_row_separator_func(
        self,
        func: TreeViewRowSeparatorFunc | None = None,
        data: object | None = None,
        destroy: GLib.DestroyNotify | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def set_rubber_banding(self, enable: bool) -> None: ...
    @deprecated("deprecated")
    def set_search_column(self, column: int) -> None: ...
    @deprecated("deprecated")
    def set_search_entry(self, entry: Editable | None = None) -> None: ...
    @deprecated("deprecated")
    def set_search_equal_func(
        self,
        search_equal_func: TreeViewSearchEqualFunc,
        search_user_data: object | None = None,
        search_destroy: GLib.DestroyNotify | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def set_show_expanders(self, enabled: bool) -> None: ...
    @deprecated("deprecated")
    def set_tooltip_cell(
        self,
        tooltip: Tooltip,
        path: TreePath | None = None,
        column: TreeViewColumn | None = None,
        cell: CellRenderer | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def set_tooltip_column(self, column: int) -> None: ...
    @deprecated("deprecated")
    def set_tooltip_row(self, tooltip: Tooltip, path: TreePath) -> None: ...
    @deprecated("deprecated")
    def unset_rows_drag_dest(self) -> None: ...
    @deprecated("deprecated")
    def unset_rows_drag_source(self) -> None: ...

    # python methods (overrides?)
    def insert_column_with_attributes(
        self,
        position: typing.Any,
        title: typing.Any,
        cell: typing.Any,
        **kwargs: typing.Any,
    ) -> typing.Any: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["columns-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["cursor-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["expand-collapse-cursor-row"],
        handler: typing.Callable[[typing_extensions.Self, bool, bool, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-cursor"],
        handler: typing.Callable[[typing_extensions.Self, MovementStep, int, bool, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["row-activated"],
        handler: typing.Callable[[typing_extensions.Self, TreePath, TreeViewColumn | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["row-collapsed"],
        handler: typing.Callable[[typing_extensions.Self, TreeIter, TreePath], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["row-expanded"],
        handler: typing.Callable[[typing_extensions.Self, TreeIter, TreePath], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["select-all"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["select-cursor-parent"],
        handler: typing.Callable[..., bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["select-cursor-row"],
        handler: typing.Callable[[typing_extensions.Self, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["start-interactive-search"],
        handler: typing.Callable[..., bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["test-collapse-row"],
        handler: typing.Callable[[typing_extensions.Self, TreeIter, TreePath], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["test-expand-row"],
        handler: typing.Callable[[typing_extensions.Self, TreeIter, TreePath], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["toggle-cursor-row"],
        handler: typing.Callable[..., bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["unselect-all"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::activate_on_single_click"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_grid_lines"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_search"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enable_tree_lines"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expander_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::fixed_height_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::headers_clickable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::headers_visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hover_expand"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hover_selection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::level_indentation"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::model"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::reorderable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rubber_banding"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::search_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::show_expanders"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tooltip_column"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TreeViewClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def columns_changed(self) -> columns_changedTreeViewClassCB: ...
    @builtins.property
    def cursor_changed(self) -> cursor_changedTreeViewClassCB: ...
    @builtins.property
    def expand_collapse_cursor_row(self) -> expand_collapse_cursor_rowTreeViewClassCB: ...
    @builtins.property
    def move_cursor(self) -> move_cursorTreeViewClassCB: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...
    @builtins.property
    def row_activated(self) -> row_activatedTreeViewClassCB: ...
    @builtins.property
    def row_collapsed(self) -> row_collapsedTreeViewClassCB: ...
    @builtins.property
    def row_expanded(self) -> row_expandedTreeViewClassCB: ...
    @builtins.property
    def select_all(self) -> select_allTreeViewClassCB: ...
    @builtins.property
    def select_cursor_parent(self) -> select_cursor_parentTreeViewClassCB: ...
    @builtins.property
    def select_cursor_row(self) -> select_cursor_rowTreeViewClassCB: ...
    @builtins.property
    def start_interactive_search(self) -> start_interactive_searchTreeViewClassCB: ...
    @builtins.property
    def test_collapse_row(self) -> test_collapse_rowTreeViewClassCB: ...
    @builtins.property
    def test_expand_row(self) -> test_expand_rowTreeViewClassCB: ...
    @builtins.property
    def toggle_cursor_row(self) -> toggle_cursor_rowTreeViewClassCB: ...
    @builtins.property
    def unselect_all(self) -> unselect_allTreeViewClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TreeViewColumn(GObject.InitiallyUnowned):
    """
    A visible column in a [class@Gtk.TreeView] widget

    The `GtkTreeViewColumn` object represents a visible column in a `GtkTreeView` widget.
    It allows to set properties of the column header, and functions as a holding pen
    for the cell renderers which determine how the data in the column is displayed.

    Please refer to the [tree widget conceptual overview](section-tree-widget.html)
    for an overview of all the objects and data types related to the tree widget and
    how they work together, and to the [class@Gtk.TreeView] documentation for specifics
    about the CSS node structure for treeviews and their headers.
    """

    class Props(GObject.InitiallyUnowned.Props):
        alignment: float
        cell_area: CellArea | None  # [cell-area]: changed because contained invalid characters
        clickable: bool
        expand: bool
        fixed_width: int  # [fixed-width]: changed because contained invalid characters
        max_width: int  # [max-width]: changed because contained invalid characters
        min_width: int  # [min-width]: changed because contained invalid characters
        reorderable: bool
        resizable: bool
        sizing: TreeViewColumnSizing
        sort_column_id: int  # [sort-column-id]: changed because contained invalid characters
        sort_indicator: bool  # [sort-indicator]: changed because contained invalid characters
        sort_order: SortType  # [sort-order]: changed because contained invalid characters
        spacing: int
        title: str
        visible: bool
        widget: Widget | None
        width: int
        x_offset: int  # [x-offset]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    @deprecated("deprecated")
    def add_attribute(self, cell_renderer: CellRenderer, attribute: str, column: int) -> None: ...
    @deprecated("deprecated")
    def cell_get_position(self, cell_renderer: CellRenderer) -> tuple[bool, int | None, int | None]: ...
    @deprecated("deprecated")
    def cell_get_size(self) -> tuple[int | None, int | None, int | None, int | None]: ...
    @deprecated("deprecated")
    def cell_is_visible(self) -> bool: ...
    @deprecated("deprecated")
    def cell_set_cell_data(
        self, tree_model: TreeModel, iter: TreeIter, is_expander: bool, is_expanded: bool
    ) -> None: ...
    @deprecated("deprecated")
    def clear(self) -> None: ...
    @deprecated("deprecated")
    def clear_attributes(self, cell_renderer: CellRenderer) -> None: ...
    @deprecated("deprecated")
    def clicked(self) -> None: ...
    @deprecated("deprecated")
    def focus_cell(self, cell: CellRenderer) -> None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_alignment(self) -> float: ...
    @deprecated("deprecated")
    def get_button(self) -> Widget: ...
    @deprecated("deprecated")
    @builtins.property
    def get_clickable(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_expand(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_fixed_width(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_max_width(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_min_width(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_reorderable(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_resizable(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_sizing(self) -> TreeViewColumnSizing: ...
    @deprecated("deprecated")
    @builtins.property
    def get_sort_column_id(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_sort_indicator(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_sort_order(self) -> SortType: ...
    @deprecated("deprecated")
    @builtins.property
    def get_spacing(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_title(self) -> str: ...
    @deprecated("deprecated")
    def get_tree_view(self) -> Widget | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_visible(self) -> bool: ...
    @deprecated("deprecated")
    @builtins.property
    def get_widget(self) -> Widget | None: ...
    @deprecated("deprecated")
    @builtins.property
    def get_width(self) -> int: ...
    @deprecated("deprecated")
    @builtins.property
    def get_x_offset(self) -> int: ...
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> TreeViewColumn: ...
    @deprecated("deprecated")
    @classmethod
    def new_with_area(cls, area: CellArea) -> TreeViewColumn: ...
    @deprecated("deprecated")
    def pack_end(self, cell: CellRenderer, expand: bool) -> None: ...
    @deprecated("deprecated")
    def pack_start(self, cell: CellRenderer, expand: bool) -> None: ...
    @deprecated("deprecated")
    def queue_resize(self) -> None: ...
    @deprecated("deprecated")
    def set_alignment(self, xalign: float) -> None: ...
    @deprecated("deprecated")
    def set_cell_data_func(
        self,
        cell_renderer: CellRenderer,
        func: TreeCellDataFunc | None,
        func_data: object | None,
        destroy: GLib.DestroyNotify,
    ) -> None: ...
    @deprecated("deprecated")
    def set_clickable(self, clickable: bool) -> None: ...
    @deprecated("deprecated")
    def set_expand(self, expand: bool) -> None: ...
    @deprecated("deprecated")
    def set_fixed_width(self, fixed_width: int) -> None: ...
    @deprecated("deprecated")
    def set_max_width(self, max_width: int) -> None: ...
    @deprecated("deprecated")
    def set_min_width(self, min_width: int) -> None: ...
    @deprecated("deprecated")
    def set_reorderable(self, reorderable: bool) -> None: ...
    @deprecated("deprecated")
    def set_resizable(self, resizable: bool) -> None: ...
    @deprecated("deprecated")
    def set_sizing(self, type: TreeViewColumnSizing) -> None: ...
    @deprecated("deprecated")
    def set_sort_column_id(self, sort_column_id: int) -> None: ...
    @deprecated("deprecated")
    def set_sort_indicator(self, setting: bool) -> None: ...
    @deprecated("deprecated")
    def set_sort_order(self, order: SortType) -> None: ...
    @deprecated("deprecated")
    def set_spacing(self, spacing: int) -> None: ...
    @deprecated("deprecated")
    def set_title(self, title: str) -> None: ...
    @deprecated("deprecated")
    def set_visible(self, visible: bool) -> None: ...
    @deprecated("deprecated")
    def set_widget(self, widget: Widget | None = None) -> None: ...

    # python methods (overrides?)
    def __init__(
        self,
        title: typing.Any = "",
        cell_renderer: typing.Any = None,
        **attributes: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    def set_attributes(
        self,
        cell_renderer: typing.Any,
        **attributes: typing.Any,
    ) -> typing.Any: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["clicked"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::alignment"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cell_area"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::clickable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::expand"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::fixed_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::min_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::reorderable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resizable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sizing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sort_column_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sort_indicator"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sort_order"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::spacing"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::x_offset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class UriLauncher(GObject.Object):
    """
    Asynchronous API to open a uri with an application.

    `GtkUriLauncher` collects the arguments that are needed to open the uri.

    Depending on system configuration, user preferences and available APIs, this
    may or may not show an app chooser dialog or launch the default application
    right away.

    The operation is started with the [method@Gtk.UriLauncher.launch] function.

    To launch a file, use [class@Gtk.FileLauncher].
    """

    class Props(GObject.Object.Props):
        uri: str

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, uri: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_uri(self) -> str | None: ...
    def launch(
        self,
        parent: Window | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def launch_finish(self, result: Gio.AsyncResult) -> bool: ...
    @classmethod
    def new(cls, uri: str | None = None) -> UriLauncher: ...
    def set_uri(self, uri: str | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class UriLauncherClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Video(Widget):
    """
    Shows a `GtkMediaStream` with media controls.

    <picture>
      <source srcset="video-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkVideo" src="video.png">
    </picture>

    The controls are available separately as [class@Gtk.MediaControls].
    If you just want to display a video without controls, you can treat it
    like any other paintable and for example put it into a [class@Gtk.Picture].

    `GtkVideo` aims to cover use cases such as previews, embedded animations,
    etc. It supports autoplay, looping, and simple media controls. It does
    not have support for video overlays, multichannel audio, device
    selection, or input. If you are writing a full-fledged video player,
    you may want to use the [iface@Gdk.Paintable] API and a media framework
    such as Gstreamer directly.
    """

    class Props(Widget.Props):
        autoplay: bool
        file: Gio.File | None
        graphics_offload: GraphicsOffloadEnabled  # [graphics-offload]: changed because contained invalid characters
        loop: bool
        media_stream: MediaStream | None  # [media-stream]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        autoplay: bool = ...,
        file: Gio.File | None = ...,
        graphics_offload: GraphicsOffloadEnabled = ...,
        loop: bool = ...,
        media_stream: MediaStream | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_autoplay(self) -> bool: ...
    @builtins.property
    def get_file(self) -> Gio.File | None: ...
    @builtins.property
    def get_graphics_offload(self) -> GraphicsOffloadEnabled: ...
    @builtins.property
    def get_loop(self) -> bool: ...
    @builtins.property
    def get_media_stream(self) -> MediaStream | None: ...
    @classmethod
    def new(cls) -> Widget: ...
    @classmethod
    def new_for_file(cls, file: Gio.File | None = None) -> Widget: ...
    @classmethod
    def new_for_filename(cls, filename: str | None = None) -> Widget: ...
    @classmethod
    def new_for_media_stream(cls, stream: MediaStream | None = None) -> Widget: ...
    @classmethod
    def new_for_resource(cls, resource_path: str | None = None) -> Widget: ...
    def set_autoplay(self, autoplay: bool) -> None: ...
    def set_file(self, file: Gio.File | None = None) -> None: ...
    def set_filename(self, filename: str | None = None) -> None: ...
    def set_graphics_offload(self, enabled: GraphicsOffloadEnabled) -> None: ...
    def set_loop(self, loop: bool) -> None: ...
    def set_media_stream(self, stream: MediaStream | None = None) -> None: ...
    def set_resource(self, resource_path: str | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::autoplay"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::graphics_offload"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::loop"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::media_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class VideoClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Viewport(Widget):
    """
    Implements scrollability for widgets that don't support scrolling
    on their own.

    Use `GtkViewport` to scroll child widgets such as `GtkGrid`,
    `GtkBox`, and so on.

    The `GtkViewport` will start scrolling content only if allocated
    less than the child widget’s minimum size in a given orientation.

    # CSS nodes

    `GtkViewport` has a single CSS node with name `viewport`.

    # Accessibility

    Until GTK 4.10, `GtkViewport` used the [enum@Gtk.AccessibleRole.group] role.

    Starting from GTK 4.12, `GtkViewport` uses the [enum@Gtk.AccessibleRole.generic] role.
    """

    class Props(Widget.Props):
        child: Widget | None
        scroll_to_focus: bool  # [scroll-to-focus]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, child: Widget | None = ..., scroll_to_focus: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_scroll_to_focus(self) -> bool: ...
    @classmethod
    def new(cls, hadjustment: Adjustment | None = None, vadjustment: Adjustment | None = None) -> Widget: ...
    def scroll_to(self, descendant: Widget, scroll: ScrollInfo | None = None) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_scroll_to_focus(self, scroll_to_focus: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scroll_to_focus"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class VolumeButton(ScaleButton):
    """
    `GtkVolumeButton` is a `GtkScaleButton` subclass tailored for
    volume control.

    <picture>
      <source srcset="volumebutton-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkVolumeButton" src="volumebutton.png">
    </picture>
    """

    class Props(ScaleButton.Props):
        use_symbolic: bool  # [use-symbolic]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, use_symbolic: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    @classmethod
    def new(cls) -> Widget: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_symbolic"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Widget(GObject.InitiallyUnowned):
    """
    The base class for all widgets.

    It manages the widget lifecycle, layout, states and style.

    ### Height-for-width Geometry Management

    GTK uses a height-for-width (and width-for-height) geometry management
    system. Height-for-width means that a widget can change how much
    vertical space it needs, depending on the amount of horizontal space
    that it is given (and similar for width-for-height). The most common
    example is a label that reflows to fill up the available width, wraps
    to fewer lines, and therefore needs less height.

    Height-for-width geometry management is implemented in GTK by way
    of two virtual methods:

    - [vfunc@Gtk.Widget.get_request_mode]
    - [vfunc@Gtk.Widget.measure]

    There are some important things to keep in mind when implementing
    height-for-width and when using it in widget implementations.

    If you implement a direct `GtkWidget` subclass that supports
    height-for-width or width-for-height geometry management for itself
    or its child widgets, the [vfunc@Gtk.Widget.get_request_mode] virtual
    function must be implemented as well and return the widget's preferred
    request mode. The default implementation of this virtual function
    returns %GTK_SIZE_REQUEST_CONSTANT_SIZE, which means that the widget will
    only ever get -1 passed as the for_size value to its
    [vfunc@Gtk.Widget.measure] implementation.

    The geometry management system will query a widget hierarchy in
    only one orientation at a time. When widgets are initially queried
    for their minimum sizes it is generally done in two initial passes
    in the [enum@Gtk.SizeRequestMode] chosen by the toplevel.

    For example, when queried in the normal %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH mode:

    First, the default minimum and natural width for each widget
    in the interface will be computed using [method@Gtk.Widget.measure] with an
    orientation of %GTK_ORIENTATION_HORIZONTAL and a for_size of -1.
    Because the preferred widths for each widget depend on the preferred
    widths of their children, this information propagates up the hierarchy,
    and finally a minimum and natural width is determined for the entire
    toplevel. Next, the toplevel will use the minimum width to query for the
    minimum height contextual to that width using [method@Gtk.Widget.measure] with an
    orientation of %GTK_ORIENTATION_VERTICAL and a for_size of the just computed
    width. This will also be a highly recursive operation. The minimum height
    for the minimum width is normally used to set the minimum size constraint
    on the toplevel.

    After the toplevel window has initially requested its size in both
    dimensions it can go on to allocate itself a reasonable size (or a size
    previously specified with [method@Gtk.Window.set_default_size]). During the
    recursive allocation process it’s important to note that request cycles
    will be recursively executed while widgets allocate their children.
    Each widget, once allocated a size, will go on to first share the
    space in one orientation among its children and then request each child's
    height for its target allocated width or its width for allocated height,
    depending. In this way a widget will typically be requested its size
    a number of times before actually being allocated a size. The size a
    widget is finally allocated can of course differ from the size it has
    requested. For this reason, `GtkWidget` caches a  small number of results
    to avoid re-querying for the same sizes in one allocation cycle.

    If a widget does move content around to intelligently use up the
    allocated size then it must support the request in both
    `GtkSizeRequestMode`s even if the widget in question only
    trades sizes in a single orientation.

    For instance, a [class@Gtk.Label] that does height-for-width word wrapping
    will not expect to have [vfunc@Gtk.Widget.measure] with an orientation of
    %GTK_ORIENTATION_VERTICAL called because that call is specific to a
    width-for-height request. In this case the label must return the height
    required for its own minimum possible width. By following this rule any
    widget that handles height-for-width or width-for-height requests will
    always be allocated at least enough space to fit its own content.

    Here are some examples of how a %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
    generally deals with width-for-height requests:

    ```c
    static void
    foo_widget_measure (GtkWidget      *widget,
                        GtkOrientation  orientation,
                        int             for_size,
                        int            *minimum_size,
                        int            *natural_size,
                        int            *minimum_baseline,
                        int            *natural_baseline)
    {
      if (orientation == GTK_ORIENTATION_HORIZONTAL)
        {
          // Calculate minimum and natural width
        }
      else // VERTICAL
        {
          if (i_am_in_height_for_width_mode)
            {
              int min_width, dummy;

              // First, get the minimum width of our widget
              GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
                                                      &min_width, &dummy, &dummy, &dummy);

              // Now use the minimum width to retrieve the minimum and natural height to display
              // that width.
              GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
                                                      minimum_size, natural_size, &dummy, &dummy);
            }
          else
            {
              // ... some widgets do both.
            }
        }
    }
    ```

    Often a widget needs to get its own request during size request or
    allocation. For example, when computing height it may need to also
    compute width. Or when deciding how to use an allocation, the widget
    may need to know its natural size. In these cases, the widget should
    be careful to call its virtual methods directly, like in the code
    example above.

    It will not work to use the wrapper function [method@Gtk.Widget.measure]
    inside your own [vfunc@Gtk.Widget.size_allocate] implementation.
    These return a request adjusted by [class@Gtk.SizeGroup], the widget's
    align and expand flags, as well as its CSS style.

    If a widget used the wrappers inside its virtual method implementations,
    then the adjustments (such as widget margins) would be applied
    twice. GTK therefore does not allow this and will warn if you try
    to do it.

    Of course if you are getting the size request for another widget, such
    as a child widget, you must use [method@Gtk.Widget.measure]; otherwise, you
    would not properly consider widget margins, [class@Gtk.SizeGroup], and
    so forth.

    GTK also supports baseline vertical alignment of widgets. This
    means that widgets are positioned such that the typographical baseline of
    widgets in the same row are aligned. This happens if a widget supports
    baselines, has a vertical alignment using baselines, and is inside
    a widget that supports baselines and has a natural “row” that it aligns to
    the baseline, or a baseline assigned to it by the grandparent.

    Baseline alignment support for a widget is also done by the
    [vfunc@Gtk.Widget.measure] virtual function. It allows you to report
    both a minimum and natural size.

    If a widget ends up baseline aligned it will be allocated all the space in
    the parent as if it was %GTK_ALIGN_FILL, but the selected baseline can be
    found via [method@Gtk.Widget.get_baseline]. If the baseline has a
    value other than -1 you need to align the widget such that the baseline
    appears at the position.

    ### GtkWidget as GtkBuildable

    The `GtkWidget` implementation of the `GtkBuildable` interface
    supports various custom elements to specify additional aspects of widgets
    that are not directly expressed as properties.

    If the widget uses a [class@Gtk.LayoutManager], `GtkWidget` supports
    a custom `<layout>` element, used to define layout properties:

    ```xml
    <object class="GtkGrid" id="my_grid">
      <child>
        <object class="GtkLabel" id="label1">
          <property name="label">Description</property>
          <layout>
            <property name="column">0</property>
            <property name="row">0</property>
            <property name="row-span">1</property>
            <property name="column-span">1</property>
          </layout>
        </object>
      </child>
      <child>
        <object class="GtkEntry" id="description_entry">
          <layout>
            <property name="column">1</property>
            <property name="row">0</property>
            <property name="row-span">1</property>
            <property name="column-span">1</property>
          </layout>
        </object>
      </child>
    </object>
    ```

    `GtkWidget` allows style information such as style classes to
    be associated with widgets, using the custom `<style>` element:

    ```xml
    <object class="GtkButton" id="button1">
      <style>
        <class name="my-special-button-class"/>
        <class name="dark-button"/>
      </style>
    </object>
    ```

    `GtkWidget` allows defining accessibility information, such as properties,
    relations, and states, using the custom `<accessibility>` element:

    ```xml
    <object class="GtkButton" id="button1">
      <accessibility>
        <property name="label">Download</property>
        <relation name="labelled-by">label1</relation>
      </accessibility>
    </object>
    ```

    ### Building composite widgets from template XML

    `GtkWidget `exposes some facilities to automate the procedure
    of creating composite widgets using "templates".

    To create composite widgets with `GtkBuilder` XML, one must associate
    the interface description with the widget class at class initialization
    time using [method@Gtk.WidgetClass.set_template].

    The interface description semantics expected in composite template descriptions
    is slightly different from regular [class@Gtk.Builder] XML.

    Unlike regular interface descriptions, [method@Gtk.WidgetClass.set_template]
    will expect a `<template>` tag as a direct child of the toplevel
    `<interface>` tag. The `<template>` tag must specify the “class” attribute
    which must be the type name of the widget. Optionally, the “parent”
    attribute may be specified to specify the direct parent type of the widget
    type; this is ignored by `GtkBuilder` but can be used by UI design tools to
    introspect what kind of properties and internal children exist for a given
    type when the actual type does not exist.

    The XML which is contained inside the `<template>` tag behaves as if it were
    added to the `<object>` tag defining the widget itself. You may set properties
    on a widget by inserting `<property>` tags into the `<template>` tag, and also
    add `<child>` tags to add children and extend a widget in the normal way you
    would with `<object>` tags.

    Additionally, `<object>` tags can also be added before and after the initial
    `<template>` tag in the normal way, allowing one to define auxiliary objects
    which might be referenced by other widgets declared as children of the
    `<template>` tag.

    Since, unlike the `<object>` tag, the `<template>` tag does not contain an
    “id” attribute, if you need to refer to the instance of the object itself that
    the template will create, simply refer to the template class name in an
    applicable element content.

    Here is an example of a template definition, which includes an example of
    this in the `<signal>` tag:

    ```xml
    <interface>
      <template class="FooWidget" parent="GtkBox">
        <property name="orientation">horizontal</property>
        <property name="spacing">4</property>
        <child>
          <object class="GtkButton" id="hello_button">
            <property name="label">Hello World</property>
            <signal name="clicked" handler="hello_button_clicked" object="FooWidget" swapped="yes"/>
          </object>
        </child>
        <child>
          <object class="GtkButton" id="goodbye_button">
            <property name="label">Goodbye World</property>
          </object>
        </child>
      </template>
    </interface>
    ```

    Typically, you'll place the template fragment into a file that is
    bundled with your project, using `GResource`. In order to load the
    template, you need to call [method@Gtk.WidgetClass.set_template_from_resource]
    from the class initialization of your `GtkWidget` type:

    ```c
    static void
    foo_widget_class_init (FooWidgetClass *klass)
    {
      // ...

      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
                                                   "/com/example/ui/foowidget.ui");
    }
    ```

    You will also need to call [method@Gtk.Widget.init_template] from the
    instance initialization function:

    ```c
    static void
    foo_widget_init (FooWidget *self)
    {
      gtk_widget_init_template (GTK_WIDGET (self));

      // Initialize the rest of the widget...
    }
    ```

    as well as calling [method@Gtk.Widget.dispose_template] from the dispose
    function:

    ```c
    static void
    foo_widget_dispose (GObject *gobject)
    {
      FooWidget *self = FOO_WIDGET (gobject);

      // Dispose objects for which you have a reference...

      // Clear the template children for this widget type
      gtk_widget_dispose_template (GTK_WIDGET (self), FOO_TYPE_WIDGET);

      G_OBJECT_CLASS (foo_widget_parent_class)->dispose (gobject);
    }
    ```

    You can access widgets defined in the template using the
    [method@Gtk.Widget.get_template_child] function, but you will typically declare
    a pointer in the instance private data structure of your type using the same
    name as the widget in the template definition, and call
    [method@Gtk.WidgetClass.bind_template_child_full] (or one of its wrapper macros
    [func@Gtk.widget_class_bind_template_child] and [func@Gtk.widget_class_bind_template_child_private])
    with that name, e.g.

    ```c
    typedef struct {
      GtkWidget *hello_button;
      GtkWidget *goodbye_button;
    } FooWidgetPrivate;

    G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)

    static void
    foo_widget_dispose (GObject *gobject)
    {
      gtk_widget_dispose_template (GTK_WIDGET (gobject), FOO_TYPE_WIDGET);

      G_OBJECT_CLASS (foo_widget_parent_class)->dispose (gobject);
    }

    static void
    foo_widget_class_init (FooWidgetClass *klass)
    {
      // ...
      G_OBJECT_CLASS (klass)->dispose = foo_widget_dispose;

      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
                                                   "/com/example/ui/foowidget.ui");
      gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
                                                    FooWidget, hello_button);
      gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
                                                    FooWidget, goodbye_button);
    }

    static void
    foo_widget_init (FooWidget *widget)
    {
      gtk_widget_init_template (GTK_WIDGET (widget));
    }
    ```

    You can also use [method@Gtk.WidgetClass.bind_template_callback_full] (or
    is wrapper macro [func@Gtk.widget_class_bind_template_callback]) to connect
    a signal callback defined in the template with a function visible in the
    scope of the class, e.g.

    ```c
    // the signal handler has the instance and user data swapped
    // because of the swapped="yes" attribute in the template XML
    static void
    hello_button_clicked (FooWidget *self,
                          GtkButton *button)
    {
      g_print ("Hello, world!\\n");
    }

    static void
    foo_widget_class_init (FooWidgetClass *klass)
    {
      // ...
      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
                                                   "/com/example/ui/foowidget.ui");
      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
    }
    ```
    """

    class Props(GObject.InitiallyUnowned.Props):
        can_focus: bool  # [can-focus]: changed because contained invalid characters
        can_target: bool  # [can-target]: changed because contained invalid characters
        css_classes: list | None  # [css-classes]: changed because contained invalid characters
        css_name: str  # [css-name]: changed because contained invalid characters
        cursor: Gdk.Cursor | None
        focus_on_click: bool  # [focus-on-click]: changed because contained invalid characters
        focusable: bool
        halign: Align
        has_default: bool  # [has-default]: changed because contained invalid characters
        has_focus: bool  # [has-focus]: changed because contained invalid characters
        has_tooltip: bool  # [has-tooltip]: changed because contained invalid characters
        height_request: int  # [height-request]: changed because contained invalid characters
        hexpand: bool
        hexpand_set: bool  # [hexpand-set]: changed because contained invalid characters
        layout_manager: LayoutManager | None  # [layout-manager]: changed because contained invalid characters
        limit_events: bool  # [limit-events]: changed because contained invalid characters
        margin_bottom: int  # [margin-bottom]: changed because contained invalid characters
        margin_end: int  # [margin-end]: changed because contained invalid characters
        margin_start: int  # [margin-start]: changed because contained invalid characters
        margin_top: int  # [margin-top]: changed because contained invalid characters
        name: str
        opacity: float
        overflow: Overflow
        parent: Widget | None
        receives_default: bool  # [receives-default]: changed because contained invalid characters
        root: Root | None
        scale_factor: int  # [scale-factor]: changed because contained invalid characters
        sensitive: bool
        tooltip_markup: str  # [tooltip-markup]: changed because contained invalid characters
        tooltip_text: str  # [tooltip-text]: changed because contained invalid characters
        valign: Align
        vexpand: bool
        vexpand_set: bool  # [vexpand-set]: changed because contained invalid characters
        visible: bool
        width_request: int  # [width-request]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        can_focus: bool = ...,
        can_target: bool = ...,
        css_classes: list | None = ...,
        css_name: str = ...,
        cursor: Gdk.Cursor | None = ...,
        focus_on_click: bool = ...,
        focusable: bool = ...,
        halign: Align = ...,
        has_tooltip: bool = ...,
        height_request: int = ...,
        hexpand: bool = ...,
        hexpand_set: bool = ...,
        layout_manager: LayoutManager | None = ...,
        limit_events: bool = ...,
        margin_bottom: int = ...,
        margin_end: int = ...,
        margin_start: int = ...,
        margin_top: int = ...,
        name: str = ...,
        opacity: float = ...,
        overflow: Overflow = ...,
        receives_default: bool = ...,
        sensitive: bool = ...,
        tooltip_markup: str = ...,
        tooltip_text: str = ...,
        valign: Align = ...,
        vexpand: bool = ...,
        vexpand_set: bool = ...,
        visible: bool = ...,
        width_request: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def action_set_enabled(self, action_name: str, enabled: bool) -> None: ...
    def activate(self) -> bool: ...
    def activate_action(self, name: str, args: GLib.Variant | None = None) -> bool: ...
    def activate_default(self) -> None: ...
    def add_controller(self, controller: EventController) -> None: ...
    def add_css_class(self, css_class: str) -> None: ...
    def add_mnemonic_label(self, label: Widget) -> None: ...
    def add_tick_callback(
        self, callback: TickCallback, user_data: object | None, notify: GLib.DestroyNotify
    ) -> int: ...
    def allocate(self, width: int, height: int, baseline: int, transform: Gsk.Transform | None = None) -> None: ...
    def child_focus(self, direction: DirectionType) -> bool: ...
    def compute_bounds(self, target: Widget) -> tuple[bool, Graphene.Rect]: ...
    def compute_expand(self, orientation: Orientation) -> bool: ...
    def compute_point(self, target: Widget, point: Graphene.Point) -> tuple[bool, Graphene.Point]: ...
    def compute_transform(self, target: Widget) -> tuple[bool, Graphene.Matrix]: ...
    def contains(self, x: float, y: float) -> bool: ...
    def create_pango_context(self) -> Pango.Context: ...
    def create_pango_layout(self, text: str | None = None) -> Pango.Layout: ...
    def dispose_template(self, widget_type: GObject.GType) -> None: ...
    def drag_check_threshold(self, start_x: int, start_y: int, current_x: int, current_y: int) -> bool: ...
    def error_bell(self) -> None: ...
    @deprecated("deprecated")
    def get_allocated_baseline(self) -> int: ...
    @deprecated("deprecated")
    def get_allocated_height(self) -> int: ...
    @deprecated("deprecated")
    def get_allocated_width(self) -> int: ...
    @deprecated("deprecated")
    def get_allocation(self) -> Gdk.Rectangle: ...
    def get_ancestor(self, widget_type: GObject.GType) -> Widget | None: ...
    def get_baseline(self) -> int: ...
    @builtins.property
    def get_can_focus(self) -> bool: ...
    @builtins.property
    def get_can_target(self) -> bool: ...
    def get_child_visible(self) -> bool: ...
    def get_clipboard(self) -> Gdk.Clipboard: ...
    def get_color(self) -> Gdk.RGBA: ...
    @builtins.property
    def get_css_classes(self) -> list: ...
    @builtins.property
    def get_css_name(self) -> str: ...
    @builtins.property
    def get_cursor(self) -> Gdk.Cursor | None: ...
    @staticmethod
    def get_default_direction() -> TextDirection: ...
    def get_direction(self) -> TextDirection: ...
    def get_display(self) -> Gdk.Display: ...
    def get_first_child(self) -> Widget | None: ...
    def get_focus_child(self) -> Widget | None: ...
    @builtins.property
    def get_focus_on_click(self) -> bool: ...
    @builtins.property
    def get_focusable(self) -> bool: ...
    def get_font_map(self) -> Pango.FontMap | None: ...
    @deprecated("deprecated")
    def get_font_options(self) -> cairo.FontOptions | None: ...
    def get_frame_clock(self) -> Gdk.FrameClock | None: ...
    @builtins.property
    def get_halign(self) -> Align: ...
    @builtins.property
    def get_has_tooltip(self) -> bool: ...
    def get_height(self) -> int: ...
    @builtins.property
    def get_hexpand(self) -> bool: ...
    @builtins.property
    def get_hexpand_set(self) -> bool: ...
    def get_last_child(self) -> Widget | None: ...
    @builtins.property
    def get_layout_manager(self) -> LayoutManager | None: ...
    @builtins.property
    def get_limit_events(self) -> bool: ...
    def get_mapped(self) -> bool: ...
    @builtins.property
    def get_margin_bottom(self) -> int: ...
    @builtins.property
    def get_margin_end(self) -> int: ...
    @builtins.property
    def get_margin_start(self) -> int: ...
    @builtins.property
    def get_margin_top(self) -> int: ...
    @builtins.property
    def get_name(self) -> str: ...
    def get_native(self) -> Native | None: ...
    def get_next_sibling(self) -> Widget | None: ...
    @builtins.property
    def get_opacity(self) -> float: ...
    @builtins.property
    def get_overflow(self) -> Overflow: ...
    def get_pango_context(self) -> Pango.Context: ...
    @builtins.property
    def get_parent(self) -> Widget | None: ...
    def get_preferred_size(self) -> tuple[Requisition | None, Requisition | None]: ...
    def get_prev_sibling(self) -> Widget | None: ...
    def get_primary_clipboard(self) -> Gdk.Clipboard: ...
    def get_realized(self) -> bool: ...
    @builtins.property
    def get_receives_default(self) -> bool: ...
    def get_request_mode(self) -> SizeRequestMode: ...
    @builtins.property
    def get_root(self) -> Root | None: ...
    @builtins.property
    def get_scale_factor(self) -> int: ...
    @builtins.property
    def get_sensitive(self) -> bool: ...
    def get_settings(self) -> Settings: ...
    def get_size(self, orientation: Orientation) -> int: ...
    def get_size_request(self) -> tuple[int | None, int | None]: ...
    def get_state_flags(self) -> StateFlags: ...
    @deprecated("deprecated")
    def get_style_context(self) -> StyleContext: ...
    def get_template_child(self, widget_type: GObject.GType, name: str) -> GObject.Object: ...
    @builtins.property
    def get_tooltip_markup(self) -> str | None: ...
    @builtins.property
    def get_tooltip_text(self) -> str | None: ...
    @builtins.property
    def get_valign(self) -> Align: ...
    @builtins.property
    def get_vexpand(self) -> bool: ...
    @builtins.property
    def get_vexpand_set(self) -> bool: ...
    @builtins.property
    def get_visible(self) -> bool: ...
    def get_width(self) -> int: ...
    def grab_focus(self) -> bool: ...
    def has_css_class(self, css_class: str) -> bool: ...
    @builtins.property
    def has_default(self) -> bool: ...
    @builtins.property
    def has_focus(self) -> bool: ...
    def has_visible_focus(self) -> bool: ...
    @deprecated("deprecated")
    def hide(self) -> None: ...
    def in_destruction(self) -> bool: ...
    def init_template(self) -> None: ...
    def insert_action_group(self, name: str, group: Gio.ActionGroup | None = None) -> None: ...
    def insert_after(self, parent: Widget, previous_sibling: Widget | None = None) -> None: ...
    def insert_before(self, parent: Widget, next_sibling: Widget | None = None) -> None: ...
    def is_ancestor(self, ancestor: Widget) -> bool: ...
    def is_drawable(self) -> bool: ...
    def is_focus(self) -> bool: ...
    def is_sensitive(self) -> bool: ...
    def is_visible(self) -> bool: ...
    def keynav_failed(self, direction: DirectionType) -> bool: ...
    def list_mnemonic_labels(self) -> list: ...
    def map(self) -> None: ...
    def measure(
        self, orientation: Orientation, for_size: int
    ) -> tuple[int | None, int | None, int | None, int | None]: ...
    def mnemonic_activate(self, group_cycling: bool) -> bool: ...
    def observe_children(self) -> Gio.ListModel: ...
    def observe_controllers(self) -> Gio.ListModel: ...
    def pick(self, x: float, y: float, flags: PickFlags) -> Widget | None: ...
    def queue_allocate(self) -> None: ...
    def queue_draw(self) -> None: ...
    def queue_resize(self) -> None: ...
    def realize(self) -> None: ...
    def remove_controller(self, controller: EventController) -> None: ...
    def remove_css_class(self, css_class: str) -> None: ...
    def remove_mnemonic_label(self, label: Widget) -> None: ...
    def remove_tick_callback(self, id: int) -> None: ...
    def set_can_focus(self, can_focus: bool) -> None: ...
    def set_can_target(self, can_target: bool) -> None: ...
    def set_child_visible(self, child_visible: bool) -> None: ...
    def set_css_classes(self, classes: list) -> None: ...
    def set_cursor(self, cursor: Gdk.Cursor | None = None) -> None: ...
    def set_cursor_from_name(self, name: str | None = None) -> None: ...
    @staticmethod
    def set_default_direction(dir: TextDirection) -> None: ...
    def set_direction(self, dir: TextDirection) -> None: ...
    def set_focus_child(self, child: Widget | None = None) -> None: ...
    def set_focus_on_click(self, focus_on_click: bool) -> None: ...
    def set_focusable(self, focusable: bool) -> None: ...
    def set_font_map(self, font_map: Pango.FontMap | None = None) -> None: ...
    @deprecated("deprecated")
    def set_font_options(self, options: cairo.FontOptions | None = None) -> None: ...
    def set_halign(self, align: Align) -> None: ...
    def set_has_tooltip(self, has_tooltip: bool) -> None: ...
    def set_hexpand(self, expand: bool) -> None: ...
    def set_hexpand_set(self, set: bool) -> None: ...
    def set_layout_manager(self, layout_manager: LayoutManager | None = None) -> None: ...
    def set_limit_events(self, limit_events: bool) -> None: ...
    def set_margin_bottom(self, margin: int) -> None: ...
    def set_margin_end(self, margin: int) -> None: ...
    def set_margin_start(self, margin: int) -> None: ...
    def set_margin_top(self, margin: int) -> None: ...
    def set_name(self, name: str) -> None: ...
    def set_opacity(self, opacity: float) -> None: ...
    def set_overflow(self, overflow: Overflow) -> None: ...
    def set_parent(self, parent: Widget) -> None: ...
    def set_receives_default(self, receives_default: bool) -> None: ...
    def set_sensitive(self, sensitive: bool) -> None: ...
    def set_size_request(self, width: int, height: int) -> None: ...
    def set_state_flags(self, flags: StateFlags, clear: bool) -> None: ...
    def set_tooltip_markup(self, markup: str | None = None) -> None: ...
    def set_tooltip_text(self, text: str | None = None) -> None: ...
    def set_valign(self, align: Align) -> None: ...
    def set_vexpand(self, expand: bool) -> None: ...
    def set_vexpand_set(self, set: bool) -> None: ...
    def set_visible(self, visible: bool) -> None: ...
    def should_layout(self) -> bool: ...
    @deprecated("deprecated")
    def show(self) -> None: ...
    def size_allocate(self, allocation: Gdk.Rectangle, baseline: int) -> None: ...
    def snapshot_child(self, child: Widget, snapshot: Snapshot) -> None: ...
    @deprecated("deprecated")
    def translate_coordinates(
        self, dest_widget: Widget, src_x: float, src_y: float
    ) -> tuple[bool, float | None, float | None]: ...
    def trigger_tooltip_query(self) -> None: ...
    def unmap(self) -> None: ...
    def unparent(self) -> None: ...
    def unrealize(self) -> None: ...
    def unset_state_flags(self, flags: StateFlags) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["destroy"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["direction-changed"],
        handler: typing.Callable[[typing_extensions.Self, TextDirection], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["hide"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["keynav-failed"],
        handler: typing.Callable[[typing_extensions.Self, DirectionType], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["map"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mnemonic-activate"],
        handler: typing.Callable[[typing_extensions.Self, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["move-focus"],
        handler: typing.Callable[[typing_extensions.Self, DirectionType], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["query-tooltip"],
        handler: typing.Callable[[typing_extensions.Self, int, int, bool, Tooltip], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["realize"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["show"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["state-flags-changed"],
        handler: typing.Callable[[typing_extensions.Self, StateFlags], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["unmap"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["unrealize"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_focus"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_target"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::css_classes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::css_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cursor"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::focus_on_click"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::focusable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::halign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_default"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_focus"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_tooltip"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::height_request"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hexpand"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hexpand_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::layout_manager"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::limit_events"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::margin_bottom"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::margin_end"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::margin_start"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::margin_top"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::opacity"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::overflow"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::receives_default"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::root"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scale_factor"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::sensitive"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tooltip_markup"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::tooltip_text"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::valign"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::vexpand"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::vexpand_set"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::width_request"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class WidgetClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def compute_expand(self) -> compute_expandWidgetClassCB: ...
    @builtins.property
    def contains(self) -> containsWidgetClassCB: ...
    @builtins.property
    def css_changed(self) -> css_changedWidgetClassCB: ...
    @builtins.property
    def direction_changed(self) -> direction_changedWidgetClassCB: ...
    @builtins.property
    def focus(self) -> focusWidgetClassCB: ...
    @builtins.property
    def get_request_mode(self) -> get_request_modeWidgetClassCB: ...
    @builtins.property
    def grab_focus(self) -> grab_focusWidgetClassCB: ...
    @builtins.property
    def hide(self) -> hideWidgetClassCB: ...
    @builtins.property
    def keynav_failed(self) -> keynav_failedWidgetClassCB: ...
    @builtins.property
    def map(self) -> mapWidgetClassCB: ...
    @builtins.property
    def measure(self) -> measureWidgetClassCB: ...
    @builtins.property
    def mnemonic_activate(self) -> mnemonic_activateWidgetClassCB: ...
    @builtins.property
    def move_focus(self) -> move_focusWidgetClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.InitiallyUnownedClass | None: ...
    @builtins.property
    def query_tooltip(self) -> query_tooltipWidgetClassCB: ...
    @builtins.property
    def realize(self) -> realizeWidgetClassCB: ...
    @builtins.property
    def root(self) -> rootWidgetClassCB: ...
    @builtins.property
    def set_focus_child(self) -> set_focus_childWidgetClassCB: ...
    @builtins.property
    def show(self) -> showWidgetClassCB: ...
    @builtins.property
    def size_allocate(self) -> size_allocateWidgetClassCB: ...
    @builtins.property
    def snapshot(self) -> snapshotWidgetClassCB: ...
    @builtins.property
    def state_flags_changed(self) -> state_flags_changedWidgetClassCB: ...
    @builtins.property
    def system_setting_changed(self) -> system_setting_changedWidgetClassCB: ...
    @builtins.property
    def unmap(self) -> unmapWidgetClassCB: ...
    @builtins.property
    def unrealize(self) -> unrealizeWidgetClassCB: ...
    @builtins.property
    def unroot(self) -> unrootWidgetClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_shortcut(self, shortcut: Shortcut) -> None: ...
    def bind_template_callback_full(self, callback_name: str, callback_symbol: GObject.Callback) -> None: ...
    def bind_template_child_full(self, name: str, internal_child: bool, struct_offset: int) -> None: ...
    def get_accessible_role(self) -> AccessibleRole: ...
    def get_activate_signal(self) -> int: ...
    def get_css_name(self) -> str: ...
    def get_layout_manager_type(self) -> GObject.GType: ...
    def install_action(
        self, action_name: str, parameter_type: str | None, activate: WidgetActionActivateFunc
    ) -> None: ...
    def install_property_action(self, action_name: str, property_name: str) -> None: ...
    def query_action(self, index_: int) -> tuple[bool, GObject.GType, str, GLib.VariantType | None, str | None]: ...
    def set_accessible_role(self, accessible_role: AccessibleRole) -> None: ...
    def set_activate_signal(self, signal_id: int) -> None: ...
    def set_activate_signal_from_name(self, signal_name: str) -> None: ...
    def set_css_name(self, name: str) -> None: ...
    def set_layout_manager_type(self, type: GObject.GType) -> None: ...
    def set_template(self, template_bytes: GLib.Bytes) -> None: ...
    def set_template_from_resource(self, resource_name: str) -> None: ...
    def set_template_scope(self, scope: BuilderScope) -> None: ...

class WidgetClassPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class WidgetPaintable(GObject.Object):
    """
    A `GdkPaintable` that displays the contents of a widget.

    `GtkWidgetPaintable` will also take care of the widget not being in a
    state where it can be drawn (like when it isn't shown) and just draw
    nothing or where it does not have a size (like when it is hidden) and
    report no size in that case.

    Of course, `GtkWidgetPaintable` allows you to monitor widgets for size
    changes by emitting the [signal@Gdk.Paintable::invalidate-size] signal
    whenever the size of the widget changes as well as for visual changes by
    emitting the [signal@Gdk.Paintable::invalidate-contents] signal whenever
    the widget changes.

    You can use a `GtkWidgetPaintable` everywhere a `GdkPaintable` is allowed,
    including using it on a `GtkPicture` (or one of its parents) that it was
    set on itself via gtk_picture_set_paintable(). The paintable will take care
    of recursion when this happens. If you do this however, ensure that the
    [property@Gtk.Picture:can-shrink] property is set to %TRUE or you might
    end up with an infinitely growing widget.
    """

    class Props(GObject.Object.Props):
        widget: Widget | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, widget: Widget | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_widget(self) -> Widget | None: ...
    @classmethod
    def new(cls, widget: Widget | None = None) -> WidgetPaintable: ...
    def set_widget(self, widget: Widget | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class WidgetPaintableClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class WidgetPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Window(Widget):
    """
    A toplevel window which can contain other widgets.

    <picture>
      <source srcset="window-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkWindow" src="window.png">
    </picture>

    Windows normally have decorations that are under the control
    of the windowing system and allow the user to manipulate the window
    (resize it, move it, close it,...).

    # GtkWindow as GtkBuildable

    The `GtkWindow` implementation of the [iface@Gtk.Buildable] interface supports
    setting a child as the titlebar by specifying “titlebar” as the “type”
    attribute of a `<child>` element.

    # Shortcuts and Gestures

    `GtkWindow` supports the following keyboard shortcuts:

    - <kbd>F10</kbd> activates the menubar, if present.
    - <kbd>Alt</kbd> makes the mnemonics visible while pressed.

    The following signals have default keybindings:

    - [signal@Gtk.Window::activate-default]
    - [signal@Gtk.Window::activate-focus]
    - [signal@Gtk.Window::enable-debugging]

    # Actions

    `GtkWindow` defines a set of built-in actions:

    - `default.activate` activates the default widget.
    - `window.minimize` minimizes the window.
    - `window.toggle-maximized` maximizes or restores the window.
    - `window.close` closes the window.

    # CSS nodes

    ```
    window.background [.csd / .solid-csd / .ssd] [.maximized / .fullscreen / .tiled]
    ├── <child>
    ╰── <titlebar child>.titlebar [.default-decoration]
    ```

    `GtkWindow` has a main CSS node with name window and style class .background.

    Style classes that are typically used with the main CSS node are .csd (when
    client-side decorations are in use), .solid-csd (for client-side decorations
    without invisible borders), .ssd (used by mutter when rendering server-side
    decorations). GtkWindow also represents window states with the following
    style classes on the main node: .maximized, .fullscreen, .tiled (when supported,
    also .tiled-top, .tiled-left, .tiled-right, .tiled-bottom).

    `GtkWindow` subclasses often add their own discriminating style classes,
    such as .dialog, .popup or .tooltip.

    Generally, some CSS properties don't make sense on the toplevel window node,
    such as margins or padding. When client-side decorations without invisible
    borders are in use (i.e. the .solid-csd style class is added to the
    main window node), the CSS border of the toplevel window is used for
    resize drags. In the .csd case, the shadow area outside of the window
    can be used to resize it.

    `GtkWindow` adds the .titlebar and .default-decoration style classes to the
    widget that is added as a titlebar child.

    # Accessibility

    `GtkWindow` uses the [enum@Gtk.AccessibleRole.window] role.

    From GTK 4.12 to 4.18, it used the [enum@Gtk.AccessibleRole.application] role.
    """

    class Props(Widget.Props):
        application: Application | None
        child: Widget | None
        decorated: bool
        default_height: int  # [default-height]: changed because contained invalid characters
        default_widget: Widget | None  # [default-widget]: changed because contained invalid characters
        default_width: int  # [default-width]: changed because contained invalid characters
        deletable: bool
        destroy_with_parent: bool  # [destroy-with-parent]: changed because contained invalid characters
        display: Gdk.Display | None
        focus_visible: bool  # [focus-visible]: changed because contained invalid characters
        focus_widget: Widget | None  # [focus-widget]: changed because contained invalid characters
        fullscreened: bool
        handle_menubar_accel: bool  # [handle-menubar-accel]: changed because contained invalid characters
        hide_on_close: bool  # [hide-on-close]: changed because contained invalid characters
        icon_name: str  # [icon-name]: changed because contained invalid characters
        is_active: bool  # [is-active]: changed because contained invalid characters
        maximized: bool
        mnemonics_visible: bool  # [mnemonics-visible]: changed because contained invalid characters
        modal: bool
        resizable: bool
        startup_id: str  # [startup-id]: changed because contained invalid characters
        suspended: bool
        title: str
        titlebar: Widget | None
        transient_for: Window | None  # [transient-for]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def close(self) -> None: ...
    def destroy(self) -> None: ...
    def fullscreen(self) -> None: ...
    def fullscreen_on_monitor(self, monitor: Gdk.Monitor) -> None: ...
    @builtins.property
    def get_application(self) -> Application | None: ...
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @builtins.property
    def get_decorated(self) -> bool: ...
    @staticmethod
    def get_default_icon_name() -> str | None: ...
    def get_default_size(self) -> tuple[int | None, int | None]: ...
    @builtins.property
    def get_default_widget(self) -> Widget | None: ...
    @builtins.property
    def get_deletable(self) -> bool: ...
    @builtins.property
    def get_destroy_with_parent(self) -> bool: ...
    @builtins.property
    def get_focus(self) -> Widget | None: ...
    @builtins.property
    def get_focus_visible(self) -> bool: ...
    def get_group(self) -> WindowGroup: ...
    @builtins.property
    def get_handle_menubar_accel(self) -> bool: ...
    @builtins.property
    def get_hide_on_close(self) -> bool: ...
    @builtins.property
    def get_icon_name(self) -> str | None: ...
    @builtins.property
    def get_mnemonics_visible(self) -> bool: ...
    @builtins.property
    def get_modal(self) -> bool: ...
    @builtins.property
    def get_resizable(self) -> bool: ...
    @builtins.property
    def get_title(self) -> str | None: ...
    @builtins.property
    def get_titlebar(self) -> Widget | None: ...
    @staticmethod
    def get_toplevels() -> Gio.ListModel: ...
    @builtins.property
    def get_transient_for(self) -> Window | None: ...
    def has_group(self) -> bool: ...
    @builtins.property
    def is_active(self) -> bool: ...
    @builtins.property
    def is_fullscreen(self) -> bool: ...
    @builtins.property
    def is_maximized(self) -> bool: ...
    @builtins.property
    def is_suspended(self) -> bool: ...
    @staticmethod
    def list_toplevels() -> list: ...
    def maximize(self) -> None: ...
    def minimize(self) -> None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def present(self) -> None: ...
    @deprecated("deprecated")
    def present_with_time(self, timestamp: int) -> None: ...
    def set_application(self, application: Application | None = None) -> None: ...
    @staticmethod
    def set_auto_startup_notification(setting: bool) -> None: ...
    def set_child(self, child: Widget | None = None) -> None: ...
    def set_decorated(self, setting: bool) -> None: ...
    @staticmethod
    def set_default_icon_name(name: str) -> None: ...
    def set_default_size(self, width: int, height: int) -> None: ...
    def set_default_widget(self, default_widget: Widget | None = None) -> None: ...
    def set_deletable(self, setting: bool) -> None: ...
    def set_destroy_with_parent(self, setting: bool) -> None: ...
    def set_display(self, display: Gdk.Display) -> None: ...
    def set_focus(self, focus: Widget | None = None) -> None: ...
    def set_focus_visible(self, setting: bool) -> None: ...
    def set_handle_menubar_accel(self, handle_menubar_accel: bool) -> None: ...
    def set_hide_on_close(self, setting: bool) -> None: ...
    def set_icon_name(self, name: str | None = None) -> None: ...
    @staticmethod
    def set_interactive_debugging(enable: bool) -> None: ...
    def set_mnemonics_visible(self, setting: bool) -> None: ...
    def set_modal(self, modal: bool) -> None: ...
    def set_resizable(self, resizable: bool) -> None: ...
    def set_startup_id(self, startup_id: str) -> None: ...
    def set_title(self, title: str | None = None) -> None: ...
    def set_titlebar(self, titlebar: Widget | None = None) -> None: ...
    def set_transient_for(self, parent: Window | None = None) -> None: ...
    def unfullscreen(self) -> None: ...
    def unmaximize(self) -> None: ...
    def unminimize(self) -> None: ...

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate-default"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate-focus"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["close-request"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["enable-debugging"],
        handler: typing.Callable[[typing_extensions.Self, bool], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["keys-changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::application"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::decorated"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::deletable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::destroy_with_parent"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::display"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::focus_visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::focus_widget"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::fullscreened"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::handle_menubar_accel"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hide_on_close"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::maximized"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::mnemonics_visible"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::modal"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resizable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::startup_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::suspended"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::title"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::titlebar"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::transient_for"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class WindowClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def activate_default(self) -> activate_defaultWindowClassCB: ...
    @builtins.property
    def activate_focus(self) -> activate_focusWindowClassCB: ...
    @builtins.property
    def close_request(self) -> close_requestWindowClassCB: ...
    @builtins.property
    def enable_debugging(self) -> enable_debuggingWindowClassCB: ...
    @builtins.property
    def keys_changed(self) -> keys_changedWindowClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class WindowControls(Widget):
    """
    Shows window frame controls.

    Typical window frame controls are minimize, maximize and close buttons,
    and the window icon.

    <picture>
      <source srcset="windowcontrols-dark.png" media="(prefers-color-scheme: dark)">
      <img alt="An example GtkWindowControls" src="windowcontrols.png">
    </picture>

    `GtkWindowControls` only displays start or end side of the controls (see
    [property@Gtk.WindowControls:side]), so it's intended to be always used
    in pair with another `GtkWindowControls` for the opposite side, for example:

    ```xml
    <object class="GtkBox">
      <child>
        <object class="GtkWindowControls">
          <property name="side">start</property>
        </object>
      </child>

      ...

      <child>
        <object class="GtkWindowControls">
          <property name="side">end</property>
        </object>
      </child>
    </object>
    ```

    # CSS nodes

    ```
    windowcontrols
    ├── [image.icon]
    ├── [button.minimize]
    ├── [button.maximize]
    ╰── [button.close]
    ```

    A `GtkWindowControls`' CSS node is called windowcontrols. It contains
    subnodes corresponding to each title button. Which of the title buttons
    exist and where they are placed exactly depends on the desktop environment
    and [property@Gtk.WindowControls:decoration-layout] value.

    When [property@Gtk.WindowControls:empty] is true, it gets the .empty
    style class.

    # Accessibility

    `GtkWindowControls` uses the [enum@Gtk.AccessibleRole.group] role.
    """

    class Props(Widget.Props):
        decoration_layout: str  # [decoration-layout]: changed because contained invalid characters
        empty: bool
        side: PackType
        use_native_controls: bool  # [use-native-controls]: changed because contained invalid characters

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, decoration_layout: str = ..., side: PackType = ..., use_native_controls: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_decoration_layout(self) -> str | None: ...
    @builtins.property
    def get_empty(self) -> bool: ...
    @builtins.property
    def get_side(self) -> PackType: ...
    @builtins.property
    def get_use_native_controls(self) -> bool: ...
    @classmethod
    def new(cls, side: PackType) -> Widget: ...
    def set_decoration_layout(self, layout: str | None = None) -> None: ...
    def set_side(self, side: PackType) -> None: ...
    def set_use_native_controls(self, setting: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::decoration_layout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::empty"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::side"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_native_controls"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class WindowControlsClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class WindowGroup(GObject.Object):
    """
    Creates groups of windows that behave like separate applications.

    It achieves this by limiting the effect of GTK grabs and modality
    to windows in the same group.

    A window can be a member in at most one window group at a time.
    Windows that have not been explicitly assigned to a group are
    implicitly treated like windows of the default window group.

    `GtkWindowGroup` objects are referenced by each window in the group,
    so once you have added all windows to a `GtkWindowGroup`, you can drop
    the initial reference to the window group with g_object_unref(). If the
    windows in the window group are subsequently destroyed, then they will
    be removed from the window group and drop their references on the window
    group; when all window have been removed, the window group will be
    freed.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_window(self, window: Window) -> None: ...
    def list_windows(self) -> list: ...
    @classmethod
    def new(cls) -> WindowGroup: ...
    def remove_window(self, window: Window) -> None: ...

class WindowGroupClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class WindowGroupPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class WindowHandle(Widget):
    """
    Implements titlebar functionality for a window.

    When added into a window, it can be dragged to move the window,
    and it implements the right click, double click and middle click
    behaviors that are expected of a titlebar.

    # CSS nodes

    `GtkWindowHandle` has a single CSS node with the name `windowhandle`.

    # Accessibility

    Until GTK 4.10, `GtkWindowHandle` used the [enum@Gtk.AccessibleRole.group] role.

    Starting from GTK 4.12, `GtkWindowHandle` uses the [enum@Gtk.AccessibleRole.generic]
    role.
    """

    class Props(Widget.Props):
        child: Widget | None

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, child: Widget | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_child(self) -> Widget | None: ...
    @classmethod
    def new(cls) -> Widget: ...
    def set_child(self, child: Widget | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::child"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class WindowHandleClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> WidgetClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

###############################################################
# Callbacks
###############################################################

class get_at_contextAccessibleInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleInterface.get_at_context
    """
    #  self
    def __call__(
        self: Accessible,
    ) -> ATContext | None: ...

class get_platform_stateAccessibleInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleInterface.get_platform_state
    """
    #  self
    def __call__(
        self: Accessible,
        state: AccessiblePlatformState,
    ) -> bool: ...

class get_accessible_parentAccessibleInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleInterface.get_accessible_parent
    """
    #  self
    def __call__(
        self: Accessible,
    ) -> Accessible | None: ...

class get_first_accessible_childAccessibleInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleInterface.get_first_accessible_child
    """
    #  self
    def __call__(
        self: Accessible,
    ) -> Accessible | None: ...

class get_next_accessible_siblingAccessibleInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleInterface.get_next_accessible_sibling
    """
    #  self
    def __call__(
        self: Accessible,
    ) -> Accessible | None: ...

class get_boundsAccessibleInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleInterface.get_bounds
    """
    #  self
    def __call__(
        self: Accessible,
    ) -> tuple[bool, int, int, int, int]: ...

class set_current_valueAccessibleRangeInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleRangeInterface.set_current_value
    """
    #  self
    def __call__(
        self: AccessibleRange,
        value: float,
    ) -> bool: ...

class get_contentsAccessibleTextInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleTextInterface.get_contents
    """
    #  self
    def __call__(
        self: AccessibleText,
        start: int,
        end: int,
    ) -> GLib.Bytes: ...

class get_contents_atAccessibleTextInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleTextInterface.get_contents_at
    """
    #  self
    def __call__(
        self: AccessibleText,
        offset: int,
        granularity: AccessibleTextGranularity,
    ) -> tuple[GLib.Bytes, int, int]: ...

class get_caret_positionAccessibleTextInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleTextInterface.get_caret_position
    """
    #  self
    def __call__(
        self: AccessibleText,
    ) -> int: ...

class get_selectionAccessibleTextInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleTextInterface.get_selection
    """
    #  self
    def __call__(
        self: AccessibleText,
    ) -> tuple[bool, int, list | None]: ...

class get_attributesAccessibleTextInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleTextInterface.get_attributes
    """
    #  self
    def __call__(
        self: AccessibleText,
        offset: int,
    ) -> tuple[bool, int, list | None, list | None, list | None]: ...

class get_default_attributesAccessibleTextInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleTextInterface.get_default_attributes
    """
    #  self
    def __call__(
        self: AccessibleText,
    ) -> tuple[list | None, list | None]: ...

class get_extentsAccessibleTextInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleTextInterface.get_extents
    """
    #  self
    def __call__(
        self: AccessibleText,
        start: int,
        end: int,
        extents: Graphene.Rect,
    ) -> bool: ...

class get_offsetAccessibleTextInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        AccessibleTextInterface.get_offset
    """
    #  self
    def __call__(
        self: AccessibleText,
        point: Graphene.Point,
    ) -> tuple[bool, int]: ...

class get_action_nameActionableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionableInterface.get_action_name
    """
    #  actionable
    def __call__(
        self,
        actionable: Actionable,
    ) -> str | None: ...

class set_action_nameActionableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionableInterface.set_action_name
    """
    #  actionable
    def __call__(
        self,
        actionable: Actionable,
        action_name: str | None = None,
    ) -> None: ...

class get_action_target_valueActionableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionableInterface.get_action_target_value
    """
    #  actionable
    def __call__(
        self,
        actionable: Actionable,
    ) -> GLib.Variant | None: ...

class set_action_target_valueActionableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionableInterface.set_action_target_value
    """
    #  actionable
    def __call__(
        self,
        actionable: Actionable,
        target_value: GLib.Variant | None = None,
    ) -> None: ...

class changedAdjustmentClassCB(typing.Protocol):
    """
    This callback was used in:
        AdjustmentClass.changed
    """
    #  adjustment
    def __call__(
        self,
        adjustment: Adjustment,
    ) -> None: ...

class value_changedAdjustmentClassCB(typing.Protocol):
    """
    This callback was used in:
        AdjustmentClass.value_changed
    """
    #  adjustment
    def __call__(
        self,
        adjustment: Adjustment,
    ) -> None: ...

class window_addedApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.window_added
    """
    #  application
    def __call__(
        self,
        application: Application,
        window: Window,
    ) -> None: ...

class window_removedApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.window_removed
    """
    #  application
    def __call__(
        self,
        application: Application,
        window: Window,
    ) -> None: ...

class AssistantPageFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_forward_page_func
    """
    #  current_page
    def __call__(
        self,
        current_page: int,
        data: object | None = None,
    ) -> int: ...

class set_idBuildableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuildableIface.set_id
    """
    #  buildable
    def __call__(
        self,
        buildable: Buildable,
        id: str,
    ) -> None: ...

class get_idBuildableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuildableIface.get_id
    """
    #  buildable
    def __call__(
        self,
        buildable: Buildable,
    ) -> str: ...

class add_childBuildableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuildableIface.add_child
    """
    #  buildable
    def __call__(
        self,
        buildable: Buildable,
        builder: Builder,
        child: GObject.Object,
        type: str | None = None,
    ) -> None: ...

class set_buildable_propertyBuildableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuildableIface.set_buildable_property
    """
    #  buildable
    def __call__(
        self,
        buildable: Buildable,
        builder: Builder,
        name: str,
        value: GObject.Value,
    ) -> None: ...

class custom_tag_startBuildableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuildableIface.custom_tag_start
    """
    #  buildable
    def __call__(
        self,
        buildable: Buildable,
        builder: Builder,
        child: GObject.Object | None,
        tagname: str,
    ) -> tuple[bool, BuildableParser, object | None]: ...

class custom_tag_endBuildableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuildableIface.custom_tag_end
    """
    #  buildable
    def __call__(
        self,
        buildable: Buildable,
        builder: Builder,
        child: GObject.Object | None,
        tagname: str,
        data: object | None = None,
    ) -> None: ...

class custom_finishedBuildableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuildableIface.custom_finished
    """
    #  buildable
    def __call__(
        self,
        buildable: Buildable,
        builder: Builder,
        child: GObject.Object | None,
        tagname: str,
        data: object | None = None,
    ) -> None: ...

class parser_finishedBuildableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuildableIface.parser_finished
    """
    #  buildable
    def __call__(
        self,
        buildable: Buildable,
        builder: Builder,
    ) -> None: ...

class get_internal_childBuildableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuildableIface.get_internal_child
    """
    #  buildable
    def __call__(
        self,
        buildable: Buildable,
        builder: Builder,
        childname: str,
    ) -> GObject.Object: ...

class start_elementBuildableParserCB(typing.Protocol):
    """
    This callback was used in:
        BuildableParser.start_element
    """
    #  context
    def __call__(
        self,
        context: BuildableParseContext,
        element_name: str,
        attribute_names: str,
        attribute_values: str,
        user_data: object | None = None,
    ) -> None: ...

class end_elementBuildableParserCB(typing.Protocol):
    """
    This callback was used in:
        BuildableParser.end_element
    """
    #  context
    def __call__(
        self,
        context: BuildableParseContext,
        element_name: str,
        user_data: object | None = None,
    ) -> None: ...

class textBuildableParserCB(typing.Protocol):
    """
    This callback was used in:
        BuildableParser.text
    """
    #  context
    def __call__(
        self,
        context: BuildableParseContext,
        text: str,
        text_len: int,
        user_data: object | None = None,
    ) -> None: ...

class errorBuildableParserCB(typing.Protocol):
    """
    This callback was used in:
        BuildableParser.error
    """
    #  context
    def __call__(
        self,
        context: BuildableParseContext,
        error: None,
        user_data: object | None = None,
    ) -> None: ...

class get_type_from_nameBuilderScopeInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuilderScopeInterface.get_type_from_name
    """
    #  self
    def __call__(
        self: BuilderScope,
        builder: Builder,
        type_name: str,
    ) -> GObject.GType: ...

class get_type_from_functionBuilderScopeInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuilderScopeInterface.get_type_from_function
    """
    #  self
    def __call__(
        self: BuilderScope,
        builder: Builder,
        function_name: str,
    ) -> GObject.GType: ...

class create_closureBuilderScopeInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        BuilderScopeInterface.create_closure
    """
    #  self
    def __call__(
        self: BuilderScope,
        builder: Builder,
        function_name: str,
        flags: BuilderClosureFlags,
        object: GObject.Object,
    ) -> GObject.Closure: ...

class clickedButtonClassCB(typing.Protocol):
    """
    This callback was used in:
        ButtonClass.clicked
    """
    #  button
    def __call__(
        self,
        button: Button,
    ) -> None: ...

class activateButtonClassCB(typing.Protocol):
    """
    This callback was used in:
        ButtonClass.activate
    """
    #  button
    def __call__(
        self,
        button: Button,
    ) -> None: ...

class ShortcutFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.new
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        args: GLib.Variant | None = None,
        user_data: object | None = None,
    ) -> bool: ...

class CellCallback(typing.Protocol):
    """
    This callback was used in:
        Gtk.foreach
    """
    #  renderer
    def __call__(
        self,
        renderer: CellRenderer,
        data: object | None = None,
    ) -> bool: ...

class CellAllocCallback(typing.Protocol):
    """
    This callback was used in:
        Gtk.foreach_alloc
    """
    #  renderer
    def __call__(
        self,
        renderer: CellRenderer,
        cell_area: Gdk.Rectangle,
        cell_background: Gdk.Rectangle,
        data: object | None = None,
    ) -> bool: ...

class addCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.add
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        renderer: CellRenderer,
    ) -> None: ...

class removeCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.remove
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        renderer: CellRenderer,
    ) -> None: ...

class foreachCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.foreach
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        callback: CellCallback,
        callback_data: object | None = None,
    ) -> None: ...

class foreach_allocCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.foreach_alloc
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        context: CellAreaContext,
        widget: Widget,
        cell_area: Gdk.Rectangle,
        background_area: Gdk.Rectangle,
        callback: CellAllocCallback,
        callback_data: object | None = None,
    ) -> None: ...

class eventCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.event
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        context: CellAreaContext,
        widget: Widget,
        event: Gdk.Event,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> int: ...

class snapshotCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.snapshot
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        context: CellAreaContext,
        widget: Widget,
        snapshot: Snapshot,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
        paint_focus: bool,
    ) -> None: ...

class apply_attributesCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.apply_attributes
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        tree_model: TreeModel,
        iter: TreeIter,
        is_expander: bool,
        is_expanded: bool,
    ) -> None: ...

class create_contextCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.create_context
    """
    #  area
    def __call__(
        self,
        area: CellArea,
    ) -> CellAreaContext: ...

class copy_contextCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.copy_context
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        context: CellAreaContext,
    ) -> CellAreaContext: ...

class get_request_modeCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.get_request_mode
    """
    #  area
    def __call__(
        self,
        area: CellArea,
    ) -> SizeRequestMode: ...

class get_preferred_widthCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.get_preferred_width
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        context: CellAreaContext,
        widget: Widget,
    ) -> tuple[int | None, int | None]: ...

class get_preferred_height_for_widthCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.get_preferred_height_for_width
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        context: CellAreaContext,
        widget: Widget,
        width: int,
    ) -> tuple[int | None, int | None]: ...

class get_preferred_heightCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.get_preferred_height
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        context: CellAreaContext,
        widget: Widget,
    ) -> tuple[int | None, int | None]: ...

class get_preferred_width_for_heightCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.get_preferred_width_for_height
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        context: CellAreaContext,
        widget: Widget,
        height: int,
    ) -> tuple[int | None, int | None]: ...

class set_cell_propertyCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.set_cell_property
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        renderer: CellRenderer,
        property_id: int,
        value: GObject.Value,
        pspec: GObject.ParamSpec,
    ) -> None: ...

class get_cell_propertyCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.get_cell_property
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        renderer: CellRenderer,
        property_id: int,
        value: GObject.Value,
        pspec: GObject.ParamSpec,
    ) -> None: ...

class focusCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.focus
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        direction: DirectionType,
    ) -> bool: ...

class is_activatableCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.is_activatable
    """
    #  area
    def __call__(
        self,
        area: CellArea,
    ) -> bool: ...

class activateCellAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaClass.activate
    """
    #  area
    def __call__(
        self,
        area: CellArea,
        context: CellAreaContext,
        widget: Widget,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
        edit_only: bool,
    ) -> bool: ...

class allocateCellAreaContextClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaContextClass.allocate
    """
    #  context
    def __call__(
        self,
        context: CellAreaContext,
        width: int,
        height: int,
    ) -> None: ...

class resetCellAreaContextClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaContextClass.reset
    """
    #  context
    def __call__(
        self,
        context: CellAreaContext,
    ) -> None: ...

class get_preferred_height_for_widthCellAreaContextClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaContextClass.get_preferred_height_for_width
    """
    #  context
    def __call__(
        self,
        context: CellAreaContext,
        width: int,
    ) -> tuple[int | None, int | None]: ...

class get_preferred_width_for_heightCellAreaContextClassCB(typing.Protocol):
    """
    This callback was used in:
        CellAreaContextClass.get_preferred_width_for_height
    """
    #  context
    def __call__(
        self,
        context: CellAreaContext,
        height: int,
    ) -> tuple[int | None, int | None]: ...

class editing_doneCellEditableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellEditableIface.editing_done
    """
    #  cell_editable
    def __call__(
        self,
        cell_editable: CellEditable,
    ) -> None: ...

class remove_widgetCellEditableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellEditableIface.remove_widget
    """
    #  cell_editable
    def __call__(
        self,
        cell_editable: CellEditable,
    ) -> None: ...

class start_editingCellEditableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellEditableIface.start_editing
    """
    #  cell_editable
    def __call__(
        self,
        cell_editable: CellEditable,
        event: Gdk.Event | None = None,
    ) -> None: ...

class CellLayoutDataFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_cell_data_func
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
        cell: CellRenderer,
        tree_model: TreeModel,
        iter: TreeIter,
        data: object | None = None,
    ) -> None: ...

class pack_startCellLayoutIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellLayoutIface.pack_start
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
        cell: CellRenderer,
        expand: bool,
    ) -> None: ...

class pack_endCellLayoutIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellLayoutIface.pack_end
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
        cell: CellRenderer,
        expand: bool,
    ) -> None: ...

class clearCellLayoutIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellLayoutIface.clear
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
    ) -> None: ...

class add_attributeCellLayoutIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellLayoutIface.add_attribute
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
        cell: CellRenderer,
        attribute: str,
        column: int,
    ) -> None: ...

class set_cell_data_funcCellLayoutIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellLayoutIface.set_cell_data_func
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
        cell: CellRenderer,
        func: CellLayoutDataFunc | None,
        func_data: object | None,
        destroy: GLib.DestroyNotify,  # type: ignore
    ) -> None: ...

class clear_attributesCellLayoutIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellLayoutIface.clear_attributes
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
        cell: CellRenderer,
    ) -> None: ...

class reorderCellLayoutIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellLayoutIface.reorder
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
        cell: CellRenderer,
        position: int,
    ) -> None: ...

class get_cellsCellLayoutIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellLayoutIface.get_cells
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
    ) -> list: ...

class get_areaCellLayoutIfaceCB(typing.Protocol):
    """
    This callback was used in:
        CellLayoutIface.get_area
    """
    #  cell_layout
    def __call__(
        self,
        cell_layout: CellLayout,
    ) -> CellArea | None: ...

class get_request_modeCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.get_request_mode
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
    ) -> SizeRequestMode: ...

class get_preferred_widthCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.get_preferred_width
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
        widget: Widget,
    ) -> tuple[int | None, int | None]: ...

class get_preferred_height_for_widthCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.get_preferred_height_for_width
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
        widget: Widget,
        width: int,
    ) -> tuple[int | None, int | None]: ...

class get_preferred_heightCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.get_preferred_height
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
        widget: Widget,
    ) -> tuple[int | None, int | None]: ...

class get_preferred_width_for_heightCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.get_preferred_width_for_height
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
        widget: Widget,
        height: int,
    ) -> tuple[int | None, int | None]: ...

class get_aligned_areaCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.get_aligned_area
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
        widget: Widget,
        flags: CellRendererState,
        cell_area: Gdk.Rectangle,
    ) -> Gdk.Rectangle: ...

class snapshotCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.snapshot
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
        snapshot: Snapshot,
        widget: Widget,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> None: ...

class activateCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.activate
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
        event: Gdk.Event,
        widget: Widget,
        path: str,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> bool: ...

class start_editingCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.start_editing
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
        event: Gdk.Event | None,
        widget: Widget,
        path: str,
        background_area: Gdk.Rectangle,
        cell_area: Gdk.Rectangle,
        flags: CellRendererState,
    ) -> CellEditable | None: ...

class editing_canceledCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.editing_canceled
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
    ) -> None: ...

class editing_startedCellRendererClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererClass.editing_started
    """
    #  cell
    def __call__(
        self,
        cell: CellRenderer,
        editable: CellEditable,
        path: str,
    ) -> None: ...

class editedCellRendererTextClassCB(typing.Protocol):
    """
    This callback was used in:
        CellRendererTextClass.edited
    """
    #  cell_renderer_text
    def __call__(
        self,
        cell_renderer_text: CellRendererText,
        path: str,
        new_text: str,
    ) -> None: ...

class toggledCheckButtonClassCB(typing.Protocol):
    """
    This callback was used in:
        CheckButtonClass.toggled
    """
    #  check_button
    def __call__(
        self,
        check_button: CheckButton,
    ) -> None: ...

class activateCheckButtonClassCB(typing.Protocol):
    """
    This callback was used in:
        CheckButtonClass.activate
    """
    #  check_button
    def __call__(
        self,
        check_button: CheckButton,
    ) -> None: ...

class get_rgbaColorChooserInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ColorChooserInterface.get_rgba
    """
    #  chooser
    def __call__(
        self,
        chooser: ColorChooser,
    ) -> Gdk.RGBA: ...

class set_rgbaColorChooserInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ColorChooserInterface.set_rgba
    """
    #  chooser
    def __call__(
        self,
        chooser: ColorChooser,
        color: Gdk.RGBA,
    ) -> None: ...

class add_paletteColorChooserInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ColorChooserInterface.add_palette
    """
    #  chooser
    def __call__(
        self,
        chooser: ColorChooser,
        orientation: Orientation,
        colors_per_line: int,
        n_colors: int,
        colors: list | None = None,
    ) -> None: ...

class color_activatedColorChooserInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ColorChooserInterface.color_activated
    """
    #  chooser
    def __call__(
        self,
        chooser: ColorChooser,
        color: Gdk.RGBA,
    ) -> None: ...

class TreeViewRowSeparatorFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_row_separator_func
    """
    #  model
    def __call__(
        self,
        model: TreeModel,
        iter: TreeIter,
        data: object | None = None,
    ) -> bool: ...

class changedComboBoxClassCB(typing.Protocol):
    """
    This callback was used in:
        ComboBoxClass.changed
    """
    #  combo_box
    def __call__(
        self,
        combo_box: ComboBox,
    ) -> None: ...

class format_entry_textComboBoxClassCB(typing.Protocol):
    """
    This callback was used in:
        ComboBoxClass.format_entry_text
    """
    #  combo_box
    def __call__(
        self,
        combo_box: ComboBox,
        path: str,
    ) -> str: ...

class activateComboBoxClassCB(typing.Protocol):
    """
    This callback was used in:
        ComboBoxClass.activate
    """
    #  combo_box
    def __call__(
        self,
        combo_box: ComboBox,
    ) -> None: ...

class CustomFilterFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.new, Gtk.set_filter_func
    """
    #  item
    def __call__(
        self,
        item: GObject.Object,
        user_data: object | None = None,
    ) -> bool: ...

class CustomRequestModeFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.new
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> SizeRequestMode: ...

class CustomMeasureFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.new
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        orientation: Orientation,
        for_size: int,
    ) -> tuple[int, int, int, int]: ...

class CustomAllocateFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.new
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        width: int,
        height: int,
        baseline: int,
    ) -> None: ...

class responseDialogClassCB(typing.Protocol):
    """
    This callback was used in:
        DialogClass.response
    """
    #  dialog
    def __call__(
        self,
        dialog: Dialog,
        response_id: int,
    ) -> None: ...

class closeDialogClassCB(typing.Protocol):
    """
    This callback was used in:
        DialogClass.close
    """
    #  dialog
    def __call__(
        self,
        dialog: Dialog,
    ) -> None: ...

class DrawingAreaDrawFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_draw_func
    """
    #  drawing_area
    def __call__(
        self,
        drawing_area: DrawingArea,
        cr: cairo.Context,
        width: int,
        height: int,
        user_data: object | None = None,
    ) -> None: ...

class resizeDrawingAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        DrawingAreaClass.resize
    """
    #  area
    def __call__(
        self,
        area: DrawingArea,
        width: int,
        height: int,
    ) -> None: ...

class insert_textEditableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        EditableInterface.insert_text
    """
    #  editable
    def __call__(
        self,
        editable: Editable,
        text: str,
        length: int,
        position: int,
    ) -> int: ...

class delete_textEditableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        EditableInterface.delete_text
    """
    #  editable
    def __call__(
        self,
        editable: Editable,
        start_pos: int,
        end_pos: int,
    ) -> None: ...

class changedEditableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        EditableInterface.changed
    """
    #  editable
    def __call__(
        self,
        editable: Editable,
    ) -> None: ...

class get_textEditableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        EditableInterface.get_text
    """
    #  editable
    def __call__(
        self,
        editable: Editable,
    ) -> str: ...

class do_insert_textEditableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        EditableInterface.do_insert_text
    """
    #  editable
    def __call__(
        self,
        editable: Editable,
        text: str,
        length: int,
        position: int,
    ) -> int: ...

class do_delete_textEditableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        EditableInterface.do_delete_text
    """
    #  editable
    def __call__(
        self,
        editable: Editable,
        start_pos: int,
        end_pos: int,
    ) -> None: ...

class get_selection_boundsEditableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        EditableInterface.get_selection_bounds
    """
    #  editable
    def __call__(
        self,
        editable: Editable,
    ) -> tuple[bool, int | None, int | None]: ...

class set_selection_boundsEditableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        EditableInterface.set_selection_bounds
    """
    #  editable
    def __call__(
        self,
        editable: Editable,
        start_pos: int,
        end_pos: int,
    ) -> None: ...

class get_delegateEditableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        EditableInterface.get_delegate
    """
    #  editable
    def __call__(
        self,
        editable: Editable,
    ) -> Editable | None: ...

class inserted_textEntryBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        EntryBufferClass.inserted_text
    """
    #  buffer
    def __call__(
        self,
        buffer: EntryBuffer,
        position: int,
        chars: str,
        n_chars: int,
    ) -> None: ...

class deleted_textEntryBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        EntryBufferClass.deleted_text
    """
    #  buffer
    def __call__(
        self,
        buffer: EntryBuffer,
        position: int,
        n_chars: int,
    ) -> None: ...

class get_textEntryBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        EntryBufferClass.get_text
    """
    #  buffer
    def __call__(
        self,
        buffer: EntryBuffer,
        n_bytes: int,
    ) -> str: ...

class get_lengthEntryBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        EntryBufferClass.get_length
    """
    #  buffer
    def __call__(
        self,
        buffer: EntryBuffer,
    ) -> int: ...

class insert_textEntryBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        EntryBufferClass.insert_text
    """
    #  buffer
    def __call__(
        self,
        buffer: EntryBuffer,
        position: int,
        chars: str,
        n_chars: int,
    ) -> int: ...

class delete_textEntryBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        EntryBufferClass.delete_text
    """
    #  buffer
    def __call__(
        self,
        buffer: EntryBuffer,
        position: int,
        n_chars: int,
    ) -> int: ...

class activateEntryClassCB(typing.Protocol):
    """
    This callback was used in:
        EntryClass.activate
    """
    #  entry
    def __call__(
        self,
        entry: Entry,
    ) -> None: ...

class EntryCompletionMatchFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_match_func
    """
    #  completion
    def __call__(
        self,
        completion: EntryCompletion,
        key: str,
        iter: TreeIter,
        user_data: object | None = None,
    ) -> bool: ...

class ExpressionNotify(typing.Protocol):
    """
    This callback was used in:
        Gtk.watch
    """
    #  user_data
    def __call__(
        self,
        user_data: object | None = None,
    ) -> None: ...

class matchFilterClassCB(typing.Protocol):
    """
    This callback was used in:
        FilterClass.match
    """
    #  self
    def __call__(
        self: Filter,
        item: GObject.Object | None = None,
    ) -> bool: ...

class get_strictnessFilterClassCB(typing.Protocol):
    """
    This callback was used in:
        FilterClass.get_strictness
    """
    #  self
    def __call__(
        self: Filter,
    ) -> FilterMatch: ...

class FlowBoxCreateWidgetFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.bind_model
    """
    #  item
    def __call__(
        self,
        item: GObject.Object,
        user_data: object | None = None,
    ) -> Widget: ...

class FlowBoxForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.selected_foreach
    """
    #  box
    def __call__(
        self,
        box: FlowBox,
        child: FlowBoxChild,
        user_data: object | None = None,
    ) -> None: ...

class FlowBoxFilterFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_filter_func
    """
    #  child
    def __call__(
        self,
        child: FlowBoxChild,
        user_data: object | None = None,
    ) -> bool: ...

class FlowBoxSortFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_sort_func
    """
    #  child1
    def __call__(
        self,
        child1: FlowBoxChild,
        child2: FlowBoxChild,
        user_data: object | None = None,
    ) -> int: ...

class activateFlowBoxChildClassCB(typing.Protocol):
    """
    This callback was used in:
        FlowBoxChildClass.activate
    """
    #  child
    def __call__(
        self,
        child: FlowBoxChild,
    ) -> None: ...

class FontFilterFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_filter_func
    """
    #  family
    def __call__(
        self,
        family: Pango.FontFamily,
        face: Pango.FontFace,
        data: object | None = None,
    ) -> bool: ...

class get_font_familyFontChooserIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FontChooserIface.get_font_family
    """
    #  fontchooser
    def __call__(
        self,
        fontchooser: FontChooser,
    ) -> Pango.FontFamily | None: ...

class get_font_faceFontChooserIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FontChooserIface.get_font_face
    """
    #  fontchooser
    def __call__(
        self,
        fontchooser: FontChooser,
    ) -> Pango.FontFace | None: ...

class get_font_sizeFontChooserIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FontChooserIface.get_font_size
    """
    #  fontchooser
    def __call__(
        self,
        fontchooser: FontChooser,
    ) -> int: ...

class set_filter_funcFontChooserIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FontChooserIface.set_filter_func
    """
    #  fontchooser
    def __call__(
        self,
        fontchooser: FontChooser,
        filter: FontFilterFunc | None,
        user_data: object | None,
        destroy: GLib.DestroyNotify,  # type: ignore
    ) -> None: ...

class font_activatedFontChooserIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FontChooserIface.font_activated
    """
    #  chooser
    def __call__(
        self,
        chooser: FontChooser,
        fontname: str,
    ) -> None: ...

class set_font_mapFontChooserIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FontChooserIface.set_font_map
    """
    #  fontchooser
    def __call__(
        self,
        fontchooser: FontChooser,
        fontmap: Pango.FontMap | None = None,
    ) -> None: ...

class get_font_mapFontChooserIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FontChooserIface.get_font_map
    """
    #  fontchooser
    def __call__(
        self,
        fontchooser: FontChooser,
    ) -> Pango.FontMap | None: ...

class compute_child_allocationFrameClassCB(typing.Protocol):
    """
    This callback was used in:
        FrameClass.compute_child_allocation
    """
    #  frame
    def __call__(
        self,
        frame: Frame,
        allocation: Gdk.Rectangle,
    ) -> None: ...

class renderGLAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        GLAreaClass.render
    """
    #  area
    def __call__(
        self,
        area: GLArea,
        context: Gdk.GLContext,
    ) -> bool: ...

class resizeGLAreaClassCB(typing.Protocol):
    """
    This callback was used in:
        GLAreaClass.resize
    """
    #  area
    def __call__(
        self,
        area: GLArea,
        width: int,
        height: int,
    ) -> None: ...

class preedit_startIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.preedit_start
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> None: ...

class preedit_endIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.preedit_end
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> None: ...

class preedit_changedIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.preedit_changed
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> None: ...

class commitIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.commit
    """
    #  context
    def __call__(
        self,
        context: IMContext,
        str: str,
    ) -> None: ...

class retrieve_surroundingIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.retrieve_surrounding
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> bool: ...

class delete_surroundingIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.delete_surrounding
    """
    #  context
    def __call__(
        self,
        context: IMContext,
        offset: int,
        n_chars: int,
    ) -> bool: ...

class set_client_widgetIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.set_client_widget
    """
    #  context
    def __call__(
        self,
        context: IMContext,
        widget: Widget | None = None,
    ) -> None: ...

class get_preedit_stringIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.get_preedit_string
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> tuple[str, Pango.AttrList, int]: ...

class filter_keypressIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.filter_keypress
    """
    #  context
    def __call__(
        self,
        context: IMContext,
        event: Gdk.Event,
    ) -> bool: ...

class focus_inIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.focus_in
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> None: ...

class focus_outIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.focus_out
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> None: ...

class resetIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.reset
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> None: ...

class set_cursor_locationIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.set_cursor_location
    """
    #  context
    def __call__(
        self,
        context: IMContext,
        area: Gdk.Rectangle,
    ) -> None: ...

class set_use_preeditIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.set_use_preedit
    """
    #  context
    def __call__(
        self,
        context: IMContext,
        use_preedit: bool,
    ) -> None: ...

class set_surroundingIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.set_surrounding
    """
    #  context
    def __call__(
        self,
        context: IMContext,
        text: str,
        len: int,
        cursor_index: int,
    ) -> None: ...

class get_surroundingIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.get_surrounding
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> tuple[bool, str, int]: ...

class set_surrounding_with_selectionIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.set_surrounding_with_selection
    """
    #  context
    def __call__(
        self,
        context: IMContext,
        text: str,
        len: int,
        cursor_index: int,
        anchor_index: int,
    ) -> None: ...

class get_surrounding_with_selectionIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.get_surrounding_with_selection
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> tuple[bool, str, int, int]: ...

class activate_oskIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.activate_osk
    """
    #  context
    def __call__(
        self,
        context: IMContext,
    ) -> None: ...

class activate_osk_with_eventIMContextClassCB(typing.Protocol):
    """
    This callback was used in:
        IMContextClass.activate_osk_with_event
    """
    #  context
    def __call__(
        self,
        context: IMContext,
        event: Gdk.Event,
    ) -> bool: ...

class IconViewForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.selected_foreach
    """
    #  icon_view
    def __call__(
        self,
        icon_view: IconView,
        path: TreePath,
        data: object | None = None,
    ) -> None: ...

class get_request_modeLayoutManagerClassCB(typing.Protocol):
    """
    This callback was used in:
        LayoutManagerClass.get_request_mode
    """
    #  manager
    def __call__(
        self,
        manager: LayoutManager,
        widget: Widget,
    ) -> SizeRequestMode: ...

class measureLayoutManagerClassCB(typing.Protocol):
    """
    This callback was used in:
        LayoutManagerClass.measure
    """
    #  manager
    def __call__(
        self,
        manager: LayoutManager,
        widget: Widget,
        orientation: Orientation,
        for_size: int,
    ) -> tuple[int | None, int | None, int | None, int | None]: ...

class allocateLayoutManagerClassCB(typing.Protocol):
    """
    This callback was used in:
        LayoutManagerClass.allocate
    """
    #  manager
    def __call__(
        self,
        manager: LayoutManager,
        widget: Widget,
        width: int,
        height: int,
        baseline: int,
    ) -> None: ...

class create_layout_childLayoutManagerClassCB(typing.Protocol):
    """
    This callback was used in:
        LayoutManagerClass.create_layout_child
    """
    #  manager
    def __call__(
        self,
        manager: LayoutManager,
        widget: Widget,
        for_child: Widget,
    ) -> LayoutChild: ...

class rootLayoutManagerClassCB(typing.Protocol):
    """
    This callback was used in:
        LayoutManagerClass.root
    """
    #  manager
    def __call__(
        self,
        manager: LayoutManager,
    ) -> None: ...

class unrootLayoutManagerClassCB(typing.Protocol):
    """
    This callback was used in:
        LayoutManagerClass.unroot
    """
    #  manager
    def __call__(
        self,
        manager: LayoutManager,
    ) -> None: ...

class ListBoxCreateWidgetFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.bind_model
    """
    #  item
    def __call__(
        self,
        item: GObject.Object,
        user_data: object | None = None,
    ) -> Widget: ...

class ListBoxForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.selected_foreach
    """
    #  box
    def __call__(
        self,
        box: ListBox,
        row: ListBoxRow,
        user_data: object | None = None,
    ) -> None: ...

class ListBoxFilterFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_filter_func
    """
    #  row
    def __call__(
        self,
        row: ListBoxRow,
        user_data: object | None = None,
    ) -> bool: ...

class ListBoxUpdateHeaderFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_header_func
    """
    #  row
    def __call__(
        self,
        row: ListBoxRow,
        before: ListBoxRow | None = None,
        user_data: object | None = None,
    ) -> None: ...

class ListBoxSortFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_sort_func
    """
    #  row1
    def __call__(
        self,
        row1: ListBoxRow,
        row2: ListBoxRow,
        user_data: object | None = None,
    ) -> int: ...

class activateListBoxRowClassCB(typing.Protocol):
    """
    This callback was used in:
        ListBoxRowClass.activate
    """
    #  row
    def __call__(
        self,
        row: ListBoxRow,
    ) -> None: ...

class MapListModelMapFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.new, Gtk.set_map_func
    """
    #  item
    def __call__(
        self,
        item: GObject.Object,
        user_data: object | None = None,
    ) -> GObject.Object: ...

class openMediaFileClassCB(typing.Protocol):
    """
    This callback was used in:
        MediaFileClass.open
    """
    #  self
    def __call__(
        self: MediaFile,
    ) -> None: ...

class closeMediaFileClassCB(typing.Protocol):
    """
    This callback was used in:
        MediaFileClass.close
    """
    #  self
    def __call__(
        self: MediaFile,
    ) -> None: ...

class playMediaStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        MediaStreamClass.play
    """
    #  self
    def __call__(
        self: MediaStream,
    ) -> bool: ...

class pauseMediaStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        MediaStreamClass.pause
    """
    #  self
    def __call__(
        self: MediaStream,
    ) -> None: ...

class seekMediaStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        MediaStreamClass.seek
    """
    #  self
    def __call__(
        self: MediaStream,
        timestamp: int,
    ) -> None: ...

class update_audioMediaStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        MediaStreamClass.update_audio
    """
    #  self
    def __call__(
        self: MediaStream,
        muted: bool,
        volume: float,
    ) -> None: ...

class realizeMediaStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        MediaStreamClass.realize
    """
    #  self
    def __call__(
        self: MediaStream,
        surface: Gdk.Surface,
    ) -> None: ...

class unrealizeMediaStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        MediaStreamClass.unrealize
    """
    #  self
    def __call__(
        self: MediaStream,
        surface: Gdk.Surface,
    ) -> None: ...

class MenuButtonCreatePopupFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_create_popup_func
    """
    #  menu_button
    def __call__(
        self,
        menu_button: MenuButton,
        user_data: object | None = None,
    ) -> None: ...

class responseNativeDialogClassCB(typing.Protocol):
    """
    This callback was used in:
        NativeDialogClass.response
    """
    #  self
    def __call__(
        self: NativeDialog,
        response_id: int,
    ) -> None: ...

class showNativeDialogClassCB(typing.Protocol):
    """
    This callback was used in:
        NativeDialogClass.show
    """
    #  self
    def __call__(
        self: NativeDialog,
    ) -> None: ...

class hideNativeDialogClassCB(typing.Protocol):
    """
    This callback was used in:
        NativeDialogClass.hide
    """
    #  self
    def __call__(
        self: NativeDialog,
    ) -> None: ...

class closedPopoverClassCB(typing.Protocol):
    """
    This callback was used in:
        PopoverClass.closed
    """
    #  popover
    def __call__(
        self,
        popover: Popover,
    ) -> None: ...

class activate_defaultPopoverClassCB(typing.Protocol):
    """
    This callback was used in:
        PopoverClass.activate_default
    """
    #  popover
    def __call__(
        self,
        popover: Popover,
    ) -> None: ...

class PrintJobCompleteFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.send
    """
    #  print_job
    def __call__(
        self,
        print_job: PrintJob,
        user_data: object | None,
        error: None,
    ) -> None: ...

class donePrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.done
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
        result: PrintOperationResult,
    ) -> None: ...

class begin_printPrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.begin_print
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
        context: PrintContext,
    ) -> None: ...

class paginatePrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.paginate
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
        context: PrintContext,
    ) -> bool: ...

class request_page_setupPrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.request_page_setup
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
        context: PrintContext,
        page_nr: int,
        setup: PageSetup,
    ) -> None: ...

class draw_pagePrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.draw_page
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
        context: PrintContext,
        page_nr: int,
    ) -> None: ...

class end_printPrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.end_print
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
        context: PrintContext,
    ) -> None: ...

class status_changedPrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.status_changed
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
    ) -> None: ...

class custom_widget_applyPrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.custom_widget_apply
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
        widget: Widget,
    ) -> None: ...

class previewPrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.preview
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
        preview: PrintOperationPreview,
        context: PrintContext,
        parent: Window,
    ) -> bool: ...

class update_custom_widgetPrintOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationClass.update_custom_widget
    """
    #  operation
    def __call__(
        self,
        operation: PrintOperation,
        widget: Widget,
        setup: PageSetup,
        settings: PrintSettings,
    ) -> None: ...

class readyPrintOperationPreviewIfaceCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationPreviewIface.ready
    """
    #  preview
    def __call__(
        self,
        preview: PrintOperationPreview,
        context: PrintContext,
    ) -> None: ...

class got_page_sizePrintOperationPreviewIfaceCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationPreviewIface.got_page_size
    """
    #  preview
    def __call__(
        self,
        preview: PrintOperationPreview,
        context: PrintContext,
        page_setup: PageSetup,
    ) -> None: ...

class render_pagePrintOperationPreviewIfaceCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationPreviewIface.render_page
    """
    #  preview
    def __call__(
        self,
        preview: PrintOperationPreview,
        page_nr: int,
    ) -> None: ...

class is_selectedPrintOperationPreviewIfaceCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationPreviewIface.is_selected
    """
    #  preview
    def __call__(
        self,
        preview: PrintOperationPreview,
        page_nr: int,
    ) -> bool: ...

class end_previewPrintOperationPreviewIfaceCB(typing.Protocol):
    """
    This callback was used in:
        PrintOperationPreviewIface.end_preview
    """
    #  preview
    def __call__(
        self,
        preview: PrintOperationPreview,
    ) -> None: ...

class PrintSettingsFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.foreach
    """
    #  key
    def __call__(
        self,
        key: str,
        value: str,
        user_data: object | None = None,
    ) -> None: ...

class value_changedRangeClassCB(typing.Protocol):
    """
    This callback was used in:
        RangeClass.value_changed
    """
    #  range
    def __call__(
        self,
        range: Range,
    ) -> None: ...

class adjust_boundsRangeClassCB(typing.Protocol):
    """
    This callback was used in:
        RangeClass.adjust_bounds
    """
    #  range
    def __call__(
        self,
        range: Range,
        new_value: float,
    ) -> None: ...

class move_sliderRangeClassCB(typing.Protocol):
    """
    This callback was used in:
        RangeClass.move_slider
    """
    #  range
    def __call__(
        self,
        range: Range,
        scroll: ScrollType,
    ) -> None: ...

class get_range_borderRangeClassCB(typing.Protocol):
    """
    This callback was used in:
        RangeClass.get_range_border
    """
    #  range
    def __call__(
        self,
        range: Range,
        border_: Border,
    ) -> None: ...

class change_valueRangeClassCB(typing.Protocol):
    """
    This callback was used in:
        RangeClass.change_value
    """
    #  range
    def __call__(
        self,
        range: Range,
        scroll: ScrollType,
        new_value: float,
    ) -> bool: ...

class changedRecentManagerClassCB(typing.Protocol):
    """
    This callback was used in:
        RecentManagerClass.changed
    """
    #  manager
    def __call__(
        self,
        manager: RecentManager,
    ) -> None: ...

class ScaleFormatValueFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_format_value_func
    """
    #  scale
    def __call__(
        self,
        scale: Scale,
        value: float,
        user_data: object | None = None,
    ) -> str: ...

class value_changedScaleButtonClassCB(typing.Protocol):
    """
    This callback was used in:
        ScaleButtonClass.value_changed
    """
    #  button
    def __call__(
        self,
        button: ScaleButton,
        value: float,
    ) -> None: ...

class get_layout_offsetsScaleClassCB(typing.Protocol):
    """
    This callback was used in:
        ScaleClass.get_layout_offsets
    """
    #  scale
    def __call__(
        self,
        scale: Scale,
    ) -> tuple[int | None, int | None]: ...

class get_borderScrollableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ScrollableInterface.get_border
    """
    #  scrollable
    def __call__(
        self,
        scrollable: Scrollable,
    ) -> tuple[bool, Border]: ...

class get_sectionSectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SectionModelInterface.get_section
    """
    #  self
    def __call__(
        self: SectionModel,
        position: int,
    ) -> tuple[int, int]: ...

class is_selectedSelectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SelectionModelInterface.is_selected
    """
    #  model
    def __call__(
        self,
        model: SelectionModel,
        position: int,
    ) -> bool: ...

class get_selection_in_rangeSelectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SelectionModelInterface.get_selection_in_range
    """
    #  model
    def __call__(
        self,
        model: SelectionModel,
        position: int,
        n_items: int,
    ) -> Bitset: ...

class select_itemSelectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SelectionModelInterface.select_item
    """
    #  model
    def __call__(
        self,
        model: SelectionModel,
        position: int,
        unselect_rest: bool,
    ) -> bool: ...

class unselect_itemSelectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SelectionModelInterface.unselect_item
    """
    #  model
    def __call__(
        self,
        model: SelectionModel,
        position: int,
    ) -> bool: ...

class select_rangeSelectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SelectionModelInterface.select_range
    """
    #  model
    def __call__(
        self,
        model: SelectionModel,
        position: int,
        n_items: int,
        unselect_rest: bool,
    ) -> bool: ...

class unselect_rangeSelectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SelectionModelInterface.unselect_range
    """
    #  model
    def __call__(
        self,
        model: SelectionModel,
        position: int,
        n_items: int,
    ) -> bool: ...

class select_allSelectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SelectionModelInterface.select_all
    """
    #  model
    def __call__(
        self,
        model: SelectionModel,
    ) -> bool: ...

class unselect_allSelectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SelectionModelInterface.unselect_all
    """
    #  model
    def __call__(
        self,
        model: SelectionModel,
    ) -> bool: ...

class set_selectionSelectionModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SelectionModelInterface.set_selection
    """
    #  model
    def __call__(
        self,
        model: SelectionModel,
        selected: Bitset,
        mask: Bitset,
    ) -> bool: ...

class add_controllerShortcutManagerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ShortcutManagerInterface.add_controller
    """
    #  self
    def __call__(
        self: ShortcutManager,
        controller: ShortcutController,
    ) -> None: ...

class remove_controllerShortcutManagerInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ShortcutManagerInterface.remove_controller
    """
    #  self
    def __call__(
        self: ShortcutManager,
        controller: ShortcutController,
    ) -> None: ...

class compareSorterClassCB(typing.Protocol):
    """
    This callback was used in:
        SorterClass.compare
    """
    #  self
    def __call__(
        self: Sorter,
        item1: GObject.Object | None = None,
        item2: GObject.Object | None = None,
    ) -> Ordering: ...

class get_orderSorterClassCB(typing.Protocol):
    """
    This callback was used in:
        SorterClass.get_order
    """
    #  self
    def __call__(
        self: Sorter,
    ) -> SorterOrder: ...

class changedStyleContextClassCB(typing.Protocol):
    """
    This callback was used in:
        StyleContextClass.changed
    """
    #  context
    def __call__(
        self,
        context: StyleContext,
    ) -> None: ...

class snapshot_symbolicSymbolicPaintableInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        SymbolicPaintableInterface.snapshot_symbolic
    """
    #  paintable
    def __call__(
        self,
        paintable: SymbolicPaintable,
        snapshot: Gdk.Snapshot,
        width: float,
        height: float,
        colors: list,
        n_colors: int,
    ) -> None: ...

class TextBufferCommitNotify(typing.Protocol):
    """
    This callback was used in:
        Gtk.add_commit_notify
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        flags: TextBufferNotifyFlags,
        position: int,
        length: int,
        user_data: object | None = None,
    ) -> None: ...

class insert_textTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.insert_text
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        pos: TextIter,
        new_text: str,
        new_text_length: int,
    ) -> None: ...

class insert_paintableTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.insert_paintable
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        iter: TextIter,
        paintable: Gdk.Paintable,
    ) -> None: ...

class insert_child_anchorTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.insert_child_anchor
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        iter: TextIter,
        anchor: TextChildAnchor,
    ) -> None: ...

class delete_rangeTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.delete_range
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        start: TextIter,
        end: TextIter,
    ) -> None: ...

class changedTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.changed
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
    ) -> None: ...

class modified_changedTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.modified_changed
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
    ) -> None: ...

class mark_setTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.mark_set
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        location: TextIter,
        mark: TextMark,
    ) -> None: ...

class mark_deletedTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.mark_deleted
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        mark: TextMark,
    ) -> None: ...

class apply_tagTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.apply_tag
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        tag: TextTag,
        start: TextIter,
        end: TextIter,
    ) -> None: ...

class remove_tagTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.remove_tag
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        tag: TextTag,
        start: TextIter,
        end: TextIter,
    ) -> None: ...

class begin_user_actionTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.begin_user_action
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
    ) -> None: ...

class end_user_actionTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.end_user_action
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
    ) -> None: ...

class paste_doneTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.paste_done
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
        clipboard: Gdk.Clipboard,
    ) -> None: ...

class undoTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.undo
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
    ) -> None: ...

class redoTextBufferClassCB(typing.Protocol):
    """
    This callback was used in:
        TextBufferClass.redo
    """
    #  buffer
    def __call__(
        self,
        buffer: TextBuffer,
    ) -> None: ...

class TextCharPredicate(typing.Protocol):
    """
    This callback was used in:
        Gtk.backward_find_char, Gtk.forward_find_char
    """
    #  ch
    def __call__(
        self,
        ch: str,
        user_data: object | None = None,
    ) -> bool: ...

class TextTagTableForeach(typing.Protocol):
    """
    This callback was used in:
        Gtk.foreach
    """
    #  tag
    def __call__(
        self,
        tag: TextTag,
        data: object | None = None,
    ) -> None: ...

class move_cursorTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.move_cursor
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
        step: MovementStep,
        count: int,
        extend_selection: bool,
    ) -> None: ...

class set_anchorTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.set_anchor
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
    ) -> None: ...

class insert_at_cursorTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.insert_at_cursor
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
        str: str,
    ) -> None: ...

class delete_from_cursorTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.delete_from_cursor
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
        type: DeleteType,
        count: int,
    ) -> None: ...

class backspaceTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.backspace
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
    ) -> None: ...

class cut_clipboardTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.cut_clipboard
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
    ) -> None: ...

class copy_clipboardTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.copy_clipboard
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
    ) -> None: ...

class paste_clipboardTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.paste_clipboard
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
    ) -> None: ...

class toggle_overwriteTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.toggle_overwrite
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
    ) -> None: ...

class snapshot_layerTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.snapshot_layer
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
        layer: TextViewLayer,
        snapshot: Snapshot,
    ) -> None: ...

class extend_selectionTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.extend_selection
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
        granularity: TextExtendSelection,
        location: TextIter,
        start: TextIter,
        end: TextIter,
    ) -> bool: ...

class insert_emojiTextViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TextViewClass.insert_emoji
    """
    #  text_view
    def __call__(
        self,
        text_view: TextView,
    ) -> None: ...

class toggledToggleButtonClassCB(typing.Protocol):
    """
    This callback was used in:
        ToggleButtonClass.toggled
    """
    #  toggle_button
    def __call__(
        self,
        toggle_button: ToggleButton,
    ) -> None: ...

class drag_data_receivedTreeDragDestIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeDragDestIface.drag_data_received
    """
    #  drag_dest
    def __call__(
        self,
        drag_dest: TreeDragDest,
        dest: TreePath,
        value: GObject.Value,
    ) -> bool: ...

class row_drop_possibleTreeDragDestIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeDragDestIface.row_drop_possible
    """
    #  drag_dest
    def __call__(
        self,
        drag_dest: TreeDragDest,
        dest_path: TreePath,
        value: GObject.Value,
    ) -> bool: ...

class row_draggableTreeDragSourceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeDragSourceIface.row_draggable
    """
    #  drag_source
    def __call__(
        self,
        drag_source: TreeDragSource,
        path: TreePath,
    ) -> bool: ...

class drag_data_getTreeDragSourceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeDragSourceIface.drag_data_get
    """
    #  drag_source
    def __call__(
        self,
        drag_source: TreeDragSource,
        path: TreePath,
    ) -> Gdk.ContentProvider | None: ...

class drag_data_deleteTreeDragSourceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeDragSourceIface.drag_data_delete
    """
    #  drag_source
    def __call__(
        self,
        drag_source: TreeDragSource,
        path: TreePath,
    ) -> bool: ...

class TreeListModelCreateModelFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.new
    """
    #  item
    def __call__(
        self,
        item: GObject.Object,
        user_data: object | None = None,
    ) -> Gio.ListModel | None: ...

class TreeModelForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.foreach
    """
    #  model
    def __call__(
        self,
        model: TreeModel,
        path: TreePath,
        iter: TreeIter,
        data: object | None = None,
    ) -> bool: ...

class TreeModelFilterModifyFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_modify_func
    """
    #  model
    def __call__(
        self,
        model: TreeModel,
        iter: TreeIter,
        column: int,
        data: object | None = None,
    ) -> GObject.Value: ...

class TreeModelFilterVisibleFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_visible_func
    """
    #  model
    def __call__(
        self,
        model: TreeModel,
        iter: TreeIter,
        data: object | None = None,
    ) -> bool: ...

class visibleTreeModelFilterClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelFilterClass.visible
    """
    #  self
    def __call__(
        self: TreeModelFilter,
        child_model: TreeModel,
        iter: TreeIter,
    ) -> bool: ...

class modifyTreeModelFilterClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelFilterClass.modify
    """
    #  self
    def __call__(
        self: TreeModelFilter,
        child_model: TreeModel,
        iter: TreeIter,
        value: GObject.Value,
        column: int,
    ) -> None: ...

class row_changedTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.row_changed
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        path: TreePath,
        iter: TreeIter,
    ) -> None: ...

class row_insertedTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.row_inserted
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        path: TreePath,
        iter: TreeIter,
    ) -> None: ...

class row_has_child_toggledTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.row_has_child_toggled
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        path: TreePath,
        iter: TreeIter,
    ) -> None: ...

class row_deletedTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.row_deleted
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        path: TreePath,
    ) -> None: ...

class rows_reorderedTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.rows_reordered
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        path: TreePath,
        iter: TreeIter,
        new_order: int,
    ) -> None: ...

class get_flagsTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.get_flags
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
    ) -> TreeModelFlags: ...

class get_n_columnsTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.get_n_columns
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
    ) -> int: ...

class get_column_typeTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.get_column_type
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        index_: int,
    ) -> GObject.GType: ...

class get_iterTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.get_iter
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        path: TreePath,
    ) -> tuple[bool, TreeIter]: ...

class get_pathTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.get_path
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        iter: TreeIter,
    ) -> TreePath: ...

class get_valueTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.get_value
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        iter: TreeIter,
        column: int,
    ) -> GObject.Value: ...

class iter_nextTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.iter_next
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        iter: TreeIter,
    ) -> bool: ...

class iter_previousTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.iter_previous
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        iter: TreeIter,
    ) -> bool: ...

class iter_childrenTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.iter_children
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        parent: TreeIter | None = None,
    ) -> tuple[bool, TreeIter]: ...

class iter_has_childTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.iter_has_child
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        iter: TreeIter,
    ) -> bool: ...

class iter_n_childrenTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.iter_n_children
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        iter: TreeIter | None = None,
    ) -> int: ...

class iter_nth_childTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.iter_nth_child
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        parent: TreeIter | None,
        n: int,
    ) -> tuple[bool, TreeIter]: ...

class iter_parentTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.iter_parent
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        child: TreeIter,
    ) -> tuple[bool, TreeIter]: ...

class ref_nodeTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.ref_node
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        iter: TreeIter,
    ) -> None: ...

class unref_nodeTreeModelIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeModelIface.unref_node
    """
    #  tree_model
    def __call__(
        self,
        tree_model: TreeModel,
        iter: TreeIter,
    ) -> None: ...

class TreeSelectionForeachFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.selected_foreach
    """
    #  model
    def __call__(
        self,
        model: TreeModel,
        path: TreePath,
        iter: TreeIter,
        data: object | None = None,
    ) -> None: ...

class TreeSelectionFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_select_function
    """
    #  selection
    def __call__(
        self,
        selection: TreeSelection,
        model: TreeModel,
        path: TreePath,
        path_currently_selected: bool,
        data: object | None = None,
    ) -> bool: ...

class TreeIterCompareFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_default_sort_func, Gtk.set_sort_func
    """
    #  model
    def __call__(
        self,
        model: TreeModel,
        a: TreeIter,
        b: TreeIter,
        user_data: object | None = None,
    ) -> int: ...

class sort_column_changedTreeSortableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeSortableIface.sort_column_changed
    """
    #  sortable
    def __call__(
        self,
        sortable: TreeSortable,
    ) -> None: ...

class get_sort_column_idTreeSortableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeSortableIface.get_sort_column_id
    """
    #  sortable
    def __call__(
        self,
        sortable: TreeSortable,
    ) -> tuple[bool, int, SortType]: ...

class set_sort_column_idTreeSortableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeSortableIface.set_sort_column_id
    """
    #  sortable
    def __call__(
        self,
        sortable: TreeSortable,
        sort_column_id: int,
        order: SortType,
    ) -> None: ...

class set_sort_funcTreeSortableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeSortableIface.set_sort_func
    """
    #  sortable
    def __call__(
        self,
        sortable: TreeSortable,
        sort_column_id: int,
        sort_func: TreeIterCompareFunc,
        user_data: object | None = None,
        destroy: GLib.DestroyNotify | None = None,  # type: ignore
    ) -> None: ...

class set_default_sort_funcTreeSortableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeSortableIface.set_default_sort_func
    """
    #  sortable
    def __call__(
        self,
        sortable: TreeSortable,
        sort_func: TreeIterCompareFunc,
        user_data: object | None = None,
        destroy: GLib.DestroyNotify | None = None,  # type: ignore
    ) -> None: ...

class has_default_sort_funcTreeSortableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        TreeSortableIface.has_default_sort_func
    """
    #  sortable
    def __call__(
        self,
        sortable: TreeSortable,
    ) -> bool: ...

class TreeCellDataFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.insert_column_with_data_func, Gtk.set_cell_data_func
    """
    #  tree_column
    def __call__(
        self,
        tree_column: TreeViewColumn,
        cell: CellRenderer,
        tree_model: TreeModel,
        iter: TreeIter,
        data: object | None = None,
    ) -> None: ...

class TreeViewMappingFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.map_expanded_rows
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        path: TreePath,
        user_data: object | None = None,
    ) -> None: ...

class TreeViewColumnDropFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_column_drag_function
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        column: TreeViewColumn,
        prev_column: TreeViewColumn,
        next_column: TreeViewColumn,
        data: object | None = None,
    ) -> bool: ...

class TreeViewSearchEqualFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.set_search_equal_func
    """
    #  model
    def __call__(
        self,
        model: TreeModel,
        column: int,
        key: str,
        iter: TreeIter,
        search_data: object | None = None,
    ) -> bool: ...

class row_activatedTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.row_activated
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        path: TreePath,
        column: TreeViewColumn | None = None,
    ) -> None: ...

class test_expand_rowTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.test_expand_row
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        iter: TreeIter,
        path: TreePath,
    ) -> bool: ...

class test_collapse_rowTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.test_collapse_row
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        iter: TreeIter,
        path: TreePath,
    ) -> bool: ...

class row_expandedTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.row_expanded
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        iter: TreeIter,
        path: TreePath,
    ) -> None: ...

class row_collapsedTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.row_collapsed
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        iter: TreeIter,
        path: TreePath,
    ) -> None: ...

class columns_changedTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.columns_changed
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
    ) -> None: ...

class cursor_changedTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.cursor_changed
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
    ) -> None: ...

class move_cursorTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.move_cursor
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        step: MovementStep,
        count: int,
        extend: bool,
        modify: bool,
    ) -> bool: ...

class select_allTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.select_all
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
    ) -> bool: ...

class unselect_allTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.unselect_all
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
    ) -> bool: ...

class select_cursor_rowTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.select_cursor_row
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        start_editing: bool,
    ) -> bool: ...

class toggle_cursor_rowTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.toggle_cursor_row
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
    ) -> bool: ...

class expand_collapse_cursor_rowTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.expand_collapse_cursor_row
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
        logical: bool,
        expand: bool,
        open_all: bool,
    ) -> bool: ...

class select_cursor_parentTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.select_cursor_parent
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
    ) -> bool: ...

class start_interactive_searchTreeViewClassCB(typing.Protocol):
    """
    This callback was used in:
        TreeViewClass.start_interactive_search
    """
    #  tree_view
    def __call__(
        self,
        tree_view: TreeView,
    ) -> bool: ...

class TickCallback(typing.Protocol):
    """
    This callback was used in:
        Gtk.add_tick_callback
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        frame_clock: Gdk.FrameClock,
        user_data: object | None = None,
    ) -> bool: ...

class showWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.show
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> None: ...

class hideWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.hide
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> None: ...

class mapWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.map
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> None: ...

class unmapWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.unmap
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> None: ...

class realizeWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.realize
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> None: ...

class unrealizeWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.unrealize
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> None: ...

class rootWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.root
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> None: ...

class unrootWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.unroot
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> None: ...

class size_allocateWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.size_allocate
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        width: int,
        height: int,
        baseline: int,
    ) -> None: ...

class state_flags_changedWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.state_flags_changed
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        previous_state_flags: StateFlags,
    ) -> None: ...

class direction_changedWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.direction_changed
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        previous_direction: TextDirection,
    ) -> None: ...

class get_request_modeWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.get_request_mode
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> SizeRequestMode: ...

class measureWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.measure
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        orientation: Orientation,
        for_size: int,
    ) -> tuple[int | None, int | None, int | None, int | None]: ...

class mnemonic_activateWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.mnemonic_activate
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        group_cycling: bool,
    ) -> bool: ...

class grab_focusWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.grab_focus
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
    ) -> bool: ...

class focusWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.focus
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        direction: DirectionType,
    ) -> bool: ...

class set_focus_childWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.set_focus_child
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        child: Widget | None = None,
    ) -> None: ...

class move_focusWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.move_focus
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        direction: DirectionType,
    ) -> None: ...

class keynav_failedWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.keynav_failed
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        direction: DirectionType,
    ) -> bool: ...

class query_tooltipWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.query_tooltip
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        x: int,
        y: int,
        keyboard_tooltip: bool,
        tooltip: Tooltip,
    ) -> bool: ...

class compute_expandWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.compute_expand
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        hexpand_p: bool,
        vexpand_p: bool,
    ) -> None: ...

class css_changedWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.css_changed
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        change: CssStyleChange,
    ) -> None: ...

class system_setting_changedWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.system_setting_changed
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        settings: SystemSetting,
    ) -> None: ...

class snapshotWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.snapshot
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        snapshot: Snapshot,
    ) -> None: ...

class containsWidgetClassCB(typing.Protocol):
    """
    This callback was used in:
        WidgetClass.contains
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        x: float,
        y: float,
    ) -> bool: ...

class WidgetActionActivateFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.install_action
    """
    #  widget
    def __call__(
        self,
        widget: Widget,
        action_name: str,
        parameter: GLib.Variant | None = None,
    ) -> None: ...

class activate_focusWindowClassCB(typing.Protocol):
    """
    This callback was used in:
        WindowClass.activate_focus
    """
    #  window
    def __call__(
        self,
        window: Window,
    ) -> None: ...

class activate_defaultWindowClassCB(typing.Protocol):
    """
    This callback was used in:
        WindowClass.activate_default
    """
    #  window
    def __call__(
        self,
        window: Window,
    ) -> None: ...

class keys_changedWindowClassCB(typing.Protocol):
    """
    This callback was used in:
        WindowClass.keys_changed
    """
    #  window
    def __call__(
        self,
        window: Window,
    ) -> None: ...

class enable_debuggingWindowClassCB(typing.Protocol):
    """
    This callback was used in:
        WindowClass.enable_debugging
    """
    #  window
    def __call__(
        self,
        window: Window,
        toggle: bool,
    ) -> bool: ...

class close_requestWindowClassCB(typing.Protocol):
    """
    This callback was used in:
        WindowClass.close_request
    """
    #  window
    def __call__(
        self,
        window: Window,
    ) -> bool: ...

class PrinterFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.enumerate_printers
    """
    #  printer
    def __call__(
        self,
        printer: Printer,
        data: object | None = None,
    ) -> bool: ...

class PageSetupDoneFunc(typing.Protocol):
    """
    This callback was used in:
        Gtk.print_run_page_setup_dialog_async
    """
    #  page_setup
    def __call__(
        self,
        page_setup: PageSetup,
        data: object | None = None,
    ) -> None: ...

###############################################################
# Aliases
###############################################################

Template = gi._gtktemplate.Template  # type: ignore
_extract_handler_and_args = gi._gtktemplate._extract_handler_and_args  # type: ignore
_lock = _thread._lock  # type: ignore
_overrides_module = ...  # this very module ...
###############################################################
# Constants
###############################################################

ACCESSIBLE_ATTRIBUTE_BACKGROUND: str = ...
ACCESSIBLE_ATTRIBUTE_FAMILY: str = ...
ACCESSIBLE_ATTRIBUTE_FOREGROUND: str = ...
ACCESSIBLE_ATTRIBUTE_OVERLINE: str = ...
ACCESSIBLE_ATTRIBUTE_OVERLINE_NONE: str = ...
ACCESSIBLE_ATTRIBUTE_OVERLINE_SINGLE: str = ...
ACCESSIBLE_ATTRIBUTE_SIZE: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH_CONDENSED: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH_EXPANDED: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH_EXTRA_CONDENSED: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH_EXTRA_EXPANDED: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH_NORMAL: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH_SEMI_CONDENSED: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH_SEMI_EXPANDED: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH_ULTRA_CONDENSED: str = ...
ACCESSIBLE_ATTRIBUTE_STRETCH_ULTRA_EXPANDED: str = ...
ACCESSIBLE_ATTRIBUTE_STRIKETHROUGH: str = ...
ACCESSIBLE_ATTRIBUTE_STYLE: str = ...
ACCESSIBLE_ATTRIBUTE_STYLE_ITALIC: str = ...
ACCESSIBLE_ATTRIBUTE_STYLE_NORMAL: str = ...
ACCESSIBLE_ATTRIBUTE_STYLE_OBLIQUE: str = ...
ACCESSIBLE_ATTRIBUTE_UNDERLINE: str = ...
ACCESSIBLE_ATTRIBUTE_UNDERLINE_DOUBLE: str = ...
ACCESSIBLE_ATTRIBUTE_UNDERLINE_ERROR: str = ...
ACCESSIBLE_ATTRIBUTE_UNDERLINE_NONE: str = ...
ACCESSIBLE_ATTRIBUTE_UNDERLINE_SINGLE: str = ...
ACCESSIBLE_ATTRIBUTE_VARIANT: str = ...
ACCESSIBLE_ATTRIBUTE_VARIANT_ALL_PETITE_CAPS: str = ...
ACCESSIBLE_ATTRIBUTE_VARIANT_ALL_SMALL_CAPS: str = ...
ACCESSIBLE_ATTRIBUTE_VARIANT_PETITE_CAPS: str = ...
ACCESSIBLE_ATTRIBUTE_VARIANT_SMALL_CAPS: str = ...
ACCESSIBLE_ATTRIBUTE_VARIANT_TITLE_CAPS: str = ...
ACCESSIBLE_ATTRIBUTE_VARIANT_UNICASE: str = ...
ACCESSIBLE_ATTRIBUTE_WEIGHT: str = ...
ACCESSIBLE_VALUE_UNDEFINED: int = ...
BINARY_AGE: int = ...
IM_MODULE_EXTENSION_POINT_NAME: str = ...
INPUT_ERROR: int = ...
INTERFACE_AGE: int = ...
INVALID_LIST_POSITION: int = ...
LEVEL_BAR_OFFSET_FULL: str = ...
LEVEL_BAR_OFFSET_HIGH: str = ...
LEVEL_BAR_OFFSET_LOW: str = ...
MAJOR_VERSION: int = ...
MAX_COMPOSE_LEN: int = ...
MEDIA_FILE_EXTENSION_POINT_NAME: str = ...
MICRO_VERSION: int = ...
MINOR_VERSION: int = ...
PAPER_NAME_A3: str = ...
PAPER_NAME_A4: str = ...
PAPER_NAME_A5: str = ...
PAPER_NAME_B5: str = ...
PAPER_NAME_EXECUTIVE: str = ...
PAPER_NAME_LEGAL: str = ...
PAPER_NAME_LETTER: str = ...
PRINT_SETTINGS_COLLATE: str = ...
PRINT_SETTINGS_DEFAULT_SOURCE: str = ...
PRINT_SETTINGS_DITHER: str = ...
PRINT_SETTINGS_DUPLEX: str = ...
PRINT_SETTINGS_FINISHINGS: str = ...
PRINT_SETTINGS_MEDIA_TYPE: str = ...
PRINT_SETTINGS_NUMBER_UP: str = ...
PRINT_SETTINGS_NUMBER_UP_LAYOUT: str = ...
PRINT_SETTINGS_N_COPIES: str = ...
PRINT_SETTINGS_ORIENTATION: str = ...
PRINT_SETTINGS_OUTPUT_BASENAME: str = ...
PRINT_SETTINGS_OUTPUT_BIN: str = ...
PRINT_SETTINGS_OUTPUT_DIR: str = ...
PRINT_SETTINGS_OUTPUT_FILE_FORMAT: str = ...
PRINT_SETTINGS_OUTPUT_URI: str = ...
PRINT_SETTINGS_PAGE_RANGES: str = ...
PRINT_SETTINGS_PAGE_SET: str = ...
PRINT_SETTINGS_PAPER_FORMAT: str = ...
PRINT_SETTINGS_PAPER_HEIGHT: str = ...
PRINT_SETTINGS_PAPER_WIDTH: str = ...
PRINT_SETTINGS_PRINTER: str = ...
PRINT_SETTINGS_PRINTER_LPI: str = ...
PRINT_SETTINGS_PRINT_PAGES: str = ...
PRINT_SETTINGS_QUALITY: str = ...
PRINT_SETTINGS_RESOLUTION: str = ...
PRINT_SETTINGS_RESOLUTION_X: str = ...
PRINT_SETTINGS_RESOLUTION_Y: str = ...
PRINT_SETTINGS_REVERSE: str = ...
PRINT_SETTINGS_SCALE: str = ...
PRINT_SETTINGS_USE_COLOR: str = ...
PRINT_SETTINGS_WIN32_DRIVER_EXTRA: str = ...
PRINT_SETTINGS_WIN32_DRIVER_VERSION: str = ...
PRIORITY_RESIZE: int = ...
STYLE_PROVIDER_PRIORITY_APPLICATION: int = ...
STYLE_PROVIDER_PRIORITY_FALLBACK: int = ...
STYLE_PROVIDER_PRIORITY_SETTINGS: int = ...
STYLE_PROVIDER_PRIORITY_THEME: int = ...
STYLE_PROVIDER_PRIORITY_USER: int = ...
TEXT_VIEW_PRIORITY_VALIDATE: int = ...
TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: int = ...
TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: int = ...
_namespace: str = ...
_version: str = ...
###############################################################
# Unknowns/Not Parsed
###############################################################
