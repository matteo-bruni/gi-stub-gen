# pyright: reportIncompatibleMethodOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: GdkPixbuf
Date: 2025-12-24
"""
# we disable method override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401
import gi  # noqa: F401

import typing
import enum
import _thread

# gi.repository imports needed by this Stub
from gi.repository import GModule
from gi.repository import Gio
from gi.repository import GObject
from gi.repository import GLib
###############################################################
# Functions
###############################################################

@staticmethod
def pixbuf_error_quark() -> int: ...

###############################################################
# Enums/Flags
###############################################################

class Colorspace(GObject.GEnum):
    """
    This enumeration defines the color spaces that are supported by
    the gdk-pixbuf library.

    Currently only RGB is supported."""

    RGB = 0
    """
    Indicates a red/green/blue additive color space.
    """

class InterpType(GObject.GEnum):
    """
    Interpolation modes for scaling functions.

    The `GDK_INTERP_NEAREST` mode is the fastest scaling method, but has
    horrible quality when scaling down; `GDK_INTERP_BILINEAR` is the best
    choice if you aren't sure what to choose, it has a good speed/quality
    balance.

    **Note**: Cubic filtering is missing from the list; hyperbolic
    interpolation is just as fast and results in higher quality."""

    NEAREST = 0
    """
    Nearest neighbor sampling; this is the fastest
     and lowest quality mode. Quality is normally unacceptable when scaling
     down, but may be OK when scaling up.
    """
    TILES = 1
    """
    This is an accurate simulation of the PostScript
     image operator without any interpolation enabled.  Each pixel is
     rendered as a tiny parallelogram of solid color, the edges of which
     are implemented with antialiasing.  It resembles nearest neighbor for
     enlargement, and bilinear for reduction.
    """
    BILINEAR = 2
    """
    Best quality/speed balance; use this mode by
     default. Bilinear interpolation.  For enlargement, it is
     equivalent to point-sampling the ideal bilinear-interpolated image.
     For reduction, it is equivalent to laying down small tiles and
     integrating over the coverage area.
    """
    HYPER = 3
    """
    This is the slowest and highest quality
     reconstruction function. It is derived from the hyperbolic filters in
     Wolberg's "Digital Image Warping", and is formally defined as the
     hyperbolic-filter sampling the ideal hyperbolic-filter interpolated
     image (the filter is designed to be idempotent for 1:1 pixel mapping).
     **Deprecated**: this interpolation filter is deprecated, as in reality
     it has a lower quality than the @GDK_INTERP_BILINEAR filter
     (Since: 2.38)
    """

class PixbufAlphaMode(GObject.GEnum):
    """
    Control the alpha channel for drawables.

    These values can be passed to gdk_pixbuf_xlib_render_to_drawable_alpha()
    in gdk-pixbuf-xlib to control how the alpha channel of an image should
    be handled.

    This function can create a bilevel clipping mask (black and white) and use
    it while painting the image.

    In the future, when the X Window System gets an alpha channel extension,
    it will be possible to do full alpha compositing onto arbitrary drawables.
    For now both cases fall back to a bilevel clipping mask."""

    BILEVEL = 0
    """
    A bilevel clipping mask (black and white)
     will be created and used to draw the image.  Pixels below 0.5 opacity
     will be considered fully transparent, and all others will be
     considered fully opaque.
    """
    FULL = 1
    """
    For now falls back to #GDK_PIXBUF_ALPHA_BILEVEL.
     In the future it will do full alpha compositing.
    """

class PixbufError(GObject.GEnum):
    """
    An error code in the `GDK_PIXBUF_ERROR` domain.

    Many gdk-pixbuf operations can cause errors in this domain, or in
    the `G_FILE_ERROR` domain."""

    CORRUPT_IMAGE = 0
    """
    An image file was broken somehow.
    """
    INSUFFICIENT_MEMORY = 1
    """
    Not enough memory.
    """
    BAD_OPTION = 2
    """
    A bad option was passed to a pixbuf save module.
    """
    UNKNOWN_TYPE = 3
    """
    Unknown image type.
    """
    UNSUPPORTED_OPERATION = 4
    """
    Don't know how to perform the
     given operation on the type of image at hand.
    """
    FAILED = 5
    """
    Generic failure code, something went wrong.
    """
    INCOMPLETE_ANIMATION = 6
    """
    Only part of the animation was loaded.
    """

class PixbufFormatFlags(enum.IntFlag):
    """
    Flags which allow a module to specify further details about the supported
    operations."""

    WRITABLE = 1
    """
    the module can write out images in the format.
    """
    SCALABLE = 2
    """
    the image format is scalable
    """
    THREADSAFE = 4
    """
    the module is threadsafe. gdk-pixbuf
        ignores modules that are not marked as threadsafe. (Since 2.28).
    """

class PixbufRotation(GObject.GEnum):
    """
    The possible rotations which can be passed to gdk_pixbuf_rotate_simple().

    To make them easier to use, their numerical values are the actual degrees."""

    NONE = 0
    """
    No rotation.
    """
    COUNTERCLOCKWISE = 90
    """
    Rotate by 90 degrees.
    """
    UPSIDEDOWN = 180
    """
    Rotate by 180 degrees.
    """
    CLOCKWISE = 270
    """
    Rotate by 270 degrees.
    """

###############################################################
# classes
###############################################################

class Pixbuf(GObject.Object):
    """
    A pixel buffer.

    `GdkPixbuf` contains information about an image's pixel data,
    its color space, bits per sample, width and height, and the
    rowstride (the number of bytes between the start of one row
    and the start of the next).

    ## Creating new `GdkPixbuf`

    The most basic way to create a pixbuf is to wrap an existing pixel
    buffer with a [class@GdkPixbuf.Pixbuf] instance. You can use the
    [`ctor@GdkPixbuf.Pixbuf.new_from_data`] function to do this.

    Every time you create a new `GdkPixbuf` instance for some data, you
    will need to specify the destroy notification function that will be
    called when the data buffer needs to be freed; this will happen when
    a `GdkPixbuf` is finalized by the reference counting functions. If
    you have a chunk of static data compiled into your application, you
    can pass in `NULL` as the destroy notification function so that the
    data will not be freed.

    The [`ctor@GdkPixbuf.Pixbuf.new`] constructor function can be used
    as a convenience to create a pixbuf with an empty buffer; this is
    equivalent to allocating a data buffer using `malloc()` and then
    wrapping it with `gdk_pixbuf_new_from_data()`. The `gdk_pixbuf_new()`
    function will compute an optimal rowstride so that rendering can be
    performed with an efficient algorithm.

    As a special case, you can use the [`ctor@GdkPixbuf.Pixbuf.new_from_xpm_data`]
    function to create a pixbuf from inline XPM image data.

    You can also copy an existing pixbuf with the [method@Pixbuf.copy]
    function. This is not the same as just acquiring a reference to
    the old pixbuf instance: the copy function will actually duplicate
    the pixel data in memory and create a new [class@Pixbuf] instance
    for it.

    ## Reference counting

    `GdkPixbuf` structures are reference counted. This means that an
    application can share a single pixbuf among many parts of the
    code. When a piece of the program needs to use a pixbuf, it should
    acquire a reference to it by calling `g_object_ref()`; when it no
    longer needs the pixbuf, it should release the reference it acquired
    by calling `g_object_unref()`. The resources associated with a
    `GdkPixbuf` will be freed when its reference count drops to zero.
    Newly-created `GdkPixbuf` instances start with a reference count
    of one.

    ## Image Data

    Image data in a pixbuf is stored in memory in an uncompressed,
    packed format. Rows in the image are stored top to bottom, and
    in each row pixels are stored from left to right.

    There may be padding at the end of a row.

    The "rowstride" value of a pixbuf, as returned by [`method@GdkPixbuf.Pixbuf.get_rowstride`],
    indicates the number of bytes between rows.

    **NOTE**: If you are copying raw pixbuf data with `memcpy()` note that the
    last row in the pixbuf may not be as wide as the full rowstride, but rather
    just as wide as the pixel data needs to be; that is: it is unsafe to do
    `memcpy (dest, pixels, rowstride * height)` to copy a whole pixbuf. Use
    [method@GdkPixbuf.Pixbuf.copy] instead, or compute the width in bytes of the
    last row as:

    ```c
    last_row = width * ((n_channels * bits_per_sample + 7) / 8);
    ```

    The same rule applies when iterating over each row of a `GdkPixbuf` pixels
    array.

    The following code illustrates a simple `put_pixel()`
    function for RGB pixbufs with 8 bits per channel with an alpha
    channel.

    ```c
    static void
    put_pixel (GdkPixbuf *pixbuf,
               int x,
               int y,
               guchar red,
               guchar green,
               guchar blue,
               guchar alpha)
    {
      int n_channels = gdk_pixbuf_get_n_channels (pixbuf);

      // Ensure that the pixbuf is valid
      g_assert (gdk_pixbuf_get_colorspace (pixbuf) == GDK_COLORSPACE_RGB);
      g_assert (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
      g_assert (gdk_pixbuf_get_has_alpha (pixbuf));
      g_assert (n_channels == 4);

      int width = gdk_pixbuf_get_width (pixbuf);
      int height = gdk_pixbuf_get_height (pixbuf);

      // Ensure that the coordinates are in a valid range
      g_assert (x >= 0 && x < width);
      g_assert (y >= 0 && y < height);

      int rowstride = gdk_pixbuf_get_rowstride (pixbuf);

      // The pixel buffer in the GdkPixbuf instance
      guchar *pixels = gdk_pixbuf_get_pixels (pixbuf);

      // The pixel we wish to modify
      guchar *p = pixels + y * rowstride + x * n_channels;
      p[0] = red;
      p[1] = green;
      p[2] = blue;
      p[3] = alpha;
    }
    ```

    ## Loading images

    The `GdkPixBuf` class provides a simple mechanism for loading
    an image from a file in synchronous and asynchronous fashion.

    For GUI applications, it is recommended to use the asynchronous
    stream API to avoid blocking the control flow of the application.

    Additionally, `GdkPixbuf` provides the [class@GdkPixbuf.PixbufLoader`]
    API for progressive image loading.

    ## Saving images

    The `GdkPixbuf` class provides methods for saving image data in
    a number of file formats. The formatted data can be written to a
    file or to a memory buffer. `GdkPixbuf` can also call a user-defined
    callback on the data, which allows to e.g. write the image
    to a socket or store it in a database.
    """

    class Props(GObject.Object.Props):
        bits_per_sample: int  # [bits-per-sample]: changed because contained invalid characters
        colorspace: Colorspace
        has_alpha: bool  # [has-alpha]: changed because contained invalid characters
        height: int
        n_channels: int  # [n-channels]: changed because contained invalid characters
        pixel_bytes: GLib.Bytes | None  # [pixel-bytes]: changed because contained invalid characters
        pixels: object | None
        rowstride: int
        width: int

    # gi Methods
    def __init__(
        self,
        bits_per_sample: int = ...,
        colorspace: Colorspace = ...,
        has_alpha: bool = ...,
        height: int = ...,
        n_channels: int = ...,
        pixel_bytes: GLib.Bytes | None = ...,
        pixels: object | None = ...,
        rowstride: int = ...,
        width: int = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_alpha(self, substitute_color: bool, r: int, g: int, b: int) -> Pixbuf | None: ...
    def apply_embedded_orientation(self) -> Pixbuf | None: ...
    @staticmethod
    def calculate_rowstride(
        colorspace: Colorspace, has_alpha: bool, bits_per_sample: int, width: int, height: int
    ) -> int: ...
    def composite(
        self,
        dest: Pixbuf,
        dest_x: int,
        dest_y: int,
        dest_width: int,
        dest_height: int,
        offset_x: float,
        offset_y: float,
        scale_x: float,
        scale_y: float,
        interp_type: InterpType,
        overall_alpha: int,
    ) -> None: ...
    def composite_color(
        self,
        dest: Pixbuf,
        dest_x: int,
        dest_y: int,
        dest_width: int,
        dest_height: int,
        offset_x: float,
        offset_y: float,
        scale_x: float,
        scale_y: float,
        interp_type: InterpType,
        overall_alpha: int,
        check_x: int,
        check_y: int,
        check_size: int,
        color1: int,
        color2: int,
    ) -> None: ...
    def composite_color_simple(
        self,
        dest_width: int,
        dest_height: int,
        interp_type: InterpType,
        overall_alpha: int,
        check_size: int,
        color1: int,
        color2: int,
    ) -> Pixbuf | None: ...
    def copy(self) -> Pixbuf | None: ...
    def copy_area(
        self, src_x: int, src_y: int, width: int, height: int, dest_pixbuf: Pixbuf, dest_x: int, dest_y: int
    ) -> None: ...
    def copy_options(self, dest_pixbuf: Pixbuf) -> bool: ...
    def fill(self, pixel: int) -> None: ...
    def flip(self, horizontal: bool) -> Pixbuf | None: ...
    @property
    def get_bits_per_sample(self) -> int: ...
    def get_byte_length(self) -> int: ...
    @property
    def get_colorspace(self) -> Colorspace: ...
    @staticmethod
    def get_file_info(filename: str) -> tuple[PixbufFormat | None, int | None, int | None]: ...
    @staticmethod
    def get_file_info_async(
        filename: str,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @staticmethod
    def get_file_info_finish(async_result: Gio.AsyncResult) -> tuple[PixbufFormat | None, int, int]: ...
    @staticmethod
    def get_formats() -> list: ...
    @property
    def get_has_alpha(self) -> bool: ...
    @property
    def get_height(self) -> int: ...
    @property
    def get_n_channels(self) -> int: ...
    def get_option(self, key: str) -> str | None: ...
    def get_options(self) -> dict: ...
    def get_pixels(self) -> tuple[list, int]: ...
    @property
    def get_rowstride(self) -> int: ...
    @property
    def get_width(self) -> int: ...
    @staticmethod
    def init_modules(path: str) -> bool: ...
    @classmethod
    def new(
        cls, colorspace: Colorspace, has_alpha: bool, bits_per_sample: int, width: int, height: int
    ) -> Pixbuf | None: ...
    @classmethod
    def new_from_bytes(
        cls,
        data: GLib.Bytes,
        colorspace: Colorspace,
        has_alpha: bool,
        bits_per_sample: int,
        width: int,
        height: int,
        rowstride: int,
    ) -> Pixbuf: ...
    @classmethod
    def new_from_data(
        cls,
        data: list,
        colorspace: Colorspace,
        has_alpha: bool,
        bits_per_sample: int,
        width: int,
        height: int,
        rowstride: int,
        destroy_fn: PixbufDestroyNotify | None = None,
        destroy_fn_data: object | None = None,
    ) -> Pixbuf: ...
    @classmethod
    def new_from_file(cls, filename: str) -> Pixbuf | None: ...
    @classmethod
    def new_from_file_at_scale(
        cls, filename: str, width: int, height: int, preserve_aspect_ratio: bool
    ) -> Pixbuf | None: ...
    @classmethod
    def new_from_file_at_size(cls, filename: str, width: int, height: int) -> Pixbuf | None: ...
    @deprecated("deprecated")
    @classmethod
    def new_from_inline(cls, data_length: int, data: list, copy_pixels: bool) -> Pixbuf: ...
    @classmethod
    def new_from_resource(cls, resource_path: str) -> Pixbuf | None: ...
    @classmethod
    def new_from_resource_at_scale(
        cls, resource_path: str, width: int, height: int, preserve_aspect_ratio: bool
    ) -> Pixbuf | None: ...
    @classmethod
    def new_from_stream(cls, stream: Gio.InputStream, cancellable: Gio.Cancellable | None = None) -> Pixbuf | None: ...
    @staticmethod
    def new_from_stream_async(
        stream: Gio.InputStream,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @classmethod
    def new_from_stream_at_scale(
        cls,
        stream: Gio.InputStream,
        width: int,
        height: int,
        preserve_aspect_ratio: bool,
        cancellable: Gio.Cancellable | None = None,
    ) -> Pixbuf | None: ...
    @staticmethod
    def new_from_stream_at_scale_async(
        stream: Gio.InputStream,
        width: int,
        height: int,
        preserve_aspect_ratio: bool,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @classmethod
    def new_from_stream_finish(cls, async_result: Gio.AsyncResult) -> Pixbuf | None: ...
    @classmethod
    def new_from_xpm_data(cls, data: list) -> Pixbuf | None: ...
    def new_subpixbuf(self, src_x: int, src_y: int, width: int, height: int) -> Pixbuf: ...
    def read_pixel_bytes(self) -> GLib.Bytes: ...
    def read_pixels(self) -> int: ...
    def remove_option(self, key: str) -> bool: ...
    def rotate_simple(self, angle: PixbufRotation) -> Pixbuf | None: ...
    def saturate_and_pixelate(self, dest: Pixbuf, saturation: float, pixelate: bool) -> None: ...
    def save_to_bufferv(
        self, type: str, option_keys: list | None = None, option_values: list | None = None
    ) -> tuple[bool, list, int]: ...
    def save_to_callbackv(
        self,
        save_func: PixbufSaveFunc,
        user_data: object | None,
        type: str,
        option_keys: list | None = None,
        option_values: list | None = None,
    ) -> bool: ...
    @staticmethod
    def save_to_stream_finish(async_result: Gio.AsyncResult) -> bool: ...
    def save_to_streamv(
        self,
        stream: Gio.OutputStream,
        type: str,
        option_keys: list | None = None,
        option_values: list | None = None,
        cancellable: Gio.Cancellable | None = None,
    ) -> bool: ...
    def save_to_streamv_async(
        self,
        stream: Gio.OutputStream,
        type: str,
        option_keys: list | None = None,
        option_values: list | None = None,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def savev(
        self, filename: str, type: str, option_keys: list | None = None, option_values: list | None = None
    ) -> bool: ...
    def scale(
        self,
        dest: Pixbuf,
        dest_x: int,
        dest_y: int,
        dest_width: int,
        dest_height: int,
        offset_x: float,
        offset_y: float,
        scale_x: float,
        scale_y: float,
        interp_type: InterpType,
    ) -> None: ...
    def scale_simple(self, dest_width: int, dest_height: int, interp_type: InterpType) -> Pixbuf | None: ...
    def set_option(self, key: str, value: str) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::bits_per_sample"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::colorspace"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_alpha"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::height"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_channels"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixel_bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pixels"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rowstride"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::width"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class PixbufAnimation(GObject.Object):
    """
    An opaque object representing an animation.

    The GdkPixBuf library provides a simple mechanism to load and
    represent animations. An animation is conceptually a series of
    frames to be displayed over time.

    The animation may not be represented as a series of frames
    internally; for example, it may be stored as a sprite and
    instructions for moving the sprite around a background.

    To display an animation you don't need to understand its
    representation, however; you just ask `GdkPixbuf` what should
    be displayed at a given point in time.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_height(self) -> int: ...
    def get_iter(self, start_time: GLib.TimeVal | None = None) -> PixbufAnimationIter: ...
    def get_static_image(self) -> Pixbuf: ...
    def get_width(self) -> int: ...
    def is_static_image(self) -> bool: ...
    @classmethod
    def new_from_file(cls, filename: str) -> PixbufAnimation | None: ...
    @classmethod
    def new_from_resource(cls, resource_path: str) -> PixbufAnimation | None: ...
    @classmethod
    def new_from_stream(
        cls, stream: Gio.InputStream, cancellable: Gio.Cancellable | None = None
    ) -> PixbufAnimation | None: ...
    @staticmethod
    def new_from_stream_async(
        stream: Gio.InputStream,
        cancellable: Gio.Cancellable | None = None,
        callback: Gio.AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @classmethod
    def new_from_stream_finish(cls, async_result: Gio.AsyncResult) -> PixbufAnimation | None: ...

    # python methods (overrides?)
    def do_get_iter(
        self,
        start_time: GLib.TimeVal | None = None,
    ) -> PixbufAnimationIter:
        """
        get_iter(self, start_time:GLib.TimeVal=None) -> GdkPixbuf.PixbufAnimationIter
        """
    def do_get_size(
        self,
        width: int,
        height: int,
    ) -> None:
        """
        get_size(self, width:int, height:int)
        """
    def do_get_static_image(
        self,
    ) -> Pixbuf:
        """
        get_static_image(self) -> GdkPixbuf.Pixbuf
        """
    def do_is_static_image(
        self,
    ) -> bool:
        """
        is_static_image(self) -> bool
        """

    ...

class PixbufAnimationClass(GObject.GPointer):
    # gi Fields
    @property
    def get_iter(self) -> get_iterPixbufAnimationClassCB: ...
    @property
    def get_size(self) -> get_sizePixbufAnimationClassCB: ...
    @property
    def get_static_image(self) -> get_static_imagePixbufAnimationClassCB: ...
    @property
    def is_static_image(self) -> is_static_imagePixbufAnimationClassCB: ...
    @property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PixbufAnimationIter(GObject.Object):
    """
    An opaque object representing an iterator which points to a
    certain position in an animation.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def advance(self, current_time: GLib.TimeVal | None = None) -> bool: ...
    def get_delay_time(self) -> int: ...
    def get_pixbuf(self) -> Pixbuf: ...
    def on_currently_loading_frame(self) -> bool: ...

    # python methods (overrides?)
    def do_advance(
        self,
        current_time: GLib.TimeVal | None = None,
    ) -> bool:
        """
        advance(self, current_time:GLib.TimeVal=None) -> bool
        """
    def do_get_delay_time(
        self,
    ) -> int:
        """
        get_delay_time(self) -> int
        """
    def do_get_pixbuf(
        self,
    ) -> Pixbuf:
        """
        get_pixbuf(self) -> GdkPixbuf.Pixbuf
        """
    def do_on_currently_loading_frame(
        self,
    ) -> bool:
        """
        on_currently_loading_frame(self) -> bool
        """

    ...

class PixbufAnimationIterClass(GObject.GPointer):
    # gi Fields
    @property
    def advance(self) -> advancePixbufAnimationIterClassCB: ...
    @property
    def get_delay_time(self) -> get_delay_timePixbufAnimationIterClassCB: ...
    @property
    def get_pixbuf(self) -> get_pixbufPixbufAnimationIterClassCB: ...
    @property
    def on_currently_loading_frame(self) -> on_currently_loading_framePixbufAnimationIterClassCB: ...
    @property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PixbufFormat(GObject.GBoxed):
    # gi Fields
    description: str = ...
    disabled: bool = ...
    domain: str = ...
    extensions: list | None = ...
    flags: int = ...
    license: str = ...
    mime_types: list | None = ...
    name: str = ...
    signature: PixbufModulePattern | None = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def copy(self) -> PixbufFormat | None: ...
    def free(self) -> None: ...
    def get_description(self) -> str | None: ...
    def get_extensions(self) -> list | None: ...
    def get_license(self) -> str | None: ...
    def get_mime_types(self) -> list | None: ...
    def get_name(self) -> str | None: ...
    def is_disabled(self) -> bool: ...
    def is_save_option_supported(self, option_key: str) -> bool: ...
    def is_scalable(self) -> bool: ...
    def is_writable(self) -> bool: ...
    def set_disabled(self, disabled: bool) -> None: ...

    ...

class PixbufLoader(GObject.Object):
    """
    Incremental image loader.

    `GdkPixbufLoader` provides a way for applications to drive the
    process of loading an image, by letting them send the image data
    directly to the loader instead of having the loader read the data
    from a file. Applications can use this functionality instead of
    `gdk_pixbuf_new_from_file()` or `gdk_pixbuf_animation_new_from_file()`
    when they need to parse image data in small chunks. For example,
    it should be used when reading an image from a (potentially) slow
    network connection, or when loading an extremely large file.

    To use `GdkPixbufLoader` to load an image, create a new instance,
    and call [method@GdkPixbuf.PixbufLoader.write] to send the data
    to it. When done, [method@GdkPixbuf.PixbufLoader.close] should be
    called to end the stream and finalize everything.

    The loader will emit three important signals throughout the process:

     - [signal@GdkPixbuf.PixbufLoader::size-prepared] will be emitted as
       soon as the image has enough information to determine the size of
       the image to be used. If you want to scale the image while loading
       it, you can call [method@GdkPixbuf.PixbufLoader.set_size] in
       response to this signal.
     - [signal@GdkPixbuf.PixbufLoader::area-prepared] will be emitted as
       soon as the pixbuf of the desired has been allocated. You can obtain
       the `GdkPixbuf` instance by calling [method@GdkPixbuf.PixbufLoader.get_pixbuf].
       If you want to use it, simply acquire a reference to it. You can
       also call `gdk_pixbuf_loader_get_pixbuf()` later to get the same
       pixbuf.
     - [signal@GdkPixbuf.PixbufLoader::area-updated] will be emitted every
       time a region is updated. This way you can update a partially
       completed image. Note that you do not know anything about the
       completeness of an image from the updated area. For example, in an
       interlaced image you will need to make several passes before the
       image is done loading.

    ## Loading an animation

    Loading an animation is almost as easy as loading an image. Once the
    first [signal@GdkPixbuf.PixbufLoader::area-prepared] signal has been
    emitted, you can call [method@GdkPixbuf.PixbufLoader.get_animation] to
    get the [class@GdkPixbuf.PixbufAnimation] instance, and then call
    and [method@GdkPixbuf.PixbufAnimation.get_iter] to get a
    [class@GdkPixbuf.PixbufAnimationIter] to retrieve the pixbuf for the
    desired time stamp.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def close(self) -> bool: ...
    def get_animation(self) -> PixbufAnimation | None: ...
    def get_format(self) -> PixbufFormat | None: ...
    def get_pixbuf(self) -> Pixbuf | None: ...
    @classmethod
    def new(cls) -> PixbufLoader: ...
    @classmethod
    def new_with_mime_type(cls, mime_type: str) -> PixbufLoader: ...
    @classmethod
    def new_with_type(cls, image_type: str) -> PixbufLoader: ...
    def set_size(self, width: int, height: int) -> None: ...
    def write(self, buf: list, count: int) -> bool: ...
    def write_bytes(self, buffer: GLib.Bytes) -> bool: ...

    # python methods (overrides?)
    def do_area_prepared(
        self,
    ) -> None:
        """
        area_prepared(self)
        """
    def do_area_updated(
        self,
        x: int,
        y: int,
        width: int,
        height: int,
    ) -> None:
        """
        area_updated(self, x:int, y:int, width:int, height:int)
        """
    def do_closed(
        self,
    ) -> None:
        """
        closed(self)
        """
    def do_size_prepared(
        self,
        width: int,
        height: int,
    ) -> None:
        """
        size_prepared(self, width:int, height:int)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["area-prepared"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["area-updated"],
        handler: typing.Callable[[typing_extensions.Self, int, int, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["closed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["size-prepared"],
        handler: typing.Callable[[typing_extensions.Self, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class PixbufLoaderClass(GObject.GPointer):
    # gi Fields
    @property
    def area_prepared(self) -> area_preparedPixbufLoaderClassCB: ...
    @property
    def area_updated(self) -> area_updatedPixbufLoaderClassCB: ...
    @property
    def closed(self) -> closedPixbufLoaderClassCB: ...
    @property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @property
    def size_prepared(self) -> size_preparedPixbufLoaderClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PixbufModule(GObject.GPointer):
    # gi Fields
    info: PixbufFormat | None = ...
    is_save_option_supported: PixbufModuleSaveOptionSupportedFuncPixbufModuleCB = ...
    load: PixbufModuleLoadFuncPixbufModuleCB = ...
    load_animation: PixbufModuleLoadAnimationFuncPixbufModuleCB = ...
    load_increment: PixbufModuleIncrementLoadFuncPixbufModuleCB = ...
    load_xpm_data: PixbufModuleLoadXpmDataFuncPixbufModuleCB = ...
    module: GModule.Module | None = ...  # type: ignore
    module_name: str = ...
    module_path: str = ...
    save: PixbufModuleSaveFuncPixbufModuleCB = ...
    stop_load: PixbufModuleStopLoadFuncPixbufModuleCB = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PixbufModulePattern(GObject.GPointer):
    # gi Fields
    mask: str = ...
    prefix: str = ...
    relevance: int = ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PixbufNonAnim(PixbufAnimation):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, pixbuf: Pixbuf) -> PixbufAnimation: ...

    ...

class PixbufSimpleAnim(PixbufAnimation):
    """
    An opaque struct representing a simple animation.
    """

    class Props(PixbufAnimation.Props):
        loop: bool

    # gi Methods
    def __init__(self, loop: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_frame(self, pixbuf: Pixbuf) -> None: ...
    @property
    def get_loop(self) -> bool: ...
    @classmethod
    def new(cls, width: int, height: int, rate: float) -> PixbufSimpleAnim: ...
    def set_loop(self, loop: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::loop"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...
    ...

class PixbufSimpleAnimClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PixbufSimpleAnimIter(PixbufAnimationIter):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

###############################################################
# Callbacks
###############################################################

class PixbufDestroyNotify(typing.Protocol):
    """
    This callback was used in:
        GdkPixbuf.new_from_data
    """
    #  pixels
    def __call__(
        self,
        pixels: list,
        data: object | None = None,
    ) -> None: ...

class PixbufSaveFunc(typing.Protocol):
    """
    This callback was used in:
        GdkPixbuf.save_to_callbackv
    """
    #  buf
    def __call__(
        self,
        buf: list,
        count: int,
        data: object | None = None,
    ) -> tuple[bool, None]: ...

class is_static_imagePixbufAnimationClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufAnimationClass.is_static_image
    """
    #  animation
    def __call__(
        self,
        animation: PixbufAnimation,
    ) -> bool: ...

class get_static_imagePixbufAnimationClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufAnimationClass.get_static_image
    """
    #  animation
    def __call__(
        self,
        animation: PixbufAnimation,
    ) -> Pixbuf: ...

class get_sizePixbufAnimationClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufAnimationClass.get_size
    """
    #  animation
    def __call__(
        self,
        animation: PixbufAnimation,
        width: int,
        height: int,
    ) -> None: ...

class get_iterPixbufAnimationClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufAnimationClass.get_iter
    """
    #  animation
    def __call__(
        self,
        animation: PixbufAnimation,
        start_time: GLib.TimeVal | None = None,
    ) -> PixbufAnimationIter: ...

class get_delay_timePixbufAnimationIterClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufAnimationIterClass.get_delay_time
    """
    #  iter
    def __call__(
        self,
        iter: PixbufAnimationIter,
    ) -> int: ...

class get_pixbufPixbufAnimationIterClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufAnimationIterClass.get_pixbuf
    """
    #  iter
    def __call__(
        self,
        iter: PixbufAnimationIter,
    ) -> Pixbuf: ...

class on_currently_loading_framePixbufAnimationIterClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufAnimationIterClass.on_currently_loading_frame
    """
    #  iter
    def __call__(
        self,
        iter: PixbufAnimationIter,
    ) -> bool: ...

class advancePixbufAnimationIterClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufAnimationIterClass.advance
    """
    #  iter
    def __call__(
        self,
        iter: PixbufAnimationIter,
        current_time: GLib.TimeVal | None = None,
    ) -> bool: ...

class size_preparedPixbufLoaderClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufLoaderClass.size_prepared
    """
    #  loader
    def __call__(
        self,
        loader: PixbufLoader,
        width: int,
        height: int,
    ) -> None: ...

class area_preparedPixbufLoaderClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufLoaderClass.area_prepared
    """
    #  loader
    def __call__(
        self,
        loader: PixbufLoader,
    ) -> None: ...

class area_updatedPixbufLoaderClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufLoaderClass.area_updated
    """
    #  loader
    def __call__(
        self,
        loader: PixbufLoader,
        x: int,
        y: int,
        width: int,
        height: int,
    ) -> None: ...

class closedPixbufLoaderClassCB(typing.Protocol):
    """
    This callback was used in:
        PixbufLoaderClass.closed
    """
    #  loader
    def __call__(
        self,
        loader: PixbufLoader,
    ) -> None: ...

class PixbufModuleLoadFuncPixbufModuleCB(typing.Protocol):
    """
    This callback was used in:
        PixbufModule.load
    """
    #  f
    def __call__(
        self,
        f: object | None = None,
    ) -> Pixbuf: ...

class PixbufModuleLoadXpmDataFuncPixbufModuleCB(typing.Protocol):
    """
    This callback was used in:
        PixbufModule.load_xpm_data
    """
    #  data
    def __call__(
        self,
        data: list,
    ) -> Pixbuf: ...

class PixbufModuleStopLoadFuncPixbufModuleCB(typing.Protocol):
    """
    This callback was used in:
        PixbufModule.stop_load
    """
    #  context
    def __call__(
        self,
        context: object | None = None,
    ) -> bool: ...

class PixbufModuleIncrementLoadFuncPixbufModuleCB(typing.Protocol):
    """
    This callback was used in:
        PixbufModule.load_increment
    """
    #  context
    def __call__(
        self,
        context: object | None,
        buf: list,
        size: int,
    ) -> bool: ...

class PixbufModuleLoadAnimationFuncPixbufModuleCB(typing.Protocol):
    """
    This callback was used in:
        PixbufModule.load_animation
    """
    #  f
    def __call__(
        self,
        f: object | None = None,
    ) -> PixbufAnimation: ...

class PixbufModuleSaveFuncPixbufModuleCB(typing.Protocol):
    """
    This callback was used in:
        PixbufModule.save
    """
    #  f
    def __call__(
        self,
        f: object | None,
        pixbuf: Pixbuf,
        param_keys: list | None = None,
        param_values: list | None = None,
    ) -> bool: ...

class PixbufModuleSaveOptionSupportedFuncPixbufModuleCB(typing.Protocol):
    """
    This callback was used in:
        PixbufModule.is_save_option_supported
    """
    #  option_key
    def __call__(
        self,
        option_key: str,
    ) -> bool: ...

###############################################################
# Aliases
###############################################################

_lock = _thread._lock  # type: ignore
_overrides_module = ...  # this very module ...
###############################################################
# Constants
###############################################################

PIXBUF_MAJOR: int = ...
PIXBUF_MICRO: int = ...
PIXBUF_MINOR: int = ...
PIXBUF_VERSION: str = ...
_namespace: str = ...
_version: str = ...
###############################################################
# Unknowns/Not Parsed
###############################################################
