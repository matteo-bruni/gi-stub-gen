# pyright: reportIncompatibleMethodOverride=false
# pyright: reportIncompatibleVariableOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: Graphene
Date: 2025-12-24
"""
# we disable override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401
import typing  # noqa: F401
import gi  # noqa: F401

import _thread
import enum

# gi.repository imports needed by this Stub
from gi.repository import GObject
###############################################################
# Functions
###############################################################

def box_empty() -> Box:
    """
    A degenerate #graphene_box_t that can only be expanded.

    The returned value is owned by Graphene and should not be modified or freed.
    """
    ...

def box_infinite() -> Box:
    """
    A degenerate #graphene_box_t that cannot be expanded.

    The returned value is owned by Graphene and should not be modified or freed.
    """
    ...

def box_minus_one() -> Box:
    """
    A #graphene_box_t with the minimum vertex set at (-1, -1, -1) and the
    maximum vertex set at (0, 0, 0).

    The returned value is owned by Graphene and should not be modified or freed.
    """
    ...

def box_one() -> Box:
    """
    A #graphene_box_t with the minimum vertex set at (0, 0, 0) and the
    maximum vertex set at (1, 1, 1).

    The returned value is owned by Graphene and should not be modified or freed.
    """
    ...

def box_one_minus_one() -> Box:
    """
    A #graphene_box_t with the minimum vertex set at (-1, -1, -1) and the
    maximum vertex set at (1, 1, 1).

    The returned value is owned by Graphene and should not be modified or freed.
    """
    ...

def box_zero() -> Box:
    """
    A #graphene_box_t with both the minimum and maximum vertices set at (0, 0, 0).

    The returned value is owned by Graphene and should not be modified or freed.
    """
    ...

def point3d_zero() -> Point3D:
    """
    Retrieves a constant point with all three coordinates set to 0.
    """
    ...

def point_zero() -> Point:
    """
    Returns a point fixed at (0, 0).
    """
    ...

def rect_alloc() -> Rect:
    """
    Allocates a new #graphene_rect_t.

    The contents of the returned rectangle are undefined.
    """
    ...

def rect_zero() -> Rect:
    """
    Returns a degenerate rectangle with origin fixed at (0, 0) and
    a size of 0, 0.
    """
    ...

def size_zero() -> Size:
    """
    A constant pointer to a zero #graphene_size_t, useful for
    equality checks and interpolations.
    """
    ...

def vec2_one() -> Vec2:
    """
    Retrieves a constant vector with (1, 1) components.
    """
    ...

def vec2_x_axis() -> Vec2:
    """
    Retrieves a constant vector with (1, 0) components.
    """
    ...

def vec2_y_axis() -> Vec2:
    """
    Retrieves a constant vector with (0, 1) components.
    """
    ...

def vec2_zero() -> Vec2:
    """
    Retrieves a constant vector with (0, 0) components.
    """
    ...

def vec3_one() -> Vec3:
    """
    Provides a constant pointer to a vector with three components,
    all sets to 1.
    """
    ...

def vec3_x_axis() -> Vec3:
    """
    Provides a constant pointer to a vector with three components
    with values set to (1, 0, 0).
    """
    ...

def vec3_y_axis() -> Vec3:
    """
    Provides a constant pointer to a vector with three components
    with values set to (0, 1, 0).
    """
    ...

def vec3_z_axis() -> Vec3:
    """
    Provides a constant pointer to a vector with three components
    with values set to (0, 0, 1).
    """
    ...

def vec3_zero() -> Vec3:
    """
    Provides a constant pointer to a vector with three components,
    all sets to 0.
    """
    ...

def vec4_one() -> Vec4:
    """
    Retrieves a pointer to a #graphene_vec4_t with all its
    components set to 1.
    """
    ...

def vec4_w_axis() -> Vec4:
    """
    Retrieves a pointer to a #graphene_vec4_t with its
    components set to (0, 0, 0, 1).
    """
    ...

def vec4_x_axis() -> Vec4:
    """
    Retrieves a pointer to a #graphene_vec4_t with its
    components set to (1, 0, 0, 0).
    """
    ...

def vec4_y_axis() -> Vec4:
    """
    Retrieves a pointer to a #graphene_vec4_t with its
    components set to (0, 1, 0, 0).
    """
    ...

def vec4_z_axis() -> Vec4:
    """
    Retrieves a pointer to a #graphene_vec4_t with its
    components set to (0, 0, 1, 0).
    """
    ...

def vec4_zero() -> Vec4:
    """
    Retrieves a pointer to a #graphene_vec4_t with all its
    components set to 0.
    """
    ...

###############################################################
# Enums/Flags
###############################################################

class EulerOrder(enum.IntEnum):
    """
    Specify the order of the rotations on each axis.

    The %GRAPHENE_EULER_ORDER_DEFAULT value is special, and is used
    as an alias for one of the other orders."""

    DEFAULT = -1
    """
    Rotate in the default order; the
      default order is one of the following enumeration values
    """
    XYZ = 0
    """
    Rotate in the X, Y, and Z order. Deprecated in
      Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SXYZ
    """
    YZX = 1
    """
    Rotate in the Y, Z, and X order. Deprecated in
      Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SYZX
    """
    ZXY = 2
    """
    Rotate in the Z, X, and Y order. Deprecated in
      Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SZXY
    """
    XZY = 3
    """
    Rotate in the X, Z, and Y order. Deprecated in
      Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SXZY
    """
    YXZ = 4
    """
    Rotate in the Y, X, and Z order. Deprecated in
      Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SYXZ
    """
    ZYX = 5
    """
    Rotate in the Z, Y, and X order. Deprecated in
      Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SZYX
    """
    SXYZ = 6
    """
    Defines a static rotation along the X, Y, and Z axes (Since: 1.10)
    """
    SXYX = 7
    """
    Defines a static rotation along the X, Y, and X axes (Since: 1.10)
    """
    SXZY = 8
    """
    Defines a static rotation along the X, Z, and Y axes (Since: 1.10)
    """
    SXZX = 9
    """
    Defines a static rotation along the X, Z, and X axes (Since: 1.10)
    """
    SYZX = 10
    """
    Defines a static rotation along the Y, Z, and X axes (Since: 1.10)
    """
    SYZY = 11
    """
    Defines a static rotation along the Y, Z, and Y axes (Since: 1.10)
    """
    SYXZ = 12
    """
    Defines a static rotation along the Y, X, and Z axes (Since: 1.10)
    """
    SYXY = 13
    """
    Defines a static rotation along the Y, X, and Y axes (Since: 1.10)
    """
    SZXY = 14
    """
    Defines a static rotation along the Z, X, and Y axes (Since: 1.10)
    """
    SZXZ = 15
    """
    Defines a static rotation along the Z, X, and Z axes (Since: 1.10)
    """
    SZYX = 16
    """
    Defines a static rotation along the Z, Y, and X axes (Since: 1.10)
    """
    SZYZ = 17
    """
    Defines a static rotation along the Z, Y, and Z axes (Since: 1.10)
    """
    RZYX = 18
    """
    Defines a relative rotation along the Z, Y, and X axes (Since: 1.10)
    """
    RXYX = 19
    """
    Defines a relative rotation along the X, Y, and X axes (Since: 1.10)
    """
    RYZX = 20
    """
    Defines a relative rotation along the Y, Z, and X axes (Since: 1.10)
    """
    RXZX = 21
    """
    Defines a relative rotation along the X, Z, and X axes (Since: 1.10)
    """
    RXZY = 22
    """
    Defines a relative rotation along the X, Z, and Y axes (Since: 1.10)
    """
    RYZY = 23
    """
    Defines a relative rotation along the Y, Z, and Y axes (Since: 1.10)
    """
    RZXY = 24
    """
    Defines a relative rotation along the Z, X, and Y axes (Since: 1.10)
    """
    RYXY = 25
    """
    Defines a relative rotation along the Y, X, and Y axes (Since: 1.10)
    """
    RYXZ = 26
    """
    Defines a relative rotation along the Y, X, and Z axes (Since: 1.10)
    """
    RZXZ = 27
    """
    Defines a relative rotation along the Z, X, and Z axes (Since: 1.10)
    """
    RXYZ = 28
    """
    Defines a relative rotation along the X, Y, and Z axes (Since: 1.10)
    """
    RZYZ = 29
    """
    Defines a relative rotation along the Z, Y, and Z axes (Since: 1.10)
    """

class RayIntersectionKind(enum.IntEnum):
    """
    The type of intersection."""

    NONE = 0
    """
    No intersection
    """
    ENTER = 1
    """
    The ray is entering the intersected
      object
    """
    LEAVE = 2
    """
    The ray is leaving the intersected
      object
    """

###############################################################
# classes
###############################################################

class Box(GObject.GBoxed):
    # gi Fields
    max: Vec3 | None = ...
    min: Vec3 | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Box: ...
    def contains_box(self, b: Box) -> bool: ...
    def contains_point(self, point: Point3D) -> bool: ...
    @staticmethod
    def empty() -> Box: ...
    def equal(self, b: Box) -> bool: ...
    def expand(self, point: Point3D) -> Box: ...
    def expand_scalar(self, scalar: float) -> Box: ...
    def expand_vec3(self, vec: Vec3) -> Box: ...
    def free(self) -> None: ...
    def get_bounding_sphere(self) -> Sphere: ...
    def get_center(self) -> Point3D: ...
    def get_depth(self) -> float: ...
    def get_height(self) -> float: ...
    def get_max(self) -> Point3D: ...
    def get_min(self) -> Point3D: ...
    def get_size(self) -> Vec3: ...
    def get_vertices(self) -> list: ...
    def get_width(self) -> float: ...
    @staticmethod
    def infinite() -> Box: ...
    def init(self, min: Point3D | None = None, max: Point3D | None = None) -> Box: ...
    def init_from_box(self, src: Box) -> Box: ...
    def init_from_points(self, n_points: int, points: list) -> Box: ...
    def init_from_vec3(self, min: Vec3 | None = None, max: Vec3 | None = None) -> Box: ...
    def init_from_vectors(self, n_vectors: int, vectors: list) -> Box: ...
    def intersection(self, b: Box) -> tuple[bool, Box | None]: ...
    @staticmethod
    def minus_one() -> Box: ...
    @staticmethod
    def one() -> Box: ...
    @staticmethod
    def one_minus_one() -> Box: ...
    def union(self, b: Box) -> Box: ...
    @staticmethod
    def zero() -> Box: ...

    ...

class Euler(GObject.GBoxed):
    # gi Fields
    angles: Vec3 | None = ...
    order: EulerOrder = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Euler: ...
    def equal(self, b: Euler) -> bool: ...
    def free(self) -> None: ...
    def get_alpha(self) -> float: ...
    def get_beta(self) -> float: ...
    def get_gamma(self) -> float: ...
    def get_order(self) -> EulerOrder: ...
    def get_x(self) -> float: ...
    def get_y(self) -> float: ...
    def get_z(self) -> float: ...
    def init(self, x: float, y: float, z: float) -> Euler: ...
    def init_from_euler(self, src: Euler | None = None) -> Euler: ...
    def init_from_matrix(self, m: Matrix | None, order: EulerOrder) -> Euler: ...
    def init_from_quaternion(self, q: Quaternion | None, order: EulerOrder) -> Euler: ...
    def init_from_radians(self, x: float, y: float, z: float, order: EulerOrder) -> Euler: ...
    def init_from_vec3(self, v: Vec3 | None, order: EulerOrder) -> Euler: ...
    def init_with_order(self, x: float, y: float, z: float, order: EulerOrder) -> Euler: ...
    def reorder(self, order: EulerOrder) -> Euler: ...
    def to_matrix(self) -> Matrix: ...
    def to_quaternion(self) -> Quaternion: ...
    def to_vec3(self) -> Vec3: ...

    ...

class Frustum(GObject.GBoxed):
    # gi Fields
    planes: list | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Frustum: ...
    def contains_point(self, point: Point3D) -> bool: ...
    def equal(self, b: Frustum) -> bool: ...
    def free(self) -> None: ...
    def get_planes(self) -> list: ...
    def init(self, p0: Plane, p1: Plane, p2: Plane, p3: Plane, p4: Plane, p5: Plane) -> Frustum: ...
    def init_from_frustum(self, src: Frustum) -> Frustum: ...
    def init_from_matrix(self, matrix: Matrix) -> Frustum: ...
    def intersects_box(self, box: Box) -> bool: ...
    def intersects_sphere(self, sphere: Sphere) -> bool: ...

    ...

class Matrix(GObject.GBoxed):
    # gi Fields
    value: Simd4X4F | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Matrix: ...
    def decompose(self) -> tuple[bool, Vec3, Vec3, Quaternion, Vec3, Vec4]: ...
    def determinant(self) -> float: ...
    def equal(self, b: Matrix) -> bool: ...
    def equal_fast(self, b: Matrix) -> bool: ...
    def free(self) -> None: ...
    def get_row(self, index_: int) -> Vec4: ...
    def get_value(self, row: int, col: int) -> float: ...
    def get_x_scale(self) -> float: ...
    def get_x_translation(self) -> float: ...
    def get_y_scale(self) -> float: ...
    def get_y_translation(self) -> float: ...
    def get_z_scale(self) -> float: ...
    def get_z_translation(self) -> float: ...
    def init_from_2d(self, xx: float, yx: float, xy: float, yy: float, x_0: float, y_0: float) -> Matrix: ...
    def init_from_float(self, v: list) -> Matrix: ...
    def init_from_matrix(self, src: Matrix) -> Matrix: ...
    def init_from_vec4(self, v0: Vec4, v1: Vec4, v2: Vec4, v3: Vec4) -> Matrix: ...
    def init_frustum(
        self, left: float, right: float, bottom: float, top: float, z_near: float, z_far: float
    ) -> Matrix: ...
    def init_identity(self) -> Matrix: ...
    def init_look_at(self, eye: Vec3, center: Vec3, up: Vec3) -> Matrix: ...
    def init_ortho(
        self, left: float, right: float, top: float, bottom: float, z_near: float, z_far: float
    ) -> Matrix: ...
    def init_perspective(self, fovy: float, aspect: float, z_near: float, z_far: float) -> Matrix: ...
    def init_rotate(self, angle: float, axis: Vec3) -> Matrix: ...
    def init_scale(self, x: float, y: float, z: float) -> Matrix: ...
    def init_skew(self, x_skew: float, y_skew: float) -> Matrix: ...
    def init_translate(self, p: Point3D) -> Matrix: ...
    def interpolate(self, b: Matrix, factor: float) -> Matrix: ...
    def inverse(self) -> tuple[bool, Matrix]: ...
    def is_2d(self) -> bool: ...
    def is_backface_visible(self) -> bool: ...
    def is_identity(self) -> bool: ...
    def is_singular(self) -> bool: ...
    def multiply(self, b: Matrix) -> Matrix: ...
    def near(self, b: Matrix, epsilon: float) -> bool: ...
    def normalize(self) -> Matrix: ...
    def perspective(self, depth: float) -> Matrix: ...
    def print_(self) -> None: ...
    def project_point(self, p: Point) -> Point: ...
    def project_rect(self, r: Rect) -> Quad: ...
    def project_rect_bounds(self, r: Rect) -> Rect: ...
    def rotate(self, angle: float, axis: Vec3) -> None: ...
    def rotate_euler(self, e: Euler) -> None: ...
    def rotate_quaternion(self, q: Quaternion) -> None: ...
    def rotate_x(self, angle: float) -> None: ...
    def rotate_y(self, angle: float) -> None: ...
    def rotate_z(self, angle: float) -> None: ...
    def scale(self, factor_x: float, factor_y: float, factor_z: float) -> None: ...
    def skew_xy(self, factor: float) -> None: ...
    def skew_xz(self, factor: float) -> None: ...
    def skew_yz(self, factor: float) -> None: ...
    def to_2d(self) -> tuple[bool, float, float, float, float, float, float]: ...
    def to_float(self) -> list: ...
    def transform_bounds(self, r: Rect) -> Rect: ...
    def transform_box(self, b: Box) -> Box: ...
    def transform_point(self, p: Point) -> Point: ...
    def transform_point3d(self, p: Point3D) -> Point3D: ...
    def transform_ray(self, r: Ray) -> Ray: ...
    def transform_rect(self, r: Rect) -> Quad: ...
    def transform_sphere(self, s: Sphere) -> Sphere: ...
    def transform_vec3(self, v: Vec3) -> Vec3: ...
    def transform_vec4(self, v: Vec4) -> Vec4: ...
    def translate(self, pos: Point3D) -> None: ...
    def transpose(self) -> Matrix: ...
    def unproject_point3d(self, modelview: Matrix, point: Point3D) -> Point3D: ...
    def untransform_bounds(self, r: Rect, bounds: Rect) -> Rect: ...
    def untransform_point(self, p: Point, bounds: Rect) -> tuple[bool, Point]: ...

    ...

class Plane(GObject.GBoxed):
    # gi Fields
    constant: float = ...
    normal: Vec3 | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Plane: ...
    def distance(self, point: Point3D) -> float: ...
    def equal(self, b: Plane) -> bool: ...
    def free(self) -> None: ...
    def get_constant(self) -> float: ...
    def get_normal(self) -> Vec3: ...
    def init(self, normal: Vec3 | None, constant: float) -> Plane: ...
    def init_from_plane(self, src: Plane) -> Plane: ...
    def init_from_point(self, normal: Vec3, point: Point3D) -> Plane: ...
    def init_from_points(self, a: Point3D, b: Point3D, c: Point3D) -> Plane: ...
    def init_from_vec4(self, src: Vec4) -> Plane: ...
    def negate(self) -> Plane: ...
    def normalize(self) -> Plane: ...
    def transform(self, matrix: Matrix, normal_matrix: Matrix | None = None) -> Plane: ...

    ...

class Point(GObject.GBoxed):
    # gi Fields
    x: float = ...
    y: float = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Point: ...
    def distance(self, b: Point) -> tuple[float, float | None, float | None]: ...
    def equal(self, b: Point) -> bool: ...
    def free(self) -> None: ...
    def init(self, x: float, y: float) -> Point: ...
    def init_from_point(self, src: Point) -> Point: ...
    def init_from_vec2(self, src: Vec2) -> Point: ...
    def interpolate(self, b: Point, factor: float) -> Point: ...
    def near(self, b: Point, epsilon: float) -> bool: ...
    def to_vec2(self) -> Vec2: ...
    @staticmethod
    def zero() -> Point: ...

    ...

class Point3D(GObject.GBoxed):
    # gi Fields
    x: float = ...
    y: float = ...
    z: float = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Point3D: ...
    def cross(self, b: Point3D) -> Point3D: ...
    def distance(self, b: Point3D) -> tuple[float, Vec3 | None]: ...
    def dot(self, b: Point3D) -> float: ...
    def equal(self, b: Point3D) -> bool: ...
    def free(self) -> None: ...
    def init(self, x: float, y: float, z: float) -> Point3D: ...
    def init_from_point(self, src: Point3D) -> Point3D: ...
    def init_from_vec3(self, v: Vec3) -> Point3D: ...
    def interpolate(self, b: Point3D, factor: float) -> Point3D: ...
    def length(self) -> float: ...
    def near(self, b: Point3D, epsilon: float) -> bool: ...
    def normalize(self) -> Point3D: ...
    def normalize_viewport(self, viewport: Rect, z_near: float, z_far: float) -> Point3D: ...
    def scale(self, factor: float) -> Point3D: ...
    def to_vec3(self) -> Vec3: ...
    @staticmethod
    def zero() -> Point3D: ...

    ...

class Quad(GObject.GBoxed):
    # gi Fields
    points: list | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Quad: ...
    def bounds(self) -> Rect: ...
    def contains(self, p: Point) -> bool: ...
    def free(self) -> None: ...
    def get_point(self, index_: int) -> Point: ...
    def init(self, p1: Point, p2: Point, p3: Point, p4: Point) -> Quad: ...
    def init_from_points(self, points: list) -> Quad: ...
    def init_from_rect(self, r: Rect) -> Quad: ...

    ...

class Quaternion(GObject.GBoxed):
    # gi Fields
    w: float = ...
    x: float = ...
    y: float = ...
    z: float = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add(self, b: Quaternion) -> Quaternion: ...
    @classmethod
    def alloc(cls) -> Quaternion: ...
    def dot(self, b: Quaternion) -> float: ...
    def equal(self, b: Quaternion) -> bool: ...
    def free(self) -> None: ...
    def init(self, x: float, y: float, z: float, w: float) -> Quaternion: ...
    def init_from_angle_vec3(self, angle: float, axis: Vec3) -> Quaternion: ...
    def init_from_angles(self, deg_x: float, deg_y: float, deg_z: float) -> Quaternion: ...
    def init_from_euler(self, e: Euler) -> Quaternion: ...
    def init_from_matrix(self, m: Matrix) -> Quaternion: ...
    def init_from_quaternion(self, src: Quaternion) -> Quaternion: ...
    def init_from_radians(self, rad_x: float, rad_y: float, rad_z: float) -> Quaternion: ...
    def init_from_vec4(self, src: Vec4) -> Quaternion: ...
    def init_identity(self) -> Quaternion: ...
    def invert(self) -> Quaternion: ...
    def multiply(self, b: Quaternion) -> Quaternion: ...
    def normalize(self) -> Quaternion: ...
    def scale(self, factor: float) -> Quaternion: ...
    def slerp(self, b: Quaternion, factor: float) -> Quaternion: ...
    def to_angle_vec3(self) -> tuple[float, Vec3]: ...
    def to_angles(self) -> tuple[float | None, float | None, float | None]: ...
    def to_matrix(self) -> Matrix: ...
    def to_radians(self) -> tuple[float | None, float | None, float | None]: ...
    def to_vec4(self) -> Vec4: ...

    ...

class Ray(GObject.GBoxed):
    # gi Fields
    direction: Vec3 | None = ...
    origin: Vec3 | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Ray: ...
    def equal(self, b: Ray) -> bool: ...
    def free(self) -> None: ...
    def get_closest_point_to_point(self, p: Point3D) -> Point3D: ...
    def get_direction(self) -> Vec3: ...
    def get_distance_to_plane(self, p: Plane) -> float: ...
    def get_distance_to_point(self, p: Point3D) -> float: ...
    def get_origin(self) -> Point3D: ...
    def get_position_at(self, t: float) -> Point3D: ...
    def init(self, origin: Point3D | None = None, direction: Vec3 | None = None) -> Ray: ...
    def init_from_ray(self, src: Ray) -> Ray: ...
    def init_from_vec3(self, origin: Vec3 | None = None, direction: Vec3 | None = None) -> Ray: ...
    def intersect_box(self, b: Box) -> tuple[RayIntersectionKind, float]: ...
    def intersect_sphere(self, s: Sphere) -> tuple[RayIntersectionKind, float]: ...
    def intersect_triangle(self, t: Triangle) -> tuple[RayIntersectionKind, float]: ...
    def intersects_box(self, b: Box) -> bool: ...
    def intersects_sphere(self, s: Sphere) -> bool: ...
    def intersects_triangle(self, t: Triangle) -> bool: ...

    ...

class Rect(GObject.GBoxed):
    # gi Fields
    origin: Point | None = ...
    size: Size | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def alloc() -> Rect: ...
    def contains_point(self, p: Point) -> bool: ...
    def contains_rect(self, b: Rect) -> bool: ...
    def equal(self, b: Rect) -> bool: ...
    def expand(self, p: Point) -> Rect: ...
    def free(self) -> None: ...
    def get_area(self) -> float: ...
    def get_bottom_left(self) -> Point: ...
    def get_bottom_right(self) -> Point: ...
    def get_center(self) -> Point: ...
    def get_height(self) -> float: ...
    def get_top_left(self) -> Point: ...
    def get_top_right(self) -> Point: ...
    def get_vertices(self) -> list: ...
    def get_width(self) -> float: ...
    def get_x(self) -> float: ...
    def get_y(self) -> float: ...
    def init(self, x: float, y: float, width: float, height: float) -> Rect: ...
    def init_from_rect(self, src: Rect) -> Rect: ...
    def inset(self, d_x: float, d_y: float) -> Rect: ...
    def inset_r(self, d_x: float, d_y: float) -> Rect: ...
    def interpolate(self, b: Rect, factor: float) -> Rect: ...
    def intersection(self, b: Rect) -> tuple[bool, Rect | None]: ...
    def normalize(self) -> Rect: ...
    def normalize_r(self) -> Rect: ...
    def offset(self, d_x: float, d_y: float) -> Rect: ...
    def offset_r(self, d_x: float, d_y: float) -> Rect: ...
    @deprecated("deprecated")
    def round(self) -> Rect: ...
    def round_extents(self) -> Rect: ...
    @deprecated("deprecated")
    def round_to_pixel(self) -> Rect: ...
    def scale(self, s_h: float, s_v: float) -> Rect: ...
    def union(self, b: Rect) -> Rect: ...
    @staticmethod
    def zero() -> Rect: ...

    ...

class Simd4F(GObject.GPointer):
    # gi Fields
    w: float = ...
    x: float = ...
    y: float = ...
    z: float = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Simd4X4F(GObject.GPointer):
    # gi Fields
    w: Simd4F | None = ...
    x: Simd4F | None = ...
    y: Simd4F | None = ...
    z: Simd4F | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Size(GObject.GBoxed):
    # gi Fields
    height: float = ...
    width: float = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Size: ...
    def equal(self, b: Size) -> bool: ...
    def free(self) -> None: ...
    def init(self, width: float, height: float) -> Size: ...
    def init_from_size(self, src: Size) -> Size: ...
    def interpolate(self, b: Size, factor: float) -> Size: ...
    def scale(self, factor: float) -> Size: ...
    @staticmethod
    def zero() -> Size: ...

    ...

class Sphere(GObject.GBoxed):
    # gi Fields
    center: Vec3 | None = ...
    radius: float = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Sphere: ...
    def contains_point(self, point: Point3D) -> bool: ...
    def distance(self, point: Point3D) -> float: ...
    def equal(self, b: Sphere) -> bool: ...
    def free(self) -> None: ...
    def get_bounding_box(self) -> Box: ...
    def get_center(self) -> Point3D: ...
    def get_radius(self) -> float: ...
    def init(self, center: Point3D | None, radius: float) -> Sphere: ...
    def init_from_points(self, n_points: int, points: list, center: Point3D | None = None) -> Sphere: ...
    def init_from_vectors(self, n_vectors: int, vectors: list, center: Point3D | None = None) -> Sphere: ...
    def is_empty(self) -> bool: ...
    def translate(self, point: Point3D) -> Sphere: ...

    ...

class Triangle(GObject.GBoxed):
    # gi Fields
    a: Vec3 | None = ...
    b: Vec3 | None = ...
    c: Vec3 | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def alloc(cls) -> Triangle: ...
    def contains_point(self, p: Point3D) -> bool: ...
    def equal(self, b: Triangle) -> bool: ...
    def free(self) -> None: ...
    def get_area(self) -> float: ...
    def get_barycoords(self, p: Point3D | None = None) -> tuple[bool, Vec2]: ...
    def get_bounding_box(self) -> Box: ...
    def get_midpoint(self) -> Point3D: ...
    def get_normal(self) -> Vec3: ...
    def get_plane(self) -> Plane: ...
    def get_points(self) -> tuple[Point3D | None, Point3D | None, Point3D | None]: ...
    def get_uv(self, p: Point3D | None, uv_a: Vec2, uv_b: Vec2, uv_c: Vec2) -> tuple[bool, Vec2]: ...
    def get_vertices(self) -> tuple[Vec3 | None, Vec3 | None, Vec3 | None]: ...
    def init_from_float(self, a: list, b: list, c: list) -> Triangle: ...
    def init_from_point3d(
        self, a: Point3D | None = None, b: Point3D | None = None, c: Point3D | None = None
    ) -> Triangle: ...
    def init_from_vec3(self, a: Vec3 | None = None, b: Vec3 | None = None, c: Vec3 | None = None) -> Triangle: ...

    ...

class Vec2(GObject.GBoxed):
    # gi Fields
    value: Simd4F | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add(self, b: Vec2) -> Vec2: ...
    @classmethod
    def alloc(cls) -> Vec2: ...
    def divide(self, b: Vec2) -> Vec2: ...
    def dot(self, b: Vec2) -> float: ...
    def equal(self, v2: Vec2) -> bool: ...
    def free(self) -> None: ...
    def get_x(self) -> float: ...
    def get_y(self) -> float: ...
    def init(self, x: float, y: float) -> Vec2: ...
    def init_from_float(self, src: list) -> Vec2: ...
    def init_from_vec2(self, src: Vec2) -> Vec2: ...
    def interpolate(self, v2: Vec2, factor: float) -> Vec2: ...
    def length(self) -> float: ...
    def max(self, b: Vec2) -> Vec2: ...
    def min(self, b: Vec2) -> Vec2: ...
    def multiply(self, b: Vec2) -> Vec2: ...
    def near(self, v2: Vec2, epsilon: float) -> bool: ...
    def negate(self) -> Vec2: ...
    def normalize(self) -> Vec2: ...
    @staticmethod
    def one() -> Vec2: ...
    def scale(self, factor: float) -> Vec2: ...
    def subtract(self, b: Vec2) -> Vec2: ...
    def to_float(self) -> list: ...
    @staticmethod
    def x_axis() -> Vec2: ...
    @staticmethod
    def y_axis() -> Vec2: ...
    @staticmethod
    def zero() -> Vec2: ...

    ...

class Vec3(GObject.GBoxed):
    # gi Fields
    value: Simd4F | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add(self, b: Vec3) -> Vec3: ...
    @classmethod
    def alloc(cls) -> Vec3: ...
    def cross(self, b: Vec3) -> Vec3: ...
    def divide(self, b: Vec3) -> Vec3: ...
    def dot(self, b: Vec3) -> float: ...
    def equal(self, v2: Vec3) -> bool: ...
    def free(self) -> None: ...
    def get_x(self) -> float: ...
    def get_xy(self) -> Vec2: ...
    def get_xy0(self) -> Vec3: ...
    def get_xyz0(self) -> Vec4: ...
    def get_xyz1(self) -> Vec4: ...
    def get_xyzw(self, w: float) -> Vec4: ...
    def get_y(self) -> float: ...
    def get_z(self) -> float: ...
    def init(self, x: float, y: float, z: float) -> Vec3: ...
    def init_from_float(self, src: list) -> Vec3: ...
    def init_from_vec3(self, src: Vec3) -> Vec3: ...
    def interpolate(self, v2: Vec3, factor: float) -> Vec3: ...
    def length(self) -> float: ...
    def max(self, b: Vec3) -> Vec3: ...
    def min(self, b: Vec3) -> Vec3: ...
    def multiply(self, b: Vec3) -> Vec3: ...
    def near(self, v2: Vec3, epsilon: float) -> bool: ...
    def negate(self) -> Vec3: ...
    def normalize(self) -> Vec3: ...
    @staticmethod
    def one() -> Vec3: ...
    def scale(self, factor: float) -> Vec3: ...
    def subtract(self, b: Vec3) -> Vec3: ...
    def to_float(self) -> list: ...
    @staticmethod
    def x_axis() -> Vec3: ...
    @staticmethod
    def y_axis() -> Vec3: ...
    @staticmethod
    def z_axis() -> Vec3: ...
    @staticmethod
    def zero() -> Vec3: ...

    ...

class Vec4(GObject.GBoxed):
    # gi Fields
    value: Simd4F | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add(self, b: Vec4) -> Vec4: ...
    @classmethod
    def alloc(cls) -> Vec4: ...
    def divide(self, b: Vec4) -> Vec4: ...
    def dot(self, b: Vec4) -> float: ...
    def equal(self, v2: Vec4) -> bool: ...
    def free(self) -> None: ...
    def get_w(self) -> float: ...
    def get_x(self) -> float: ...
    def get_xy(self) -> Vec2: ...
    def get_xyz(self) -> Vec3: ...
    def get_y(self) -> float: ...
    def get_z(self) -> float: ...
    def init(self, x: float, y: float, z: float, w: float) -> Vec4: ...
    def init_from_float(self, src: list) -> Vec4: ...
    def init_from_vec2(self, src: Vec2, z: float, w: float) -> Vec4: ...
    def init_from_vec3(self, src: Vec3, w: float) -> Vec4: ...
    def init_from_vec4(self, src: Vec4) -> Vec4: ...
    def interpolate(self, v2: Vec4, factor: float) -> Vec4: ...
    def length(self) -> float: ...
    def max(self, b: Vec4) -> Vec4: ...
    def min(self, b: Vec4) -> Vec4: ...
    def multiply(self, b: Vec4) -> Vec4: ...
    def near(self, v2: Vec4, epsilon: float) -> bool: ...
    def negate(self) -> Vec4: ...
    def normalize(self) -> Vec4: ...
    @staticmethod
    def one() -> Vec4: ...
    def scale(self, factor: float) -> Vec4: ...
    def subtract(self, b: Vec4) -> Vec4: ...
    def to_float(self) -> list: ...
    @staticmethod
    def w_axis() -> Vec4: ...
    @staticmethod
    def x_axis() -> Vec4: ...
    @staticmethod
    def y_axis() -> Vec4: ...
    @staticmethod
    def z_axis() -> Vec4: ...
    @staticmethod
    def zero() -> Vec4: ...

    ...

###############################################################
# Aliases
###############################################################

_lock = _thread._lock  # type: ignore
###############################################################
# Constants
###############################################################

PI: float = ...
PI_2: float = ...
VEC2_LEN: int = ...
VEC3_LEN: int = ...
VEC4_LEN: int = ...
_namespace: str = ...
_version: str = ...
###############################################################
# Unknowns/Not Parsed
###############################################################
