# pyright: reportIncompatibleMethodOverride=false
# pyright: reportIncompatibleVariableOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: Gio
Date: 2025-12-24
"""
# we disable override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401
import typing  # noqa: F401
import gi  # noqa: F401

import _thread
import typing

# gi.repository imports needed by this Stub
from gi.repository import GLib
from gi.repository import GioUnix
from gi.repository import GObject
###############################################################
# Functions
###############################################################

def action_name_is_valid(
    action_name: str,
) -> bool:
    """
    Checks if @action_name is valid.

    @action_name is valid if it consists only of alphanumeric characters,
    plus `-` and `.`.  The empty string is not a valid action name.

    It is an error to call this function with a non-UTF-8 @action_name.
    @action_name must not be `NULL`.
    """
    ...

def action_parse_detailed_name(
    detailed_name: str,
) -> tuple[bool, str | None, GLib.Variant | None]:
    """
    Parses a detailed action name into its separate name and target
    components.

    Detailed action names can have three formats.

    The first format is used to represent an action name with no target
    value and consists of just an action name containing no whitespace
    nor the characters `:`, `(` or `)`.  For example: `app.action`.

    The second format is used to represent an action with a target value
    that is a non-empty string consisting only of alphanumerics, plus `-`
    and `.`.  In that case, the action name and target value are
    separated by a double colon (`::`).  For example:
    `app.action::target`.

    The third format is used to represent an action with any type of
    target value, including strings.  The target value follows the action
    name, surrounded in parens.  For example: `app.action(42)`.  The
    target value is parsed using [func@GLib.Variant.parse].  If a tuple-typed
    value is desired, it must be specified in the same way, resulting in
    two sets of parens, for example: `app.action((1,2,3))`.  A string
    target can be specified this way as well: `app.action('target')`.
    For strings, this third format must be used if target value is
    empty or contains characters other than alphanumerics, `-` and `.`.

    If this function returns `TRUE`, a non-`NULL` value is guaranteed to be returned
    in @action_name (if a pointer is passed in). A `NULL` value may still be
    returned in @target_value, as the @detailed_name may not contain a target.

    If returned, the [type@GLib.Variant] in @target_value is guaranteed to not be floating.
    """
    ...

def action_print_detailed_name(
    action_name: str,
    target_value: GLib.Variant | None = None,
) -> str:
    """
    Formats a detailed action name from @action_name and @target_value.

    It is an error to call this function with an invalid action name.

    This function is the opposite of [func@Gio.Action.parse_detailed_name].
    It will produce a string that can be parsed back to the @action_name
    and @target_value by that function.

    See that function for the types of strings that will be printed by
    this function.
    """
    ...

def app_info_create_from_commandline(
    commandline: str,
    application_name: str | None,
    flags: AppInfoCreateFlags,
) -> AppInfo:
    """
    Creates a new [iface@Gio.AppInfo] from the given information.

    Note that for @commandline, the quoting rules of the `Exec` key of the
    [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
    are applied. For example, if the @commandline contains
    percent-encoded URIs, the percent-character must be doubled in order to prevent it from
    being swallowed by `Exec` key unquoting. See
    [the specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html)
    for exact quoting rules.
    """
    ...

def app_info_get_all() -> list:
    """
    Gets a list of all of the applications currently registered
    on this system.

    For desktop files, this includes applications that have
    [`NoDisplay=true`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-nodisplay)
    set or are excluded from display by means of
    [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-onlyshowin)
    or [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-notshowin).
    See [method@Gio.AppInfo.should_show].

    The returned list does not include applications which have the
    [`Hidden` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-hidden)
    set.
    """
    ...

def app_info_get_all_for_type(
    content_type: str,
) -> list:
    """
    Gets a list of all [iface@Gio.AppInfo]s for a given content type,
    including the recommended and fallback [iface@Gio.AppInfo]s. See
    [func@Gio.AppInfo.get_recommended_for_type] and
    [func@Gio.AppInfo.get_fallback_for_type].
    """
    ...

def app_info_get_default_for_type(
    content_type: str,
    must_support_uris: bool,
) -> AppInfo | None:
    """
    Gets the default [iface@Gio.AppInfo] for a given content type.
    """
    ...

def app_info_get_default_for_type_async(
    content_type: str,
    must_support_uris: bool,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    user_data: object | None = None,
) -> None:
    """
    Asynchronously gets the default [iface@Gio.AppInfo] for a given content
    type.
    """
    ...

def app_info_get_default_for_type_finish(
    result: AsyncResult,
) -> AppInfo:
    """
    Finishes a default [iface@Gio.AppInfo] lookup started by
    [func@Gio.AppInfo.get_default_for_type_async].

    If no #[iface@Gio.AppInfo] is found, then @error will be set to
    [error@Gio.IOErrorEnum.NOT_FOUND].
    """
    ...

def app_info_get_default_for_uri_scheme(
    uri_scheme: str,
) -> AppInfo | None:
    """
    Gets the default application for handling URIs with the given URI scheme.

    A URI scheme is the initial part of the URI, up to but not including the `:`.
    For example, `http`, `ftp` or `sip`.
    """
    ...

def app_info_get_default_for_uri_scheme_async(
    uri_scheme: str,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    user_data: object | None = None,
) -> None:
    """
    Asynchronously gets the default application for handling URIs with
    the given URI scheme. A URI scheme is the initial part
    of the URI, up to but not including the `:`, e.g. `http`,
    `ftp` or `sip`.
    """
    ...

def app_info_get_default_for_uri_scheme_finish(
    result: AsyncResult,
) -> AppInfo:
    """
    Finishes a default [iface@Gio.AppInfo] lookup started by
    [func@Gio.AppInfo.get_default_for_uri_scheme_async].

    If no [iface@Gio.AppInfo] is found, then @error will be set to
    [error@Gio.IOErrorEnum.NOT_FOUND].
    """
    ...

def app_info_get_fallback_for_type(
    content_type: str,
) -> list:
    """
    Gets a list of fallback [iface@Gio.AppInfo]s for a given content type, i.e.
    those applications which claim to support the given content type by MIME
    type subclassing and not directly.
    """
    ...

def app_info_get_recommended_for_type(
    content_type: str,
) -> list:
    """
    Gets a list of recommended [iface@Gio.AppInfo]s for a given content type,
    i.e. those applications which claim to support the given content type
    exactly, and not by MIME type subclassing.

    Note that the first application of the list is the last used one, i.e.
    the last one for which [method@Gio.AppInfo.set_as_last_used_for_type] has
    been called.
    """
    ...

def app_info_launch_default_for_uri(
    uri: str,
    context: AppLaunchContext | None = None,
) -> bool:
    """
    Utility function that launches the default application registered to handle
    the specified uri. Synchronous I/O is done on the uri to detect the type of
    the file if required.

    The D-Bus–activated applications don’t have to be started if your application
    terminates too soon after this function. To prevent this, use
    [func@Gio.AppInfo.launch_default_for_uri_async] instead.
    """
    ...

def app_info_launch_default_for_uri_async(
    uri: str,
    context: AppLaunchContext | None = None,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    user_data: object | None = None,
) -> None:
    """
    Async version of [func@Gio.AppInfo.launch_default_for_uri].

    This version is useful if you are interested in receiving error information
    in the case where the application is sandboxed and the portal may present an
    application chooser dialog to the user.

    This is also useful if you want to be sure that the D-Bus–activated
    applications are really started before termination and if you are interested
    in receiving error information from their activation.
    """
    ...

def app_info_launch_default_for_uri_finish(
    result: AsyncResult,
) -> bool:
    """
    Finishes an asynchronous launch-default-for-uri operation.
    """
    ...

def app_info_reset_type_associations(
    content_type: str,
) -> None:
    """
    Removes all changes to the type associations done by
    [method@Gio.AppInfo.set_as_default_for_type],
    [method@Gio.AppInfo.set_as_default_for_extension],
    [method@Gio.AppInfo.add_supports_type] or
    [method@Gio.AppInfo.remove_supports_type].
    """
    ...

def async_initable_newv_async(
    object_type: GObject.GType,
    n_parameters: int,
    parameters: GObject.Parameter,
    io_priority: int,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    user_data: object | None = None,
) -> None:
    """
    Helper function for constructing #GAsyncInitable object. This is
    similar to g_object_newv() but also initializes the object asynchronously.

    When the initialization is finished, @callback will be called. You can
    then call g_async_initable_new_finish() to get the new object and check
    for any errors.
    """
    ...

def bus_get(
    bus_type: BusType,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    user_data: object | None = None,
) -> None:
    """
    Asynchronously connects to the message bus specified by @bus_type.

    When the operation is finished, @callback will be invoked. You can
    then call g_bus_get_finish() to get the result of the operation.

    This is an asynchronous failable function. See g_bus_get_sync() for
    the synchronous version.
    """
    ...

def bus_get_finish(
    res: AsyncResult,
) -> DBusConnection:
    """
    Finishes an operation started with g_bus_get().

    The returned object is a singleton, that is, shared with other
    callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
    event that you need a private message bus connection, use
    g_dbus_address_get_for_bus_sync() and
    g_dbus_connection_new_for_address() with
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.

    Note that the returned #GDBusConnection object will (usually) have
    the #GDBusConnection:exit-on-close property set to %TRUE.
    """
    ...

def bus_get_sync(
    bus_type: BusType,
    cancellable: Cancellable | None = None,
) -> DBusConnection:
    """
    Synchronously connects to the message bus specified by @bus_type.
    Note that the returned object may shared with other callers,
    e.g. if two separate parts of a process calls this function with
    the same @bus_type, they will share the same object.

    This is a synchronous failable function. See g_bus_get() and
    g_bus_get_finish() for the asynchronous version.

    The returned object is a singleton, that is, shared with other
    callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
    event that you need a private message bus connection, use
    g_dbus_address_get_for_bus_sync() and
    g_dbus_connection_new_for_address() with
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.

    Note that the returned #GDBusConnection object will (usually) have
    the #GDBusConnection:exit-on-close property set to %TRUE.
    """
    ...

def bus_own_name(
    bus_type: BusType,
    name: str,
    flags: BusNameOwnerFlags,
    bus_acquired_closure: GObject.Closure | None = None,
    name_acquired_closure: GObject.Closure | None = None,
    name_lost_closure: GObject.Closure | None = None,
) -> int:
    """
    Requests ownership of @name on the bus specified by @bus_type.

    It asynchronously calls @name_acquired_handler and @name_lost_handler when
    the name is acquired and lost, respectively.

    Callbacks will be invoked in the thread-default
    main context (see [method@GLib.MainContext.push_thread_default])
    of the thread you are calling this function from.

    You are guaranteed that one of the @name_acquired_handler and @name_lost_handler
    callbacks will be invoked after calling this function — there are three
    possible cases:

    - @name_lost_handler with a `NULL` connection (if a connection to the bus
      can’t be made).
    - @bus_acquired_handler then @name_lost_handler (if the name can’t be
      obtained).
    - @bus_acquired_handler then @name_acquired_handler (if the name was
      obtained).

    When you are done owning the name, call [func@Gio.bus_unown_name] with the
    owner ID this function returns.

    If the name is acquired or lost (for example another application
    could acquire the name if you allow replacement or the application
    currently owning the name exits), the handlers are also invoked.
    If the [class@Gio.DBusConnection] that is used for attempting to own the name
    closes, then @name_lost_handler is invoked since it is no longer
    possible for other processes to access the process.

    You cannot use [func@Gio.bus_own_name] several times for the same name (unless
    interleaved with calls to [func@Gio.bus_unown_name]) — only the first call
    will work.

    Another guarantee is that invocations of @name_acquired_handler
    and @name_lost_handler are guaranteed to alternate; that
    is, if @name_acquired_handler is invoked then you are
    guaranteed that the next time one of the handlers is invoked, it
    will be @name_lost_handler. The reverse is also true.

    If you plan on exporting objects (using, for example,
    [method@Gio.DBusConnection.register_object]), note that it is generally too late
    to export the objects in @name_acquired_handler. Instead, you can do this
    in @bus_acquired_handler since you are guaranteed that this will run
    before @name is requested from the bus.

    This behavior makes it very simple to write applications that want
    to [own names](dbus-name-owning.html#d-bus-name-owning) and export objects.
    Simply register objects to be exported in @bus_acquired_handler and
    unregister the objects (if any) in @name_lost_handler.
    """
    ...

def bus_own_name_on_connection(
    connection: DBusConnection,
    name: str,
    flags: BusNameOwnerFlags,
    name_acquired_closure: GObject.Closure | None = None,
    name_lost_closure: GObject.Closure | None = None,
) -> int:
    """
    Like [func@Gio.bus_own_name] but takes a [class@Gio.DBusConnection] instead
    of a [enum@Gio.BusType].
    """
    ...

def bus_unown_name(
    owner_id: int,
) -> None:
    """
    Stops owning a name.

    Note that there may still be D-Bus traffic to process (relating to owning
    and unowning the name) in the current thread-default
    [struct@GLib.MainContext] after this function has returned. You should
    continue to iterate the [struct@GLib.MainContext] until the
    [callback@GLib.DestroyNotify] function passed to [func@Gio.bus_own_name] is
    called, in order to avoid memory leaks through callbacks queued on the
    [struct@GLib.MainContext] after it’s stopped being iterated.
    """
    ...

def bus_unwatch_name(
    watcher_id: int,
) -> None:
    """
    Stops watching a name.

    Note that there may still be D-Bus traffic to process (relating to watching
    and unwatching the name) in the current thread-default #GMainContext after
    this function has returned. You should continue to iterate the #GMainContext
    until the #GDestroyNotify function passed to g_bus_watch_name() is called, in
    order to avoid memory leaks through callbacks queued on the #GMainContext
    after it’s stopped being iterated.
    """
    ...

def bus_watch_name(
    bus_type: BusType,
    name: str,
    flags: BusNameWatcherFlags,
    name_appeared_closure: GObject.Closure | None = None,
    name_vanished_closure: GObject.Closure | None = None,
) -> int:
    """
    Starts watching @name on the bus specified by @bus_type and calls
    @name_appeared_handler and @name_vanished_handler when the name is
    known to have an owner respectively known to lose its
    owner. Callbacks will be invoked in the thread-default main context
    (see [method@GLib.MainContext.push_thread_default])
    of the thread you are calling this function from.

    You are guaranteed that one of the handlers will be invoked after
    calling this function. When you are done watching the name, just
    call g_bus_unwatch_name() with the watcher id this function
    returns.

    If the name vanishes or appears (for example the application owning
    the name could restart), the handlers are also invoked. If the
    #GDBusConnection that is used for watching the name disconnects, then
    @name_vanished_handler is invoked since it is no longer
    possible to access the name.

    Another guarantee is that invocations of @name_appeared_handler
    and @name_vanished_handler are guaranteed to alternate; that
    is, if @name_appeared_handler is invoked then you are
    guaranteed that the next time one of the handlers is invoked, it
    will be @name_vanished_handler. The reverse is also true.

    This behavior makes it very simple to write applications that want
    to take action when a certain [name exists](dbus-name-watching.html#d-bus-name-watching).
    Basically, the application should create object proxies in
    @name_appeared_handler and destroy them again (if any) in
    @name_vanished_handler.
    """
    ...

def bus_watch_name_on_connection(
    connection: DBusConnection,
    name: str,
    flags: BusNameWatcherFlags,
    name_appeared_closure: GObject.Closure | None = None,
    name_vanished_closure: GObject.Closure | None = None,
) -> int:
    """
    Like g_bus_watch_name() but takes a #GDBusConnection instead of a
    #GBusType.
    """
    ...

def content_type_can_be_executable(
    type: str,
) -> bool:
    """
    Checks if a content type can be executable. Note that for instance
    things like text files can be executables (i.e. scripts and batch files).
    """
    ...

def content_type_equals(
    type1: str,
    type2: str,
) -> bool:
    """
    Compares two content types for equality.
    """
    ...

def content_type_from_mime_type(
    mime_type: str,
) -> str | None:
    """
    Tries to find a content type based on the mime type name.
    """
    ...

def content_type_get_description(
    type: str,
) -> str:
    """
    Gets the human readable description of the content type.
    """
    ...

def content_type_get_generic_icon_name(
    type: str,
) -> str | None:
    """
    Gets the generic icon name for a content type.

    See the
    [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
    specification for more on the generic icon name.
    """
    ...

def content_type_get_icon(
    type: str,
) -> Icon:
    """
    Gets the icon for a content type.
    """
    ...

def content_type_get_mime_dirs() -> list:
    """
    Get the list of directories which MIME data is loaded from. See
    g_content_type_set_mime_dirs() for details.
    """
    ...

def content_type_get_mime_type(
    type: str,
) -> str | None:
    """
    Gets the mime type for the content type, if one is registered.
    """
    ...

def content_type_get_symbolic_icon(
    type: str,
) -> Icon:
    """
    Gets the symbolic icon for a content type.
    """
    ...

def content_type_guess(
    filename: str | None,
    data: list | None,
    data_size: int,
) -> tuple[str, bool | None]:
    """
    Guesses the content type based on example data. If the function is
    uncertain, @result_uncertain will be set to %TRUE. Either @filename
    or @data may be %NULL, in which case the guess will be based solely
    on the other argument.
    """
    ...

def content_type_guess_for_tree(
    root: File,
) -> list:
    """
    Tries to guess the type of the tree with root @root, by
    looking at the files it contains. The result is an array
    of content types, with the best guess coming first.

    The types returned all have the form x-content/foo, e.g.
    x-content/audio-cdda (for audio CDs) or x-content/image-dcf
    (for a camera memory card). See the
    [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
    specification for more on x-content types.

    This function is useful in the implementation of
    g_mount_guess_content_type().
    """
    ...

def content_type_is_a(
    type: str,
    supertype: str,
) -> bool:
    """
    Determines if @type is a subset of @supertype.
    """
    ...

def content_type_is_mime_type(
    type: str,
    mime_type: str,
) -> bool:
    """
    Determines if @type is a subset of @mime_type.
    Convenience wrapper around g_content_type_is_a().
    """
    ...

def content_type_is_unknown(
    type: str,
) -> bool:
    """
    Checks if the content type is the generic "unknown" type.
    On UNIX this is the "application/octet-stream" mimetype,
    while on win32 it is "*" and on OSX it is a dynamic type
    or octet-stream.
    """
    ...

def content_type_set_mime_dirs(
    dirs: list | None = None,
) -> None:
    """
    Set the list of directories used by GIO to load the MIME database.
    If @dirs is %NULL, the directories used are the default:

     - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
     - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`

    This function is intended to be used when writing tests that depend on
    information stored in the MIME database, in order to control the data.

    Typically, in case your tests use %G_TEST_OPTION_ISOLATE_DIRS, but they
    depend on the system’s MIME database, you should call this function
    with @dirs set to %NULL before calling g_test_init(), for instance:

    |[<!-- language="C" -->
      // Load MIME data from the system
      g_content_type_set_mime_dirs (NULL);
      // Isolate the environment
      g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);

      …

      return g_test_run ();
    ]|
    """
    ...

def content_types_get_registered() -> list:
    """
    Gets a list of strings containing all the registered content types
    known to the system. The list and its data should be freed using
    `g_list_free_full (list, g_free)`.
    """
    ...

def dbus_address_escape_value(
    string: str,
) -> str:
    """
    Escape @string so it can appear in a D-Bus address as the value
    part of a key-value pair.

    For instance, if @string is `/run/bus-for-:0`,
    this function would return `/run/bus-for-%3A0`,
    which could be used in a D-Bus address like
    `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0`.
    """
    ...

def dbus_address_get_for_bus_sync(
    bus_type: BusType,
    cancellable: Cancellable | None = None,
) -> str:
    """
    Synchronously looks up the D-Bus address for the well-known message
    bus instance specified by @bus_type. This may involve using various
    platform specific mechanisms.

    The returned address will be in the
    [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
    """
    ...

def dbus_address_get_stream(
    address: str,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    user_data: object | None = None,
) -> None:
    """
    Asynchronously connects to an endpoint specified by @address and
    sets up the connection so it is in a state to run the client-side
    of the D-Bus authentication conversation. @address must be in the
    [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

    When the operation is finished, @callback will be invoked. You can
    then call g_dbus_address_get_stream_finish() to get the result of
    the operation.

    This is an asynchronous failable function. See
    g_dbus_address_get_stream_sync() for the synchronous version.
    """
    ...

def dbus_address_get_stream_finish(
    res: AsyncResult,
) -> tuple[IOStream, str | None]:
    """
    Finishes an operation started with g_dbus_address_get_stream().

    A server is not required to set a GUID, so @out_guid may be set to %NULL
    even on success.
    """
    ...

def dbus_address_get_stream_sync(
    address: str,
    cancellable: Cancellable | None = None,
) -> tuple[IOStream, str | None]:
    """
    Synchronously connects to an endpoint specified by @address and
    sets up the connection so it is in a state to run the client-side
    of the D-Bus authentication conversation. @address must be in the
    [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

    A server is not required to set a GUID, so @out_guid may be set to %NULL
    even on success.

    This is a synchronous failable function. See
    g_dbus_address_get_stream() for the asynchronous version.
    """
    ...

def dbus_annotation_info_lookup(
    annotations: list | None,
    name: str,
) -> str | None:
    """
    Looks up the value of an annotation.

    The cost of this function is O(n) in number of annotations.
    """
    ...

def dbus_error_encode_gerror(
    error: None,
) -> str:
    """
    Creates a D-Bus error name to use for @error. If @error matches
    a registered error (cf. g_dbus_error_register_error()), the corresponding
    D-Bus error name will be returned.

    Otherwise the a name of the form
    `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
    will be used. This allows other GDBus applications to map the error
    on the wire back to a #GError using g_dbus_error_new_for_dbus_error().

    This function is typically only used in object mappings to put a
    #GError on the wire. Regular applications should not use it.
    """
    ...

def dbus_error_get_remote_error(
    error: None,
) -> str | None:
    """
    Gets the D-Bus error name used for @error, if any.

    This function is guaranteed to return a D-Bus error name for all
    #GErrors returned from functions handling remote method calls
    (e.g. g_dbus_connection_call_finish()) unless
    g_dbus_error_strip_remote_error() has been used on @error.
    """
    ...

def dbus_error_is_remote_error(
    error: None,
) -> bool:
    """
    Checks if @error represents an error received via D-Bus from a remote peer. If so,
    use g_dbus_error_get_remote_error() to get the name of the error.
    """
    ...

def dbus_error_new_for_dbus_error(
    dbus_error_name: str,
    dbus_error_message: str,
) -> None:
    """
    Creates a #GError based on the contents of @dbus_error_name and
    @dbus_error_message.

    Errors registered with g_dbus_error_register_error() will be looked
    up using @dbus_error_name and if a match is found, the error domain
    and code is used. Applications can use g_dbus_error_get_remote_error()
    to recover @dbus_error_name.

    If a match against a registered error is not found and the D-Bus
    error name is in a form as returned by g_dbus_error_encode_gerror()
    the error domain and code encoded in the name is used to
    create the #GError. Also, @dbus_error_name is added to the error message
    such that it can be recovered with g_dbus_error_get_remote_error().

    Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
    in the %G_IO_ERROR error domain is returned. Also, @dbus_error_name is
    added to the error message such that it can be recovered with
    g_dbus_error_get_remote_error().

    In all three cases, @dbus_error_name can always be recovered from the
    returned #GError using the g_dbus_error_get_remote_error() function
    (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).

    This function is typically only used in object mappings to prepare
    #GError instances for applications. Regular applications should not use
    it.
    """
    ...

def dbus_error_quark() -> int: ...
def dbus_error_register_error(
    error_domain: int,
    error_code: int,
    dbus_error_name: str,
) -> bool:
    """
    Creates an association to map between @dbus_error_name and
    #GErrors specified by @error_domain and @error_code.

    This is typically done in the routine that returns the #GQuark for
    an error domain.
    """
    ...

def dbus_error_register_error_domain(
    error_domain_quark_name: str,
    quark_volatile: int,
    entries: list,
    num_entries: int,
) -> None:
    """
    Helper function for associating a #GError error domain with D-Bus error names.

    While @quark_volatile has a `volatile` qualifier, this is a historical
    artifact and the argument passed to it should not be `volatile`.
    """
    ...

def dbus_error_strip_remote_error(
    error: None,
) -> bool:
    """
    Looks for extra information in the error message used to recover
    the D-Bus error name and strips it if found. If stripped, the
    message field in @error will correspond exactly to what was
    received on the wire.

    This is typically used when presenting errors to the end user.
    """
    ...

def dbus_error_unregister_error(
    error_domain: int,
    error_code: int,
    dbus_error_name: str,
) -> bool:
    """
    Destroys an association previously set up with g_dbus_error_register_error().
    """
    ...

def dbus_escape_object_path(
    s: str,
) -> str:
    """
    This is a language binding friendly version of g_dbus_escape_object_path_bytestring().
    """
    ...

def dbus_escape_object_path_bytestring(
    bytes: list,
) -> str:
    """
    Escapes @bytes for use in a D-Bus object path component.
    @bytes is an array of zero or more nonzero bytes in an
    unspecified encoding, followed by a single zero byte.

    The escaping method consists of replacing all non-alphanumeric
    characters (see g_ascii_isalnum()) with their hexadecimal value
    preceded by an underscore (`_`). For example:
    `foo.bar.baz` will become `foo_2ebar_2ebaz`.

    This method is appropriate to use when the input is nearly
    a valid object path component but is not when your input
    is far from being a valid object path component.
    Other escaping algorithms are also valid to use with
    D-Bus object paths.

    This can be reversed with g_dbus_unescape_object_path().
    """
    ...

def dbus_generate_guid() -> str:
    """
    Generate a D-Bus GUID that can be used with
    e.g. g_dbus_connection_new().

    See the
    [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#uuids)
    regarding what strings are valid D-Bus GUIDs. The specification refers to
    these as ‘UUIDs’ whereas GLib (for historical reasons) refers to them as
    ‘GUIDs’. The terms are interchangeable.

    Note that D-Bus GUIDs do not follow
    [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
    """
    ...

def dbus_gvalue_to_gvariant(
    gvalue: GObject.Value,
    type: GLib.VariantType,
) -> GLib.Variant:
    """
    Converts a #GValue to a #GVariant of the type indicated by the @type
    parameter.

    The conversion is using the following rules:

    - `G_TYPE_STRING`: 's', 'o', 'g' or 'ay'
    - `G_TYPE_STRV`: 'as', 'ao' or 'aay'
    - `G_TYPE_BOOLEAN`: 'b'
    - `G_TYPE_UCHAR`: 'y'
    - `G_TYPE_INT`: 'i', 'n'
    - `G_TYPE_UINT`: 'u', 'q'
    - `G_TYPE_INT64`: 'x'
    - `G_TYPE_UINT64`: 't'
    - `G_TYPE_DOUBLE`: 'd'
    - `G_TYPE_VARIANT`: Any #GVariantType

    This can fail if e.g. @gvalue is of type %G_TYPE_STRING and @type
    is 'i', i.e. %G_VARIANT_TYPE_INT32. It will also fail for any #GType
    (including e.g. %G_TYPE_OBJECT and %G_TYPE_BOXED derived-types) not
    in the table above.

    Note that if @gvalue is of type %G_TYPE_VARIANT and its value is
    %NULL, the empty #GVariant instance (never %NULL) for @type is
    returned (e.g. 0 for scalar types, the empty string for string types,
    '/' for object path types, the empty array for any array type and so on).

    See the g_dbus_gvariant_to_gvalue() function for how to convert a
    #GVariant to a #GValue.
    """
    ...

def dbus_gvariant_to_gvalue(
    value: GLib.Variant,
) -> GObject.Value:
    """
    Converts a #GVariant to a #GValue. If @value is floating, it is consumed.

    The rules specified in the g_dbus_gvalue_to_gvariant() function are
    used - this function is essentially its reverse form. So, a #GVariant
    containing any basic or string array type will be converted to a #GValue
    containing a basic value or string array. Any other #GVariant (handle,
    variant, tuple, dict entry) will be converted to a #GValue containing that
    #GVariant.

    The conversion never fails - a valid #GValue is always returned in
    @out_gvalue.
    """
    ...

def dbus_is_address(
    string: str,
) -> bool:
    """
    Checks if @string is a
    [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

    This doesn't check if @string is actually supported by #GDBusServer
    or #GDBusConnection - use g_dbus_is_supported_address() to do more
    checks.
    """
    ...

def dbus_is_error_name(
    string: str,
) -> bool:
    """
    Check whether @string is a valid D-Bus error name.

    This function returns the same result as g_dbus_is_interface_name(),
    because D-Bus error names are defined to have exactly the
    same syntax as interface names.
    """
    ...

def dbus_is_guid(
    string: str,
) -> bool:
    """
    Checks if @string is a D-Bus GUID.

    See the documentation for g_dbus_generate_guid() for more information about
    the format of a GUID.
    """
    ...

def dbus_is_interface_name(
    string: str,
) -> bool:
    """
    Checks if @string is a valid D-Bus interface name.
    """
    ...

def dbus_is_member_name(
    string: str,
) -> bool:
    """
    Checks if @string is a valid D-Bus member (e.g. signal or method) name.
    """
    ...

def dbus_is_name(
    string: str,
) -> bool:
    """
    Checks if @string is a valid D-Bus bus name (either unique or well-known).
    """
    ...

def dbus_is_supported_address(
    string: str,
) -> bool:
    """
    Like g_dbus_is_address() but also checks if the library supports the
    transports in @string and that key/value pairs for each transport
    are valid. See the specification of the
    [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
    """
    ...

def dbus_is_unique_name(
    string: str,
) -> bool:
    """
    Checks if @string is a valid D-Bus unique bus name.
    """
    ...

def dbus_unescape_object_path(
    s: str,
) -> list | None:
    """
    Unescapes an string that was previously escaped with
    g_dbus_escape_object_path(). If the string is in a format that could
    not have been returned by g_dbus_escape_object_path(), this function
    returns %NULL.

    Encoding alphanumeric characters which do not need to be
    encoded is not allowed (e.g `_63` is not valid, the string
    should contain `c` instead).
    """
    ...

def dtls_client_connection_new(
    base_socket: DatagramBased,
    server_identity: SocketConnectable | None = None,
) -> DtlsClientConnection:
    """
    Creates a new #GDtlsClientConnection wrapping @base_socket which is
    assumed to communicate with the server identified by @server_identity.
    """
    ...

def dtls_server_connection_new(
    base_socket: DatagramBased,
    certificate: TlsCertificate | None = None,
) -> DtlsServerConnection:
    """
    Creates a new #GDtlsServerConnection wrapping @base_socket.
    """
    ...

def file_new_build_filenamev(
    args: list,
) -> File:
    """
    Constructs a #GFile from a vector of elements using the correct
    separator for filenames.

    Using this function is equivalent to calling g_build_filenamev(),
    followed by g_file_new_for_path() on the result.
    """
    ...

def file_new_for_commandline_arg(
    arg: str,
) -> File:
    """
    Creates a #GFile with the given argument from the command line.
    The value of @arg can be either a URI, an absolute path or a
    relative path resolved relative to the current working directory.
    This operation never fails, but the returned object might not
    support any I/O operation if @arg points to a malformed path.

    Note that on Windows, this function expects its argument to be in
    UTF-8 -- not the system code page.  This means that you
    should not use this function with string from argv as it is passed
    to main().  g_win32_get_command_line() will return a UTF-8 version of
    the commandline.  #GApplication also uses UTF-8 but
    g_application_command_line_create_file_for_arg() may be more useful
    for you there.  It is also always possible to use this function with
    #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
    """
    ...

def file_new_for_commandline_arg_and_cwd(
    arg: str,
    cwd: str,
) -> File:
    """
    Creates a #GFile with the given argument from the command line.

    This function is similar to g_file_new_for_commandline_arg() except
    that it allows for passing the current working directory as an
    argument instead of using the current working directory of the
    process.

    This is useful if the commandline argument was given in a context
    other than the invocation of the current process.

    See also g_application_command_line_create_file_for_arg().
    """
    ...

def file_new_for_path(
    path: str,
) -> File:
    """
    Constructs a #GFile for a given path. This operation never
    fails, but the returned object might not support any I/O
    operation if @path is malformed.
    """
    ...

def file_new_for_uri(
    uri: str,
) -> File:
    """
    Constructs a #GFile for a given URI. This operation never
    fails, but the returned object might not support any I/O
    operation if @uri is malformed or if the uri type is
    not supported.
    """
    ...

def file_new_tmp(
    tmpl: str | None = None,
) -> tuple[File, FileIOStream]:
    """
    Opens a file in the preferred directory for temporary files (as
    returned by g_get_tmp_dir()) and returns a #GFile and
    #GFileIOStream pointing to it.

    @tmpl should be a string in the GLib file name encoding
    containing a sequence of six 'X' characters, and containing no
    directory components. If it is %NULL, a default template is used.

    Unlike the other #GFile constructors, this will return %NULL if
    a temporary file could not be created.
    """
    ...

def file_new_tmp_async(
    tmpl: str | None,
    io_priority: int,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    user_data: object | None = None,
) -> None:
    """
    Asynchronously opens a file in the preferred directory for temporary files
     (as returned by g_get_tmp_dir()) as g_file_new_tmp().

    @tmpl should be a string in the GLib file name encoding
    containing a sequence of six 'X' characters, and containing no
    directory components. If it is %NULL, a default template is used.
    """
    ...

def file_new_tmp_dir_async(
    tmpl: str | None,
    io_priority: int,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    user_data: object | None = None,
) -> None:
    """
    Asynchronously creates a directory in the preferred directory for
    temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().

    @tmpl should be a string in the GLib file name encoding
    containing a sequence of six 'X' characters, and containing no
    directory components. If it is %NULL, a default template is used.
    """
    ...

def file_new_tmp_dir_finish(
    result: AsyncResult,
) -> File:
    """
    Finishes a temporary directory creation started by
    g_file_new_tmp_dir_async().
    """
    ...

def file_new_tmp_finish(
    result: AsyncResult,
) -> tuple[File, FileIOStream]:
    """
    Finishes a temporary file creation started by g_file_new_tmp_async().
    """
    ...

def file_parse_name(
    parse_name: str,
) -> File:
    """
    Constructs a #GFile with the given @parse_name (i.e. something
    given by g_file_get_parse_name()). This operation never fails,
    but the returned object might not support any I/O operation if
    the @parse_name cannot be parsed.
    """
    ...

def icon_deserialize(
    value: GLib.Variant,
) -> Icon | None:
    """
    Deserializes a #GIcon previously serialized using g_icon_serialize().
    """
    ...

def icon_new_for_string(
    str: str,
) -> Icon:
    """
    Generate a #GIcon instance from @str. This function can fail if
    @str is not valid - see g_icon_to_string() for discussion.

    If your application or library provides one or more #GIcon
    implementations you need to ensure that each #GType is registered
    with the type system prior to calling g_icon_new_for_string().
    """
    ...

def initable_newv(
    object_type: GObject.GType,
    n_parameters: int,
    parameters: list,
    cancellable: Cancellable | None = None,
) -> GObject.Object:
    """
    Helper function for constructing #GInitable object. This is
    similar to g_object_newv() but also initializes the object
    and returns %NULL, setting an error on failure.
    """
    ...

def io_error_from_errno(
    err_no: int,
) -> IOErrorEnum:
    """
    Converts `errno.h` error codes into GIO error codes.

    The fallback value %G_IO_ERROR_FAILED is returned for error codes not
    currently handled (but note that future GLib releases may return a more
    specific value instead).

    As `errno` is global and may be modified by intermediate function
    calls, you should save its value immediately after the call returns,
    and use the saved value instead of `errno`:


    |[<!-- language="C" -->
      int saved_errno;

      ret = read (blah);
      saved_errno = errno;

      g_io_error_from_errno (saved_errno);
    ]|
    """
    ...

def io_error_from_file_error(
    file_error: GLib.FileError,
) -> IOErrorEnum:
    """
    Converts #GFileError error codes into GIO error codes.
    """
    ...

def io_error_quark() -> int:
    """
    Gets the GIO Error Quark.
    """
    ...

def io_extension_point_implement(
    extension_point_name: str,
    type: GObject.GType,
    extension_name: str,
    priority: int,
) -> IOExtension:
    """
    Registers @type as extension for the extension point with name
    @extension_point_name.

    If @type has already been registered as an extension for this
    extension point, the existing #GIOExtension object is returned.
    """
    ...

def io_extension_point_lookup(
    name: str,
) -> IOExtensionPoint:
    """
    Looks up an existing extension point.
    """
    ...

def io_extension_point_register(
    name: str,
) -> IOExtensionPoint:
    """
    Registers an extension point.
    """
    ...

def io_modules_load_all_in_directory(
    dirname: str,
) -> list:
    """
    Loads all the modules in the specified directory.

    If don't require all modules to be initialized (and thus registering
    all gtypes) then you can use g_io_modules_scan_all_in_directory()
    which allows delayed/lazy loading of modules.
    """
    ...

def io_modules_load_all_in_directory_with_scope(
    dirname: str,
    scope: IOModuleScope,
) -> list:
    """
    Loads all the modules in the specified directory.

    If don't require all modules to be initialized (and thus registering
    all gtypes) then you can use g_io_modules_scan_all_in_directory()
    which allows delayed/lazy loading of modules.
    """
    ...

def io_modules_scan_all_in_directory(
    dirname: str,
) -> None:
    """
    Scans all the modules in the specified directory, ensuring that
    any extension point implemented by a module is registered.

    This may not actually load and initialize all the types in each
    module, some modules may be lazily loaded and initialized when
    an extension point it implements is used with e.g.
    g_io_extension_point_get_extensions() or
    g_io_extension_point_get_extension_by_name().

    If you need to guarantee that all types are loaded in all the modules,
    use g_io_modules_load_all_in_directory().
    """
    ...

def io_modules_scan_all_in_directory_with_scope(
    dirname: str,
    scope: IOModuleScope,
) -> None:
    """
    Scans all the modules in the specified directory, ensuring that
    any extension point implemented by a module is registered.

    This may not actually load and initialize all the types in each
    module, some modules may be lazily loaded and initialized when
    an extension point it implements is used with e.g.
    g_io_extension_point_get_extensions() or
    g_io_extension_point_get_extension_by_name().

    If you need to guarantee that all types are loaded in all the modules,
    use g_io_modules_load_all_in_directory().
    """
    ...

def io_scheduler_cancel_all_jobs() -> None:
    """
    Cancels all cancellable I/O jobs.

    A job is cancellable if a #GCancellable was passed into
    g_io_scheduler_push_job().
    """
    ...

def io_scheduler_push_job(
    job_func: IOSchedulerJobFunc,
    user_data: object | None,
    notify: GLib.DestroyNotify | None,  # type: ignore
    io_priority: int,
    cancellable: Cancellable | None = None,
) -> None:
    """
    Schedules the I/O job to run in another thread.

    @notify will be called on @user_data after @job_func has returned,
    regardless whether the job was cancelled or has run to completion.

    If @cancellable is not %NULL, it can be used to cancel the I/O job
    by calling g_cancellable_cancel() or by calling
    g_io_scheduler_cancel_all_jobs().
    """
    ...

def keyfile_settings_backend_new(
    filename: str,
    root_path: str,
    root_group: str | None = None,
) -> SettingsBackend:
    """
    Creates a keyfile-backed [class@Gio.SettingsBackend].

    The filename of the keyfile to use is given by @filename.

    All settings read to or written from the backend must fall under the
    path given in @root_path (which must start and end with a slash and
    not contain two consecutive slashes).  @root_path may be `"/"`.

    If @root_group is non-`NULL` then it specifies the name of the keyfile
    group used for keys that are written directly below @root_path.  For
    example, if @root_path is `"/apps/example/"` and @root_group is
    `"toplevel"`, then setting the key `"/apps/example/enabled"` to true will
    cause the following to appear in the keyfile:

    ```
    [toplevel]
    enabled=true
    ```

    If @root_group is `NULL` then it is not permitted to store keys
    directly below the @root_path.

    For keys not stored directly below @root_path (ie: in a sub-path),
    the name of the subpath (with the final slash stripped) is used as
    the name of the keyfile group.  To continue the example, if
    `"/apps/example/profiles/default/font-size"` were set to
    `12` then the following would appear in the keyfile:

    ```
    [profiles/default]
    font-size=12
    ```

    The backend will refuse writes (and return writability as being
    false) for keys outside of @root_path and, in the event that
    @root_group is `NULL`, also for keys directly under @root_path.
    Writes will also be refused if the backend detects that it has the
    inability to rewrite the keyfile (ie: the containing directory is not
    writable).

    There is no checking done for your key namespace clashing with the
    syntax of the key file format.  For example, if you have `[` or `]`
    characters in your path names or `=` in your key names you may be in
    trouble.

    The backend reads default values from a keyfile called `defaults` in
    the directory specified by the `GKeyfileSettingsBackend:defaults-dir`
    property, and a list of locked keys from a text file with the name `locks` in
    the same location.
    """
    ...

def memory_monitor_dup_default() -> MemoryMonitor:
    """
    Gets a reference to the default #GMemoryMonitor for the system.
    """
    ...

def memory_settings_backend_new() -> SettingsBackend:
    """
    Creates a memory-backed #GSettingsBackend.

    This backend allows changes to settings, but does not write them
    to any backing storage, so the next time you run your application,
    the memory backend will start out with the default values again.
    """
    ...

def network_monitor_get_default() -> NetworkMonitor:
    """
    Gets the default #GNetworkMonitor for the system.
    """
    ...

def networking_init() -> None:
    """
    Initializes the platform networking libraries (eg, on Windows, this
    calls WSAStartup()). GLib will call this itself if it is needed, so
    you only need to call it if you directly call system networking
    functions (without calling any GLib networking functions first).
    """
    ...

def null_settings_backend_new() -> SettingsBackend:
    """
    Creates a readonly #GSettingsBackend.

    This backend does not allow changes to settings, so all settings
    will always have their default values.
    """
    ...

def pollable_source_new(
    pollable_stream: GObject.Object,
) -> GLib.Source:
    """
    Utility method for #GPollableInputStream and #GPollableOutputStream
    implementations. Creates a new #GSource that expects a callback of
    type #GPollableSourceFunc. The new source does not actually do
    anything on its own; use g_source_add_child_source() to add other
    sources to it to cause it to trigger.
    """
    ...

def pollable_source_new_full(
    pollable_stream: GObject.Object,
    child_source: GLib.Source | None = None,
    cancellable: Cancellable | None = None,
) -> GLib.Source:
    """
    Utility method for #GPollableInputStream and #GPollableOutputStream
    implementations. Creates a new #GSource, as with
    g_pollable_source_new(), but also attaching @child_source (with a
    dummy callback), and @cancellable, if they are non-%NULL.
    """
    ...

def pollable_stream_read(
    stream: InputStream,
    buffer: list,
    count: int,
    blocking: bool,
    cancellable: Cancellable | None = None,
) -> int:
    """
    Tries to read from @stream, as with g_input_stream_read() (if
    @blocking is %TRUE) or g_pollable_input_stream_read_nonblocking()
    (if @blocking is %FALSE). This can be used to more easily share
    code between blocking and non-blocking implementations of a method.

    If @blocking is %FALSE, then @stream must be a
    #GPollableInputStream for which g_pollable_input_stream_can_poll()
    returns %TRUE, or else the behavior is undefined. If @blocking is
    %TRUE, then @stream does not need to be a #GPollableInputStream.
    """
    ...

def pollable_stream_write(
    stream: OutputStream,
    buffer: list,
    count: int,
    blocking: bool,
    cancellable: Cancellable | None = None,
) -> int:
    """
    Tries to write to @stream, as with g_output_stream_write() (if
    @blocking is %TRUE) or g_pollable_output_stream_write_nonblocking()
    (if @blocking is %FALSE). This can be used to more easily share
    code between blocking and non-blocking implementations of a method.

    If @blocking is %FALSE, then @stream must be a
    #GPollableOutputStream for which
    g_pollable_output_stream_can_poll() returns %TRUE or else the
    behavior is undefined. If @blocking is %TRUE, then @stream does not
    need to be a #GPollableOutputStream.
    """
    ...

def pollable_stream_write_all(
    stream: OutputStream,
    buffer: list,
    count: int,
    blocking: bool,
    cancellable: Cancellable | None = None,
) -> tuple[bool, int]:
    """
    Tries to write @count bytes to @stream, as with
    g_output_stream_write_all(), but using g_pollable_stream_write()
    rather than g_output_stream_write().

    On a successful write of @count bytes, %TRUE is returned, and
    @bytes_written is set to @count.

    If there is an error during the operation (including
    %G_IO_ERROR_WOULD_BLOCK in the non-blocking case), %FALSE is
    returned and @error is set to indicate the error status,
    @bytes_written is updated to contain the number of bytes written
    into the stream before the error occurred.

    As with g_pollable_stream_write(), if @blocking is %FALSE, then
    @stream must be a #GPollableOutputStream for which
    g_pollable_output_stream_can_poll() returns %TRUE or else the
    behavior is undefined. If @blocking is %TRUE, then @stream does not
    need to be a #GPollableOutputStream.
    """
    ...

def power_profile_monitor_dup_default() -> PowerProfileMonitor:
    """
    Gets a reference to the default #GPowerProfileMonitor for the system.
    """
    ...

def proxy_get_default_for_protocol(
    protocol: str,
) -> Proxy | None:
    """
    Find the `gio-proxy` extension point for a proxy implementation that supports
    the specified protocol.
    """
    ...

def proxy_resolver_get_default() -> ProxyResolver:
    """
    Gets the default #GProxyResolver for the system.
    """
    ...

def resolver_error_quark() -> int:
    """
    Gets the #GResolver Error Quark.
    """
    ...

def resource_error_quark() -> int:
    """
    Gets the [struct@Gio.Resource] Error Quark.
    """
    ...

def resource_load(
    filename: str,
) -> Resource:
    """
    Loads a binary resource bundle and creates a [struct@Gio.Resource]
    representation of it, allowing you to query it for data.

    If you want to use this resource in the global resource namespace you need
    to register it with [func@Gio.resources_register].

    If @filename is empty or the data in it is corrupt,
    %G_RESOURCE_ERROR_INTERNAL will be returned. If @filename doesn’t exist, or
    there is an error in reading it, an error from [ctor@GLib.MappedFile.new]
    will be returned.
    """
    ...

def resources_enumerate_children(
    path: str,
    lookup_flags: ResourceLookupFlags,
) -> list:
    """
    Returns all the names of children at the specified @path in the set of
    globally registered resources.

    The return result is a `NULL` terminated list of strings which should
    be released with [func@GLib.strfreev].

    @lookup_flags controls the behaviour of the lookup.
    """
    ...

def resources_get_info(
    path: str,
    lookup_flags: ResourceLookupFlags,
) -> tuple[bool, int | None, int | None]:
    """
    Looks for a file at the specified @path in the set of
    globally registered resources and if found returns information about it.

    @lookup_flags controls the behaviour of the lookup.
    """
    ...

def resources_has_children(
    path: str,
) -> bool:
    """
    Returns whether the specified @path in the set of
    globally registered resources has children.
    """
    ...

def resources_lookup_data(
    path: str,
    lookup_flags: ResourceLookupFlags,
) -> GLib.Bytes:
    """
    Looks for a file at the specified @path in the set of
    globally registered resources and returns a [struct@GLib.Bytes] that
    lets you directly access the data in memory.

    The data is always followed by a zero byte, so you
    can safely use the data as a C string. However, that byte
    is not included in the size of the [struct@GLib.Bytes].

    For uncompressed resource files this is a pointer directly into
    the resource bundle, which is typically in some read-only data section
    in the program binary. For compressed files we allocate memory on
    the heap and automatically uncompress the data.

    @lookup_flags controls the behaviour of the lookup.
    """
    ...

def resources_open_stream(
    path: str,
    lookup_flags: ResourceLookupFlags,
) -> InputStream:
    """
    Looks for a file at the specified @path in the set of
    globally registered resources and returns a [class@Gio.InputStream]
    that lets you read the data.

    @lookup_flags controls the behaviour of the lookup.
    """
    ...

def resources_register(
    resource: Resource,
) -> None:
    """
    Registers the resource with the process-global set of resources.

    Once a resource is registered the files in it can be accessed
    with the global resource lookup functions like
    [func@Gio.resources_lookup_data].
    """
    ...

def resources_unregister(
    resource: Resource,
) -> None:
    """
    Unregisters the resource from the process-global set of resources.
    """
    ...

def settings_schema_source_get_default() -> SettingsSchemaSource | None:
    """
    Gets the default system schema source.

    This function is not required for normal uses of #GSettings but it
    may be useful to authors of plugin management systems or to those who
    want to introspect the content of schemas.

    If no schemas are installed, %NULL will be returned.

    The returned source may actually consist of multiple schema sources
    from different directories, depending on which directories were given
    in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
    lookups performed against the default source should probably be done
    recursively.
    """
    ...

def simple_async_report_gerror_in_idle(
    object: GObject.Object | None,
    callback: AsyncReadyCallback | None,
    user_data: object | None,
    error: None,
) -> None:
    """
    Reports an error in an idle function. Similar to
    g_simple_async_report_error_in_idle(), but takes a #GError rather
    than building a new one.
    """
    ...

def tls_backend_get_default() -> TlsBackend:
    """
    Gets the default #GTlsBackend for the system.
    """
    ...

def tls_channel_binding_error_quark() -> int:
    """
    Gets the TLS channel binding error quark.
    """
    ...

def tls_client_connection_new(
    base_io_stream: IOStream,
    server_identity: SocketConnectable | None = None,
) -> TlsClientConnection:
    """
    Creates a new #GTlsClientConnection wrapping @base_io_stream (which
    must have pollable input and output streams) which is assumed to
    communicate with the server identified by @server_identity.

    See the documentation for #GTlsConnection:base-io-stream for restrictions
    on when application code can run operations on the @base_io_stream after
    this function has returned.
    """
    ...

def tls_error_quark() -> int:
    """
    Gets the TLS error quark.
    """
    ...

def tls_file_database_new(
    anchors: str,
) -> TlsFileDatabase:
    """
    Creates a new #GTlsFileDatabase which uses anchor certificate authorities
    in @anchors to verify certificate chains.

    The certificates in @anchors must be PEM encoded.
    """
    ...

def tls_server_connection_new(
    base_io_stream: IOStream,
    certificate: TlsCertificate | None = None,
) -> TlsServerConnection:
    """
    Creates a new #GTlsServerConnection wrapping @base_io_stream (which
    must have pollable input and output streams).

    See the documentation for #GTlsConnection:base-io-stream for restrictions
    on when application code can run operations on the @base_io_stream after
    this function has returned.
    """
    ...

def unix_is_mount_path_system_internal(
    mount_path: str,
) -> bool:
    """
    Determines if @mount_path is considered an implementation of the
    OS.

    This is primarily used for hiding mountable and mounted volumes
    that only are used in the OS and has little to no relevance to the
    casual user.
    """
    ...

def unix_is_system_device_path(
    device_path: str,
) -> bool:
    """
    Determines if @device_path is considered a block device path which is only
    used in implementation of the OS.

    This is primarily used for hiding mounted volumes that are intended as APIs
    for programs to read, and system administrators at a shell; rather than
    something that should, for example, appear in a GUI. For example, the Linux
    `/proc` filesystem.

    The list of device paths considered ‘system’ ones may change over time.
    """
    ...

def unix_is_system_fs_type(
    fs_type: str,
) -> bool:
    """
    Determines if @fs_type is considered a type of file system which is only
    used in implementation of the OS.

    This is primarily used for hiding mounted volumes that are intended as APIs
    for programs to read, and system administrators at a shell; rather than
    something that should, for example, appear in a GUI. For example, the Linux
    `/proc` filesystem.

    The list of file system types considered ‘system’ ones may change over time.
    """
    ...

def unix_mount_at(
    mount_path: str,
) -> tuple[GioUnix.MountEntry | None, int | None]:
    """
    Gets a [struct@GioUnix.MountEntry] for a given mount path.

    If @time_read is set, it will be filled with a Unix timestamp for checking
    if the mounts have changed since with
    [func@GioUnix.mount_entries_changed_since].

    If more mounts have the same mount path, the last matching mount
    is returned.

    This will return `NULL` if there is no mount point at @mount_path.
    """
    ...

def unix_mount_compare(
    mount1: GioUnix.MountEntry,
    mount2: GioUnix.MountEntry,
) -> int:
    """
    Compares two Unix mounts.
    """
    ...

def unix_mount_copy(
    mount_entry: GioUnix.MountEntry,
) -> GioUnix.MountEntry:
    """
    Makes a copy of @mount_entry.
    """
    ...

def unix_mount_entries_changed_since(
    time: int,
) -> bool:
    """
    Checks if the Unix mounts have changed since a given Unix time.

    This can only work reliably if a [class@GioUnix.MountMonitor] is running in
    the process, otherwise changes in the mount entries file (such as
    `/proc/self/mountinfo` on Linux) cannot be detected and, as a result, this
    function has to conservatively always return `TRUE`.

    It is more efficient to use [signal@GioUnix.MountMonitor::mounts-changed] to
    be signalled of changes to the mount entries, rather than polling using this
    function. This function is more appropriate for infrequently determining
    cache validity.
    """
    ...

def unix_mount_entries_get() -> tuple[list, int | None]:
    """
    Gets a list of [struct@GioUnix.MountEntry] instances representing the Unix
    mounts.

    If @time_read is set, it will be filled with the mount timestamp, allowing
    for checking if the mounts have changed with
    [func@GioUnix.mount_entries_changed_since].
    """
    ...

def unix_mount_entries_get_from_file(
    table_path: str,
) -> tuple[list | None, int | None, int | None]:
    """
    Gets an array of [struct@Gio.UnixMountEntry]s containing the Unix mounts
    listed in @table_path.

    This is a generalized version of [func@GioUnix.mount_entries_get], mainly
    intended for internal testing use. Note that [func@GioUnix.mount_entries_get]
    may parse multiple hierarchical table files, so this function is not a direct
    superset of its functionality.

    If there is an error reading or parsing the file, `NULL` will be returned
    and both out parameters will be set to `0`.
    """
    ...

def unix_mount_entry_at(
    mount_path: str,
) -> tuple[GioUnix.MountEntry | None, int | None]:
    """
    Gets a [struct@GioUnix.MountEntry] for a given mount path.

    If @time_read is set, it will be filled with a Unix timestamp for checking
    if the mounts have changed since with
    [func@GioUnix.mount_entries_changed_since].

    If more mounts have the same mount path, the last matching mount
    is returned.

    This will return `NULL` if there is no mount point at @mount_path.
    """
    ...

def unix_mount_entry_for(
    file_path: str,
) -> tuple[GioUnix.MountEntry | None, int | None]:
    """
    Gets a [struct@GioUnix.MountEntry] for a given file path.

    If @time_read is set, it will be filled with a Unix timestamp for checking
    if the mounts have changed since with
    [func@GioUnix.mount_entries_changed_since].

    If more mounts have the same mount path, the last matching mount
    is returned.

    This will return `NULL` if looking up the mount entry fails, if
    @file_path doesn’t exist or there is an I/O error.
    """
    ...

def unix_mount_for(
    file_path: str,
) -> tuple[GioUnix.MountEntry | None, int | None]:
    """
    Gets a [struct@GioUnix.MountEntry] for a given file path.

    If @time_read is set, it will be filled with a Unix timestamp for checking
    if the mounts have changed since with
    [func@GioUnix.mount_entries_changed_since].

    If more mounts have the same mount path, the last matching mount
    is returned.

    This will return `NULL` if looking up the mount entry fails, if
    @file_path doesn’t exist or there is an I/O error.
    """
    ...

def unix_mount_free(
    mount_entry: GioUnix.MountEntry,
) -> None:
    """
    Frees a Unix mount.
    """
    ...

def unix_mount_get_device_path(
    mount_entry: GioUnix.MountEntry,
) -> str:
    """
    Gets the device path for a Unix mount.
    """
    ...

def unix_mount_get_fs_type(
    mount_entry: GioUnix.MountEntry,
) -> str:
    """
    Gets the filesystem type for the Unix mount.
    """
    ...

def unix_mount_get_mount_path(
    mount_entry: GioUnix.MountEntry,
) -> str:
    """
    Gets the mount path for a Unix mount.
    """
    ...

def unix_mount_get_options(
    mount_entry: GioUnix.MountEntry,
) -> str | None:
    """
    Gets a comma separated list of mount options for the Unix mount.

    For example: `rw,relatime,seclabel,data=ordered`.

    This is similar to [func@GioUnix.MountPoint.get_options], but it takes
    a [struct@GioUnix.MountEntry] as an argument.
    """
    ...

def unix_mount_get_root_path(
    mount_entry: GioUnix.MountEntry,
) -> str | None:
    """
    Gets the root of the mount within the filesystem. This is useful e.g. for
    mounts created by bind operation, or btrfs subvolumes.

    For example, the root path is equal to `/` for a mount created by
    `mount /dev/sda1 /mnt/foo` and `/bar` for
    `mount --bind /mnt/foo/bar /mnt/bar`.
    """
    ...

def unix_mount_guess_can_eject(
    mount_entry: GioUnix.MountEntry,
) -> bool:
    """
    Guesses whether a Unix mount entry can be ejected.
    """
    ...

def unix_mount_guess_icon(
    mount_entry: GioUnix.MountEntry,
) -> Icon:
    """
    Guesses the icon of a Unix mount entry.
    """
    ...

def unix_mount_guess_name(
    mount_entry: GioUnix.MountEntry,
) -> str:
    """
    Guesses the name of a Unix mount entry.

    The result is a translated string.
    """
    ...

def unix_mount_guess_should_display(
    mount_entry: GioUnix.MountEntry,
) -> bool:
    """
    Guesses whether a Unix mount entry should be displayed in the UI.
    """
    ...

def unix_mount_guess_symbolic_icon(
    mount_entry: GioUnix.MountEntry,
) -> Icon:
    """
    Guesses the symbolic icon of a Unix mount entry.
    """
    ...

def unix_mount_is_readonly(
    mount_entry: GioUnix.MountEntry,
) -> bool:
    """
    Checks if a Unix mount is mounted read only.
    """
    ...

def unix_mount_is_system_internal(
    mount_entry: GioUnix.MountEntry,
) -> bool:
    """
    Checks if a Unix mount is a system mount.

    This is the Boolean OR of
    [func@GioUnix.is_system_fs_type], [func@GioUnix.is_system_device_path] and
    [func@GioUnix.is_mount_path_system_internal] on @mount_entry’s properties.

    The definition of what a ‘system’ mount entry is may change over time as new
    file system types and device paths are ignored.
    """
    ...

def unix_mount_point_at(
    mount_path: str,
) -> tuple[GioUnix.MountPoint | None, int | None]:
    """
    Gets a [struct@GioUnix.MountPoint] for a given mount path.

    If @time_read is set, it will be filled with a Unix timestamp for checking if
    the mount points have changed since with
    [func@GioUnix.mount_points_changed_since].

    If more mount points have the same mount path, the last matching mount point
    is returned.
    """
    ...

def unix_mount_points_changed_since(
    time: int,
) -> bool:
    """
    Checks if the Unix mount points have changed since a given Unix time.

    Unlike [func@GioUnix.mount_entries_changed_since], this function can work
    reliably without a [class@GioUnix.MountMonitor] running, as it accesses the
    static mount point information (such as `/etc/fstab` on Linux), which has a
    valid modification time.

    It is more efficient to use [signal@GioUnix.MountMonitor::mountpoints-changed]
    to be signalled of changes to the mount points, rather than polling using
    this function. This function is more appropriate for infrequently determining
    cache validity.
    """
    ...

def unix_mount_points_get() -> tuple[list, int | None]:
    """
    Gets a list of [struct@GioUnix.MountPoint] instances representing the Unix
    mount points.

    If @time_read is set, it will be filled with the mount timestamp, allowing
    for checking if the mounts have changed with
    [func@GioUnix.mount_points_changed_since].
    """
    ...

def unix_mount_points_get_from_file(
    table_path: str,
) -> tuple[list | None, int | None, int | None]:
    """
    Gets an array of [struct@Gio.UnixMountPoint]s containing the Unix mount
    points listed in @table_path.

    This is a generalized version of [func@GioUnix.mount_points_get], mainly
    intended for internal testing use. Note that [func@GioUnix.mount_points_get]
    may parse multiple hierarchical table files, so this function is not a direct
    superset of its functionality.

    If there is an error reading or parsing the file, `NULL` will be returned
    and both out parameters will be set to `0`.
    """
    ...

def unix_mounts_changed_since(
    time: int,
) -> bool:
    """
    Checks if the Unix mounts have changed since a given Unix time.
    """
    ...

def unix_mounts_get() -> tuple[list, int | None]:
    """
    Gets a list of [struct@GioUnix.MountEntry] instances representing the Unix
    mounts.

    If @time_read is set, it will be filled with the mount timestamp, allowing
    for checking if the mounts have changed with
    [func@GioUnix.mount_entries_changed_since].
    """
    ...

def unix_mounts_get_from_file(
    table_path: str,
) -> tuple[list | None, int | None, int | None]:
    """
    Gets an array of [struct@Gio.UnixMountEntry]s containing the Unix mounts
    listed in @table_path.

    This is a generalized version of [func@GioUnix.mount_entries_get], mainly
    intended for internal testing use. Note that [func@GioUnix.mount_entries_get]
    may parse multiple hierarchical table files, so this function is not a direct
    superset of its functionality.

    If there is an error reading or parsing the file, `NULL` will be returned
    and both out parameters will be set to `0`.
    """
    ...

###############################################################
# Enums/Flags
###############################################################

class AppInfoCreateFlags(GObject.GFlags):
    """
    Flags used when creating a #GAppInfo."""

    NONE = 0
    """
    No flags.
    """
    NEEDS_TERMINAL = 1
    """
    Application opens in a terminal window.
    """
    SUPPORTS_URIS = 2
    """
    Application supports URI arguments.
    """
    SUPPORTS_STARTUP_NOTIFICATION = 4
    """
    Application supports startup notification. Since 2.26
    """

class ApplicationFlags(GObject.GFlags):
    """
    Flags used to define the behaviour of a #GApplication."""

    FLAGS_NONE = 0
    """
    Default flags.
    """
    DEFAULT_FLAGS = 0
    """
    Default flags.
    """
    IS_SERVICE = 1
    """
    Run as a service. In this mode, registration
         fails if the service is already running, and the application
         will initially wait up to 10 seconds for an initial activation
         message to arrive.
    """
    IS_LAUNCHER = 2
    """
    Don't try to become the primary instance.
    """
    HANDLES_OPEN = 4
    """
    This application handles opening files (in
        the primary instance). Note that this flag only affects the default
        implementation of local_command_line(), and has no effect if
        %G_APPLICATION_HANDLES_COMMAND_LINE is given.
        See g_application_run() for details.
    """
    HANDLES_COMMAND_LINE = 8
    """
    This application handles command line
        arguments (in the primary instance). Note that this flag only affect
        the default implementation of local_command_line().
        See g_application_run() for details.
    """
    SEND_ENVIRONMENT = 16
    """
    Send the environment of the
        launching process to the primary instance. Set this flag if your
        application is expected to behave differently depending on certain
        environment variables. For instance, an editor might be expected
        to use the `GIT_COMMITTER_NAME` environment variable
        when editing a git commit message. The environment is available
        to the #GApplication::command-line signal handler, via
        g_application_command_line_getenv().
    """
    NON_UNIQUE = 32
    """
    Make no attempts to do any of the typical
        single-instance application negotiation, even if the application
        ID is given.  The application neither attempts to become the
        owner of the application ID nor does it check if an existing
        owner already exists.  Everything occurs in the local process.
        Since: 2.30.
    """
    CAN_OVERRIDE_APP_ID = 64
    """
    Allow users to override the
        application ID from the command line with `--gapplication-app-id`.
        Since: 2.48
    """
    ALLOW_REPLACEMENT = 128
    """
    Allow another instance to take over
        the bus name. Since: 2.60
    """
    REPLACE = 256
    """
    Take over from another instance. This flag is
        usually set by passing `--gapplication-replace` on the commandline.
        Since: 2.60
    """

class AskPasswordFlags(GObject.GFlags):
    """
    #GAskPasswordFlags are used to request specific information from the
    user, or to notify the user of their choices in an authentication
    situation."""

    NEED_PASSWORD = 1
    """
    operation requires a password.
    """
    NEED_USERNAME = 2
    """
    operation requires a username.
    """
    NEED_DOMAIN = 4
    """
    operation requires a domain.
    """
    SAVING_SUPPORTED = 8
    """
    operation supports saving settings.
    """
    ANONYMOUS_SUPPORTED = 16
    """
    operation supports anonymous users.
    """
    TCRYPT = 32
    """
    operation takes TCRYPT parameters (Since: 2.58)
    """

class BusNameOwnerFlags(GObject.GFlags):
    """
    Flags used in g_bus_own_name()."""

    NONE = 0
    """
    No flags set.
    """
    ALLOW_REPLACEMENT = 1
    """
    Allow another message bus connection to claim the name.
    """
    REPLACE = 2
    """
    If another message bus connection owns the name and have
    specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
    """
    DO_NOT_QUEUE = 4
    """
    If another message bus connection owns the name, immediately
    return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)
    """

class BusNameWatcherFlags(GObject.GFlags):
    """
    Flags used in g_bus_watch_name()."""

    NONE = 0
    """
    No flags set.
    """
    AUTO_START = 1
    """
    If no-one owns the name when
    beginning to watch the name, ask the bus to launch an owner for the
    name.
    """

class BusType(GObject.GEnum):
    """
    An enumeration for well-known message buses."""

    STARTER = -1
    """
    An alias for the message bus that activated the process, if any.
    """
    NONE = 0
    """
    Not a message bus.
    """
    SYSTEM = 1
    """
    The system-wide message bus.
    """
    SESSION = 2
    """
    The login session message bus.
    """

class ConverterFlags(GObject.GFlags):
    """
    Flags used when calling a g_converter_convert()."""

    NONE = 0
    """
    No flags.
    """
    INPUT_AT_END = 1
    """
    At end of input data
    """
    FLUSH = 2
    """
    Flush data
    """

class ConverterResult(GObject.GEnum):
    """
    Results returned from g_converter_convert()."""

    ERROR = 0
    """
    There was an error during conversion.
    """
    CONVERTED = 1
    """
    Some data was consumed or produced
    """
    FINISHED = 2
    """
    The conversion is finished
    """
    FLUSHED = 3
    """
    Flushing is finished
    """

class CredentialsType(GObject.GEnum):
    """
    Enumeration describing different kinds of native credential types."""

    INVALID = 0
    """
    Indicates an invalid native credential type.
    """
    LINUX_UCRED = 1
    """
    The native credentials type is a `struct ucred`.
    """
    FREEBSD_CMSGCRED = 2
    """
    The native credentials type is a `struct cmsgcred`.
    """
    OPENBSD_SOCKPEERCRED = 3
    """
    The native credentials type is a `struct sockpeercred`. Added in 2.30.
    """
    SOLARIS_UCRED = 4
    """
    The native credentials type is a `ucred_t`. Added in 2.40.
    """
    NETBSD_UNPCBID = 5
    """
    The native credentials type is a `struct unpcbid`. Added in 2.42.
    """
    APPLE_XUCRED = 6
    """
    The native credentials type is a `struct xucred`. Added in 2.66.
    """
    WIN32_PID = 7
    """
    The native credentials type is a PID `DWORD`. Added in 2.72.
    """

class DBusCallFlags(GObject.GFlags):
    """
    Flags used in g_dbus_connection_call() and similar APIs."""

    NONE = 0
    """
    No flags set.
    """
    NO_AUTO_START = 1
    """
    The bus must not launch
    an owner for the destination name in response to this method
    invocation.
    """
    ALLOW_INTERACTIVE_AUTHORIZATION = 2
    """
    the caller is prepared to
    wait for interactive authorization. Since 2.46.
    """

class DBusCapabilityFlags(GObject.GFlags):
    """
    Capabilities negotiated with the remote peer."""

    NONE = 0
    """
    No flags set.
    """
    UNIX_FD_PASSING = 1
    """
    The connection
    supports exchanging UNIX file descriptors with the remote peer.
    """

class DBusConnectionFlags(GObject.GFlags):
    """
    Flags used when creating a new #GDBusConnection."""

    NONE = 0
    """
    No flags set.
    """
    AUTHENTICATION_CLIENT = 1
    """
    Perform authentication against server.
    """
    AUTHENTICATION_SERVER = 2
    """
    Perform authentication against client.
    """
    AUTHENTICATION_ALLOW_ANONYMOUS = 4
    """
    When
    authenticating as a server, allow the anonymous authentication
    method.
    """
    MESSAGE_BUS_CONNECTION = 8
    """
    Pass this flag if connecting to a peer that is a
    message bus. This means that the Hello() method will be invoked as part of the connection setup.
    """
    DELAY_MESSAGE_PROCESSING = 16
    """
    If set, processing of D-Bus messages is
    delayed until g_dbus_connection_start_message_processing() is called.
    """
    AUTHENTICATION_REQUIRE_SAME_USER = 32
    """
    When authenticating
    as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)
    """
    CROSS_NAMESPACE = 64
    """
    When authenticating, try to use
     protocols that work across a Linux user namespace boundary, even if this
     reduces interoperability with older D-Bus implementations. This currently
     affects client-side `EXTERNAL` authentication, for which this flag makes
     connections to a server in another user namespace succeed, but causes
     a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74
    """

class DBusError(GObject.GEnum):
    """
    Error codes for the %G_DBUS_ERROR error domain."""

    FAILED = 0
    """
    A generic error; "something went wrong" - see the error message for
    more.
    """
    NO_MEMORY = 1
    """
    There was not enough memory to complete an operation.
    """
    SERVICE_UNKNOWN = 2
    """
    The bus doesn't know how to launch a service to supply the bus name
    you wanted.
    """
    NAME_HAS_NO_OWNER = 3
    """
    The bus name you referenced doesn't exist (i.e. no application owns
    it).
    """
    NO_REPLY = 4
    """
    No reply to a message expecting one, usually means a timeout occurred.
    """
    IO_ERROR = 5
    """
    Something went wrong reading or writing to a socket, for example.
    """
    BAD_ADDRESS = 6
    """
    A D-Bus bus address was malformed.
    """
    NOT_SUPPORTED = 7
    """
    Requested operation isn't supported (like ENOSYS on UNIX).
    """
    LIMITS_EXCEEDED = 8
    """
    Some limited resource is exhausted.
    """
    ACCESS_DENIED = 9
    """
    Security restrictions don't allow doing what you're trying to do.
    """
    AUTH_FAILED = 10
    """
    Authentication didn't work.
    """
    NO_SERVER = 11
    """
    Unable to connect to server (probably caused by ECONNREFUSED on a
    socket).
    """
    TIMEOUT = 12
    """
    Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
    %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
    this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
    exists. We can't fix it for compatibility reasons so just be
    careful.
    """
    NO_NETWORK = 13
    """
    No network access (probably ENETUNREACH on a socket).
    """
    ADDRESS_IN_USE = 14
    """
    Can't bind a socket since its address is in use (i.e. EADDRINUSE).
    """
    DISCONNECTED = 15
    """
    The connection is disconnected and you're trying to use it.
    """
    INVALID_ARGS = 16
    """
    Invalid arguments passed to a method call.
    """
    FILE_NOT_FOUND = 17
    """
    Missing file.
    """
    FILE_EXISTS = 18
    """
    Existing file and the operation you're using does not silently overwrite.
    """
    UNKNOWN_METHOD = 19
    """
    Method name you invoked isn't known by the object you invoked it on.
    """
    TIMED_OUT = 20
    """
    Certain timeout errors, e.g. while starting a service. Warning: this is
    confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
    can't fix it for compatibility reasons so just be careful.
    """
    MATCH_RULE_NOT_FOUND = 21
    """
    Tried to remove or modify a match rule that didn't exist.
    """
    MATCH_RULE_INVALID = 22
    """
    The match rule isn't syntactically valid.
    """
    SPAWN_EXEC_FAILED = 23
    """
    While starting a new process, the exec() call failed.
    """
    SPAWN_FORK_FAILED = 24
    """
    While starting a new process, the fork() call failed.
    """
    SPAWN_CHILD_EXITED = 25
    """
    While starting a new process, the child exited with a status code.
    """
    SPAWN_CHILD_SIGNALED = 26
    """
    While starting a new process, the child exited on a signal.
    """
    SPAWN_FAILED = 27
    """
    While starting a new process, something went wrong.
    """
    SPAWN_SETUP_FAILED = 28
    """
    We failed to setup the environment correctly.
    """
    SPAWN_CONFIG_INVALID = 29
    """
    We failed to setup the config parser correctly.
    """
    SPAWN_SERVICE_INVALID = 30
    """
    Bus name was not valid.
    """
    SPAWN_SERVICE_NOT_FOUND = 31
    """
    Service file not found in system-services directory.
    """
    SPAWN_PERMISSIONS_INVALID = 32
    """
    Permissions are incorrect on the setuid helper.
    """
    SPAWN_FILE_INVALID = 33
    """
    Service file invalid (Name, User or Exec missing).
    """
    SPAWN_NO_MEMORY = 34
    """
    Tried to get a UNIX process ID and it wasn't available.
    """
    UNIX_PROCESS_ID_UNKNOWN = 35
    """
    Tried to get a UNIX process ID and it wasn't available.
    """
    INVALID_SIGNATURE = 36
    """
    A type signature is not valid.
    """
    INVALID_FILE_CONTENT = 37
    """
    A file contains invalid syntax or is otherwise broken.
    """
    SELINUX_SECURITY_CONTEXT_UNKNOWN = 38
    """
    Asked for SELinux security context and it wasn't available.
    """
    ADT_AUDIT_DATA_UNKNOWN = 39
    """
    Asked for ADT audit data and it wasn't available.
    """
    OBJECT_PATH_IN_USE = 40
    """
    There's already an object with the requested object path.
    """
    UNKNOWN_OBJECT = 41
    """
    Object you invoked a method on isn't known. Since 2.42
    """
    UNKNOWN_INTERFACE = 42
    """
    Interface you invoked a method on isn't known by the object. Since 2.42
    """
    UNKNOWN_PROPERTY = 43
    """
    Property you tried to access isn't known by the object. Since 2.42
    """
    PROPERTY_READ_ONLY = 44
    """
    Property you tried to set is read-only. Since 2.42
    """

class DBusInterfaceSkeletonFlags(GObject.GFlags):
    """
    Flags describing the behavior of a #GDBusInterfaceSkeleton instance."""

    NONE = 0
    """
    No flags set.
    """
    HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1
    """
    Each method invocation is handled in
      a thread dedicated to the invocation. This means that the method implementation can use blocking IO
      without blocking any other part of the process. It also means that the method implementation must
      use locking to access data structures used by other threads.
    """

class DBusMessageByteOrder(GObject.GEnum):
    """
    Enumeration used to describe the byte order of a D-Bus message."""

    BIG_ENDIAN = 66
    """
    The byte order is big endian.
    """
    LITTLE_ENDIAN = 108
    """
    The byte order is little endian.
    """

class DBusMessageFlags(GObject.GFlags):
    """
    Message flags used in #GDBusMessage."""

    NONE = 0
    """
    No flags set.
    """
    NO_REPLY_EXPECTED = 1
    """
    A reply is not expected.
    """
    NO_AUTO_START = 2
    """
    The bus must not launch an
    owner for the destination name in response to this message.
    """
    ALLOW_INTERACTIVE_AUTHORIZATION = 4
    """
    If set on a method
    call, this flag means that the caller is prepared to wait for interactive
    authorization. Since 2.46.
    """

class DBusMessageHeaderField(GObject.GEnum):
    """
    Header fields used in #GDBusMessage."""

    INVALID = 0
    """
    Not a valid header field.
    """
    PATH = 1
    """
    The object path.
    """
    INTERFACE = 2
    """
    The interface name.
    """
    MEMBER = 3
    """
    The method or signal name.
    """
    ERROR_NAME = 4
    """
    The name of the error that occurred.
    """
    REPLY_SERIAL = 5
    """
    The serial number the message is a reply to.
    """
    DESTINATION = 6
    """
    The name the message is intended for.
    """
    SENDER = 7
    """
    Unique name of the sender of the message (filled in by the bus).
    """
    SIGNATURE = 8
    """
    The signature of the message body.
    """
    NUM_UNIX_FDS = 9
    """
    The number of UNIX file descriptors that accompany the message.
    """

class DBusMessageType(GObject.GEnum):
    """
    Message types used in #GDBusMessage."""

    INVALID = 0
    """
    Message is of invalid type.
    """
    METHOD_CALL = 1
    """
    Method call.
    """
    METHOD_RETURN = 2
    """
    Method reply.
    """
    ERROR = 3
    """
    Error reply.
    """
    SIGNAL = 4
    """
    Signal emission.
    """

class DBusObjectManagerClientFlags(GObject.GFlags):
    """
    Flags used when constructing a #GDBusObjectManagerClient."""

    NONE = 0
    """
    No flags set.
    """
    DO_NOT_AUTO_START = 1
    """
    If not set and the
      manager is for a well-known name, then request the bus to launch
      an owner for the name if no-one owns the name. This flag can only
      be used in managers for well-known names.
    """

class DBusPropertyInfoFlags(GObject.GFlags):
    """
    Flags describing the access control of a D-Bus property."""

    NONE = 0
    """
    No flags set.
    """
    READABLE = 1
    """
    Property is readable.
    """
    WRITABLE = 2
    """
    Property is writable.
    """

class DBusProxyFlags(GObject.GFlags):
    """
    Flags used when constructing an instance of a #GDBusProxy derived class."""

    NONE = 0
    """
    No flags set.
    """
    DO_NOT_LOAD_PROPERTIES = 1
    """
    Don't load properties.
    """
    DO_NOT_CONNECT_SIGNALS = 2
    """
    Don't connect to signals on the remote object.
    """
    DO_NOT_AUTO_START = 4
    """
    If the proxy is for a well-known name,
    do not ask the bus to launch an owner during proxy initialization or a method call.
    This flag is only meaningful in proxies for well-known names.
    """
    GET_INVALIDATED_PROPERTIES = 8
    """
    If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.
    """
    DO_NOT_AUTO_START_AT_CONSTRUCTION = 16
    """
    If the proxy is for a well-known name,
    do not ask the bus to launch an owner during proxy initialization, but allow it to be
    autostarted by a method call. This flag is only meaningful in proxies for well-known names,
    and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
    """
    NO_MATCH_RULE = 32
    """
    Don't actually send the AddMatch D-Bus
       call for this signal subscription. This gives you more control
       over which match rules you add (but you must add them manually). (Since: 2.72)
    """

class DBusSendMessageFlags(GObject.GFlags):
    """
    Flags used when sending #GDBusMessages on a #GDBusConnection."""

    NONE = 0
    """
    No flags set.
    """
    PRESERVE_SERIAL = 1
    """
    Do not automatically
    assign a serial number from the #GDBusConnection object when
    sending a message.
    """

class DBusServerFlags(GObject.GFlags):
    """
    Flags used when creating a #GDBusServer."""

    NONE = 0
    """
    No flags set.
    """
    RUN_IN_THREAD = 1
    """
    All #GDBusServer::new-connection
    signals will run in separated dedicated threads (see signal for
    details).
    """
    AUTHENTICATION_ALLOW_ANONYMOUS = 2
    """
    Allow the anonymous
    authentication method.
    """
    AUTHENTICATION_REQUIRE_SAME_USER = 4
    """
    Require the UID of the
    peer to be the same as the UID of the server when authenticating. (Since: 2.68)
    """

class DBusSignalFlags(GObject.GFlags):
    """
    Flags used when subscribing to signals via g_dbus_connection_signal_subscribe()."""

    NONE = 0
    """
    No flags set.
    """
    NO_MATCH_RULE = 1
    """
    Don't actually send the AddMatch
    D-Bus call for this signal subscription.  This gives you more control
    over which match rules you add (but you must add them manually).
    """
    MATCH_ARG0_NAMESPACE = 2
    """
    Match first arguments that
    contain a bus or interface name with the given namespace.
    """
    MATCH_ARG0_PATH = 4
    """
    Match first arguments that
    contain an object path that is either equivalent to the given path,
    or one of the paths is a subpath of the other.
    """

class DBusSubtreeFlags(GObject.GFlags):
    """
    Flags passed to g_dbus_connection_register_subtree()."""

    NONE = 0
    """
    No flags set.
    """
    DISPATCH_TO_UNENUMERATED_NODES = 1
    """
    Method calls to objects not in the enumerated range
                                                          will still be dispatched. This is useful if you want
                                                          to dynamically spawn objects in the subtree.
    """

class DataStreamByteOrder(GObject.GEnum):
    """
    #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
    across various machine architectures."""

    BIG_ENDIAN = 0
    """
    Selects Big Endian byte order.
    """
    LITTLE_ENDIAN = 1
    """
    Selects Little Endian byte order.
    """
    HOST_ENDIAN = 2
    """
    Selects endianness based on host machine's architecture.
    """

class DataStreamNewlineType(GObject.GEnum):
    """
    #GDataStreamNewlineType is used when checking for or setting the line endings for a given file."""

    LF = 0
    """
    Selects "LF" line endings, common on most modern UNIX platforms.
    """
    CR = 1
    """
    Selects "CR" line endings.
    """
    CR_LF = 2
    """
    Selects "CR, LF" line ending, common on Microsoft Windows.
    """
    ANY = 3
    """
    Automatically try to handle any line ending type.
    """

class DriveStartFlags(GObject.GFlags):
    """
    Flags used when starting a drive."""

    NONE = 0
    """
    No flags set.
    """

class DriveStartStopType(GObject.GEnum):
    """
    Enumeration describing how a drive can be started/stopped."""

    UNKNOWN = 0
    """
    Unknown or drive doesn't support
       start/stop.
    """
    SHUTDOWN = 1
    """
    The stop method will physically
       shut down the drive and e.g. power down the port the drive is
       attached to.
    """
    NETWORK = 2
    """
    The start/stop methods are used
       for connecting/disconnect to the drive over the network.
    """
    MULTIDISK = 3
    """
    The start/stop methods will
       assemble/disassemble a virtual drive from several physical
       drives.
    """
    PASSWORD = 4
    """
    The start/stop methods will
       unlock/lock the disk (for example using the ATA `SECURITY UNLOCK
       DEVICE` command)
    """

class EmblemOrigin(GObject.GEnum):
    """
    GEmblemOrigin is used to add information about the origin of the emblem
    to #GEmblem."""

    UNKNOWN = 0
    """
    Emblem of unknown origin
    """
    DEVICE = 1
    """
    Emblem adds device-specific information
    """
    LIVEMETADATA = 2
    """
    Emblem depicts live metadata, such as "readonly"
    """
    TAG = 3
    """
    Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
    """

class FileAttributeInfoFlags(GObject.GFlags):
    """
    Flags specifying the behaviour of an attribute."""

    NONE = 0
    """
    no flags set.
    """
    COPY_WITH_FILE = 1
    """
    copy the attribute values when the file is copied.
    """
    COPY_WHEN_MOVED = 2
    """
    copy the attribute values when the file is moved.
    """

class FileAttributeStatus(GObject.GEnum):
    """
    Used by g_file_set_attributes_from_info() when setting file attributes."""

    UNSET = 0
    """
    Attribute value is unset (empty).
    """
    SET = 1
    """
    Attribute value is set.
    """
    ERROR_SETTING = 2
    """
    Indicates an error in setting the value.
    """

class FileAttributeType(GObject.GEnum):
    """
    The data types for file attributes."""

    INVALID = 0
    """
    indicates an invalid or uninitialized type.
    """
    STRING = 1
    """
    a null terminated UTF8 string.
    """
    BYTE_STRING = 2
    """
    a zero terminated string of non-zero bytes.
    """
    BOOLEAN = 3
    """
    a boolean value.
    """
    UINT32 = 4
    """
    an unsigned 4-byte/32-bit integer.
    """
    INT32 = 5
    """
    a signed 4-byte/32-bit integer.
    """
    UINT64 = 6
    """
    an unsigned 8-byte/64-bit integer.
    """
    INT64 = 7
    """
    a signed 8-byte/64-bit integer.
    """
    OBJECT = 8
    """
    a #GObject.
    """
    STRINGV = 9
    """
    a %NULL terminated char **. Since 2.22
    """

class FileCopyFlags(GObject.GFlags):
    """
    Flags used when copying or moving files."""

    NONE = 0
    """
    No flags set.
    """
    OVERWRITE = 1
    """
    Overwrite any existing files
    """
    BACKUP = 2
    """
    Make a backup of any existing files.
    """
    NOFOLLOW_SYMLINKS = 4
    """
    Don't follow symlinks.
    """
    ALL_METADATA = 8
    """
    Copy all file metadata instead of just default set used for copy (see #GFileInfo).
    """
    NO_FALLBACK_FOR_MOVE = 16
    """
    Don't use copy and delete fallback if native move not supported.
    """
    TARGET_DEFAULT_PERMS = 32
    """
    Leaves target file with default perms, instead of setting the source file perms.
    """
    TARGET_DEFAULT_MODIFIED_TIME = 64
    """
    Use default modification
        timestamps instead of copying them from the source file. Since 2.80
    """

class FileCreateFlags(GObject.GFlags):
    """
    Flags used when an operation may create a file."""

    NONE = 0
    """
    No flags set.
    """
    PRIVATE = 1
    """
    Create a file that can only be
       accessed by the current user.
    """
    REPLACE_DESTINATION = 2
    """
    Replace the destination
       as if it didn't exist before. Don't try to keep any old
       permissions, replace instead of following links. This
       is generally useful if you're doing a "copy over"
       rather than a "save new version of" replace operation.
       You can think of it as "unlink destination" before
       writing to it, although the implementation may not
       be exactly like that. This flag can only be used with
       g_file_replace() and its variants, including g_file_replace_contents().
       Since 2.20
    """

class FileMeasureFlags(GObject.GFlags):
    """
    Flags that can be used with g_file_measure_disk_usage()."""

    NONE = 0
    """
    No flags set.
    """
    REPORT_ANY_ERROR = 2
    """
    Report any error encountered
      while traversing the directory tree.  Normally errors are only
      reported for the toplevel file.
    """
    APPARENT_SIZE = 4
    """
    Tally usage based on apparent file
      sizes.  Normally, the block-size is used, if available, as this is a
      more accurate representation of disk space used.
      Compare with `du --apparent-size`.
      Since GLib 2.78. and similarly to `du` since GNU Coreutils 9.2, this will
      ignore the sizes of file types other than regular files and links, as the
      sizes of other file types are not specified in a standard way.
    """
    NO_XDEV = 8
    """
    Do not cross mount point boundaries.
      Compare with `du -x`.
    """

class FileMonitorEvent(GObject.GEnum):
    """
    Specifies what type of event a monitor event is."""

    CHANGED = 0
    """
    a file changed.
    """
    CHANGES_DONE_HINT = 1
    """
    a hint that this was probably the last change in a set of changes.
    """
    DELETED = 2
    """
    a file was deleted.
    """
    CREATED = 3
    """
    a file was created.
    """
    ATTRIBUTE_CHANGED = 4
    """
    a file attribute was changed.
    """
    PRE_UNMOUNT = 5
    """
    the file location will soon be unmounted.
    """
    UNMOUNTED = 6
    """
    the file location was unmounted.
    """
    MOVED = 7
    """
    the file was moved -- only sent if the
      (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set
    """
    RENAMED = 8
    """
    the file was renamed within the
      current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
      flag is set.  Since: 2.46.
    """
    MOVED_IN = 9
    """
    the file was moved into the
      monitored directory from another location -- only sent if the
      %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
    """
    MOVED_OUT = 10
    """
    the file was moved out of the
      monitored directory to another location -- only sent if the
      %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
    """

class FileMonitorFlags(GObject.GFlags):
    """
    Flags used to set what a #GFileMonitor will watch for."""

    NONE = 0
    """
    No flags set.
    """
    WATCH_MOUNTS = 1
    """
    Watch for mount events.
    """
    SEND_MOVED = 2
    """
    Pair DELETED and CREATED events caused
      by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
      event instead (NB: not supported on all backends; the default
      behaviour -without specifying this flag- is to send single DELETED
      and CREATED events).  Deprecated since 2.46: use
      %G_FILE_MONITOR_WATCH_MOVES instead.
    """
    WATCH_HARD_LINKS = 4
    """
    Watch for changes to the file made
      via another hard link. Since 2.36.
    """
    WATCH_MOVES = 8
    """
    Watch for rename operations on a
      monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
      %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
      events to be emitted when possible.  Since: 2.46.
    """

class FileQueryInfoFlags(GObject.GFlags):
    """
    Flags used when querying a #GFileInfo."""

    NONE = 0
    """
    No flags set.
    """
    NOFOLLOW_SYMLINKS = 1
    """
    Don't follow symlinks.
    """

class FileType(GObject.GEnum):
    """
    Indicates the file's on-disk type.

    On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
    use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
    whether a file is a symlink or not. This is due to the fact that NTFS does
    not have a single filesystem object type for symbolic links - it has
    files that symlink to files, and directories that symlink to directories.
    #GFileType enumeration cannot precisely represent this important distinction,
    which is why all Windows symlinks will continue to be reported as
    %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY."""

    UNKNOWN = 0
    """
    File's type is unknown.
    """
    REGULAR = 1
    """
    File handle represents a regular file.
    """
    DIRECTORY = 2
    """
    File handle represents a directory.
    """
    SYMBOLIC_LINK = 3
    """
    File handle represents a symbolic link
       (Unix systems).
    """
    SPECIAL = 4
    """
    File is a "special" file, such as a socket, fifo,
       block device, or character device.
    """
    SHORTCUT = 5
    """
    File is a shortcut (Windows systems).
    """
    MOUNTABLE = 6
    """
    File is a mountable location.
    """

class FilesystemPreviewType(GObject.GEnum):
    """
    Indicates a hint from the file system whether files should be
    previewed in a file manager. Returned as the value of the key
    %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW."""

    IF_ALWAYS = 0
    """
    Only preview files if user has explicitly requested it.
    """
    IF_LOCAL = 1
    """
    Preview files if user has requested preview of "local" files.
    """
    NEVER = 2
    """
    Never preview files.
    """

class IOErrorEnum(GObject.GEnum):
    """
    Error codes returned by GIO functions.

    Note that this domain may be extended in future GLib releases. In
    general, new error codes either only apply to new APIs, or else
    replace %G_IO_ERROR_FAILED in cases that were not explicitly
    distinguished before. You should therefore avoid writing code like
    |[<!-- language="C" -->
    if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
      {
        // Assume that this is EPRINTERONFIRE
        ...
      }
    ]|
    but should instead treat all unrecognized error codes the same as
    %G_IO_ERROR_FAILED.

    See also #GPollableReturn for a cheaper way of returning
    %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError."""

    FAILED = 0
    """
    Generic error condition for when an operation fails
        and no more specific #GIOErrorEnum value is defined.
    """
    NOT_FOUND = 1
    """
    File not found.
    """
    EXISTS = 2
    """
    File already exists.
    """
    IS_DIRECTORY = 3
    """
    File is a directory.
    """
    NOT_DIRECTORY = 4
    """
    File is not a directory.
    """
    NOT_EMPTY = 5
    """
    File is a directory that isn't empty.
    """
    NOT_REGULAR_FILE = 6
    """
    File is not a regular file.
    """
    NOT_SYMBOLIC_LINK = 7
    """
    File is not a symbolic link.
    """
    NOT_MOUNTABLE_FILE = 8
    """
    File cannot be mounted.
    """
    FILENAME_TOO_LONG = 9
    """
    Filename is too many characters.
    """
    INVALID_FILENAME = 10
    """
    Filename is invalid or contains invalid characters.
    """
    TOO_MANY_LINKS = 11
    """
    File contains too many symbolic links.
    """
    NO_SPACE = 12
    """
    No space left on drive.
    """
    INVALID_ARGUMENT = 13
    """
    Invalid argument.
    """
    PERMISSION_DENIED = 14
    """
    Permission denied.
    """
    NOT_SUPPORTED = 15
    """
    Operation (or one of its parameters) not supported
    """
    NOT_MOUNTED = 16
    """
    File isn't mounted.
    """
    ALREADY_MOUNTED = 17
    """
    File is already mounted.
    """
    CLOSED = 18
    """
    File was closed.
    """
    CANCELLED = 19
    """
    Operation was cancelled. See #GCancellable.
    """
    PENDING = 20
    """
    Operations are still pending.
    """
    READ_ONLY = 21
    """
    File is read only.
    """
    CANT_CREATE_BACKUP = 22
    """
    Backup couldn't be created.
    """
    WRONG_ETAG = 23
    """
    File's Entity Tag was incorrect.
    """
    TIMED_OUT = 24
    """
    Operation timed out.
    """
    WOULD_RECURSE = 25
    """
    Operation would be recursive.
    """
    BUSY = 26
    """
    File is busy.
    """
    WOULD_BLOCK = 27
    """
    Operation would block.
    """
    HOST_NOT_FOUND = 28
    """
    Host couldn't be found (remote operations).
    """
    WOULD_MERGE = 29
    """
    Operation would merge files.
    """
    FAILED_HANDLED = 30
    """
    Operation failed and a helper program has
        already interacted with the user. Do not display any error dialog.
    """
    TOO_MANY_OPEN_FILES = 31
    """
    The current process has too many files
        open and can't open any more. Duplicate descriptors do count toward
        this limit. Since 2.20
    """
    NOT_INITIALIZED = 32
    """
    The object has not been initialized. Since 2.22
    """
    ADDRESS_IN_USE = 33
    """
    The requested address is already in use. Since 2.22
    """
    PARTIAL_INPUT = 34
    """
    Need more input to finish operation. Since 2.24
    """
    INVALID_DATA = 35
    """
    The input data was invalid. Since 2.24
    """
    DBUS_ERROR = 36
    """
    A remote object generated an error that
        doesn't correspond to a locally registered #GError error
        domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
        error name and g_dbus_error_strip_remote_error() to fix up the
        message so it matches what was received on the wire. Since 2.26.
    """
    HOST_UNREACHABLE = 37
    """
    Host unreachable. Since 2.26
    """
    NETWORK_UNREACHABLE = 38
    """
    Network unreachable. Since 2.26
    """
    CONNECTION_REFUSED = 39
    """
    Connection refused. Since 2.26
    """
    PROXY_FAILED = 40
    """
    Connection to proxy server failed. Since 2.26
    """
    PROXY_AUTH_FAILED = 41
    """
    Proxy authentication failed. Since 2.26
    """
    PROXY_NEED_AUTH = 42
    """
    Proxy server needs authentication. Since 2.26
    """
    PROXY_NOT_ALLOWED = 43
    """
    Proxy connection is not allowed by ruleset.
        Since 2.26
    """
    BROKEN_PIPE = 44
    """
    Broken pipe. Since 2.36
    """
    CONNECTION_CLOSED = 44
    """
    Connection closed by peer. Note that this
        is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
        "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
        returned %G_IO_ERROR_FAILED. Now they should all return the same
        value, which has this more logical name. Since 2.44.
    """
    NOT_CONNECTED = 45
    """
    Transport endpoint is not connected. Since 2.44
    """
    MESSAGE_TOO_LARGE = 46
    """
    Message too large. Since 2.48.
    """
    NO_SUCH_DEVICE = 47
    """
    No such device found. Since 2.74
    """
    DESTINATION_UNSET = 48
    """
    Destination address unset. Since 2.80
    """

class IOModuleScopeFlags(GObject.GEnum):
    """
    Flags for use with g_io_module_scope_new()."""

    NONE = 0
    """
    No module scan flags
    """
    BLOCK_DUPLICATES = 1
    """
    When using this scope to load or
        scan modules, automatically block a modules which has the same base
        basename as previously loaded module.
    """

class IOStreamSpliceFlags(GObject.GFlags):
    """
    GIOStreamSpliceFlags determine how streams should be spliced."""

    NONE = 0
    """
    Do not close either stream.
    """
    CLOSE_STREAM1 = 1
    """
    Close the first stream after
        the splice.
    """
    CLOSE_STREAM2 = 2
    """
    Close the second stream after
        the splice.
    """
    WAIT_FOR_BOTH = 4
    """
    Wait for both splice operations to finish
        before calling the callback.
    """

class MemoryMonitorWarningLevel(GObject.GEnum):
    """
    Memory availability warning levels.

    Note that because new values might be added, it is recommended that applications check
    #GMemoryMonitorWarningLevel as ranges, for example:
    |[<!-- language="C" -->
    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
      drop_caches ();
    ]|"""

    LOW = 50
    """
    Memory on the device is low, processes
      should free up unneeded resources (for example, in-memory caches) so they can
      be used elsewhere.
    """
    MEDIUM = 100
    """
    Same as @G_MEMORY_MONITOR_WARNING_LEVEL_LOW
      but the device has even less free memory, so processes should try harder to free
      up unneeded resources. If your process does not need to stay running, it is a
      good time for it to quit.
    """
    CRITICAL = 255
    """
    The system will soon start terminating
      processes to reclaim memory, including background processes.
    """

class MountMountFlags(GObject.GFlags):
    """
    Flags used when mounting a mount."""

    NONE = 0
    """
    No flags set.
    """

class MountOperationResult(GObject.GEnum):
    """
    #GMountOperationResult is returned as a result when a request for
    information is send by the mounting operation."""

    HANDLED = 0
    """
    The request was fulfilled and the
        user specified data is now available
    """
    ABORTED = 1
    """
    The user requested the mount operation
        to be aborted
    """
    UNHANDLED = 2
    """
    The request was unhandled (i.e. not
        implemented)
    """

class MountUnmountFlags(GObject.GFlags):
    """
    Flags used when an unmounting a mount."""

    NONE = 0
    """
    No flags set.
    """
    FORCE = 1
    """
    Unmount even if there are outstanding
     file operations on the mount.
    """

class NetworkConnectivity(GObject.GEnum):
    """
    The host's network connectivity state, as reported by #GNetworkMonitor."""

    LOCAL = 1
    """
    The host is not configured with a
      route to the Internet; it may or may not be connected to a local
      network.
    """
    LIMITED = 2
    """
    The host is connected to a network, but
      does not appear to be able to reach the full Internet, perhaps
      due to upstream network problems.
    """
    PORTAL = 3
    """
    The host is behind a captive portal and
      cannot reach the full Internet.
    """
    FULL = 4
    """
    The host is connected to a network, and
      appears to be able to reach the full Internet.
    """

class NotificationPriority(GObject.GEnum):
    """
    Priority levels for #GNotifications."""

    NORMAL = 0
    """
    the default priority, to be used for the
      majority of notifications (for example email messages, software updates,
      completed download/sync operations)
    """
    LOW = 1
    """
    for notifications that do not require
      immediate attention - typically used for contextual background
      information, such as contact birthdays or local weather
    """
    HIGH = 2
    """
    for events that require more attention,
      usually because responses are time-sensitive (for example chat and SMS
      messages or alarms)
    """
    URGENT = 3
    """
    for urgent notifications, or notifications
      that require a response in a short space of time (for example phone calls
      or emergency warnings)
    """

class OutputStreamSpliceFlags(GObject.GFlags):
    """
    GOutputStreamSpliceFlags determine how streams should be spliced."""

    NONE = 0
    """
    Do not close either stream.
    """
    CLOSE_SOURCE = 1
    """
    Close the source stream after
        the splice.
    """
    CLOSE_TARGET = 2
    """
    Close the target stream after
        the splice.
    """

class PasswordSave(GObject.GEnum):
    """
    #GPasswordSave is used to indicate the lifespan of a saved password.

    #Gvfs stores passwords in the Gnome keyring when this flag allows it
    to, and later retrieves it again from there."""

    NEVER = 0
    """
    never save a password.
    """
    FOR_SESSION = 1
    """
    save a password for the session.
    """
    PERMANENTLY = 2
    """
    save a password permanently.
    """

class PollableReturn(GObject.GEnum):
    """
    Return value for various IO operations that signal errors via the
    return value and not necessarily via a #GError.

    This enum exists to be able to return errors to callers without having to
    allocate a #GError. Allocating #GErrors can be quite expensive for
    regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.

    In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
    operation to give details about the error that happened."""

    FAILED = 0
    """
    Generic error condition for when an operation fails.
    """
    OK = 1
    """
    The operation was successfully finished.
    """
    WOULD_BLOCK = -27
    """
    The operation would block.
    """

class ResolverError(GObject.GEnum):
    """
    An error code used with %G_RESOLVER_ERROR in a #GError returned
    from a #GResolver routine."""

    NOT_FOUND = 0
    """
    the requested name/address/service was not
        found
    """
    TEMPORARY_FAILURE = 1
    """
    the requested information could not
        be looked up due to a network error or similar problem
    """
    INTERNAL = 2
    """
    unknown error
    """

class ResolverNameLookupFlags(GObject.GFlags):
    """
    Flags to modify lookup behavior."""

    DEFAULT = 0
    """
    default behavior (same as g_resolver_lookup_by_name())
    """
    IPV4_ONLY = 1
    """
    only resolve ipv4 addresses
    """
    IPV6_ONLY = 2
    """
    only resolve ipv6 addresses
    """

class ResolverRecordType(GObject.GEnum):
    """
    The type of record that g_resolver_lookup_records() or
    g_resolver_lookup_records_async() should retrieve. The records are returned
    as lists of #GVariant tuples. Each record type has different values in
    the variant tuples returned.

    %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
    `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
    weight, a `guint16` with the port, and a string of the hostname.

    %G_RESOLVER_RECORD_MX records are returned as variants with the signature
    `(qs)`, representing a `guint16` with the preference, and a string containing
    the mail exchanger hostname.

    %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
    `(as)`, representing an array of the strings in the text record. Note: Most TXT
    records only contain a single string, but
    [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
    record to contain multiple strings. The RFC which defines the interpretation
    of a specific TXT record will likely require concatenation of multiple
    strings if they are present, as with
    [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).

    %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
    `(ssuuuuu)`, representing a string containing the primary name server, a
    string containing the administrator, the serial as a `guint32`, the refresh
    interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
    as a `guint32`, and the TTL as a `guint32`.

    %G_RESOLVER_RECORD_NS records are returned as variants with the signature
    `(s)`, representing a string of the hostname of the name server."""

    SRV = 1
    """
    look up DNS SRV records for a domain
    """
    MX = 2
    """
    look up DNS MX records for a domain
    """
    TXT = 3
    """
    look up DNS TXT records for a name
    """
    SOA = 4
    """
    look up DNS SOA records for a zone
    """
    NS = 5
    """
    look up DNS NS records for a domain
    """

class ResourceError(GObject.GEnum):
    """
    An error code used with %G_RESOURCE_ERROR in a #GError returned
    from a #GResource routine."""

    NOT_FOUND = 0
    """
    no file was found at the requested path
    """
    INTERNAL = 1
    """
    unknown error
    """

class ResourceFlags(GObject.GFlags):
    """
    GResourceFlags give information about a particular file inside a resource
    bundle."""

    NONE = 0
    """
    No flags set.
    """
    COMPRESSED = 1
    """
    The file is compressed.
    """

class ResourceLookupFlags(GObject.GFlags):
    """
    GResourceLookupFlags determine how resource path lookups are handled."""

    NONE = 0
    """
    No flags set.
    """

class SettingsBindFlags(GObject.GFlags):
    """
    Flags used when creating a binding.

    These flags determine in which direction the binding works. The default is to
    synchronize in both directions."""

    DEFAULT = 0
    """
    Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
    """
    GET = 1
    """
    Update the [class@GObject.Object] property when the setting changes.
      It is an error to use this flag if the property is not writable.
    """
    SET = 2
    """
    Update the setting when the [class@GObject.Object] property changes.
      It is an error to use this flag if the property is not readable.
    """
    NO_SENSITIVITY = 4
    """
    Do not try to bind a ‘sensitivity’ property to the writability of the setting
    """
    GET_NO_CHANGES = 8
    """
    When set in addition to [flags@Gio.SettingsBindFlags.GET],
      set the [class@GObject.Object] property
      value initially from the setting, but do not listen for changes of the setting
    """
    INVERT_BOOLEAN = 16
    """
    When passed to [method@Gio.Settings.bind],
      uses a pair of mapping functions that invert
      the boolean value when mapping between the setting and the property.  The setting and property must both
      be booleans.  You cannot pass this flag to [method@Gio.Settings.bind_with_mapping].
    """

class SocketClientEvent(GObject.GEnum):
    """
    Describes an event occurring on a #GSocketClient. See the
    #GSocketClient::event signal for more details.

    Additional values may be added to this type in the future."""

    RESOLVING = 0
    """
    The client is doing a DNS lookup.
    """
    RESOLVED = 1
    """
    The client has completed a DNS lookup.
    """
    CONNECTING = 2
    """
    The client is connecting to a remote
      host (either a proxy or the destination server).
    """
    CONNECTED = 3
    """
    The client has connected to a remote
      host.
    """
    PROXY_NEGOTIATING = 4
    """
    The client is negotiating
      with a proxy to connect to the destination server.
    """
    PROXY_NEGOTIATED = 5
    """
    The client has negotiated
      with the proxy server.
    """
    TLS_HANDSHAKING = 6
    """
    The client is performing a
      TLS handshake.
    """
    TLS_HANDSHAKED = 7
    """
    The client has performed a
      TLS handshake.
    """
    COMPLETE = 8
    """
    The client is done with a particular
      #GSocketConnectable.
    """

class SocketFamily(GObject.GEnum):
    """
    The protocol family of a #GSocketAddress. (These values are
    identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
    if available.)"""

    INVALID = 0
    """
    no address family
    """
    UNIX = 1
    """
    the UNIX domain family
    """
    IPV4 = 2
    """
    the IPv4 family
    """
    IPV6 = 10
    """
    the IPv6 family
    """

class SocketListenerEvent(GObject.GEnum):
    """
    Describes an event occurring on a #GSocketListener. See the
    #GSocketListener::event signal for more details.

    Additional values may be added to this type in the future."""

    BINDING = 0
    """
    The listener is about to bind a socket.
    """
    BOUND = 1
    """
    The listener has bound a socket.
    """
    LISTENING = 2
    """
    The listener is about to start
       listening on this socket.
    """
    LISTENED = 3
    """
    The listener is now listening on
      this socket.
    """

class SocketMsgFlags(GObject.GFlags):
    """
    Flags used in g_socket_receive_message() and g_socket_send_message().
    The flags listed in the enum are some commonly available flags, but the
    values used for them are the same as on the platform, and any other flags
    are passed in/out as is. So to use a platform specific flag, just include
    the right system header and pass in the flag."""

    NONE = 0
    """
    No flags.
    """
    OOB = 1
    """
    Request to send/receive out of band data.
    """
    PEEK = 2
    """
    Read data from the socket without removing it from
        the queue.
    """
    DONTROUTE = 4
    """
    Don't use a gateway to send out the packet,
        only send to hosts on directly connected networks.
    """

class SocketProtocol(GObject.GEnum):
    """
    A protocol identifier is specified when creating a #GSocket, which is a
    family/type specific identifier, where 0 means the default protocol for
    the particular family/type.

    This enum contains a set of commonly available and used protocols. You
    can also pass any other identifiers handled by the platform in order to
    use protocols not listed here."""

    UNKNOWN = -1
    """
    The protocol type is unknown
    """
    DEFAULT = 0
    """
    The default protocol for the family/type
    """
    TCP = 6
    """
    TCP over IP
    """
    UDP = 17
    """
    UDP over IP
    """
    SCTP = 132
    """
    SCTP over IP
    """

class SocketType(GObject.GEnum):
    """
    Flags used when creating a #GSocket. Some protocols may not implement
    all the socket types."""

    INVALID = 0
    """
    Type unknown or wrong
    """
    STREAM = 1
    """
    Reliable connection-based byte streams (e.g. TCP).
    """
    DATAGRAM = 2
    """
    Connectionless, unreliable datagram passing.
        (e.g. UDP)
    """
    SEQPACKET = 3
    """
    Reliable connection-based passing of datagrams
        of fixed maximum length (e.g. SCTP).
    """

class SubprocessFlags(GObject.GFlags):
    """
    Flags to define the behaviour of a #GSubprocess.

    Note that the default for stdin is to redirect from `/dev/null`.  For
    stdout and stderr the default are for them to inherit the
    corresponding descriptor from the calling process.

    Note that it is a programmer error to mix 'incompatible' flags.  For
    example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
    %G_SUBPROCESS_FLAGS_STDOUT_SILENCE."""

    NONE = 0
    """
    No flags.
    """
    STDIN_PIPE = 1
    """
    create a pipe for the stdin of the
      spawned process that can be accessed with
      g_subprocess_get_stdin_pipe().
    """
    STDIN_INHERIT = 2
    """
    stdin is inherited from the
      calling process.
    """
    STDOUT_PIPE = 4
    """
    create a pipe for the stdout of the
      spawned process that can be accessed with
      g_subprocess_get_stdout_pipe().
    """
    STDOUT_SILENCE = 8
    """
    silence the stdout of the spawned
      process (ie: redirect to `/dev/null`).
    """
    STDERR_PIPE = 16
    """
    create a pipe for the stderr of the
      spawned process that can be accessed with
      g_subprocess_get_stderr_pipe().
    """
    STDERR_SILENCE = 32
    """
    silence the stderr of the spawned
      process (ie: redirect to `/dev/null`).
    """
    STDERR_MERGE = 64
    """
    merge the stderr of the spawned
      process with whatever the stdout happens to be.  This is a good way
      of directing both streams to a common log file, for example.
    """
    INHERIT_FDS = 128
    """
    spawned processes will inherit the
      file descriptors of their parent, unless those descriptors have
      been explicitly marked as close-on-exec.  This flag has no effect
      over the "standard" file descriptors (stdin, stdout, stderr).
    """
    SEARCH_PATH_FROM_ENVP = 256
    """
    if path searching is
      needed when spawning the subprocess, use the `PATH` in the launcher
      environment. (Since: 2.72)
    """

class TestDBusFlags(GObject.GFlags):
    """
    Flags to define future #GTestDBus behaviour."""

    NONE = 0
    """
    No flags.
    """

class TlsAuthenticationMode(GObject.GEnum):
    """
    The client authentication mode for a #GTlsServerConnection."""

    NONE = 0
    """
    client authentication not required
    """
    REQUESTED = 1
    """
    client authentication is requested
    """
    REQUIRED = 2
    """
    client authentication is required
    """

class TlsCertificateFlags(GObject.GFlags):
    """
    A set of flags describing TLS certification validation. This can be
    used to describe why a particular certificate was rejected (for
    example, in #GTlsConnection::accept-certificate).

    GLib guarantees that if certificate verification fails, at least one
    flag will be set, but it does not guarantee that all possible flags
    will be set. Accordingly, you may not safely decide to ignore any
    particular type of error. For example, it would be incorrect to mask
    %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
    because this could potentially be the only error flag set even if
    other problems exist with the certificate."""

    NO_FLAGS = 0
    """
    No flags set. Since: 2.74
    """
    UNKNOWN_CA = 1
    """
    The signing certificate authority is
      not known.
    """
    BAD_IDENTITY = 2
    """
    The certificate does not match the
      expected identity of the site that it was retrieved from.
    """
    NOT_ACTIVATED = 4
    """
    The certificate's activation time
      is still in the future
    """
    EXPIRED = 8
    """
    The certificate has expired
    """
    REVOKED = 16
    """
    The certificate has been revoked
      according to the #GTlsConnection's certificate revocation list.
    """
    INSECURE = 32
    """
    The certificate's algorithm is
      considered insecure.
    """
    GENERIC_ERROR = 64
    """
    Some other error occurred validating
      the certificate
    """
    VALIDATE_ALL = 127
    """
    the combination of all of the above
      flags
    """

class TlsCertificateRequestFlags(GObject.GEnum):
    """
    Flags for g_tls_interaction_request_certificate(),
    g_tls_interaction_request_certificate_async(), and
    g_tls_interaction_invoke_request_certificate()."""

    NONE = 0
    """
    No flags
    """

class TlsChannelBindingError(GObject.GEnum):
    """
    An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to
    indicate a TLS channel binding retrieval error."""

    NOT_IMPLEMENTED = 0
    """
    Either entire binding
       retrieval facility or specific binding type is not implemented in the
       TLS backend.
    """
    INVALID_STATE = 1
    """
    The handshake is not yet
       complete on the connection which is a strong requirement for any existing
       binding type.
    """
    NOT_AVAILABLE = 2
    """
    Handshake is complete but
       binding data is not available. That normally indicates the TLS
       implementation failed to provide the binding data. For example, some
       implementations do not provide a peer certificate for resumed connections.
    """
    NOT_SUPPORTED = 3
    """
    Binding type is not supported
       on the current connection. This error could be triggered when requesting
       `tls-server-end-point` binding data for a certificate which has no hash
       function or uses multiple hash functions.
    """
    GENERAL_ERROR = 4
    """
    Any other backend error
       preventing binding data retrieval.
    """

class TlsChannelBindingType(GObject.GEnum):
    """
    The type of TLS channel binding data to retrieve from #GTlsConnection
    or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The
    [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
    binding type is not currently implemented."""

    UNIQUE = 0
    """
    [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
       type
    """
    SERVER_END_POINT = 1
    """
    [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
       binding type
    """
    EXPORTER = 2
    """
    [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding
       type. Since: 2.74
    """

class TlsDatabaseLookupFlags(GObject.GEnum):
    """
    Flags for g_tls_database_lookup_certificate_for_handle(),
    g_tls_database_lookup_certificate_issuer(),
    and g_tls_database_lookup_certificates_issued_by()."""

    NONE = 0
    """
    No lookup flags
    """
    KEYPAIR = 1
    """
    Restrict lookup to certificates that have
        a private key.
    """

class TlsDatabaseVerifyFlags(GObject.GFlags):
    """
    Flags for g_tls_database_verify_chain()."""

    NONE = 0
    """
    No verification flags
    """

class TlsError(GObject.GEnum):
    """
    An error code used with %G_TLS_ERROR in a #GError returned from a
    TLS-related routine."""

    UNAVAILABLE = 0
    """
    No TLS provider is available
    """
    MISC = 1
    """
    Miscellaneous TLS error
    """
    BAD_CERTIFICATE = 2
    """
    The certificate presented could not
      be parsed or failed validation.
    """
    NOT_TLS = 3
    """
    The TLS handshake failed because the
      peer does not seem to be a TLS server.
    """
    HANDSHAKE = 4
    """
    The TLS handshake failed because the
      peer's certificate was not acceptable.
    """
    CERTIFICATE_REQUIRED = 5
    """
    The TLS handshake failed because
      the server requested a client-side certificate, but none was
      provided. See g_tls_connection_set_certificate().
    """
    EOF = 6
    """
    The TLS connection was closed without proper
      notice, which may indicate an attack. See
      g_tls_connection_set_require_close_notify().
    """
    INAPPROPRIATE_FALLBACK = 7
    """
    The TLS handshake failed
      because the client sent the fallback SCSV, indicating a protocol
      downgrade attack. Since: 2.60
    """
    BAD_CERTIFICATE_PASSWORD = 8
    """
    The certificate failed
      to load because a password was incorrect. Since: 2.72
    """

class TlsInteractionResult(GObject.GEnum):
    """
    #GTlsInteractionResult is returned by various functions in #GTlsInteraction
    when finishing an interaction request."""

    UNHANDLED = 0
    """
    The interaction was unhandled (i.e. not
        implemented).
    """
    HANDLED = 1
    """
    The interaction completed, and resulting data
        is available.
    """
    FAILED = 2
    """
    The interaction has failed, or was cancelled.
        and the operation should be aborted.
    """

class TlsPasswordFlags(GObject.GFlags):
    """
    Various flags for the password."""

    NONE = 0
    """
    No flags
    """
    RETRY = 2
    """
    The password was wrong, and the user should retry.
    """
    MANY_TRIES = 4
    """
    Hint to the user that the password has been
       wrong many times, and the user may not have many chances left.
    """
    FINAL_TRY = 8
    """
    Hint to the user that this is the last try to get
       this password right.
    """
    PKCS11_USER = 16
    """
    For PKCS #11, the user PIN is required.
       Since: 2.70.
    """
    PKCS11_SECURITY_OFFICER = 32
    """
    For PKCS #11, the security officer
       PIN is required. Since: 2.70.
    """
    PKCS11_CONTEXT_SPECIFIC = 64
    """
    For PKCS #11, the context-specific
       PIN is required. Since: 2.70.
    """

class TlsProtocolVersion(GObject.GEnum):
    """
    The TLS or DTLS protocol version used by a #GTlsConnection or
    #GDtlsConnection. The integer values of these versions are sequential
    to ensure newer known protocol versions compare greater than older
    known versions. Any known DTLS protocol version will compare greater
    than any SSL or TLS protocol version. The protocol version may be
    %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
    protocol version that GLib does not yet know about. This means that
    it's possible for an unknown DTLS protocol version to compare less
    than the TLS protocol versions."""

    UNKNOWN = 0
    """
    No protocol version or unknown protocol version
    """
    SSL_3_0 = 1
    """
    SSL 3.0, which is insecure and should not be used
    """
    TLS_1_0 = 2
    """
    TLS 1.0, which is insecure and should not be used
    """
    TLS_1_1 = 3
    """
    TLS 1.1, which is insecure and should not be used
    """
    TLS_1_2 = 4
    """
    TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
    """
    TLS_1_3 = 5
    """
    TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
    """
    DTLS_1_0 = 201
    """
    DTLS 1.0, which is insecure and should not be used
    """
    DTLS_1_2 = 202
    """
    DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
    """

class TlsRehandshakeMode(GObject.GEnum):
    """
    When to allow rehandshaking. See
    g_tls_connection_set_rehandshake_mode()."""

    NEVER = 0
    """
    Never allow rehandshaking
    """
    SAFELY = 1
    """
    Allow safe rehandshaking only
    """
    UNSAFELY = 2
    """
    Allow unsafe rehandshaking
    """

class UnixSocketAddressType(GObject.GEnum):
    """
    The type of name used by a #GUnixSocketAddress.
    %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
    socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
    indicates a socket not bound to any name (eg, a client-side socket,
    or a socket created with socketpair()).

    For abstract sockets, there are two incompatible ways of naming
    them; the man pages suggest using the entire `struct sockaddr_un`
    as the name, padding the unused parts of the %sun_path field with
    zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
    However, many programs instead just use a portion of %sun_path, and
    pass an appropriate smaller length to bind() or connect(). This is
    %G_UNIX_SOCKET_ADDRESS_ABSTRACT."""

    INVALID = 0
    """
    invalid
    """
    ANONYMOUS = 1
    """
    anonymous
    """
    PATH = 2
    """
    a filesystem path
    """
    ABSTRACT = 3
    """
    an abstract name
    """
    ABSTRACT_PADDED = 4
    """
    an abstract name, 0-padded
      to the full length of a unix socket name
    """

class ZlibCompressorFormat(GObject.GEnum):
    """
    Used to select the type of data format to use for #GZlibDecompressor
    and #GZlibCompressor."""

    ZLIB = 0
    """
    deflate compression with zlib header
    """
    GZIP = 1
    """
    gzip file format
    """
    RAW = 2
    """
    deflate compression with no header
    """

###############################################################
# classes
###############################################################

class Action(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        enabled: bool
        name: str
        parameter_type: GLib.VariantType | None  # [parameter-type]: changed because contained invalid characters
        state: GLib.Variant | None
        state_type: GLib.VariantType | None  # [state-type]: changed because contained invalid characters

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def activate(self, parameter: GLib.Variant | None = None) -> None: ...
    def change_state(self, value: GLib.Variant) -> None: ...
    @property
    def get_enabled(self) -> bool: ...
    @property
    def get_name(self) -> str: ...
    @property
    def get_parameter_type(self) -> GLib.VariantType | None: ...
    @property
    def get_state(self) -> GLib.Variant | None: ...
    def get_state_hint(self) -> GLib.Variant | None: ...
    @property
    def get_state_type(self) -> GLib.VariantType | None: ...
    @staticmethod
    def name_is_valid(action_name: str) -> bool: ...
    @staticmethod
    def parse_detailed_name(detailed_name: str) -> tuple[bool, str | None, GLib.Variant | None]: ...
    @staticmethod
    def print_detailed_name(action_name: str, target_value: GLib.Variant | None = None) -> str: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parameter_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ActionEntry(GObject.GPointer):
    # gi Fields
    activate: activateActionEntryCB = ...
    change_state: change_stateActionEntryCB = ...
    name: str = ...
    padding: list | None = ...
    parameter_type: str = ...
    state: str = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ActionGroup(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def action_added(self, action_name: str) -> None: ...
    def action_enabled_changed(self, action_name: str, enabled: bool) -> None: ...
    def action_removed(self, action_name: str) -> None: ...
    def action_state_changed(self, action_name: str, state: GLib.Variant) -> None: ...
    def activate_action(self, action_name: str, parameter: GLib.Variant | None = None) -> None: ...
    def change_action_state(self, action_name: str, value: GLib.Variant) -> None: ...
    def get_action_enabled(self, action_name: str) -> bool: ...
    def get_action_parameter_type(self, action_name: str) -> GLib.VariantType | None: ...
    def get_action_state(self, action_name: str) -> GLib.Variant | None: ...
    def get_action_state_hint(self, action_name: str) -> GLib.Variant | None: ...
    def get_action_state_type(self, action_name: str) -> GLib.VariantType | None: ...
    def has_action(self, action_name: str) -> bool: ...
    def list_actions(self) -> list: ...
    def query_action(
        self, action_name: str
    ) -> tuple[
        bool, bool, GLib.VariantType | None, GLib.VariantType | None, GLib.Variant | None, GLib.Variant | None
    ]: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["action-added"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["action-enabled-changed"],
        handler: typing.Callable[[typing_extensions.Self, str, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["action-removed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["action-state-changed"],
        handler: typing.Callable[[typing_extensions.Self, str, GLib.Variant], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ActionGroupInterface(GObject.GPointer):
    # gi Fields
    action_added: action_addedActionGroupInterfaceCB = ...
    action_enabled_changed: action_enabled_changedActionGroupInterfaceCB = ...
    action_removed: action_removedActionGroupInterfaceCB = ...
    action_state_changed: action_state_changedActionGroupInterfaceCB = ...
    activate_action: activate_actionActionGroupInterfaceCB = ...
    change_action_state: change_action_stateActionGroupInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_action_enabled: get_action_enabledActionGroupInterfaceCB = ...
    get_action_parameter_type: get_action_parameter_typeActionGroupInterfaceCB | None = ...
    get_action_state: get_action_stateActionGroupInterfaceCB | None = ...
    get_action_state_hint: get_action_state_hintActionGroupInterfaceCB | None = ...
    get_action_state_type: get_action_state_typeActionGroupInterfaceCB | None = ...
    has_action: has_actionActionGroupInterfaceCB = ...
    list_actions: list_actionsActionGroupInterfaceCB = ...
    query_action: query_actionActionGroupInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ActionInterface(GObject.GPointer):
    # gi Fields
    activate: activateActionInterfaceCB = ...
    change_state: change_stateActionInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_enabled: get_enabledActionInterfaceCB = ...
    get_name: get_nameActionInterfaceCB = ...
    get_parameter_type: get_parameter_typeActionInterfaceCB | None = ...
    get_state: get_stateActionInterfaceCB | None = ...
    get_state_hint: get_state_hintActionInterfaceCB | None = ...
    get_state_type: get_state_typeActionInterfaceCB | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ActionMap(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_action(self, action: Action) -> None: ...
    def add_action_entries(self, entries: list, n_entries: int, user_data: object | None = None) -> None: ...
    def lookup_action(self, action_name: str) -> Action | None: ...
    def remove_action(self, action_name: str) -> None: ...
    def remove_action_entries(self, entries: list, n_entries: int) -> None: ...

    ...

class ActionMapInterface(GObject.GPointer):
    # gi Fields
    add_action: add_actionActionMapInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    lookup_action: lookup_actionActionMapInterfaceCB | None = ...
    remove_action: remove_actionActionMapInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class AppInfo(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_supports_type(self, content_type: str) -> bool: ...
    def can_delete(self) -> bool: ...
    def can_remove_supports_type(self) -> bool: ...
    @staticmethod
    def create_from_commandline(
        commandline: str, application_name: str | None, flags: AppInfoCreateFlags
    ) -> AppInfo: ...
    def delete(self) -> bool: ...
    def dup(self) -> AppInfo: ...
    def equal(self, appinfo2: AppInfo) -> bool: ...
    @staticmethod
    def get_all() -> list: ...
    @staticmethod
    def get_all_for_type(content_type: str) -> list: ...
    def get_commandline(self) -> str | None: ...
    @staticmethod
    def get_default_for_type(content_type: str, must_support_uris: bool) -> AppInfo | None: ...
    @staticmethod
    async def get_default_for_type_async(
        content_type: str,
        must_support_uris: bool,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @staticmethod
    def get_default_for_type_finish(result: AsyncResult) -> AppInfo: ...
    @staticmethod
    def get_default_for_uri_scheme(uri_scheme: str) -> AppInfo | None: ...
    @staticmethod
    async def get_default_for_uri_scheme_async(
        uri_scheme: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @staticmethod
    def get_default_for_uri_scheme_finish(result: AsyncResult) -> AppInfo: ...
    def get_description(self) -> str | None: ...
    def get_display_name(self) -> str: ...
    def get_executable(self) -> str: ...
    @staticmethod
    def get_fallback_for_type(content_type: str) -> list: ...
    def get_icon(self) -> Icon | None: ...
    def get_id(self) -> str | None: ...
    def get_name(self) -> str: ...
    @staticmethod
    def get_recommended_for_type(content_type: str) -> list: ...
    def get_supported_types(self) -> list: ...
    def launch(self, files: list | None = None, context: AppLaunchContext | None = None) -> bool: ...
    @staticmethod
    def launch_default_for_uri(uri: str, context: AppLaunchContext | None = None) -> bool: ...
    @staticmethod
    async def launch_default_for_uri_async(
        uri: str,
        context: AppLaunchContext | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @staticmethod
    def launch_default_for_uri_finish(result: AsyncResult) -> bool: ...
    def launch_uris(self, uris: list | None = None, context: AppLaunchContext | None = None) -> bool: ...
    async def launch_uris_async(
        self,
        uris: list | None = None,
        context: AppLaunchContext | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def launch_uris_finish(self, result: AsyncResult) -> bool: ...
    def remove_supports_type(self, content_type: str) -> bool: ...
    @staticmethod
    def reset_type_associations(content_type: str) -> None: ...
    def set_as_default_for_extension(self, extension: str) -> bool: ...
    def set_as_default_for_type(self, content_type: str) -> bool: ...
    def set_as_last_used_for_type(self, content_type: str) -> bool: ...
    def should_show(self) -> bool: ...
    def supports_files(self) -> bool: ...
    def supports_uris(self) -> bool: ...

    ...

class AppInfoIface(GObject.GPointer):
    # gi Fields
    add_supports_type: add_supports_typeAppInfoIfaceCB = ...
    can_delete: can_deleteAppInfoIfaceCB = ...
    can_remove_supports_type: can_remove_supports_typeAppInfoIfaceCB = ...
    do_delete: do_deleteAppInfoIfaceCB = ...
    dup: dupAppInfoIfaceCB = ...
    equal: equalAppInfoIfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_commandline: get_commandlineAppInfoIfaceCB | None = ...
    get_description: get_descriptionAppInfoIfaceCB | None = ...
    get_display_name: get_display_nameAppInfoIfaceCB = ...
    get_executable: get_executableAppInfoIfaceCB = ...
    get_icon: get_iconAppInfoIfaceCB | None = ...
    get_id: get_idAppInfoIfaceCB | None = ...
    get_name: get_nameAppInfoIfaceCB = ...
    get_supported_types: get_supported_typesAppInfoIfaceCB = ...
    launch: launchAppInfoIfaceCB = ...
    launch_uris: launch_urisAppInfoIfaceCB = ...
    launch_uris_async: launch_uris_asyncAppInfoIfaceCB = ...
    launch_uris_finish: launch_uris_finishAppInfoIfaceCB = ...
    remove_supports_type: remove_supports_typeAppInfoIfaceCB = ...
    set_as_default_for_extension: set_as_default_for_extensionAppInfoIfaceCB = ...
    set_as_default_for_type: set_as_default_for_typeAppInfoIfaceCB = ...
    set_as_last_used_for_type: set_as_last_used_for_typeAppInfoIfaceCB = ...
    should_show: should_showAppInfoIfaceCB = ...
    supports_files: supports_filesAppInfoIfaceCB = ...
    supports_uris: supports_urisAppInfoIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class AppInfoMonitor(GObject.Object):
    """
    `GAppInfoMonitor` monitors application information for changes.

    `GAppInfoMonitor` is a very simple object used for monitoring the app
    info database for changes (newly installed or removed applications).

    Call [func@Gio.AppInfoMonitor.get] to get a `GAppInfoMonitor` and connect
    to the [signal@Gio.AppInfoMonitor::changed] signal. The signal will be emitted once when
    the app info database changes, and will not be emitted again until after the
    next call to [func@Gio.AppInfo.get_all] or another `g_app_info_*()` function.
    This is because monitoring the app info database for changes is expensive.

    The following functions will re-arm the [signal@Gio.AppInfoMonitor::changed]
    signal so it can be emitted again:

     - [func@Gio.AppInfo.get_all]
     - [func@Gio.AppInfo.get_all_for_type]
     - [func@Gio.AppInfo.get_default_for_type]
     - [func@Gio.AppInfo.get_fallback_for_type]
     - [func@Gio.AppInfo.get_recommended_for_type]
     - [`g_desktop_app_info_get_implementations()`](../gio-unix/type_func.DesktopAppInfo.get_implementation.html)
     - [`g_desktop_app_info_new()`](../gio-unix/ctor.DesktopAppInfo.new.html)
     - [`g_desktop_app_info_new_from_filename()`](../gio-unix/ctor.DesktopAppInfo.new_from_filename.html)
     - [`g_desktop_app_info_new_from_keyfile()`](../gio-unix/ctor.DesktopAppInfo.new_from_keyfile.html)
     - [`g_desktop_app_info_search()`](../gio-unix/type_func.DesktopAppInfo.search.html)

    The latter functions are available if using
    [`GDesktopAppInfo`](../gio-unix/class.DesktopAppInfo.html) from
    `gio-unix-2.0.pc` (GIR namespace `GioUnix-2.0`).

    In the usual case, applications should try to make note of the change
    (doing things like invalidating caches) but not act on it. In
    particular, applications should avoid making calls to `GAppInfo` APIs
    in response to the change signal, deferring these until the time that
    the updated data is actually required. The exception to this case is when
    application information is actually being displayed on the screen
    (for example, during a search or when the list of all applications is shown).
    The reason for this is that changes to the list of installed applications
    often come in groups (like during system updates) and rescanning the list
    on every change is pointless and expensive.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get() -> AppInfoMonitor: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class AppLaunchContext(GObject.Object):
    """
    Integrating the launch with the launching application. This is used to
    handle for instance startup notification and launching the new application
    on the same screen as the launching window.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_display(self, info: AppInfo, files: list) -> str | None: ...
    def get_environment(self) -> list: ...
    def get_startup_notify_id(self, info: AppInfo | None = None, files: list | None = None) -> str | None: ...
    def launch_failed(self, startup_notify_id: str) -> None: ...
    @classmethod
    def new(cls) -> AppLaunchContext: ...
    def setenv(self, variable: str, value: str) -> None: ...
    def unsetenv(self, variable: str) -> None: ...

    # python methods
    def do_get_display(
        self,
        info: AppInfo,
        files: list,
    ) -> str | None:
        """
        get_display(self, info:Gio.AppInfo, files:list) -> str or None
        """
    def do_get_startup_notify_id(
        self,
        info: AppInfo | None = None,
        files: list | None = None,
    ) -> str | None:
        """
        get_startup_notify_id(self, info:Gio.AppInfo=None, files:list=None) -> str or None
        """
    def do_launch_failed(
        self,
        startup_notify_id: str,
    ) -> None:
        """
        launch_failed(self, startup_notify_id:str)
        """
    def do_launch_started(
        self,
        info: AppInfo,
        platform_data: GLib.Variant,
    ) -> None:
        """
        launch_started(self, info:Gio.AppInfo, platform_data:GLib.Variant)
        """
    def do_launched(
        self,
        info: AppInfo,
        platform_data: GLib.Variant,
    ) -> None:
        """
        launched(self, info:Gio.AppInfo, platform_data:GLib.Variant)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["launch-failed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["launch-started"],
        handler: typing.Callable[[typing_extensions.Self, AppInfo, GLib.Variant | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["launched"],
        handler: typing.Callable[[typing_extensions.Self, AppInfo, GLib.Variant], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class AppLaunchContextClass(GObject.GPointer):
    # gi Fields
    get_display: get_displayAppLaunchContextClassCB | None = ...
    get_startup_notify_id: get_startup_notify_idAppLaunchContextClassCB | None = ...
    launch_failed: launch_failedAppLaunchContextClassCB = ...
    launch_started: launch_startedAppLaunchContextClassCB = ...
    launched: launchedAppLaunchContextClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class AppLaunchContextPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Application(GObject.Object):
    """
    `GApplication` is the core class for application support.

    A `GApplication` is the foundation of an application. It wraps some
    low-level platform-specific services and is intended to act as the
    foundation for higher-level application classes such as
    `GtkApplication` or `MxApplication`. In general, you should not use
    this class outside of a higher level framework.

    `GApplication` provides convenient life-cycle management by maintaining
    a "use count" for the primary application instance. The use count can
    be changed using [method@Gio.Application.hold] and
    [method@Gio.Application.release]. If it drops to zero, the application
    exits. Higher-level classes such as `GtkApplication` employ the use count
    to ensure that the application stays alive as long as it has any opened
    windows.

    Another feature that `GApplication` (optionally) provides is process
    uniqueness. Applications can make use of this functionality by
    providing a unique application ID. If given, only one application
    with this ID can be running at a time per session. The session
    concept is platform-dependent, but corresponds roughly to a graphical
    desktop login. When your application is launched again, its
    arguments are passed through platform communication to the already
    running program. The already running instance of the program is
    called the "primary instance"; for non-unique applications this is
    always the current instance. On Linux, the D-Bus session bus
    is used for communication.

    The use of `GApplication` differs from some other commonly-used
    uniqueness libraries (such as libunique) in important ways. The
    application is not expected to manually register itself and check
    if it is the primary instance. Instead, the main() function of a
    `GApplication` should do very little more than instantiating the
    application instance, possibly connecting signal handlers, then
    calling [method@Gio.Application.run]. All checks for uniqueness are done
    internally. If the application is the primary instance then the
    startup signal is emitted and the mainloop runs. If the application
    is not the primary instance then a signal is sent to the primary
    instance and [method@Gio.Application.run] promptly returns. See the code
    examples below.

    If used, the expected form of an application identifier is the
    same as that of a
    [D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
    Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
    `org._7_zip.Archiver`.
    For details on valid application identifiers, see [func@Gio.Application.id_is_valid].

    On Linux, the application identifier is claimed as a well-known bus name
    on the user's session bus. This means that the uniqueness of your
    application is scoped to the current session. It also means that your
    application may provide additional services (through registration of other
    object paths) at that bus name. The registration of these object paths
    should be done with the shared GDBus session bus. Note that due to the
    internal architecture of GDBus, method calls can be dispatched at any time
    (even if a main loop is not running). For this reason, you must ensure that
    any object paths that you wish to register are registered before #GApplication
    attempts to acquire the bus name of your application (which happens in
    [method@Gio.Application.register]). Unfortunately, this means that you cannot
    use [property@Gio.Application:is-remote] to decide if you want to register
    object paths.

    `GApplication` also implements the [iface@Gio.ActionGroup] and [iface@Gio.ActionMap]
    interfaces and lets you easily export actions by adding them with
    [method@Gio.ActionMap.add_action]. When invoking an action by calling
    [method@Gio.ActionGroup.activate_action] on the application, it is always
    invoked in the primary instance. The actions are also exported on
    the session bus, and GIO provides the [class@Gio.DBusActionGroup] wrapper to
    conveniently access them remotely. GIO provides a [class@Gio.DBusMenuModel] wrapper
    for remote access to exported [class@Gio.MenuModel]s.

    Note: Due to the fact that actions are exported on the session bus,
    using `maybe` parameters is not supported, since D-Bus does not support
    `maybe` types.

    There is a number of different entry points into a `GApplication`:

    - via 'Activate' (i.e. just starting the application)

    - via 'Open' (i.e. opening some files)

    - by handling a command-line

    - via activating an action

    The [signal@Gio.Application::startup] signal lets you handle the application
    initialization for all of these in a single place.

    Regardless of which of these entry points is used to start the
    application, `GApplication` passes some ‘platform data’ from the
    launching instance to the primary instance, in the form of a
    [struct@GLib.Variant] dictionary mapping strings to variants. To use platform
    data, override the [vfunc@Gio.Application.before_emit] or
    [vfunc@Gio.Application.after_emit] virtual functions
    in your `GApplication` subclass. When dealing with
    [class@Gio.ApplicationCommandLine] objects, the platform data is
    directly available via [method@Gio.ApplicationCommandLine.get_cwd],
    [method@Gio.ApplicationCommandLine.get_environ] and
    [method@Gio.ApplicationCommandLine.get_platform_data].

    As the name indicates, the platform data may vary depending on the
    operating system, but it always includes the current directory (key
    `cwd`), and optionally the environment (ie the set of environment
    variables and their values) of the calling process (key `environ`).
    The environment is only added to the platform data if the
    `G_APPLICATION_SEND_ENVIRONMENT` flag is set. `GApplication` subclasses
    can add their own platform data by overriding the
    [vfunc@Gio.Application.add_platform_data] virtual function. For instance,
    `GtkApplication` adds startup notification data in this way.

    To parse commandline arguments you may handle the
    [signal@Gio.Application::command-line] signal or override the
    [vfunc@Gio.Application.local_command_line] virtual function, to parse them in
    either the primary instance or the local instance, respectively.

    For an example of opening files with a `GApplication`, see
    [gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).

    For an example of using actions with `GApplication`, see
    [gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).

    For an example of using extra D-Bus hooks with `GApplication`, see
    [gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
    """

    class Props(GObject.Object.Props):
        action_group: ActionGroup | None  # [action-group]: changed because contained invalid characters
        application_id: str  # [application-id]: changed because contained invalid characters
        flags: ApplicationFlags
        inactivity_timeout: int  # [inactivity-timeout]: changed because contained invalid characters
        is_busy: bool  # [is-busy]: changed because contained invalid characters
        is_registered: bool  # [is-registered]: changed because contained invalid characters
        is_remote: bool  # [is-remote]: changed because contained invalid characters
        resource_base_path: str  # [resource-base-path]: changed because contained invalid characters
        version: str

    # gi Methods
    def activate(self) -> None: ...
    def add_main_option(
        self,
        long_name: str,
        short_name: int,
        flags: GLib.OptionFlags,
        arg: GLib.OptionArg,
        description: str,
        arg_description: str | None = None,
    ) -> None: ...
    def add_main_option_entries(self, entries: list) -> None: ...
    def add_option_group(self, group: GLib.OptionGroup) -> None: ...
    def bind_busy_property(self, object: GObject.Object, property: str) -> None: ...
    @property
    def get_application_id(self) -> str | None: ...
    def get_dbus_connection(self) -> DBusConnection | None: ...
    def get_dbus_object_path(self) -> str | None: ...
    @staticmethod
    def get_default() -> Application | None: ...
    @property
    def get_flags(self) -> ApplicationFlags: ...
    @property
    def get_inactivity_timeout(self) -> int: ...
    @property
    def get_is_busy(self) -> bool: ...
    @property
    def get_is_registered(self) -> bool: ...
    @property
    def get_is_remote(self) -> bool: ...
    @property
    def get_resource_base_path(self) -> str | None: ...
    @property
    def get_version(self) -> str | None: ...
    def hold(self) -> None: ...
    @staticmethod
    def id_is_valid(application_id: str) -> bool: ...
    def mark_busy(self) -> None: ...
    @classmethod
    def new(cls, application_id: str | None, flags: ApplicationFlags) -> Application: ...
    def open(self, files: list, n_files: int, hint: str) -> None: ...
    def quit(self) -> None: ...
    def register(self, cancellable: Cancellable | None = None) -> bool: ...
    def release(self) -> None: ...
    def run(self, argc: int, argv: list | None = None) -> int: ...
    def send_notification(self, id: str | None, notification: Notification) -> None: ...
    @deprecated("deprecated")
    def set_action_group(self, action_group: ActionGroup | None = None) -> None: ...
    def set_application_id(self, application_id: str | None = None) -> None: ...
    def set_default(self) -> None: ...
    def set_flags(self, flags: ApplicationFlags) -> None: ...
    def set_inactivity_timeout(self, inactivity_timeout: int) -> None: ...
    def set_option_context_description(self, description: str | None = None) -> None: ...
    def set_option_context_parameter_string(self, parameter_string: str | None = None) -> None: ...
    def set_option_context_summary(self, summary: str | None = None) -> None: ...
    def set_resource_base_path(self, resource_path: str | None = None) -> None: ...
    def set_version(self, version: str) -> None: ...
    def unbind_busy_property(self, object: GObject.Object, property: str) -> None: ...
    def unmark_busy(self) -> None: ...
    def withdraw_notification(self, id: str) -> None: ...

    # python methods
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    def create_asyncio_task(
        self,
        coro: typing.Any,
    ) -> typing.Any:
        """
        Safely create an asyncio task. The application will not quit until the
        task completes. For potentially longer running tasks, you should add
        cancellation logic to abort a task when it is not needed anymore (e.g.
        cancelling it from the Gtk.Window.do_unmap event).

        Note that python will only log a raised exception if the Task is
        destroyed without the result having been collected. However, this does
        also not happen when the task is cancelled. As such, be careful to not
        cancel tasks that are already finished.

        You can deal with this by either only storing a weak reference to the
        Task, by explicitly collecting the result, or by only cancelling it if
        it is not done already.
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["command-line"],
        handler: typing.Callable[[typing_extensions.Self, ApplicationCommandLine], int],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["handle-local-options"],
        handler: typing.Callable[[typing_extensions.Self, GLib.VariantDict], int],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["name-lost"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["open"],
        handler: typing.Callable[[typing_extensions.Self, list, int, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["shutdown"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["startup"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::action_group"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::application_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inactivity_timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_busy"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_registered"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_remote"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resource_base_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::version"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ApplicationClass(GObject.GPointer):
    # gi Fields
    activate: activateApplicationClassCB = ...
    add_platform_data: add_platform_dataApplicationClassCB = ...
    after_emit: after_emitApplicationClassCB = ...
    before_emit: before_emitApplicationClassCB = ...
    command_line: command_lineApplicationClassCB = ...
    dbus_register: dbus_registerApplicationClassCB = ...
    dbus_unregister: dbus_unregisterApplicationClassCB = ...
    handle_local_options: handle_local_optionsApplicationClassCB = ...
    local_command_line: local_command_lineApplicationClassCB = ...
    name_lost: name_lostApplicationClassCB = ...
    open: openApplicationClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    quit_mainloop: quit_mainloopApplicationClassCB = ...
    run_mainloop: run_mainloopApplicationClassCB = ...
    shutdown: shutdownApplicationClassCB = ...
    startup: startupApplicationClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ApplicationCommandLine(GObject.Object):
    """
    `GApplicationCommandLine` represents a command-line invocation of
    an application.

    It is created by [class@Gio.Application] and emitted
    in the [signal@Gio.Application::command-line] signal and virtual function.

    The class contains the list of arguments that the program was invoked
    with. It is also possible to query if the commandline invocation was
    local (ie: the current process is running in direct response to the
    invocation) or remote (ie: some other process forwarded the
    commandline to this process).

    The `GApplicationCommandLine` object can provide the @argc and @argv
    parameters for use with the [struct@GLib.OptionContext] command-line parsing API,
    with the [method@Gio.ApplicationCommandLine.get_arguments] function. See
    [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
    for an example.

    The exit status of the originally-invoked process may be set and
    messages can be printed to stdout or stderr of that process.

    For remote invocation, the originally-invoked process exits when
    [method@Gio.ApplicationCommandLine.done] method is called. This method is
    also automatically called when the object is disposed.

    The main use for `GApplicationCommandLine` (and the
    [signal@Gio.Application::command-line] signal) is 'Emacs server' like use cases:
    You can set the `EDITOR` environment variable to have e.g. git use
    your favourite editor to edit commit messages, and if you already
    have an instance of the editor running, the editing will happen
    in the running instance, instead of opening a new one. An important
    aspect of this use case is that the process that gets started by git
    does not return until the editing is done.

    Normally, the commandline is completely handled in the
    [signal@Gio.Application::command-line] handler. The launching instance exits
    once the signal handler in the primary instance has returned, and
    the return value of the signal handler becomes the exit status
    of the launching instance.

    ```c
    static int
    command_line (GApplication            *application,
                  GApplicationCommandLine *cmdline)
    {
      gchar **argv;
      gint argc;
      gint i;

      argv = g_application_command_line_get_arguments (cmdline, &argc);

      g_application_command_line_print (cmdline,
                                        "This text is written back\\n"
                                        "to stdout of the caller\\n");

      for (i = 0; i < argc; i++)
        g_print ("argument %d: %s\\n", i, argv[i]);

      g_strfreev (argv);

      return 0;
    }
    ```

    The complete example can be found here:
    [gapplication-example-cmdline.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)

    In more complicated cases, the handling of the commandline can be
    split between the launcher and the primary instance.

    ```c
    static gboolean
     test_local_cmdline (GApplication   *application,
                         gchar        ***arguments,
                         gint           *exit_status)
    {
      gint i, j;
      gchar **argv;

      argv = *arguments;

      if (argv[0] == NULL)
        {
          *exit_status = 0;
          return FALSE;
        }

      i = 1;
      while (argv[i])
        {
          if (g_str_has_prefix (argv[i], "--local-"))
            {
              g_print ("handling argument %s locally\\n", argv[i]);
              g_free (argv[i]);
              for (j = i; argv[j]; j++)
                argv[j] = argv[j + 1];
            }
          else
            {
              g_print ("not handling argument %s locally\\n", argv[i]);
              i++;
            }
        }

      *exit_status = 0;

      return FALSE;
    }

    static void
    test_application_class_init (TestApplicationClass *class)
    {
      G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;

      ...
    }
    ```

    In this example of split commandline handling, options that start
    with `--local-` are handled locally, all other options are passed
    to the [signal@Gio.Application::command-line] handler which runs in the primary
    instance.

    The complete example can be found here:
    [gapplication-example-cmdline2.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)

    If handling the commandline requires a lot of work, it may be better to defer it.

    ```c
    static gboolean
    my_cmdline_handler (gpointer data)
    {
      GApplicationCommandLine *cmdline = data;

      // do the heavy lifting in an idle

      g_application_command_line_set_exit_status (cmdline, 0);
      g_object_unref (cmdline); // this releases the application

      return G_SOURCE_REMOVE;
    }

    static int
    command_line (GApplication            *application,
                  GApplicationCommandLine *cmdline)
    {
      // keep the application running until we are done with this commandline
      g_application_hold (application);

      g_object_set_data_full (G_OBJECT (cmdline),
                              "application", application,
                              (GDestroyNotify)g_application_release);

      g_object_ref (cmdline);
      g_idle_add (my_cmdline_handler, cmdline);

      return 0;
    }
    ```

    In this example the commandline is not completely handled before
    the [signal@Gio.Application::command-line] handler returns. Instead, we keep
    a reference to the `GApplicationCommandLine` object and handle it
    later (in this example, in an idle). Note that it is necessary to
    hold the application until you are done with the commandline.

    The complete example can be found here:
    [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
    """

    class Props(GObject.Object.Props):
        arguments: GLib.Variant | None
        is_remote: bool  # [is-remote]: changed because contained invalid characters
        options: GLib.Variant | None
        platform_data: GLib.Variant | None  # [platform-data]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        arguments: GLib.Variant | None = ...,
        options: GLib.Variant | None = ...,
        platform_data: GLib.Variant | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def create_file_for_arg(self, arg: str) -> File: ...
    def done(self) -> None: ...
    def get_arguments(self) -> tuple[list, int | None]: ...
    def get_cwd(self) -> str | None: ...
    def get_environ(self) -> list: ...
    def get_exit_status(self) -> int: ...
    @property
    def get_is_remote(self) -> bool: ...
    def get_options_dict(self) -> GLib.VariantDict: ...
    def get_platform_data(self) -> GLib.Variant | None: ...
    def get_stdin(self) -> InputStream | None: ...
    def getenv(self, name: str) -> str | None: ...
    def print_literal(self, message: str) -> None: ...
    def printerr_literal(self, message: str) -> None: ...
    def set_exit_status(self, exit_status: int) -> None: ...

    # python methods
    def do_done(
        self,
    ) -> None:
        """
        done(self)
        """
    def do_get_stdin(
        self,
    ) -> InputStream | None:
        """
        get_stdin(self) -> Gio.InputStream or None
        """
    def do_print_literal(
        self,
        message: str,
    ) -> None:
        """
        print_literal(self, message:str)
        """
    def do_printerr_literal(
        self,
        message: str,
    ) -> None:
        """
        printerr_literal(self, message:str)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::arguments"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_remote"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::options"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::platform_data"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ApplicationCommandLineClass(GObject.GPointer):
    # gi Fields
    done: doneApplicationCommandLineClassCB = ...
    get_stdin: get_stdinApplicationCommandLineClassCB | None = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    print_literal: print_literalApplicationCommandLineClassCB = ...
    printerr_literal: printerr_literalApplicationCommandLineClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ApplicationCommandLinePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ApplicationPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class AsyncInitable(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    async def init_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def init_finish(self, res: AsyncResult) -> bool: ...
    def new_finish(self, res: AsyncResult) -> GObject.Object: ...
    @deprecated("deprecated")
    @staticmethod
    def newv_async(
        object_type: GObject.GType,
        n_parameters: int,
        parameters: GObject.Parameter,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

    ...

class AsyncInitableIface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    init_async: init_asyncAsyncInitableIfaceCB = ...
    init_finish: init_finishAsyncInitableIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class AsyncResult(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_source_object(self) -> GObject.Object | None: ...
    def get_user_data(self) -> object | None: ...
    def is_tagged(self, source_tag: object | None = None) -> bool: ...
    def legacy_propagate_error(self) -> bool: ...

    ...

class AsyncResultIface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_source_object: get_source_objectAsyncResultIfaceCB | None = ...
    get_user_data: get_user_dataAsyncResultIfaceCB | None = ...
    is_tagged: is_taggedAsyncResultIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BufferedInputStream(FilterInputStream):
    """
    Buffered input stream implements [class@Gio.FilterInputStream] and provides
    for buffered reads.

    By default, `GBufferedInputStream`'s buffer size is set at 4 kilobytes.

    To create a buffered input stream, use [ctor@Gio.BufferedInputStream.new],
    or [ctor@Gio.BufferedInputStream.new_sized] to specify the buffer's size at
    construction.

    To get the size of a buffer within a buffered input stream, use
    [method@Gio.BufferedInputStream.get_buffer_size]. To change the size of a
    buffered input stream's buffer, use [method@Gio.BufferedInputStream.set_buffer_size].
    Note that the buffer's size cannot be reduced below the size of the data within the buffer.
    """

    class Props(FilterInputStream.Props):
        buffer_size: int  # [buffer-size]: changed because contained invalid characters

    # gi Methods
    def __init__(self, buffer_size: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def fill(self, count: int, cancellable: Cancellable | None = None) -> int: ...
    async def fill_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def fill_finish(self, result: AsyncResult) -> int: ...
    def get_available(self) -> int: ...
    @property
    def get_buffer_size(self) -> int: ...
    @classmethod
    def new(cls, base_stream: InputStream) -> InputStream: ...
    @classmethod
    def new_sized(cls, base_stream: InputStream, size: int) -> InputStream: ...
    def peek(self, buffer: list, offset: int, count: int) -> int: ...
    def peek_buffer(self) -> tuple[list, int]: ...
    def read_byte(self, cancellable: Cancellable | None = None) -> int: ...
    def set_buffer_size(self, size: int) -> None: ...

    # python methods
    def do_fill(
        self,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        fill(self, count:int, cancellable:Gio.Cancellable=None) -> int
        """
    def do_fill_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        fill_async(self, count:int, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_fill_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        fill_finish(self, result:Gio.AsyncResult) -> int
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class BufferedInputStreamClass(GObject.GPointer):
    # gi Fields
    fill: fillBufferedInputStreamClassCB = ...
    fill_async: fill_asyncBufferedInputStreamClassCB = ...
    fill_finish: fill_finishBufferedInputStreamClassCB = ...
    parent_class: FilterInputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BufferedInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BufferedOutputStream(FilterOutputStream):
    """
    Buffered output stream implements [class@Gio.FilterOutputStream] and provides
    for buffered writes.

    By default, `GBufferedOutputStream`'s buffer size is set at 4 kilobytes.

    To create a buffered output stream, use [ctor@Gio.BufferedOutputStream.new],
    or [ctor@Gio.BufferedOutputStream.new_sized] to specify the buffer's size
    at construction.

    To get the size of a buffer within a buffered input stream, use
    [method@Gio.BufferedOutputStream.get_buffer_size]. To change the size of a
    buffered output stream's buffer, use [method@Gio.BufferedOutputStream.set_buffer_size].
    Note that the buffer's size cannot be reduced below the size of the data within the buffer.
    """

    class Props(FilterOutputStream.Props):
        auto_grow: bool  # [auto-grow]: changed because contained invalid characters
        buffer_size: int  # [buffer-size]: changed because contained invalid characters

    # gi Methods
    def __init__(self, auto_grow: bool = ..., buffer_size: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_auto_grow(self) -> bool: ...
    @property
    def get_buffer_size(self) -> int: ...
    @classmethod
    def new(cls, base_stream: OutputStream) -> OutputStream: ...
    @classmethod
    def new_sized(cls, base_stream: OutputStream, size: int) -> OutputStream: ...
    def set_auto_grow(self, auto_grow: bool) -> None: ...
    def set_buffer_size(self, size: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::auto_grow"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class BufferedOutputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: FilterOutputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BufferedOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class BytesIcon(GObject.Object):
    """
    `GBytesIcon` specifies an image held in memory in a common format (usually
    PNG) to be used as icon.
    """

    class Props(GObject.Object.Props):
        bytes: GLib.Bytes | None

    # gi Methods
    def __init__(self, bytes: GLib.Bytes | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_bytes(self) -> GLib.Bytes: ...
    @classmethod
    def new(cls, bytes: GLib.Bytes) -> BytesIcon: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class Cancellable(GObject.Object):
    """
    `GCancellable` allows operations to be cancelled.

    `GCancellable` is a thread-safe operation cancellation stack used
    throughout GIO to allow for cancellation of synchronous and
    asynchronous operations.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def cancel(self) -> None: ...
    def connect(
        self,
        callback: GObject.Callback,
        data: object | None = None,
        data_destroy_func: GLib.DestroyNotify | None = None,
    ) -> int:
        """
        [note from gi-stub-gen] Cancellable has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    def disconnect(self, handler_id: int) -> None: ...
    @staticmethod
    def get_current() -> Cancellable | None: ...
    def get_fd(self) -> int: ...
    def is_cancelled(self) -> bool: ...
    def make_pollfd(self, pollfd: GLib.PollFD) -> bool: ...
    @classmethod
    def new(cls) -> Cancellable: ...
    def pop_current(self) -> None: ...
    def push_current(self) -> None: ...
    def release_fd(self) -> None: ...
    def reset(self) -> None: ...
    def set_error_if_cancelled(self) -> bool: ...
    def source_new(self) -> GLib.Source: ...

    # python methods
    def do_cancelled(
        self,
    ) -> None:
        """
        cancelled(self)
        """

    ...

class CancellableClass(GObject.GPointer):
    # gi Fields
    cancelled: cancelledCancellableClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class CancellablePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class CharsetConverter(GObject.Object):
    """
    `GCharsetConverter` is an implementation of [iface@Gio.Converter] based on
    [struct@GLib.IConv].
    """

    class Props(GObject.Object.Props):
        from_charset: str  # [from-charset]: changed because contained invalid characters
        to_charset: str  # [to-charset]: changed because contained invalid characters
        use_fallback: bool  # [use-fallback]: changed because contained invalid characters

    # gi Methods
    def __init__(self, from_charset: str = ..., to_charset: str = ..., use_fallback: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_num_fallbacks(self) -> int: ...
    @property
    def get_use_fallback(self) -> bool: ...
    @classmethod
    def new(cls, to_charset: str, from_charset: str) -> CharsetConverter: ...
    def set_use_fallback(self, use_fallback: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::from_charset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::to_charset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_fallback"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class CharsetConverterClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Converter(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def convert(
        self, inbuf: list, inbuf_size: int, outbuf: list, outbuf_size: int, flags: ConverterFlags
    ) -> tuple[ConverterResult, int, int]: ...
    def convert_bytes(self, bytes: GLib.Bytes) -> GLib.Bytes: ...
    def reset(self) -> None: ...

    ...

class ConverterIface(GObject.GPointer):
    # gi Fields
    convert: convertConverterIfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    reset: resetConverterIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ConverterInputStream(FilterInputStream):
    """
    Converter input stream implements [class@Gio.InputStream] and allows
    conversion of data of various types during reading.

    As of GLib 2.34, `GConverterInputStream` implements
    [iface@Gio.PollableInputStream].
    """

    class Props(FilterInputStream.Props):
        converter: Converter | None

    # gi Methods
    def __init__(self, converter: Converter | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_converter(self) -> Converter: ...
    @classmethod
    def new(cls, base_stream: InputStream, converter: Converter) -> InputStream: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::converter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ConverterInputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: FilterInputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ConverterInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ConverterOutputStream(FilterOutputStream):
    """
    Converter output stream implements [class@Gio.OutputStream] and allows
    conversion of data of various types during reading.

    As of GLib 2.34, `GConverterOutputStream` implements
    [iface@Gio.PollableOutputStream].
    """

    class Props(FilterOutputStream.Props):
        converter: Converter | None

    # gi Methods
    def __init__(self, converter: Converter | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_converter(self) -> Converter: ...
    @classmethod
    def new(cls, base_stream: OutputStream, converter: Converter) -> OutputStream: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::converter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ConverterOutputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: FilterOutputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ConverterOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Credentials(GObject.Object):
    """
    The `GCredentials` type is a reference-counted wrapper for native
    credentials.

    The information in `GCredentials` is typically used for identifying,
    authenticating and authorizing other processes.

    Some operating systems supports looking up the credentials of the remote
    peer of a communication endpoint - see e.g. [method@Gio.Socket.get_credentials].

    Some operating systems supports securely sending and receiving
    credentials over a Unix Domain Socket, see [class@Gio.UnixCredentialsMessage],
    [method@Gio.UnixConnection.send_credentials] and
    [method@Gio.UnixConnection.receive_credentials] for details.

    On Linux, the native credential type is a `struct ucred` - see the
    [`unix(7)` man page](man:unix(7)) for details. This corresponds to
    `G_CREDENTIALS_TYPE_LINUX_UCRED`.

    On Apple operating systems (including iOS, tvOS, and macOS), the native credential
    type is a `struct xucred`. This corresponds to `G_CREDENTIALS_TYPE_APPLE_XUCRED`.

    On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is a
    `struct cmsgcred`. This corresponds to `G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED`.

    On NetBSD, the native credential type is a `struct unpcbid`.
    This corresponds to `G_CREDENTIALS_TYPE_NETBSD_UNPCBID`.

    On OpenBSD, the native credential type is a `struct sockpeercred`.
    This corresponds to `G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED`.

    On Solaris (including OpenSolaris and its derivatives), the native credential type
    is a `ucred_t`. This corresponds to `G_CREDENTIALS_TYPE_SOLARIS_UCRED`.

    Since GLib 2.72, on Windows, the native credentials may contain the PID of a
    process. This corresponds to `G_CREDENTIALS_TYPE_WIN32_PID`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_unix_pid(self) -> int: ...
    def get_unix_user(self) -> int: ...
    def is_same_user(self, other_credentials: Credentials) -> bool: ...
    @classmethod
    def new(cls) -> Credentials: ...
    def set_native(self, native_type: CredentialsType, native: object) -> None: ...
    def set_unix_user(self, uid: int) -> bool: ...
    def to_string(self) -> str: ...

    ...

class CredentialsClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusActionGroup(GObject.Object):
    """
    `GDBusActionGroup` is an implementation of the [iface@Gio.ActionGroup]
    interface.

    `GDBusActionGroup` can be used as a proxy for an action group
    that is exported over D-Bus with [method@Gio.DBusConnection.export_action_group].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get(connection: DBusConnection, bus_name: str | None, object_path: str) -> DBusActionGroup: ...

    ...

class DBusAnnotationInfo(GObject.GBoxed):
    # gi Methods
    @staticmethod
    def lookup(annotations: list | None, name: str) -> str | None: ...
    def ref(self) -> DBusAnnotationInfo: ...
    def unref(self) -> None: ...

    # python methods
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class DBusArgInfo(GObject.GBoxed):
    # gi Methods
    def ref(self) -> DBusArgInfo: ...
    def unref(self) -> None: ...

    # python methods
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class DBusAuthObserver(GObject.Object):
    """
    `GDBusAuthObserver` provides a mechanism for participating
    in how a [class@Gio.DBusServer] (or a [class@Gio.DBusConnection])
    authenticates remote peers.

    Simply instantiate a `GDBusAuthObserver` and connect to the
    signals you are interested in. Note that new signals may be added
    in the future.

    ## Controlling Authentication Mechanisms

    By default, a `GDBusServer` or server-side `GDBusConnection` will allow
    any authentication mechanism to be used. If you only want to allow D-Bus
    connections with the `EXTERNAL` mechanism, which makes use of credentials
    passing and is the recommended mechanism for modern Unix platforms such
    as Linux and the BSD family, you would use a signal handler like this:

    ```c
    static gboolean
    on_allow_mechanism (GDBusAuthObserver *observer,
                        const gchar       *mechanism,
                        gpointer           user_data)
    {
      if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
        {
          return TRUE;
        }

      return FALSE;
    }
    ```

    ## Controlling Authorization

    By default, a `GDBusServer` or server-side `GDBusConnection` will accept
    connections from any successfully authenticated user (but not from
    anonymous connections using the `ANONYMOUS` mechanism). If you only
    want to allow D-Bus connections from processes owned by the same uid
    as the server, since GLib 2.68, you should use the
    `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag. It’s equivalent
    to the following signal handler:

    ```c
    static gboolean
    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
                                     GIOStream         *stream,
                                     GCredentials      *credentials,
                                     gpointer           user_data)
    {
      gboolean authorized;

      authorized = FALSE;
      if (credentials != NULL)
        {
          GCredentials *own_credentials;
          own_credentials = g_credentials_new ();
          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
            authorized = TRUE;
          g_object_unref (own_credentials);
        }

      return authorized;
    }
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def allow_mechanism(self, mechanism: str) -> bool: ...
    def authorize_authenticated_peer(self, stream: IOStream, credentials: Credentials | None = None) -> bool: ...
    @classmethod
    def new(cls) -> DBusAuthObserver: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["allow-mechanism"],
        handler: typing.Callable[[typing_extensions.Self, str], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["authorize-authenticated-peer"],
        handler: typing.Callable[[typing_extensions.Self, IOStream, Credentials | None], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusConnection(GObject.Object):
    """
    The `GDBusConnection` type is used for D-Bus connections to remote
    peers such as a message buses.

    It is a low-level API that offers a lot of flexibility. For instance,
    it lets you establish a connection over any transport that can by represented
    as a [class@Gio.IOStream].

    This class is rarely used directly in D-Bus clients. If you are writing
    a D-Bus client, it is often easier to use the [func@Gio.bus_own_name],
    [func@Gio.bus_watch_name] or [func@Gio.DBusProxy.new_for_bus] APIs.

    As an exception to the usual GLib rule that a particular object must not
    be used by two threads at the same time, `GDBusConnection`s methods may be
    called from any thread. This is so that [func@Gio.bus_get] and
    [func@Gio.bus_get_sync] can safely return the same `GDBusConnection` when
    called from any thread.

    Most of the ways to obtain a `GDBusConnection` automatically initialize it
    (i.e. connect to D-Bus): for instance, [func@Gio.DBusConnection.new] and
    [func@Gio.bus_get], and the synchronous versions of those methods, give you
    an initialized connection. Language bindings for GIO should use
    [func@Gio.Initable.new] or [func@Gio.AsyncInitable.new_async], which also
    initialize the connection.

    If you construct an uninitialized `GDBusConnection`, such as via
    [ctor@GObject.Object.new], you must initialize it via [method@Gio.Initable.init] or
    [method@Gio.AsyncInitable.init_async] before using its methods or properties.
    Calling methods or accessing properties on a `GDBusConnection` that has not
    completed initialization successfully is considered to be invalid, and leads
    to undefined behaviour. In particular, if initialization fails with a
    `GError`, the only valid thing you can do with that `GDBusConnection` is to
    free it with [method@GObject.Object.unref].

    ## An example D-Bus server

    Here is an example for a D-Bus server:
    [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)

    ## An example for exporting a subtree

    Here is an example for exporting a subtree:
    [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)

    ## An example for file descriptor passing

    Here is an example for passing UNIX file descriptors:
    [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)

    ## An example for exporting a GObject

    Here is an example for exporting a #GObject:
    [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
    """

    class Props(GObject.Object.Props):
        address: str
        authentication_observer: (
            DBusAuthObserver | None
        )  # [authentication-observer]: changed because contained invalid characters
        capabilities: DBusCapabilityFlags
        closed: bool
        exit_on_close: bool  # [exit-on-close]: changed because contained invalid characters
        flags: DBusConnectionFlags
        guid: str
        stream: IOStream | None
        unique_name: str  # [unique-name]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        address: str = ...,
        authentication_observer: DBusAuthObserver | None = ...,
        exit_on_close: bool = ...,
        flags: DBusConnectionFlags = ...,
        guid: str = ...,
        stream: IOStream | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_filter(
        self,
        filter_function: DBusMessageFilterFunction,
        user_data: object | None,
        user_data_free_func: GLib.DestroyNotify,
    ) -> int: ...
    async def call(
        self,
        bus_name: str | None,
        object_path: str,
        interface_name: str,
        method_name: str,
        parameters: GLib.Variant | None,
        reply_type: GLib.VariantType | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def call_finish(self, res: AsyncResult) -> GLib.Variant: ...
    def call_sync(
        self,
        bus_name: str | None,
        object_path: str,
        interface_name: str,
        method_name: str,
        parameters: GLib.Variant | None,
        reply_type: GLib.VariantType | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
    ) -> GLib.Variant: ...
    async def call_with_unix_fd_list(
        self,
        bus_name: str | None,
        object_path: str,
        interface_name: str,
        method_name: str,
        parameters: GLib.Variant | None,
        reply_type: GLib.VariantType | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        fd_list: UnixFDList | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def call_with_unix_fd_list_finish(self, res: AsyncResult) -> tuple[GLib.Variant, UnixFDList | None]: ...
    def call_with_unix_fd_list_sync(
        self,
        bus_name: str | None,
        object_path: str,
        interface_name: str,
        method_name: str,
        parameters: GLib.Variant | None,
        reply_type: GLib.VariantType | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        fd_list: UnixFDList | None = None,
        cancellable: Cancellable | None = None,
    ) -> tuple[GLib.Variant, UnixFDList | None]: ...
    async def close(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def close_finish(self, res: AsyncResult) -> bool: ...
    def close_sync(self, cancellable: Cancellable | None = None) -> bool: ...
    def emit_signal(
        self,
        destination_bus_name: str | None,
        object_path: str,
        interface_name: str,
        signal_name: str,
        parameters: GLib.Variant | None = None,
    ) -> bool: ...
    def export_action_group(self, object_path: str, action_group: ActionGroup) -> int: ...
    def export_menu_model(self, object_path: str, menu: MenuModel) -> int: ...
    async def flush(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def flush_finish(self, res: AsyncResult) -> bool: ...
    def flush_sync(self, cancellable: Cancellable | None = None) -> bool: ...
    @property
    def get_capabilities(self) -> DBusCapabilityFlags: ...
    @property
    def get_exit_on_close(self) -> bool: ...
    @property
    def get_flags(self) -> DBusConnectionFlags: ...
    @property
    def get_guid(self) -> str: ...
    def get_last_serial(self) -> int: ...
    def get_peer_credentials(self) -> Credentials | None: ...
    @property
    def get_stream(self) -> IOStream: ...
    @property
    def get_unique_name(self) -> str | None: ...
    @property
    def is_closed(self) -> bool: ...
    @staticmethod
    async def new(
        stream: IOStream,
        guid: str | None,
        flags: DBusConnectionFlags,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @classmethod
    def new_finish(cls, res: AsyncResult) -> DBusConnection: ...
    @staticmethod
    async def new_for_address(
        address: str,
        flags: DBusConnectionFlags,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @classmethod
    def new_for_address_finish(cls, res: AsyncResult) -> DBusConnection: ...
    @classmethod
    def new_for_address_sync(
        cls,
        address: str,
        flags: DBusConnectionFlags,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
    ) -> DBusConnection: ...
    @classmethod
    def new_sync(
        cls,
        stream: IOStream,
        guid: str | None,
        flags: DBusConnectionFlags,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
    ) -> DBusConnection: ...
    @deprecated("deprecated")
    def register_object(
        self,
        object_path: str,
        interface_info: DBusInterfaceInfo,
        method_call_closure: GObject.Closure | None = None,
        get_property_closure: GObject.Closure | None = None,
        set_property_closure: GObject.Closure | None = None,
    ) -> int: ...
    def register_object_with_closures2(
        self,
        object_path: str,
        interface_info: DBusInterfaceInfo,
        method_call_closure: GObject.Closure | None = None,
        get_property_closure: GObject.Closure | None = None,
        set_property_closure: GObject.Closure | None = None,
    ) -> int: ...
    def register_subtree(
        self,
        object_path: str,
        vtable: DBusSubtreeVTable,
        flags: DBusSubtreeFlags,
        user_data: object | None,
        user_data_free_func: GLib.DestroyNotify,
    ) -> int: ...
    def remove_filter(self, filter_id: int) -> None: ...
    def send_message(self, message: DBusMessage, flags: DBusSendMessageFlags) -> tuple[bool, int | None]: ...
    async def send_message_with_reply(
        self,
        message: DBusMessage,
        flags: DBusSendMessageFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> int | None: ...
    def send_message_with_reply_finish(self, res: AsyncResult) -> DBusMessage: ...
    def send_message_with_reply_sync(
        self,
        message: DBusMessage,
        flags: DBusSendMessageFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
    ) -> tuple[DBusMessage, int | None]: ...
    def set_exit_on_close(self, exit_on_close: bool) -> None: ...
    def signal_subscribe(
        self,
        sender: str | None,
        interface_name: str | None,
        member: str | None,
        object_path: str | None,
        arg0: str | None,
        flags: DBusSignalFlags,
        callback: DBusSignalCallback,
        user_data: object | None = None,
        user_data_free_func: GLib.DestroyNotify | None = None,
    ) -> int: ...
    def signal_unsubscribe(self, subscription_id: int) -> None: ...
    def start_message_processing(self) -> None: ...
    def unexport_action_group(self, export_id: int) -> None: ...
    def unexport_menu_model(self, export_id: int) -> None: ...
    def unregister_object(self, registration_id: int) -> bool: ...
    def unregister_subtree(self, registration_id: int) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["closed"],
        handler: typing.Callable[[typing_extensions.Self, bool, None | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::authentication_observer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::capabilities"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::closed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::exit_on_close"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::guid"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::unique_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusErrorEntry(GObject.GPointer):
    # gi Fields
    dbus_error_name: str = ...
    error_code: int = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusInterface(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_info(self) -> DBusInterfaceInfo: ...
    def get_object(self) -> DBusObject | None: ...
    def set_object(self, object: DBusObject | None = None) -> None: ...

    ...

class DBusInterfaceIface(GObject.GPointer):
    # gi Fields
    dup_object: dup_objectDBusInterfaceIfaceCB | None = ...
    get_info: get_infoDBusInterfaceIfaceCB = ...
    get_object: get_objectDBusInterfaceIfaceCB | None = ...
    parent_iface: GObject.TypeInterface | None = ...  # type: ignore
    set_object: set_objectDBusInterfaceIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusInterfaceInfo(GObject.GBoxed):
    # gi Methods
    def cache_build(self) -> None: ...
    def cache_release(self) -> None: ...
    def generate_xml(self, indent: int, string_builder: GLib.String) -> None: ...
    def lookup_method(self, name: str) -> DBusMethodInfo | None: ...
    def lookup_property(self, name: str) -> DBusPropertyInfo | None: ...
    def lookup_signal(self, name: str) -> DBusSignalInfo | None: ...
    def ref(self) -> DBusInterfaceInfo: ...
    def unref(self) -> None: ...

    # python methods
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class DBusInterfaceSkeleton(GObject.Object):
    """
    Abstract base class for D-Bus interfaces on the service side.
    """

    class Props(GObject.Object.Props):
        g_flags: DBusInterfaceSkeletonFlags  # [g-flags]: changed because contained invalid characters

    # gi Methods
    def __init__(self, g_flags: DBusInterfaceSkeletonFlags = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def export(self, connection: DBusConnection, object_path: str) -> bool: ...
    def flush(self) -> None: ...
    def get_connection(self) -> DBusConnection | None: ...
    def get_connections(self) -> list: ...
    def get_flags(self) -> DBusInterfaceSkeletonFlags: ...
    def get_info(self) -> DBusInterfaceInfo: ...
    def get_object_path(self) -> str | None: ...
    def get_properties(self) -> GLib.Variant: ...
    def get_vtable(self) -> DBusInterfaceVTable: ...
    def has_connection(self, connection: DBusConnection) -> bool: ...
    def set_flags(self, flags: DBusInterfaceSkeletonFlags) -> None: ...
    def unexport(self) -> None: ...
    def unexport_from_connection(self, connection: DBusConnection) -> None: ...

    # python methods
    def do_flush(
        self,
    ) -> None:
        """
        flush(self)
        """
    def do_g_authorize_method(
        self,
        invocation: DBusMethodInvocation,
    ) -> bool:
        """
        g_authorize_method(self, invocation:Gio.DBusMethodInvocation) -> bool
        """
    def do_get_info(
        self,
    ) -> DBusInterfaceInfo:
        """
        get_info(self) -> Gio.DBusInterfaceInfo
        """
    def do_get_properties(
        self,
    ) -> GLib.Variant:
        """
        get_properties(self) -> GLib.Variant
        """
    def do_get_vtable(
        self,
    ) -> DBusInterfaceVTable:
        """
        get_vtable(self) -> Gio.DBusInterfaceVTable
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["g-authorize-method"],
        handler: typing.Callable[[typing_extensions.Self, DBusMethodInvocation], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusInterfaceSkeletonClass(GObject.GPointer):
    # gi Fields
    flush: flushDBusInterfaceSkeletonClassCB = ...
    g_authorize_method: g_authorize_methodDBusInterfaceSkeletonClassCB = ...
    get_info: get_infoDBusInterfaceSkeletonClassCB = ...
    get_properties: get_propertiesDBusInterfaceSkeletonClassCB = ...
    get_vtable: get_vtableDBusInterfaceSkeletonClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    signal_padding: list | None = ...
    vfunc_padding: list | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusInterfaceSkeletonPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusInterfaceVTable(GObject.GPointer):
    # gi Fields
    get_property: DBusInterfaceGetPropertyFuncDBusInterfaceVTableCB = ...
    method_call: DBusInterfaceMethodCallFuncDBusInterfaceVTableCB = ...
    padding: list | None = ...
    set_property: DBusInterfaceSetPropertyFuncDBusInterfaceVTableCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusMenuModel(MenuModel):
    """
    `GDBusMenuModel` is an implementation of [class@Gio.MenuModel] that can be
    used as a proxy for a menu model that is exported over D-Bus with
    [method@Gio.DBusConnection.export_menu_model].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get(connection: DBusConnection, bus_name: str | None, object_path: str) -> DBusMenuModel: ...

    ...

class DBusMessage(GObject.Object):
    """
    A type for representing D-Bus messages that can be sent or received
    on a [class@Gio.DBusConnection].
    """

    class Props(GObject.Object.Props):
        locked: bool

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def bytes_needed(blob: list, blob_len: int) -> int: ...
    def copy(self) -> DBusMessage: ...
    def get_arg0(self) -> str | None: ...
    def get_arg0_path(self) -> str | None: ...
    def get_body(self) -> GLib.Variant | None: ...
    def get_byte_order(self) -> DBusMessageByteOrder: ...
    def get_destination(self) -> str | None: ...
    def get_error_name(self) -> str | None: ...
    def get_flags(self) -> DBusMessageFlags: ...
    def get_header(self, header_field: DBusMessageHeaderField) -> GLib.Variant | None: ...
    def get_header_fields(self) -> list: ...
    def get_interface(self) -> str | None: ...
    @property
    def get_locked(self) -> bool: ...
    def get_member(self) -> str | None: ...
    def get_message_type(self) -> DBusMessageType: ...
    def get_num_unix_fds(self) -> int: ...
    def get_path(self) -> str | None: ...
    def get_reply_serial(self) -> int: ...
    def get_sender(self) -> str | None: ...
    def get_serial(self) -> int: ...
    def get_signature(self) -> str: ...
    def get_unix_fd_list(self) -> UnixFDList | None: ...
    def lock(self) -> None: ...
    @classmethod
    def new(cls) -> DBusMessage: ...
    @classmethod
    def new_from_blob(cls, blob: list, blob_len: int, capabilities: DBusCapabilityFlags) -> DBusMessage: ...
    @classmethod
    def new_method_call(cls, name: str | None, path: str, interface_: str | None, method: str) -> DBusMessage: ...
    def new_method_error_literal(self, error_name: str, error_message: str) -> DBusMessage: ...
    def new_method_reply(self) -> DBusMessage: ...
    @classmethod
    def new_signal(cls, path: str, interface_: str, signal: str) -> DBusMessage: ...
    def print_(self, indent: int) -> str: ...
    def set_body(self, body: GLib.Variant) -> None: ...
    def set_byte_order(self, byte_order: DBusMessageByteOrder) -> None: ...
    def set_destination(self, value: str | None = None) -> None: ...
    def set_error_name(self, value: str) -> None: ...
    def set_flags(self, flags: DBusMessageFlags) -> None: ...
    def set_header(self, header_field: DBusMessageHeaderField, value: GLib.Variant | None = None) -> None: ...
    def set_interface(self, value: str | None = None) -> None: ...
    def set_member(self, value: str | None = None) -> None: ...
    def set_message_type(self, type: DBusMessageType) -> None: ...
    def set_num_unix_fds(self, value: int) -> None: ...
    def set_path(self, value: str | None = None) -> None: ...
    def set_reply_serial(self, value: int) -> None: ...
    def set_sender(self, value: str | None = None) -> None: ...
    def set_serial(self, serial: int) -> None: ...
    def set_signature(self, value: str | None = None) -> None: ...
    def set_unix_fd_list(self, fd_list: UnixFDList | None = None) -> None: ...
    def to_blob(self, capabilities: DBusCapabilityFlags) -> tuple[list, int]: ...
    def to_gerror(self) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::locked"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusMethodInfo(GObject.GBoxed):
    # gi Methods
    def ref(self) -> DBusMethodInfo: ...
    def unref(self) -> None: ...

    # python methods
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class DBusMethodInvocation(GObject.Object):
    """
    Instances of the `GDBusMethodInvocation` class are used when
    handling D-Bus method calls. It provides a way to asynchronously
    return results and errors.

    The normal way to obtain a `GDBusMethodInvocation` object is to receive
    it as an argument to the `handle_method_call()` function in a
    [type@Gio.DBusInterfaceVTable] that was passed to
    [method@Gio.DBusConnection.register_object].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_connection(self) -> DBusConnection: ...
    def get_interface_name(self) -> str | None: ...
    def get_message(self) -> DBusMessage: ...
    def get_method_info(self) -> DBusMethodInfo | None: ...
    def get_method_name(self) -> str: ...
    def get_object_path(self) -> str: ...
    def get_parameters(self) -> GLib.Variant: ...
    def get_property_info(self) -> DBusPropertyInfo | None: ...
    def get_sender(self) -> str | None: ...
    def return_dbus_error(self, error_name: str, error_message: str) -> None: ...
    def return_error_literal(self, domain: int, code: int, message: str) -> None: ...
    def return_gerror(self, error: None) -> None: ...
    def return_value(self, parameters: GLib.Variant | None = None) -> None: ...
    def return_value_with_unix_fd_list(
        self, parameters: GLib.Variant | None = None, fd_list: UnixFDList | None = None
    ) -> None: ...

    ...

class DBusNodeInfo(GObject.GBoxed):
    # gi Methods
    def generate_xml(self, indent: int, string_builder: GLib.String) -> None: ...
    def lookup_interface(self, name: str) -> DBusInterfaceInfo | None: ...
    @classmethod
    def new_for_xml(cls, xml_data: str) -> DBusNodeInfo: ...
    def ref(self) -> DBusNodeInfo: ...
    def unref(self) -> None: ...

    # python methods
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class DBusObject(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_interface(self, interface_name: str) -> DBusInterface | None: ...
    def get_interfaces(self) -> list: ...
    def get_object_path(self) -> str: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-added"],
        handler: typing.Callable[[typing_extensions.Self, DBusInterface], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-removed"],
        handler: typing.Callable[[typing_extensions.Self, DBusInterface], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusObjectIface(GObject.GPointer):
    # gi Fields
    get_interface: get_interfaceDBusObjectIfaceCB | None = ...
    get_interfaces: get_interfacesDBusObjectIfaceCB = ...
    get_object_path: get_object_pathDBusObjectIfaceCB = ...
    interface_added: interface_addedDBusObjectIfaceCB = ...
    interface_removed: interface_removedDBusObjectIfaceCB = ...
    parent_iface: GObject.TypeInterface | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusObjectManager(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_interface(self, object_path: str, interface_name: str) -> DBusInterface | None: ...
    def get_object(self, object_path: str) -> DBusObject | None: ...
    def get_object_path(self) -> str: ...
    def get_objects(self) -> list: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-added"],
        handler: typing.Callable[[typing_extensions.Self, DBusObject, DBusInterface], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-removed"],
        handler: typing.Callable[[typing_extensions.Self, DBusObject, DBusInterface], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["object-added"],
        handler: typing.Callable[[typing_extensions.Self, DBusObject], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["object-removed"],
        handler: typing.Callable[[typing_extensions.Self, DBusObject], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusObjectManagerClient(GObject.Object):
    """
    `GDBusObjectManagerClient` is used to create, monitor and delete object
    proxies for remote objects exported by a [class@Gio.DBusObjectManagerServer]
    (or any code implementing the
    [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
    interface).

    Once an instance of this type has been created, you can connect to
    the [signal@Gio.DBusObjectManager::object-added] and
    [signal@Gio.DBusObjectManager::object-removed signals] and inspect the
    [class@Gio.DBusObjectProxy] objects returned by
    [method@Gio.DBusObjectManager.get_objects].

    If the name for a `GDBusObjectManagerClient` is not owned by anyone at
    object construction time, the default behavior is to request the
    message bus to launch an owner for the name. This behavior can be
    disabled using the `G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START`
    flag. It’s also worth noting that this only works if the name of
    interest is activatable in the first place. E.g. in some cases it
    is not possible to launch an owner for the requested name. In this
    case, `GDBusObjectManagerClient` object construction still succeeds but
    there will be no object proxies
    (e.g. [method@Gio.DBusObjectManager.get_objects] returns the empty list) and
    the [property@Gio.DBusObjectManagerClient:name-owner] property is `NULL`.

    The owner of the requested name can come and go (for example
    consider a system service being restarted) – `GDBusObjectManagerClient`
    handles this case too; simply connect to the [signal@GObject.Object::notify]
    signal to watch for changes on the
    [property@Gio.DBusObjectManagerClient:name-owner] property. When the name
    owner vanishes, the behavior is that
    [property@Gio.DBusObjectManagerClient:name-owner] is set to `NULL` (this
    includes emission of the [signal@GObject.Object::notify] signal) and then
    [signal@Gio.DBusObjectManager::object-removed] signals are synthesized
    for all currently existing object proxies. Since
    [property@Gio.DBusObjectManagerClient:name-owner] is `NULL` when this
    happens, you can use this information to disambiguate a synthesized signal
    from a genuine signal caused by object removal on the remote
    [iface@Gio.DBusObjectManager]. Similarly, when a new name owner appears,
    [signal@Gio.DBusObjectManager::object-added] signals are synthesized
    while [property@Gio.DBusObjectManagerClient:name-owner] is still `NULL`. Only
    when all object proxies have been added, the
    [property@Gio.DBusObjectManagerClient:name-owner] is set to the new name
    owner (this includes emission of the [signal@GObject.Object::notify] signal).
    Furthermore, you are guaranteed that
    [property@Gio.DBusObjectManagerClient:name-owner] will alternate between a
    name owner (e.g. `:1.42`) and `NULL` even in the case where
    the name of interest is atomically replaced

    Ultimately, `GDBusObjectManagerClient` is used to obtain
    [class@Gio.DBusProxy] instances. All signals (including the
    `org.freedesktop.DBus.Properties::PropertiesChanged` signal)
    delivered to [class@Gio.DBusProxy] instances are guaranteed to originate
    from the name owner. This guarantee along with the behavior
    described above, means that certain race conditions including the
    “half the proxy is from the old owner and the other half is from
    the new owner” problem cannot happen.

    To avoid having the application connect to signals on the returned
    [class@Gio.DBusObjectProxy] and [class@Gio.DBusProxy] objects, the
    [signal@Gio.DBusObject::interface-added],
    [signal@Gio.DBusObject::interface-removed],
    [signal@Gio.DBusProxy::g-properties-changed] and
    [signal@Gio.DBusProxy::g-signal] signals
    are also emitted on the `GDBusObjectManagerClient` instance managing these
    objects. The signals emitted are
    [signal@Gio.DBusObjectManager::interface-added],
    [signal@Gio.DBusObjectManager::interface-removed],
    [signal@Gio.DBusObjectManagerClient::interface-proxy-properties-changed] and
    [signal@Gio.DBusObjectManagerClient::interface-proxy-signal].

    Note that all callbacks and signals are emitted in the
    thread-default main context (see
    [method@GLib.MainContext.push_thread_default]) that the
    `GDBusObjectManagerClient` object was constructed in. Additionally, the
    [class@Gio.DBusObjectProxy] and [class@Gio.DBusProxy] objects
    originating from the `GDBusObjectManagerClient` object will be created in
    the same context and, consequently, will deliver signals in the
    same main loop.
    """

    class Props(GObject.Object.Props):
        bus_type: BusType  # [bus-type]: changed because contained invalid characters
        connection: DBusConnection | None
        flags: DBusObjectManagerClientFlags
        get_proxy_type_destroy_notify: (
            object | None
        )  # [get-proxy-type-destroy-notify]: changed because contained invalid characters
        get_proxy_type_func: object | None  # [get-proxy-type-func]: changed because contained invalid characters
        get_proxy_type_user_data: (
            object | None
        )  # [get-proxy-type-user-data]: changed because contained invalid characters
        name: str
        name_owner: str  # [name-owner]: changed because contained invalid characters
        object_path: str  # [object-path]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        bus_type: BusType = ...,
        connection: DBusConnection | None = ...,
        flags: DBusObjectManagerClientFlags = ...,
        get_proxy_type_destroy_notify: object | None = ...,
        get_proxy_type_func: object | None = ...,
        get_proxy_type_user_data: object | None = ...,
        name: str = ...,
        object_path: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_connection(self) -> DBusConnection: ...
    @property
    def get_flags(self) -> DBusObjectManagerClientFlags: ...
    @property
    def get_name(self) -> str: ...
    @property
    def get_name_owner(self) -> str | None: ...
    @staticmethod
    async def new(
        connection: DBusConnection,
        flags: DBusObjectManagerClientFlags,
        name: str,
        object_path: str,
        get_proxy_type_func: DBusProxyTypeFunc | None = None,
        get_proxy_type_user_data: object | None = None,
        get_proxy_type_destroy_notify: GLib.DestroyNotify | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @classmethod
    def new_finish(cls, res: AsyncResult) -> DBusObjectManagerClient: ...
    @staticmethod
    async def new_for_bus(
        bus_type: BusType,
        flags: DBusObjectManagerClientFlags,
        name: str,
        object_path: str,
        get_proxy_type_func: DBusProxyTypeFunc | None = None,
        get_proxy_type_user_data: object | None = None,
        get_proxy_type_destroy_notify: GLib.DestroyNotify | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @classmethod
    def new_for_bus_finish(cls, res: AsyncResult) -> DBusObjectManagerClient: ...
    @classmethod
    def new_for_bus_sync(
        cls,
        bus_type: BusType,
        flags: DBusObjectManagerClientFlags,
        name: str,
        object_path: str,
        get_proxy_type_func: DBusProxyTypeFunc | None = None,
        get_proxy_type_user_data: object | None = None,
        get_proxy_type_destroy_notify: GLib.DestroyNotify | None = None,
        cancellable: Cancellable | None = None,
    ) -> DBusObjectManagerClient: ...
    @classmethod
    def new_sync(
        cls,
        connection: DBusConnection,
        flags: DBusObjectManagerClientFlags,
        name: str | None,
        object_path: str,
        get_proxy_type_func: DBusProxyTypeFunc | None = None,
        get_proxy_type_user_data: object | None = None,
        get_proxy_type_destroy_notify: GLib.DestroyNotify | None = None,
        cancellable: Cancellable | None = None,
    ) -> DBusObjectManagerClient: ...

    # python methods
    def do_interface_proxy_properties_changed(
        self,
        object_proxy: DBusObjectProxy,
        interface_proxy: DBusProxy,
        changed_properties: GLib.Variant,
        invalidated_properties: str,
    ) -> None:
        """
        interface_proxy_properties_changed(self, object_proxy:Gio.DBusObjectProxy, interface_proxy:Gio.DBusProxy, changed_properties:GLib.Variant, invalidated_properties:str)
        """
    def do_interface_proxy_signal(
        self,
        object_proxy: DBusObjectProxy,
        interface_proxy: DBusProxy,
        sender_name: str,
        signal_name: str,
        parameters: GLib.Variant,
    ) -> None:
        """
        interface_proxy_signal(self, object_proxy:Gio.DBusObjectProxy, interface_proxy:Gio.DBusProxy, sender_name:str, signal_name:str, parameters:GLib.Variant)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-proxy-properties-changed"],
        handler: typing.Callable[[typing_extensions.Self, DBusObjectProxy, DBusProxy, GLib.Variant, list], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-proxy-signal"],
        handler: typing.Callable[[typing_extensions.Self, DBusObjectProxy, DBusProxy, str, str, GLib.Variant], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::bus_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::get_proxy_type_destroy_notify"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::get_proxy_type_func"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::get_proxy_type_user_data"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name_owner"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusObjectManagerClientClass(GObject.GPointer):
    # gi Fields
    interface_proxy_properties_changed: interface_proxy_properties_changedDBusObjectManagerClientClassCB = ...
    interface_proxy_signal: interface_proxy_signalDBusObjectManagerClientClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusObjectManagerClientPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusObjectManagerIface(GObject.GPointer):
    # gi Fields
    get_interface: get_interfaceDBusObjectManagerIfaceCB | None = ...
    get_object: get_objectDBusObjectManagerIfaceCB | None = ...
    get_object_path: get_object_pathDBusObjectManagerIfaceCB = ...
    get_objects: get_objectsDBusObjectManagerIfaceCB = ...
    interface_added: interface_addedDBusObjectManagerIfaceCB = ...
    interface_removed: interface_removedDBusObjectManagerIfaceCB = ...
    object_added: object_addedDBusObjectManagerIfaceCB = ...
    object_removed: object_removedDBusObjectManagerIfaceCB = ...
    parent_iface: GObject.TypeInterface | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusObjectManagerServer(GObject.Object):
    """
    `GDBusObjectManagerServer` is used to export [iface@Gio.DBusObject] instances
    using the standardized
    [`org.freedesktop.DBus.ObjectManager`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
    interface. For example, remote D-Bus clients can get all objects
    and properties in a single call. Additionally, any change in the
    object hierarchy is broadcast using signals. This means that D-Bus
    clients can keep caches up to date by only listening to D-Bus
    signals.

    The recommended path to export an object manager at is the path form of the
    well-known name of a D-Bus service, or below. For example, if a D-Bus service
    is available at the well-known name `net.example.ExampleService1`, the object
    manager should typically be exported at `/net/example/ExampleService1`, or
    below (to allow for multiple object managers in a service).

    It is supported, but not recommended, to export an object manager at the root
    path, `/`.

    See [class@Gio.DBusObjectManagerClient] for the client-side code that is
    intended to be used with `GDBusObjectManagerServer` or any D-Bus
    object implementing the `org.freedesktop.DBus.ObjectManager` interface.
    """

    class Props(GObject.Object.Props):
        connection: DBusConnection | None
        object_path: str  # [object-path]: changed because contained invalid characters

    # gi Methods
    def __init__(self, connection: DBusConnection | None = ..., object_path: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def export(self, object: DBusObjectSkeleton) -> None: ...
    def export_uniquely(self, object: DBusObjectSkeleton) -> None: ...
    @property
    def get_connection(self) -> DBusConnection | None: ...
    def is_exported(self, object: DBusObjectSkeleton) -> bool: ...
    @classmethod
    def new(cls, object_path: str) -> DBusObjectManagerServer: ...
    def set_connection(self, connection: DBusConnection | None = None) -> None: ...
    def unexport(self, object_path: str) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusObjectManagerServerClass(GObject.GPointer):
    # gi Fields
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusObjectManagerServerPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusObjectProxy(GObject.Object):
    """
    A `GDBusObjectProxy` is an object used to represent a remote object
    with one or more D-Bus interfaces. Normally, you don’t instantiate
    a `GDBusObjectProxy` yourself — typically [class@Gio.DBusObjectManagerClient]
    is used to obtain it.
    """

    class Props(GObject.Object.Props):
        g_connection: DBusConnection | None  # [g-connection]: changed because contained invalid characters
        g_object_path: str  # [g-object-path]: changed because contained invalid characters

    # gi Methods
    def __init__(self, g_connection: DBusConnection | None = ..., g_object_path: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_connection(self) -> DBusConnection: ...
    @classmethod
    def new(cls, connection: DBusConnection, object_path: str) -> DBusObjectProxy: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusObjectProxyClass(GObject.GPointer):
    # gi Fields
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusObjectProxyPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusObjectSkeleton(GObject.Object):
    """
    A `GDBusObjectSkeleton` instance is essentially a group of D-Bus
    interfaces. The set of exported interfaces on the object may be
    dynamic and change at runtime.

    This type is intended to be used with [iface@Gio.DBusObjectManager].
    """

    class Props(GObject.Object.Props):
        g_object_path: str  # [g-object-path]: changed because contained invalid characters

    # gi Methods
    def __init__(self, g_object_path: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_interface(self, interface_: DBusInterfaceSkeleton) -> None: ...
    def flush(self) -> None: ...
    @classmethod
    def new(cls, object_path: str) -> DBusObjectSkeleton: ...
    def remove_interface(self, interface_: DBusInterfaceSkeleton) -> None: ...
    def remove_interface_by_name(self, interface_name: str) -> None: ...
    def set_object_path(self, object_path: str) -> None: ...

    # python methods
    def do_authorize_method(
        self,
        interface_: DBusInterfaceSkeleton,
        invocation: DBusMethodInvocation,
    ) -> bool:
        """
        authorize_method(self, interface_:Gio.DBusInterfaceSkeleton, invocation:Gio.DBusMethodInvocation) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["authorize-method"],
        handler: typing.Callable[[typing_extensions.Self, DBusInterfaceSkeleton, DBusMethodInvocation], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusObjectSkeletonClass(GObject.GPointer):
    # gi Fields
    authorize_method: authorize_methodDBusObjectSkeletonClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusObjectSkeletonPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusPropertyInfo(GObject.GBoxed):
    # gi Fields
    annotations: list | None = ...
    flags: DBusPropertyInfoFlags = ...
    name: str = ...
    ref_count: int = ...
    signature: str = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def ref(self) -> DBusPropertyInfo: ...
    def unref(self) -> None: ...

    ...

class DBusProxy(GObject.Object):
    """
    `GDBusProxy` is a base class used for proxies to access a D-Bus
    interface on a remote object. A `GDBusProxy` can be constructed for
    both well-known and unique names.

    By default, `GDBusProxy` will cache all properties (and listen to
    changes) of the remote object, and proxy all signals that get
    emitted. This behaviour can be changed by passing suitable
    [flags@Gio.DBusProxyFlags] when the proxy is created. If the proxy is for a
    well-known name, the property cache is flushed when the name owner
    vanishes and reloaded when a name owner appears.

    The unique name owner of the proxy’s name is tracked and can be read from
    [property@Gio.DBusProxy:g-name-owner]. Connect to the
    [signal@GObject.Object::notify] signal to get notified of changes.
    Additionally, only signals and property changes emitted from the current name
    owner are considered and calls are always sent to the current name owner.
    This avoids a number of race conditions when the name is lost by one owner
    and claimed by another. However, if no name owner currently exists,
    then calls will be sent to the well-known name which may result in
    the message bus launching an owner (unless
    `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` is set).

    If the proxy is for a stateless D-Bus service, where the name owner may
    be started and stopped between calls, the
    [property@Gio.DBusProxy:g-name-owner] tracking of `GDBusProxy` will cause the
    proxy to drop signal and property changes from the service after it has
    restarted for the first time. When interacting with a stateless D-Bus
    service, do not use `GDBusProxy` — use direct D-Bus method calls and signal
    connections.

    The generic [signal@Gio.DBusProxy::g-properties-changed] and
    [signal@Gio.DBusProxy::g-signal] signals are not very convenient to work
    with. Therefore, the recommended way of working with proxies is to subclass
    `GDBusProxy`, and have more natural properties and signals in your derived
    class. This [example](migrating-gdbus.html#using-gdbus-codegen) shows how
    this can easily be done using the [`gdbus-codegen`](gdbus-codegen.html) tool.

    A `GDBusProxy` instance can be used from multiple threads but note
    that all signals (e.g. [signal@Gio.DBusProxy::g-signal],
    [signal@Gio.DBusProxy::g-properties-changed] and
    [signal@GObject.Object::notify]) are emitted in the thread-default main
    context (see [method@GLib.MainContext.push_thread_default]) of the thread
    where the instance was constructed.


    ## A watch proxy example
    An example using a proxy for a well-known name can be found in
    [`gdbus-example-watch-proxy.c`](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c).
    """

    class Props(GObject.Object.Props):
        g_bus_type: BusType  # [g-bus-type]: changed because contained invalid characters
        g_connection: DBusConnection | None  # [g-connection]: changed because contained invalid characters
        g_default_timeout: int  # [g-default-timeout]: changed because contained invalid characters
        g_flags: DBusProxyFlags  # [g-flags]: changed because contained invalid characters
        g_interface_info: DBusInterfaceInfo | None  # [g-interface-info]: changed because contained invalid characters
        g_interface_name: str  # [g-interface-name]: changed because contained invalid characters
        g_name: str  # [g-name]: changed because contained invalid characters
        g_name_owner: str  # [g-name-owner]: changed because contained invalid characters
        g_object_path: str  # [g-object-path]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        g_bus_type: BusType = ...,
        g_connection: DBusConnection | None = ...,
        g_default_timeout: int = ...,
        g_flags: DBusProxyFlags = ...,
        g_interface_info: DBusInterfaceInfo | None = ...,
        g_interface_name: str = ...,
        g_name: str = ...,
        g_object_path: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    async def call(
        self,
        method_name: str,
        parameters: GLib.Variant | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def call_finish(self, res: AsyncResult) -> GLib.Variant: ...
    def call_sync(
        self,
        method_name: str,
        parameters: GLib.Variant | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
    ) -> GLib.Variant: ...
    async def call_with_unix_fd_list(
        self,
        method_name: str,
        parameters: GLib.Variant | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        fd_list: UnixFDList | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def call_with_unix_fd_list_finish(self, res: AsyncResult) -> tuple[GLib.Variant, UnixFDList | None]: ...
    def call_with_unix_fd_list_sync(
        self,
        method_name: str,
        parameters: GLib.Variant | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        fd_list: UnixFDList | None = None,
        cancellable: Cancellable | None = None,
    ) -> tuple[GLib.Variant, UnixFDList | None]: ...
    def get_cached_property(self, property_name: str) -> GLib.Variant | None: ...
    def get_cached_property_names(self) -> list | None: ...
    def get_connection(self) -> DBusConnection: ...
    def get_default_timeout(self) -> int: ...
    def get_flags(self) -> DBusProxyFlags: ...
    def get_interface_info(self) -> DBusInterfaceInfo | None: ...
    def get_interface_name(self) -> str: ...
    def get_name(self) -> str | None: ...
    def get_name_owner(self) -> str | None: ...
    def get_object_path(self) -> str: ...
    @staticmethod
    async def new(
        connection: DBusConnection,
        flags: DBusProxyFlags,
        info: DBusInterfaceInfo | None,
        name: str | None,
        object_path: str,
        interface_name: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @classmethod
    def new_finish(cls, res: AsyncResult) -> DBusProxy: ...
    @staticmethod
    async def new_for_bus(
        bus_type: BusType,
        flags: DBusProxyFlags,
        info: DBusInterfaceInfo | None,
        name: str,
        object_path: str,
        interface_name: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @classmethod
    def new_for_bus_finish(cls, res: AsyncResult) -> DBusProxy: ...
    @classmethod
    def new_for_bus_sync(
        cls,
        bus_type: BusType,
        flags: DBusProxyFlags,
        info: DBusInterfaceInfo | None,
        name: str,
        object_path: str,
        interface_name: str,
        cancellable: Cancellable | None = None,
    ) -> DBusProxy: ...
    @classmethod
    def new_sync(
        cls,
        connection: DBusConnection,
        flags: DBusProxyFlags,
        info: DBusInterfaceInfo | None,
        name: str | None,
        object_path: str,
        interface_name: str,
        cancellable: Cancellable | None = None,
    ) -> DBusProxy: ...
    def set_cached_property(self, property_name: str, value: GLib.Variant | None = None) -> None: ...
    def set_default_timeout(self, timeout_msec: int) -> None: ...
    def set_interface_info(self, info: DBusInterfaceInfo | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["g-properties-changed"],
        handler: typing.Callable[[typing_extensions.Self, GLib.Variant, list], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["g-signal"],
        handler: typing.Callable[[typing_extensions.Self, str | None, str, GLib.Variant], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_bus_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_default_timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_interface_info"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_interface_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_name_owner"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusProxyClass(GObject.GPointer):
    # gi Fields
    g_properties_changed: g_properties_changedDBusProxyClassCB = ...
    g_signal: g_signalDBusProxyClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusProxyPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DBusServer(GObject.Object):
    """
    `GDBusServer` is a helper for listening to and accepting D-Bus
    connections. This can be used to create a new D-Bus server, allowing two
    peers to use the D-Bus protocol for their own specialized communication.
    A server instance provided in this way will not perform message routing or
    implement the
    [`org.freedesktop.DBus` interface](https://dbus.freedesktop.org/doc/dbus-specification.html#message-bus-messages).

    To just export an object on a well-known name on a message bus, such as the
    session or system bus, you should instead use [func@Gio.bus_own_name].

    An example of peer-to-peer communication with GDBus can be found
    in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).

    Note that a minimal `GDBusServer` will accept connections from any
    peer. In many use-cases it will be necessary to add a
    [class@Gio.DBusAuthObserver] that only accepts connections that have
    successfully authenticated as the same user that is running the
    `GDBusServer`. Since GLib 2.68 this can be achieved more simply by passing
    the `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag to the
    server.
    """

    class Props(GObject.Object.Props):
        active: bool
        address: str
        authentication_observer: (
            DBusAuthObserver | None
        )  # [authentication-observer]: changed because contained invalid characters
        client_address: str  # [client-address]: changed because contained invalid characters
        flags: DBusServerFlags
        guid: str

    # gi Methods
    def __init__(
        self,
        address: str = ...,
        authentication_observer: DBusAuthObserver | None = ...,
        flags: DBusServerFlags = ...,
        guid: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_client_address(self) -> str: ...
    @property
    def get_flags(self) -> DBusServerFlags: ...
    @property
    def get_guid(self) -> str: ...
    @property
    def is_active(self) -> bool: ...
    @classmethod
    def new_sync(
        cls,
        address: str,
        flags: DBusServerFlags,
        guid: str,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
    ) -> DBusServer: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["new-connection"],
        handler: typing.Callable[[typing_extensions.Self, DBusConnection], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::authentication_observer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::client_address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::guid"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DBusSignalInfo(GObject.GBoxed):
    # gi Methods
    def ref(self) -> DBusSignalInfo: ...
    def unref(self) -> None: ...

    # python methods
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class DBusSubtreeVTable(GObject.GPointer):
    # gi Fields
    dispatch: DBusSubtreeDispatchFuncDBusSubtreeVTableCB | None = ...
    enumerate: DBusSubtreeEnumerateFuncDBusSubtreeVTableCB = ...
    introspect: DBusSubtreeIntrospectFuncDBusSubtreeVTableCB | None = ...
    padding: list | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DataInputStream(BufferedInputStream):
    """
    Data input stream implements [class@Gio.InputStream] and includes functions
    for reading structured data directly from a binary input stream.
    """

    class Props(BufferedInputStream.Props):
        byte_order: DataStreamByteOrder  # [byte-order]: changed because contained invalid characters
        newline_type: DataStreamNewlineType  # [newline-type]: changed because contained invalid characters

    # gi Methods
    def __init__(self, byte_order: DataStreamByteOrder = ..., newline_type: DataStreamNewlineType = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_byte_order(self) -> DataStreamByteOrder: ...
    @property
    def get_newline_type(self) -> DataStreamNewlineType: ...
    @classmethod
    def new(cls, base_stream: InputStream) -> DataInputStream: ...
    def read_byte(self, cancellable: Cancellable | None = None) -> int: ...
    def read_int16(self, cancellable: Cancellable | None = None) -> int: ...
    def read_int32(self, cancellable: Cancellable | None = None) -> int: ...
    def read_int64(self, cancellable: Cancellable | None = None) -> int: ...
    def read_line(self, cancellable: Cancellable | None = None) -> tuple[list | None, int | None]: ...
    async def read_line_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def read_line_finish(self, result: AsyncResult) -> tuple[list | None, int | None]: ...
    def read_line_finish_utf8(self, result: AsyncResult) -> tuple[str | None, int | None]: ...
    def read_line_utf8(self, cancellable: Cancellable | None = None) -> tuple[str | None, int | None]: ...
    def read_uint16(self, cancellable: Cancellable | None = None) -> int: ...
    def read_uint32(self, cancellable: Cancellable | None = None) -> int: ...
    def read_uint64(self, cancellable: Cancellable | None = None) -> int: ...
    @deprecated("deprecated")
    def read_until(self, stop_chars: str, cancellable: Cancellable | None = None) -> tuple[str, int | None]: ...
    @deprecated("deprecated")
    async def read_until_async(
        self,
        stop_chars: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def read_until_finish(self, result: AsyncResult) -> tuple[str, int | None]: ...
    def read_upto(
        self, stop_chars: str, stop_chars_len: int, cancellable: Cancellable | None = None
    ) -> tuple[str, int | None]: ...
    async def read_upto_async(
        self,
        stop_chars: str,
        stop_chars_len: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def read_upto_finish(self, result: AsyncResult) -> tuple[str, int | None]: ...
    def set_byte_order(self, order: DataStreamByteOrder) -> None: ...
    def set_newline_type(self, type: DataStreamNewlineType) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::byte_order"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::newline_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DataInputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: BufferedInputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DataInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DataOutputStream(FilterOutputStream):
    """
    Data output stream implements [class@Gio.OutputStream] and includes functions
    for writing data directly to an output stream.
    """

    class Props(FilterOutputStream.Props):
        byte_order: DataStreamByteOrder  # [byte-order]: changed because contained invalid characters

    # gi Methods
    def __init__(self, byte_order: DataStreamByteOrder = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_byte_order(self) -> DataStreamByteOrder: ...
    @classmethod
    def new(cls, base_stream: OutputStream) -> DataOutputStream: ...
    def put_byte(self, data: int, cancellable: Cancellable | None = None) -> bool: ...
    def put_int16(self, data: int, cancellable: Cancellable | None = None) -> bool: ...
    def put_int32(self, data: int, cancellable: Cancellable | None = None) -> bool: ...
    def put_int64(self, data: int, cancellable: Cancellable | None = None) -> bool: ...
    def put_string(self, str: str, cancellable: Cancellable | None = None) -> bool: ...
    def put_uint16(self, data: int, cancellable: Cancellable | None = None) -> bool: ...
    def put_uint32(self, data: int, cancellable: Cancellable | None = None) -> bool: ...
    def put_uint64(self, data: int, cancellable: Cancellable | None = None) -> bool: ...
    def set_byte_order(self, order: DataStreamByteOrder) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::byte_order"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DataOutputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: FilterOutputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DataOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DatagramBased(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def condition_check(self, condition: GLib.IOCondition) -> GLib.IOCondition: ...
    def condition_wait(
        self, condition: GLib.IOCondition, timeout: int, cancellable: Cancellable | None = None
    ) -> bool: ...
    def create_source(self, condition: GLib.IOCondition, cancellable: Cancellable | None = None) -> GLib.Source: ...
    def receive_messages(
        self, messages: list, num_messages: int, flags: int, timeout: int, cancellable: Cancellable | None = None
    ) -> int: ...
    def send_messages(
        self, messages: list, num_messages: int, flags: int, timeout: int, cancellable: Cancellable | None = None
    ) -> int: ...

    ...

class DatagramBasedInterface(GObject.GPointer):
    # gi Fields
    condition_check: condition_checkDatagramBasedInterfaceCB = ...
    condition_wait: condition_waitDatagramBasedInterfaceCB = ...
    create_source: create_sourceDatagramBasedInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    receive_messages: receive_messagesDatagramBasedInterfaceCB = ...
    send_messages: send_messagesDatagramBasedInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DebugController(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        debug_enabled: bool  # [debug-enabled]: changed because contained invalid characters

    # gi Methods
    def __init__(self, debug_enabled: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_debug_enabled(self) -> bool: ...
    def set_debug_enabled(self, debug_enabled: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::debug_enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DebugControllerDBus(GObject.Object):
    """
    `GDebugControllerDBus` is an implementation of [iface@Gio.DebugController]
    which exposes debug settings as a D-Bus object.

    It is a [iface@Gio.Initable] object, and will register an object at
    `/org/gtk/Debugging` on the bus given as
    [property@Gio.DebugControllerDBus:connection] once it’s initialized. The
    object will be unregistered when the last reference to the
    `GDebugControllerDBus` is dropped.

    This D-Bus object can be used by remote processes to enable or disable debug
    output in this process. Remote processes calling
    `org.gtk.Debugging.SetDebugEnabled()` will affect the value of
    [property@Gio.DebugController:debug-enabled] and, by default,
    [func@GLib.log_get_debug_enabled].

    By default, no processes are allowed to call `SetDebugEnabled()` unless a
    [signal@Gio.DebugControllerDBus::authorize] signal handler is installed. This
    is because the process may be privileged, or might expose sensitive
    information in its debug output. You may want to restrict the ability to
    enable debug output to privileged users or processes.

    One option is to install a D-Bus security policy which restricts access to
    `SetDebugEnabled()`, installing something like the following in
    `$datadir/dbus-1/system.d/`:

    ```xml
    <?xml version="1.0"?> <!--*-nxml-*-->
    <!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
         "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
    <busconfig>
      <policy user="root">
        <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
      </policy>
      <policy context="default">
        <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
      </policy>
    </busconfig>
    ```

    This will prevent the `SetDebugEnabled()` method from being called by all
    except root. It will not prevent the `DebugEnabled` property from being read,
    as it’s accessed through the `org.freedesktop.DBus.Properties` interface.

    Another option is to use polkit to allow or deny requests on a case-by-case
    basis, allowing for the possibility of dynamic authorisation. To do this,
    connect to the [signal@Gio.DebugControllerDBus::authorize] signal and query
    polkit in it:

    ```c
      g_autoptr(GError) child_error = NULL;
      g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
      gulong debug_controller_authorize_id = 0;

      // Set up the debug controller.
      debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, NULL, &child_error));
      if (debug_controller == NULL)
        {
          g_error ("Could not register debug controller on bus: %s",
                   child_error->message);
        }

      debug_controller_authorize_id = g_signal_connect (debug_controller,
                                                        "authorize",
                                                        G_CALLBACK (debug_controller_authorize_cb),
                                                        self);

      static gboolean
      debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
                                     GDBusMethodInvocation *invocation,
                                     gpointer               user_data)
      {
        g_autoptr(PolkitAuthority) authority = NULL;
        g_autoptr(PolkitSubject) subject = NULL;
        g_autoptr(PolkitAuthorizationResult) auth_result = NULL;
        g_autoptr(GError) local_error = NULL;
        GDBusMessage *message;
        GDBusMessageFlags message_flags;
        PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;

        message = g_dbus_method_invocation_get_message (invocation);
        message_flags = g_dbus_message_get_flags (message);

        authority = polkit_authority_get_sync (NULL, &local_error);
        if (authority == NULL)
          {
            g_warning ("Failed to get polkit authority: %s", local_error->message);
            return FALSE;
          }

        if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
          flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;

        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));

        auth_result = polkit_authority_check_authorization_sync (authority,
                                                                 subject,
                                                                 "com.example.MyService.set-debug-enabled",
                                                                 NULL,
                                                                 flags,
                                                                 NULL,
                                                                 &local_error);
        if (auth_result == NULL)
          {
            g_warning ("Failed to get check polkit authorization: %s", local_error->message);
            return FALSE;
          }

        return polkit_authorization_result_get_is_authorized (auth_result);
      }
    ```
    """

    class Props(GObject.Object.Props):
        connection: DBusConnection | None

    # gi Methods
    def __init__(self, connection: DBusConnection | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, connection: DBusConnection, cancellable: Cancellable | None = None) -> DebugControllerDBus | None: ...
    def stop(self) -> None: ...

    # python methods
    def do_authorize(
        self,
        invocation: DBusMethodInvocation,
    ) -> bool:
        """
        authorize(self, invocation:Gio.DBusMethodInvocation) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["authorize"],
        handler: typing.Callable[[typing_extensions.Self, DBusMethodInvocation], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DebugControllerDBusClass(GObject.GPointer):
    # gi Fields
    authorize: authorizeDebugControllerDBusClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DebugControllerInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DesktopAppInfo(GObject.Object):
    """
    `GDesktopAppInfo` is an implementation of [iface@Gio.AppInfo] based on
    desktop files.

    Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific
    GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
    file or the `GioUnix-2.0` GIR namespace when using it.
    """

    class Props(GObject.Object.Props):
        filename: str

    # gi Methods
    def __init__(self, filename: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_action_name(self, action_name: str) -> str: ...
    def get_boolean(self, key: str) -> bool: ...
    def get_categories(self) -> str | None: ...
    @property
    def get_filename(self) -> str | None: ...
    def get_generic_name(self) -> str | None: ...
    @staticmethod
    def get_implementations(interface: str) -> list: ...
    def get_is_hidden(self) -> bool: ...
    def get_keywords(self) -> list: ...
    def get_locale_string(self, key: str) -> str | None: ...
    def get_nodisplay(self) -> bool: ...
    def get_show_in(self, desktop_env: str | None = None) -> bool: ...
    def get_startup_wm_class(self) -> str | None: ...
    def get_string(self, key: str) -> str | None: ...
    def get_string_list(self, key: str) -> tuple[list, int | None]: ...
    def has_key(self, key: str) -> bool: ...
    def launch_action(self, action_name: str, launch_context: AppLaunchContext | None = None) -> None: ...
    def launch_uris_as_manager(
        self,
        uris: list,
        launch_context: AppLaunchContext | None,
        spawn_flags: GLib.SpawnFlags,
        user_setup: GLib.SpawnChildSetupFunc | None = None,
        user_setup_data: object | None = None,
        pid_callback: DesktopAppLaunchCallback | None = None,
        pid_callback_data: object | None = None,
    ) -> bool: ...
    def launch_uris_as_manager_with_fds(
        self,
        uris: list,
        launch_context: AppLaunchContext | None,
        spawn_flags: GLib.SpawnFlags,
        user_setup: GLib.SpawnChildSetupFunc | None,
        user_setup_data: object | None,
        pid_callback: DesktopAppLaunchCallback | None,
        pid_callback_data: object | None,
        stdin_fd: int,
        stdout_fd: int,
        stderr_fd: int,
    ) -> bool: ...
    def list_actions(self) -> list: ...
    @classmethod
    def new(cls, desktop_id: str) -> DesktopAppInfo | None: ...
    @classmethod
    def new_from_filename(cls, filename: str) -> DesktopAppInfo | None: ...
    @classmethod
    def new_from_keyfile(cls, key_file: GLib.KeyFile) -> DesktopAppInfo | None: ...
    @staticmethod
    def search(search_string: str) -> list: ...
    @deprecated("deprecated")
    @staticmethod
    def set_desktop_env(desktop_env: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::filename"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DesktopAppInfoClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DesktopAppInfoLookup(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def get_default_for_uri_scheme(self, uri_scheme: str) -> AppInfo | None: ...

    ...

class DesktopAppInfoLookupIface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_default_for_uri_scheme: get_default_for_uri_schemeDesktopAppInfoLookupIfaceCB | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Drive(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_eject(self) -> bool: ...
    def can_poll_for_media(self) -> bool: ...
    def can_start(self) -> bool: ...
    def can_start_degraded(self) -> bool: ...
    def can_stop(self) -> bool: ...
    @deprecated("deprecated")
    async def eject(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def eject_finish(self, result: AsyncResult) -> bool: ...
    async def eject_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def eject_with_operation_finish(self, result: AsyncResult) -> bool: ...
    def enumerate_identifiers(self) -> list: ...
    def get_icon(self) -> Icon: ...
    def get_identifier(self, kind: str) -> str | None: ...
    def get_name(self) -> str: ...
    def get_sort_key(self) -> str | None: ...
    def get_start_stop_type(self) -> DriveStartStopType: ...
    def get_symbolic_icon(self) -> Icon: ...
    def get_volumes(self) -> list: ...
    def has_media(self) -> bool: ...
    def has_volumes(self) -> bool: ...
    def is_media_check_automatic(self) -> bool: ...
    def is_media_removable(self) -> bool: ...
    def is_removable(self) -> bool: ...
    async def poll_for_media(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def poll_for_media_finish(self, result: AsyncResult) -> bool: ...
    async def start(
        self,
        flags: DriveStartFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def start_finish(self, result: AsyncResult) -> bool: ...
    async def stop(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def stop_finish(self, result: AsyncResult) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["disconnected"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["eject-button"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["stop-button"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DriveIface(GObject.GPointer):
    # gi Fields
    can_eject: can_ejectDriveIfaceCB = ...
    can_poll_for_media: can_poll_for_mediaDriveIfaceCB = ...
    can_start: can_startDriveIfaceCB = ...
    can_start_degraded: can_start_degradedDriveIfaceCB = ...
    can_stop: can_stopDriveIfaceCB = ...
    changed: changedDriveIfaceCB = ...
    disconnected: disconnectedDriveIfaceCB = ...
    eject: ejectDriveIfaceCB = ...
    eject_button: eject_buttonDriveIfaceCB = ...
    eject_finish: eject_finishDriveIfaceCB = ...
    eject_with_operation: eject_with_operationDriveIfaceCB = ...
    eject_with_operation_finish: eject_with_operation_finishDriveIfaceCB = ...
    enumerate_identifiers: enumerate_identifiersDriveIfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_icon: get_iconDriveIfaceCB = ...
    get_identifier: get_identifierDriveIfaceCB | None = ...
    get_name: get_nameDriveIfaceCB = ...
    get_sort_key: get_sort_keyDriveIfaceCB | None = ...
    get_start_stop_type: get_start_stop_typeDriveIfaceCB = ...
    get_symbolic_icon: get_symbolic_iconDriveIfaceCB = ...
    get_volumes: get_volumesDriveIfaceCB = ...
    has_media: has_mediaDriveIfaceCB = ...
    has_volumes: has_volumesDriveIfaceCB = ...
    is_media_check_automatic: is_media_check_automaticDriveIfaceCB = ...
    is_media_removable: is_media_removableDriveIfaceCB = ...
    is_removable: is_removableDriveIfaceCB = ...
    poll_for_media: poll_for_mediaDriveIfaceCB = ...
    poll_for_media_finish: poll_for_media_finishDriveIfaceCB = ...
    start: startDriveIfaceCB = ...
    start_finish: start_finishDriveIfaceCB = ...
    stop: stopDriveIfaceCB = ...
    stop_button: stop_buttonDriveIfaceCB = ...
    stop_finish: stop_finishDriveIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DtlsClientConnection(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        accepted_cas: list | None  # [accepted-cas]: changed because contained invalid characters
        server_identity: SocketConnectable | None  # [server-identity]: changed because contained invalid characters
        validation_flags: TlsCertificateFlags  # [validation-flags]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self, server_identity: SocketConnectable | None = ..., validation_flags: TlsCertificateFlags = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_accepted_cas(self) -> list: ...
    @property
    def get_server_identity(self) -> SocketConnectable: ...
    @deprecated("deprecated")
    @property
    def get_validation_flags(self) -> TlsCertificateFlags: ...
    @staticmethod
    def new(base_socket: DatagramBased, server_identity: SocketConnectable | None = None) -> DtlsClientConnection: ...
    def set_server_identity(self, identity: SocketConnectable) -> None: ...
    @deprecated("deprecated")
    def set_validation_flags(self, flags: TlsCertificateFlags) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accepted_cas"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::server_identity"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::validation_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DtlsClientConnectionInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DtlsConnection(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        advertised_protocols: list | None  # [advertised-protocols]: changed because contained invalid characters
        base_socket: DatagramBased | None  # [base-socket]: changed because contained invalid characters
        certificate: TlsCertificate | None
        ciphersuite_name: str  # [ciphersuite-name]: changed because contained invalid characters
        database: TlsDatabase | None
        interaction: TlsInteraction | None
        negotiated_protocol: str  # [negotiated-protocol]: changed because contained invalid characters
        peer_certificate: TlsCertificate | None  # [peer-certificate]: changed because contained invalid characters
        peer_certificate_errors: (
            TlsCertificateFlags  # [peer-certificate-errors]: changed because contained invalid characters
        )
        protocol_version: TlsProtocolVersion  # [protocol-version]: changed because contained invalid characters
        rehandshake_mode: TlsRehandshakeMode  # [rehandshake-mode]: changed because contained invalid characters
        require_close_notify: bool  # [require-close-notify]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        advertised_protocols: list | None = ...,
        base_socket: DatagramBased | None = ...,
        certificate: TlsCertificate | None = ...,
        database: TlsDatabase | None = ...,
        interaction: TlsInteraction | None = ...,
        rehandshake_mode: TlsRehandshakeMode = ...,
        require_close_notify: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def close(self, cancellable: Cancellable | None = None) -> bool: ...
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def close_finish(self, result: AsyncResult) -> bool: ...
    def emit_accept_certificate(self, peer_cert: TlsCertificate, errors: TlsCertificateFlags) -> bool: ...
    @property
    def get_certificate(self) -> TlsCertificate | None: ...
    def get_channel_binding_data(self, type: TlsChannelBindingType) -> tuple[bool, list | None]: ...
    @property
    def get_ciphersuite_name(self) -> str | None: ...
    @property
    def get_database(self) -> TlsDatabase | None: ...
    @property
    def get_interaction(self) -> TlsInteraction | None: ...
    @property
    def get_negotiated_protocol(self) -> str | None: ...
    @property
    def get_peer_certificate(self) -> TlsCertificate | None: ...
    @property
    def get_peer_certificate_errors(self) -> TlsCertificateFlags: ...
    @property
    def get_protocol_version(self) -> TlsProtocolVersion: ...
    @deprecated("deprecated")
    @property
    def get_rehandshake_mode(self) -> TlsRehandshakeMode: ...
    @property
    def get_require_close_notify(self) -> bool: ...
    def handshake(self, cancellable: Cancellable | None = None) -> bool: ...
    async def handshake_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def handshake_finish(self, result: AsyncResult) -> bool: ...
    def set_advertised_protocols(self, protocols: list | None = None) -> None: ...
    def set_certificate(self, certificate: TlsCertificate) -> None: ...
    def set_database(self, database: TlsDatabase | None = None) -> None: ...
    def set_interaction(self, interaction: TlsInteraction | None = None) -> None: ...
    @deprecated("deprecated")
    def set_rehandshake_mode(self, mode: TlsRehandshakeMode) -> None: ...
    def set_require_close_notify(self, require_close_notify: bool) -> None: ...
    def shutdown(self, shutdown_read: bool, shutdown_write: bool, cancellable: Cancellable | None = None) -> bool: ...
    async def shutdown_async(
        self,
        shutdown_read: bool,
        shutdown_write: bool,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def shutdown_finish(self, result: AsyncResult) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["accept-certificate"],
        handler: typing.Callable[[typing_extensions.Self, TlsCertificate, TlsCertificateFlags], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::advertised_protocols"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_socket"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ciphersuite_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::database"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::interaction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::negotiated_protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::peer_certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::peer_certificate_errors"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::protocol_version"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rehandshake_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::require_close_notify"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DtlsConnectionInterface(GObject.GPointer):
    # gi Fields
    accept_certificate: accept_certificateDtlsConnectionInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_binding_data: get_binding_dataDtlsConnectionInterfaceCB = ...
    get_negotiated_protocol: get_negotiated_protocolDtlsConnectionInterfaceCB | None = ...
    handshake: handshakeDtlsConnectionInterfaceCB = ...
    handshake_async: handshake_asyncDtlsConnectionInterfaceCB = ...
    handshake_finish: handshake_finishDtlsConnectionInterfaceCB = ...
    set_advertised_protocols: set_advertised_protocolsDtlsConnectionInterfaceCB = ...
    shutdown: shutdownDtlsConnectionInterfaceCB = ...
    shutdown_async: shutdown_asyncDtlsConnectionInterfaceCB = ...
    shutdown_finish: shutdown_finishDtlsConnectionInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class DtlsServerConnection(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        authentication_mode: (
            TlsAuthenticationMode  # [authentication-mode]: changed because contained invalid characters
        )

    # gi Methods
    def __init__(self, authentication_mode: TlsAuthenticationMode = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def new(base_socket: DatagramBased, certificate: TlsCertificate | None = None) -> DtlsServerConnection: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::authentication_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class DtlsServerConnectionInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Emblem(GObject.Object):
    """
    `GEmblem` is an implementation of [iface@Gio.Icon] that supports
    having an emblem, which is an icon with additional properties.
    It can than be added to a [class@Gio.EmblemedIcon].

    Currently, only metainformation about the emblem's origin is
    supported. More may be added in the future.
    """

    class Props(GObject.Object.Props):
        icon: GObject.Object | None
        origin: EmblemOrigin

    # gi Methods
    def __init__(self, icon: GObject.Object | None = ..., origin: EmblemOrigin = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_icon(self) -> Icon: ...
    @property
    def get_origin(self) -> EmblemOrigin: ...
    @classmethod
    def new(cls, icon: Icon) -> Emblem: ...
    @classmethod
    def new_with_origin(cls, icon: Icon, origin: EmblemOrigin) -> Emblem: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::origin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class EmblemClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class EmblemedIcon(GObject.Object):
    """
    `GEmblemedIcon` is an implementation of [iface@Gio.Icon] that supports
    adding an emblem to an icon. Adding multiple emblems to an
    icon is ensured via [method@Gio.EmblemedIcon.add_emblem].

    Note that `GEmblemedIcon` allows no control over the position
    of the emblems. See also [class@Gio.Emblem] for more information.
    """

    class Props(GObject.Object.Props):
        gicon: Icon | None

    # gi Methods
    def __init__(self, gicon: Icon | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_emblem(self, emblem: Emblem) -> None: ...
    def clear_emblems(self) -> None: ...
    def get_emblems(self) -> list: ...
    def get_icon(self) -> Icon: ...
    @classmethod
    def new(cls, icon: Icon, emblem: Emblem | None = None) -> EmblemedIcon: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gicon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class EmblemedIconClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class EmblemedIconPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class File(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append_to(self, flags: FileCreateFlags, cancellable: Cancellable | None = None) -> FileOutputStream: ...
    async def append_to_async(
        self,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def append_to_finish(self, res: AsyncResult) -> FileOutputStream: ...
    def build_attribute_list_for_copy(self, flags: FileCopyFlags, cancellable: Cancellable | None = None) -> str: ...
    def copy(
        self,
        destination: File,
        flags: FileCopyFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        progress_callback_data: object | None = None,
    ) -> bool: ...
    async def copy_async(
        self,
        destination: File,
        flags: FileCopyFlags,
        io_priority: int,
        cancellable: Cancellable | None,
        progress_callback_closure: GObject.Closure | None,
        ready_callback_closure: GObject.Closure,
    ) -> None: ...
    def copy_attributes(
        self, destination: File, flags: FileCopyFlags, cancellable: Cancellable | None = None
    ) -> bool: ...
    def copy_finish(self, res: AsyncResult) -> bool: ...
    def create(self, flags: FileCreateFlags, cancellable: Cancellable | None = None) -> FileOutputStream: ...
    async def create_async(
        self,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def create_finish(self, res: AsyncResult) -> FileOutputStream: ...
    def create_readwrite(self, flags: FileCreateFlags, cancellable: Cancellable | None = None) -> FileIOStream: ...
    async def create_readwrite_async(
        self,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def create_readwrite_finish(self, res: AsyncResult) -> FileIOStream: ...
    def delete(self, cancellable: Cancellable | None = None) -> bool: ...
    async def delete_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def delete_finish(self, result: AsyncResult) -> bool: ...
    def dup(self) -> File: ...
    @deprecated("deprecated")
    async def eject_mountable(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def eject_mountable_finish(self, result: AsyncResult) -> bool: ...
    async def eject_mountable_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def eject_mountable_with_operation_finish(self, result: AsyncResult) -> bool: ...
    def enumerate_children(
        self, attributes: str, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> FileEnumerator: ...
    async def enumerate_children_async(
        self,
        attributes: str,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def enumerate_children_finish(self, res: AsyncResult) -> FileEnumerator: ...
    def equal(self, file2: File) -> bool: ...
    def find_enclosing_mount(self, cancellable: Cancellable | None = None) -> Mount: ...
    async def find_enclosing_mount_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def find_enclosing_mount_finish(self, res: AsyncResult) -> Mount: ...
    def get_basename(self) -> str | None: ...
    def get_child(self, name: str) -> File: ...
    def get_child_for_display_name(self, display_name: str) -> File: ...
    def get_parent(self) -> File | None: ...
    def get_parse_name(self) -> str: ...
    def get_path(self) -> str | None: ...
    def get_relative_path(self, descendant: File) -> str | None: ...
    def get_uri(self) -> str: ...
    def get_uri_scheme(self) -> str | None: ...
    def has_parent(self, parent: File | None = None) -> bool: ...
    def has_prefix(self, prefix: File) -> bool: ...
    def has_uri_scheme(self, uri_scheme: str) -> bool: ...
    def hash(self) -> int: ...
    def is_native(self) -> bool: ...
    def load_bytes(self, cancellable: Cancellable | None = None) -> tuple[GLib.Bytes, str | None]: ...
    async def load_bytes_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def load_bytes_finish(self, result: AsyncResult) -> tuple[GLib.Bytes, str | None]: ...
    def load_contents(self, cancellable: Cancellable | None = None) -> tuple[bool, list, int | None, str | None]: ...
    async def load_contents_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def load_contents_finish(self, res: AsyncResult) -> tuple[bool, list, int | None, str | None]: ...
    def load_partial_contents_finish(self, res: AsyncResult) -> tuple[bool, list, int | None, str | None]: ...
    def make_directory(self, cancellable: Cancellable | None = None) -> bool: ...
    async def make_directory_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def make_directory_finish(self, result: AsyncResult) -> bool: ...
    def make_directory_with_parents(self, cancellable: Cancellable | None = None) -> bool: ...
    def make_symbolic_link(self, symlink_value: str, cancellable: Cancellable | None = None) -> bool: ...
    async def make_symbolic_link_async(
        self,
        symlink_value: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def make_symbolic_link_finish(self, result: AsyncResult) -> bool: ...
    def measure_disk_usage(
        self,
        flags: FileMeasureFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileMeasureProgressCallback | None = None,
        progress_data: object | None = None,
    ) -> tuple[bool, int | None, int | None, int | None]: ...
    def measure_disk_usage_finish(self, result: AsyncResult) -> tuple[bool, int | None, int | None, int | None]: ...
    def monitor(self, flags: FileMonitorFlags, cancellable: Cancellable | None = None) -> FileMonitor: ...
    def monitor_directory(self, flags: FileMonitorFlags, cancellable: Cancellable | None = None) -> FileMonitor: ...
    def monitor_file(self, flags: FileMonitorFlags, cancellable: Cancellable | None = None) -> FileMonitor: ...
    async def mount_enclosing_volume(
        self,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def mount_enclosing_volume_finish(self, result: AsyncResult) -> bool: ...
    async def mount_mountable(
        self,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def mount_mountable_finish(self, result: AsyncResult) -> File: ...
    def move(
        self,
        destination: File,
        flags: FileCopyFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        progress_callback_data: object | None = None,
    ) -> bool: ...
    async def move_async(
        self,
        destination: File,
        flags: FileCopyFlags,
        io_priority: int,
        cancellable: Cancellable | None,
        progress_callback_closure: GObject.Closure | None,
        ready_callback_closure: GObject.Closure,
    ) -> None: ...
    def move_finish(self, result: AsyncResult) -> bool: ...
    @staticmethod
    def new_build_filenamev(args: list) -> File: ...
    @staticmethod
    def new_for_commandline_arg(arg: str) -> File: ...
    @staticmethod
    def new_for_commandline_arg_and_cwd(arg: str, cwd: str) -> File: ...
    @staticmethod
    def new_for_path(path: str) -> File: ...
    @staticmethod
    def new_for_uri(uri: str) -> File: ...
    @staticmethod
    def new_tmp(tmpl: str | None = None) -> tuple[File, FileIOStream]: ...
    @staticmethod
    async def new_tmp_async(
        tmpl: str | None,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @staticmethod
    async def new_tmp_dir_async(
        tmpl: str | None,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @staticmethod
    def new_tmp_dir_finish(result: AsyncResult) -> File: ...
    @staticmethod
    def new_tmp_finish(result: AsyncResult) -> tuple[File, FileIOStream]: ...
    def open_readwrite(self, cancellable: Cancellable | None = None) -> FileIOStream: ...
    async def open_readwrite_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def open_readwrite_finish(self, res: AsyncResult) -> FileIOStream: ...
    @staticmethod
    def parse_name(parse_name: str) -> File: ...
    def peek_path(self) -> str | None: ...
    async def poll_mountable(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def poll_mountable_finish(self, result: AsyncResult) -> bool: ...
    def query_default_handler(self, cancellable: Cancellable | None = None) -> AppInfo: ...
    async def query_default_handler_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def query_default_handler_finish(self, result: AsyncResult) -> AppInfo: ...
    def query_exists(self, cancellable: Cancellable | None = None) -> bool: ...
    def query_file_type(self, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None) -> FileType: ...
    def query_filesystem_info(self, attributes: str, cancellable: Cancellable | None = None) -> FileInfo: ...
    async def query_filesystem_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def query_filesystem_info_finish(self, res: AsyncResult) -> FileInfo: ...
    def query_info(
        self, attributes: str, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> FileInfo: ...
    async def query_info_async(
        self,
        attributes: str,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def query_info_finish(self, res: AsyncResult) -> FileInfo: ...
    def query_settable_attributes(self, cancellable: Cancellable | None = None) -> FileAttributeInfoList: ...
    def query_writable_namespaces(self, cancellable: Cancellable | None = None) -> FileAttributeInfoList: ...
    def read(self, cancellable: Cancellable | None = None) -> FileInputStream: ...
    async def read_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def read_finish(self, res: AsyncResult) -> FileInputStream: ...
    def replace(
        self, etag: str | None, make_backup: bool, flags: FileCreateFlags, cancellable: Cancellable | None = None
    ) -> FileOutputStream: ...
    async def replace_async(
        self,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def replace_contents(
        self,
        contents: list,
        length: int,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> tuple[bool, str | None]: ...
    async def replace_contents_async(
        self,
        contents: list,
        length: int,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def replace_contents_bytes_async(
        self,
        contents: GLib.Bytes,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def replace_contents_finish(self, res: AsyncResult) -> tuple[bool, str | None]: ...
    def replace_finish(self, res: AsyncResult) -> FileOutputStream: ...
    def replace_readwrite(
        self, etag: str | None, make_backup: bool, flags: FileCreateFlags, cancellable: Cancellable | None = None
    ) -> FileIOStream: ...
    async def replace_readwrite_async(
        self,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def replace_readwrite_finish(self, res: AsyncResult) -> FileIOStream: ...
    def resolve_relative_path(self, relative_path: str) -> File: ...
    def set_attribute(
        self,
        attribute: str,
        type: FileAttributeType,
        value_p: object | None,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool: ...
    def set_attribute_byte_string(
        self, attribute: str, value: str, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool: ...
    def set_attribute_int32(
        self, attribute: str, value: int, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool: ...
    def set_attribute_int64(
        self, attribute: str, value: int, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool: ...
    def set_attribute_string(
        self, attribute: str, value: str, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool: ...
    def set_attribute_uint32(
        self, attribute: str, value: int, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool: ...
    def set_attribute_uint64(
        self, attribute: str, value: int, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool: ...
    async def set_attributes_async(
        self,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def set_attributes_finish(self, result: AsyncResult) -> tuple[bool, FileInfo]: ...
    def set_attributes_from_info(
        self, info: FileInfo, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool: ...
    def set_display_name(self, display_name: str, cancellable: Cancellable | None = None) -> File: ...
    async def set_display_name_async(
        self,
        display_name: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def set_display_name_finish(self, res: AsyncResult) -> File: ...
    async def start_mountable(
        self,
        flags: DriveStartFlags,
        start_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def start_mountable_finish(self, result: AsyncResult) -> bool: ...
    async def stop_mountable(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def stop_mountable_finish(self, result: AsyncResult) -> bool: ...
    def supports_thread_contexts(self) -> bool: ...
    def trash(self, cancellable: Cancellable | None = None) -> bool: ...
    async def trash_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def trash_finish(self, result: AsyncResult) -> bool: ...
    @deprecated("deprecated")
    async def unmount_mountable(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def unmount_mountable_finish(self, result: AsyncResult) -> bool: ...
    async def unmount_mountable_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def unmount_mountable_with_operation_finish(self, result: AsyncResult) -> bool: ...

    ...

class FileAttributeInfo(GObject.GPointer):
    # gi Fields
    flags: FileAttributeInfoFlags = ...
    name: str = ...
    type: FileAttributeType = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileAttributeInfoList(GObject.GBoxed):
    # gi Fields
    infos: FileAttributeInfo | None = ...
    n_infos: int = ...
    # gi Methods
    def add(self, name: str, type: FileAttributeType, flags: FileAttributeInfoFlags) -> None: ...
    def dup(self) -> FileAttributeInfoList: ...
    def lookup(self, name: str) -> FileAttributeInfo: ...
    @classmethod
    def new(cls) -> FileAttributeInfoList: ...
    def ref(self) -> FileAttributeInfoList: ...
    def unref(self) -> None: ...

    # python methods
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class FileAttributeMatcher(GObject.GBoxed):
    # gi Methods
    def enumerate_namespace(self, ns: str) -> bool: ...
    def enumerate_next(self) -> str | None: ...
    def matches(self, attribute: str) -> bool: ...
    def matches_only(self, attribute: str) -> bool: ...
    @classmethod
    def new(cls, attributes: str) -> FileAttributeMatcher: ...
    def ref(self) -> FileAttributeMatcher: ...
    def subtract(self, subtract: FileAttributeMatcher | None = None) -> FileAttributeMatcher | None: ...
    def to_string(self) -> str: ...
    def unref(self) -> None: ...

    # python methods
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class FileDescriptorBased(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_fd(self) -> int: ...

    ...

class FileDescriptorBasedIface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_fd: get_fdFileDescriptorBasedIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileEnumerator(GObject.Object):
    """
    `GFileEnumerator` allows you to operate on a set of [iface@Gio.File] objects,
    returning a [class@Gio.FileInfo] structure for each file enumerated (e.g.
    [method@Gio.File.enumerate_children] will return a `GFileEnumerator` for each
    of the children within a directory).

    To get the next file's information from a `GFileEnumerator`, use
    [method@Gio.FileEnumerator.next_file] or its asynchronous version,
    [method@Gio.FileEnumerator.next_files_async]. Note that the asynchronous
    version will return a list of [class@Gio.FileInfo] objects, whereas the
    synchronous will only return the next file in the enumerator.

    The ordering of returned files is unspecified for non-Unix
    platforms; for more information, see [method@GLib.Dir.read_name].  On Unix,
    when operating on local files, returned files will be sorted by
    inode number.  Effectively you can assume that the ordering of
    returned files will be stable between successive calls (and
    applications) assuming the directory is unchanged.

    If your application needs a specific ordering, such as by name or
    modification time, you will have to implement that in your
    application code.

    To close a `GFileEnumerator`, use [method@Gio.FileEnumerator.close], or
    its asynchronous version, [method@Gio.FileEnumerator.close_async]. Once
    a `GFileEnumerator` is closed, no further actions may be performed
    on it, and it should be freed with [method@GObject.Object.unref].
    """

    class Props(GObject.Object.Props):
        container: File | None

    # gi Methods
    def __init__(self, container: File | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def close(self, cancellable: Cancellable | None = None) -> bool: ...
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def close_finish(self, result: AsyncResult) -> bool: ...
    def get_child(self, info: FileInfo) -> File: ...
    def get_container(self) -> File: ...
    def has_pending(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def iterate(self, cancellable: Cancellable | None = None) -> tuple[bool, FileInfo | None, File | None]: ...
    def next_file(self, cancellable: Cancellable | None = None) -> FileInfo | None: ...
    async def next_files_async(
        self,
        num_files: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def next_files_finish(self, result: AsyncResult) -> list: ...
    def set_pending(self, pending: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::container"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class FileEnumeratorClass(GObject.GPointer):
    # gi Fields
    close_async: close_asyncFileEnumeratorClassCB = ...
    close_finish: close_finishFileEnumeratorClassCB = ...
    close_fn: close_fnFileEnumeratorClassCB = ...
    next_file: next_fileFileEnumeratorClassCB | None = ...
    next_files_async: next_files_asyncFileEnumeratorClassCB = ...
    next_files_finish: next_files_finishFileEnumeratorClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileEnumeratorPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileIOStream(IOStream):
    """
    `GFileIOStream` provides I/O streams that both read and write to the same
    file handle.

    `GFileIOStream` implements [iface@Gio.Seekable], which allows the I/O
    stream to jump to arbitrary positions in the file and to truncate
    the file, provided the filesystem of the file supports these
    operations.

    To find the position of a file I/O stream, use [method@Gio.Seekable.tell].

    To find out if a file I/O stream supports seeking, use
    [method@Gio.Seekable.can_seek]. To position a file I/O stream, use
    [method@Gio.Seekable.seek]. To find out if a file I/O stream supports
    truncating, use [method@Gio.Seekable.can_truncate]. To truncate a file I/O
    stream, use [method@Gio.Seekable.truncate].

    The default implementation of all the `GFileIOStream` operations
    and the implementation of [iface@Gio.Seekable] just call into the same
    operations on the output stream.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_etag(self) -> str | None: ...
    def query_info(self, attributes: str, cancellable: Cancellable | None = None) -> FileInfo: ...
    async def query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def query_info_finish(self, result: AsyncResult) -> FileInfo: ...

    # python methods
    def do_can_seek(
        self,
    ) -> bool:
        """
        can_seek(self) -> bool
        """
    def do_can_truncate(
        self,
    ) -> bool:
        """
        can_truncate(self) -> bool
        """
    def do_get_etag(
        self,
    ) -> str | None:
        """
        get_etag(self) -> str or None
        """
    def do_query_info(
        self,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo:
        """
        query_info(self, attributes:str, cancellable:Gio.Cancellable=None) -> Gio.FileInfo
        """
    def do_query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        query_info_async(self, attributes:str, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_query_info_finish(
        self,
        result: AsyncResult,
    ) -> FileInfo:
        """
        query_info_finish(self, result:Gio.AsyncResult) -> Gio.FileInfo
        """
    def do_seek(
        self,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        seek(self, offset:int, type:GLib.SeekType, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_tell(
        self,
    ) -> int:
        """
        tell(self) -> int
        """
    def do_truncate_fn(
        self,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        truncate_fn(self, size:int, cancellable:Gio.Cancellable=None) -> bool
        """

    ...

class FileIOStreamClass(GObject.GPointer):
    # gi Fields
    can_seek: can_seekFileIOStreamClassCB = ...
    can_truncate: can_truncateFileIOStreamClassCB = ...
    get_etag: get_etagFileIOStreamClassCB | None = ...
    parent_class: IOStreamClass | None = ...
    query_info: query_infoFileIOStreamClassCB = ...
    query_info_async: query_info_asyncFileIOStreamClassCB = ...
    query_info_finish: query_info_finishFileIOStreamClassCB = ...
    seek: seekFileIOStreamClassCB = ...
    tell: tellFileIOStreamClassCB = ...
    truncate_fn: truncate_fnFileIOStreamClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileIOStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileIcon(GObject.Object):
    """
    `GFileIcon` specifies an icon by pointing to an image file
    to be used as icon.

    It implements [iface@Gio.LoadableIcon].
    """

    class Props(GObject.Object.Props):
        file: File | None

    # gi Methods
    def __init__(self, file: File | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_file(self) -> File: ...
    @classmethod
    def new(cls, file: File) -> FileIcon: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class FileIconClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileIface(GObject.GPointer):
    # gi Fields
    append_to: append_toFileIfaceCB = ...
    append_to_async: append_to_asyncFileIfaceCB = ...
    append_to_finish: append_to_finishFileIfaceCB = ...
    copy: copyFileIfaceCB = ...
    copy_async: copy_asyncFileIfaceCB = ...
    copy_finish: copy_finishFileIfaceCB = ...
    create: createFileIfaceCB = ...
    create_async: create_asyncFileIfaceCB = ...
    create_finish: create_finishFileIfaceCB = ...
    create_readwrite: create_readwriteFileIfaceCB = ...
    create_readwrite_async: create_readwrite_asyncFileIfaceCB = ...
    create_readwrite_finish: create_readwrite_finishFileIfaceCB = ...
    delete_file: delete_fileFileIfaceCB = ...
    delete_file_async: delete_file_asyncFileIfaceCB = ...
    delete_file_finish: delete_file_finishFileIfaceCB = ...
    dup: dupFileIfaceCB = ...
    eject_mountable: eject_mountableFileIfaceCB = ...
    eject_mountable_finish: eject_mountable_finishFileIfaceCB = ...
    eject_mountable_with_operation: eject_mountable_with_operationFileIfaceCB = ...
    eject_mountable_with_operation_finish: eject_mountable_with_operation_finishFileIfaceCB = ...
    enumerate_children: enumerate_childrenFileIfaceCB = ...
    enumerate_children_async: enumerate_children_asyncFileIfaceCB = ...
    enumerate_children_finish: enumerate_children_finishFileIfaceCB = ...
    equal: equalFileIfaceCB = ...
    find_enclosing_mount: find_enclosing_mountFileIfaceCB = ...
    find_enclosing_mount_async: find_enclosing_mount_asyncFileIfaceCB = ...
    find_enclosing_mount_finish: find_enclosing_mount_finishFileIfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_basename: get_basenameFileIfaceCB | None = ...
    get_child_for_display_name: get_child_for_display_nameFileIfaceCB = ...
    get_parent: get_parentFileIfaceCB | None = ...
    get_parse_name: get_parse_nameFileIfaceCB = ...
    get_path: get_pathFileIfaceCB | None = ...
    get_relative_path: get_relative_pathFileIfaceCB | None = ...
    get_uri: get_uriFileIfaceCB = ...
    get_uri_scheme: get_uri_schemeFileIfaceCB | None = ...
    has_uri_scheme: has_uri_schemeFileIfaceCB = ...
    hash: hashFileIfaceCB = ...
    is_native: is_nativeFileIfaceCB = ...
    make_directory: make_directoryFileIfaceCB = ...
    make_directory_async: make_directory_asyncFileIfaceCB = ...
    make_directory_finish: make_directory_finishFileIfaceCB = ...
    make_symbolic_link: make_symbolic_linkFileIfaceCB = ...
    make_symbolic_link_async: make_symbolic_link_asyncFileIfaceCB = ...
    make_symbolic_link_finish: make_symbolic_link_finishFileIfaceCB = ...
    measure_disk_usage: measure_disk_usageFileIfaceCB = ...
    measure_disk_usage_finish: measure_disk_usage_finishFileIfaceCB = ...
    monitor_dir: monitor_dirFileIfaceCB = ...
    monitor_file: monitor_fileFileIfaceCB = ...
    mount_enclosing_volume: mount_enclosing_volumeFileIfaceCB = ...
    mount_enclosing_volume_finish: mount_enclosing_volume_finishFileIfaceCB = ...
    mount_mountable: mount_mountableFileIfaceCB = ...
    mount_mountable_finish: mount_mountable_finishFileIfaceCB = ...
    move: moveFileIfaceCB = ...
    move_async: move_asyncFileIfaceCB = ...
    move_finish: move_finishFileIfaceCB = ...
    open_readwrite: open_readwriteFileIfaceCB = ...
    open_readwrite_async: open_readwrite_asyncFileIfaceCB = ...
    open_readwrite_finish: open_readwrite_finishFileIfaceCB = ...
    poll_mountable: poll_mountableFileIfaceCB = ...
    poll_mountable_finish: poll_mountable_finishFileIfaceCB = ...
    prefix_matches: prefix_matchesFileIfaceCB = ...
    query_exists: query_existsFileIfaceCB = ...
    query_filesystem_info: query_filesystem_infoFileIfaceCB = ...
    query_filesystem_info_async: query_filesystem_info_asyncFileIfaceCB = ...
    query_filesystem_info_finish: query_filesystem_info_finishFileIfaceCB = ...
    query_info: query_infoFileIfaceCB = ...
    query_info_async: query_info_asyncFileIfaceCB = ...
    query_info_finish: query_info_finishFileIfaceCB = ...
    query_settable_attributes: query_settable_attributesFileIfaceCB = ...
    query_writable_namespaces: query_writable_namespacesFileIfaceCB = ...
    read_async: read_asyncFileIfaceCB = ...
    read_finish: read_finishFileIfaceCB = ...
    read_fn: read_fnFileIfaceCB = ...
    replace: replaceFileIfaceCB = ...
    replace_async: replace_asyncFileIfaceCB = ...
    replace_finish: replace_finishFileIfaceCB = ...
    replace_readwrite: replace_readwriteFileIfaceCB = ...
    replace_readwrite_async: replace_readwrite_asyncFileIfaceCB = ...
    replace_readwrite_finish: replace_readwrite_finishFileIfaceCB = ...
    resolve_relative_path: resolve_relative_pathFileIfaceCB = ...
    set_attribute: set_attributeFileIfaceCB = ...
    set_attributes_async: set_attributes_asyncFileIfaceCB = ...
    set_attributes_finish: set_attributes_finishFileIfaceCB = ...
    set_attributes_from_info: set_attributes_from_infoFileIfaceCB = ...
    set_display_name: set_display_nameFileIfaceCB = ...
    set_display_name_async: set_display_name_asyncFileIfaceCB = ...
    set_display_name_finish: set_display_name_finishFileIfaceCB = ...
    start_mountable: start_mountableFileIfaceCB = ...
    start_mountable_finish: start_mountable_finishFileIfaceCB = ...
    stop_mountable: stop_mountableFileIfaceCB = ...
    stop_mountable_finish: stop_mountable_finishFileIfaceCB = ...
    supports_thread_contexts: bool = ...
    trash: trashFileIfaceCB = ...
    trash_async: trash_asyncFileIfaceCB = ...
    trash_finish: trash_finishFileIfaceCB = ...
    unmount_mountable: unmount_mountableFileIfaceCB = ...
    unmount_mountable_finish: unmount_mountable_finishFileIfaceCB = ...
    unmount_mountable_with_operation: unmount_mountable_with_operationFileIfaceCB = ...
    unmount_mountable_with_operation_finish: unmount_mountable_with_operation_finishFileIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileInfo(GObject.Object):
    """
    Stores information about a file system object referenced by a [iface@Gio.File].

    Functionality for manipulating basic metadata for files. `GFileInfo`
    implements methods for getting information that all files should
    contain, and allows for manipulation of extended attributes.

    See the [file attributes](file-attributes.html) document for more
    information on how GIO handles file attributes.

    To obtain a `GFileInfo` for a [iface@Gio.File], use
    [method@Gio.File.query_info] (or its async variant). To obtain a `GFileInfo`
    for a file input or output stream, use [method@Gio.FileInputStream.query_info]
    or [method@Gio.FileOutputStream.query_info] (or their async variants).

    To change the actual attributes of a file, you should then set the
    attribute in the `GFileInfo` and call [method@Gio.File.set_attributes_from_info]
    or [method@Gio.File.set_attributes_async] on a `GFile`.

    However, not all attributes can be changed in the file. For instance,
    the actual size of a file cannot be changed via [method@Gio.FileInfo.set_size].
    You may call [method@Gio.File.query_settable_attributes] and
    [method@Gio.File.query_writable_namespaces] to discover the settable attributes
    of a particular file at runtime.

    The direct accessors, such as [method@Gio.FileInfo.get_name], are slightly more
    optimized than the generic attribute accessors, such as
    [method@Gio.FileInfo.get_attribute_byte_string].This optimization will matter
    only if calling the API in a tight loop.

    It is an error to call these accessors without specifying their required file
    attributes when creating the `GFileInfo`. Use
    [method@Gio.FileInfo.has_attribute] or [method@Gio.FileInfo.list_attributes]
    to check what attributes are specified for a `GFileInfo`.

    [struct@Gio.FileAttributeMatcher] allows for searching through a `GFileInfo`
    for attributes.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear_status(self) -> None: ...
    def copy_into(self, dest_info: FileInfo) -> None: ...
    def dup(self) -> FileInfo: ...
    def get_access_date_time(self) -> GLib.DateTime | None: ...
    def get_attribute_as_string(self, attribute: str) -> str | None: ...
    def get_attribute_boolean(self, attribute: str) -> bool: ...
    def get_attribute_byte_string(self, attribute: str) -> str | None: ...
    def get_attribute_data(
        self, attribute: str
    ) -> tuple[bool, FileAttributeType | None, object | None, FileAttributeStatus | None]: ...
    def get_attribute_file_path(self, attribute: str) -> str | None: ...
    def get_attribute_int32(self, attribute: str) -> int: ...
    def get_attribute_int64(self, attribute: str) -> int: ...
    def get_attribute_object(self, attribute: str) -> GObject.Object | None: ...
    def get_attribute_status(self, attribute: str) -> FileAttributeStatus: ...
    def get_attribute_string(self, attribute: str) -> str | None: ...
    def get_attribute_stringv(self, attribute: str) -> list | None: ...
    def get_attribute_type(self, attribute: str) -> FileAttributeType: ...
    def get_attribute_uint32(self, attribute: str) -> int: ...
    def get_attribute_uint64(self, attribute: str) -> int: ...
    def get_content_type(self) -> str | None: ...
    def get_creation_date_time(self) -> GLib.DateTime | None: ...
    def get_deletion_date(self) -> GLib.DateTime | None: ...
    def get_display_name(self) -> str: ...
    def get_edit_name(self) -> str: ...
    def get_etag(self) -> str | None: ...
    def get_file_type(self) -> FileType: ...
    def get_icon(self) -> Icon | None: ...
    def get_is_backup(self) -> bool: ...
    def get_is_hidden(self) -> bool: ...
    def get_is_symlink(self) -> bool: ...
    def get_modification_date_time(self) -> GLib.DateTime | None: ...
    @deprecated("deprecated")
    def get_modification_time(self) -> GLib.TimeVal: ...
    def get_name(self) -> str: ...
    def get_size(self) -> int: ...
    def get_sort_order(self) -> int: ...
    def get_symbolic_icon(self) -> Icon | None: ...
    def get_symlink_target(self) -> str | None: ...
    def has_attribute(self, attribute: str) -> bool: ...
    def has_namespace(self, name_space: str) -> bool: ...
    def list_attributes(self, name_space: str | None = None) -> list | None: ...
    @classmethod
    def new(cls) -> FileInfo: ...
    def remove_attribute(self, attribute: str) -> None: ...
    def set_access_date_time(self, atime: GLib.DateTime) -> None: ...
    def set_attribute(self, attribute: str, type: FileAttributeType, value_p: object) -> None: ...
    def set_attribute_boolean(self, attribute: str, attr_value: bool) -> None: ...
    def set_attribute_byte_string(self, attribute: str, attr_value: str) -> None: ...
    def set_attribute_file_path(self, attribute: str, attr_value: str) -> None: ...
    def set_attribute_int32(self, attribute: str, attr_value: int) -> None: ...
    def set_attribute_int64(self, attribute: str, attr_value: int) -> None: ...
    def set_attribute_mask(self, mask: FileAttributeMatcher) -> None: ...
    def set_attribute_object(self, attribute: str, attr_value: GObject.Object) -> None: ...
    def set_attribute_status(self, attribute: str, status: FileAttributeStatus) -> bool: ...
    def set_attribute_string(self, attribute: str, attr_value: str) -> None: ...
    def set_attribute_stringv(self, attribute: str, attr_value: list) -> None: ...
    def set_attribute_uint32(self, attribute: str, attr_value: int) -> None: ...
    def set_attribute_uint64(self, attribute: str, attr_value: int) -> None: ...
    def set_content_type(self, content_type: str) -> None: ...
    def set_creation_date_time(self, creation_time: GLib.DateTime) -> None: ...
    def set_display_name(self, display_name: str) -> None: ...
    def set_edit_name(self, edit_name: str) -> None: ...
    def set_file_type(self, type: FileType) -> None: ...
    def set_icon(self, icon: Icon) -> None: ...
    def set_is_hidden(self, is_hidden: bool) -> None: ...
    def set_is_symlink(self, is_symlink: bool) -> None: ...
    def set_modification_date_time(self, mtime: GLib.DateTime) -> None: ...
    @deprecated("deprecated")
    def set_modification_time(self, mtime: GLib.TimeVal) -> None: ...
    def set_name(self, name: str) -> None: ...
    def set_size(self, size: int) -> None: ...
    def set_sort_order(self, sort_order: int) -> None: ...
    def set_symbolic_icon(self, icon: Icon) -> None: ...
    def set_symlink_target(self, symlink_target: str) -> None: ...
    def unset_attribute_mask(self) -> None: ...

    ...

class FileInfoClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileInputStream(InputStream):
    """
    `GFileInputStream` provides input streams that take their
    content from a file.

    `GFileInputStream` implements [iface@Gio.Seekable], which allows the input
    stream to jump to arbitrary positions in the file, provided the
    filesystem of the file allows it. To find the position of a file
    input stream, use [method@Gio.Seekable.tell]. To find out if a file input
    stream supports seeking, use [vfunc@Gio.Seekable.can_seek].
    To position a file input stream, use [vfunc@Gio.Seekable.seek].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def query_info(self, attributes: str, cancellable: Cancellable | None = None) -> FileInfo: ...
    async def query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def query_info_finish(self, result: AsyncResult) -> FileInfo: ...

    # python methods
    def do_can_seek(
        self,
    ) -> bool:
        """
        can_seek(self) -> bool
        """
    def do_query_info(
        self,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo:
        """
        query_info(self, attributes:str, cancellable:Gio.Cancellable=None) -> Gio.FileInfo
        """
    def do_query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        query_info_async(self, attributes:str, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_query_info_finish(
        self,
        result: AsyncResult,
    ) -> FileInfo:
        """
        query_info_finish(self, result:Gio.AsyncResult) -> Gio.FileInfo
        """
    def do_seek(
        self,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        seek(self, offset:int, type:GLib.SeekType, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_tell(
        self,
    ) -> int:
        """
        tell(self) -> int
        """

    ...

class FileInputStreamClass(GObject.GPointer):
    # gi Fields
    can_seek: can_seekFileInputStreamClassCB = ...
    parent_class: InputStreamClass | None = ...
    query_info: query_infoFileInputStreamClassCB = ...
    query_info_async: query_info_asyncFileInputStreamClassCB = ...
    query_info_finish: query_info_finishFileInputStreamClassCB = ...
    seek: seekFileInputStreamClassCB = ...
    tell: tellFileInputStreamClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileMonitor(GObject.Object):
    """
    Monitors a file or directory for changes.

    To obtain a `GFileMonitor` for a file or directory, use
    [method@Gio.File.monitor], [method@Gio.File.monitor_file], or
    [method@Gio.File.monitor_directory].

    To get informed about changes to the file or directory you are
    monitoring, connect to the [signal@Gio.FileMonitor::changed] signal. The
    signal will be emitted in the thread-default main context (see
    [method@GLib.MainContext.push_thread_default]) of the thread that the monitor
    was created in (though if the global default main context is blocked, this
    may cause notifications to be blocked even if the thread-default
    context is still running).
    """

    class Props(GObject.Object.Props):
        cancelled: bool
        rate_limit: int  # [rate-limit]: changed because contained invalid characters

    # gi Methods
    def __init__(self, rate_limit: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def cancel(self) -> bool: ...
    def emit_event(self, child: File, other_file: File, event_type: FileMonitorEvent) -> None: ...
    @property
    def is_cancelled(self) -> bool: ...
    def set_rate_limit(self, limit_msecs: int) -> None: ...

    # python methods
    def do_cancel(
        self,
    ) -> bool:
        """
        cancel(self) -> bool
        """
    def do_changed(
        self,
        file: File,
        other_file: File,
        event_type: FileMonitorEvent,
    ) -> None:
        """
        changed(self, file:Gio.File, other_file:Gio.File, event_type:Gio.FileMonitorEvent)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["changed"],
        handler: typing.Callable[[typing_extensions.Self, File, File | None, FileMonitorEvent], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cancelled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rate_limit"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class FileMonitorClass(GObject.GPointer):
    # gi Fields
    cancel: cancelFileMonitorClassCB = ...
    changed: changedFileMonitorClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileMonitorPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileOutputStream(OutputStream):
    """
    `GFileOutputStream` provides output streams that write their
    content to a file.

    `GFileOutputStream` implements [iface@Gio.Seekable], which allows the output
    stream to jump to arbitrary positions in the file and to truncate
    the file, provided the filesystem of the file supports these
    operations.

    To find the position of a file output stream, use [method@Gio.Seekable.tell].
    To find out if a file output stream supports seeking, use
    [method@Gio.Seekable.can_seek].To position a file output stream, use
    [method@Gio.Seekable.seek]. To find out if a file output stream supports
    truncating, use [method@Gio.Seekable.can_truncate]. To truncate a file output
    stream, use [method@Gio.Seekable.truncate].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_etag(self) -> str | None: ...
    def query_info(self, attributes: str, cancellable: Cancellable | None = None) -> FileInfo: ...
    async def query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def query_info_finish(self, result: AsyncResult) -> FileInfo: ...

    # python methods
    def do_can_seek(
        self,
    ) -> bool:
        """
        can_seek(self) -> bool
        """
    def do_can_truncate(
        self,
    ) -> bool:
        """
        can_truncate(self) -> bool
        """
    def do_get_etag(
        self,
    ) -> str | None:
        """
        get_etag(self) -> str or None
        """
    def do_query_info(
        self,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo:
        """
        query_info(self, attributes:str, cancellable:Gio.Cancellable=None) -> Gio.FileInfo
        """
    def do_query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        query_info_async(self, attributes:str, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_query_info_finish(
        self,
        result: AsyncResult,
    ) -> FileInfo:
        """
        query_info_finish(self, result:Gio.AsyncResult) -> Gio.FileInfo
        """
    def do_seek(
        self,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        seek(self, offset:int, type:GLib.SeekType, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_tell(
        self,
    ) -> int:
        """
        tell(self) -> int
        """
    def do_truncate_fn(
        self,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        truncate_fn(self, size:int, cancellable:Gio.Cancellable=None) -> bool
        """

    ...

class FileOutputStreamClass(GObject.GPointer):
    # gi Fields
    can_seek: can_seekFileOutputStreamClassCB = ...
    can_truncate: can_truncateFileOutputStreamClassCB = ...
    get_etag: get_etagFileOutputStreamClassCB | None = ...
    parent_class: OutputStreamClass | None = ...
    query_info: query_infoFileOutputStreamClassCB = ...
    query_info_async: query_info_asyncFileOutputStreamClassCB = ...
    query_info_finish: query_info_finishFileOutputStreamClassCB = ...
    seek: seekFileOutputStreamClassCB = ...
    tell: tellFileOutputStreamClassCB = ...
    truncate_fn: truncate_fnFileOutputStreamClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FileOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FilenameCompleter(GObject.Object):
    """
    Completes partial file and directory names given a partial string by
    looking in the file system for clues. Can return a list of possible
    completion strings for widget implementations.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_completion_suffix(self, initial_text: str) -> str | None: ...
    def get_completions(self, initial_text: str) -> list: ...
    @classmethod
    def new(cls) -> FilenameCompleter: ...
    def set_dirs_only(self, dirs_only: bool) -> None: ...

    # python methods
    def do_got_completion_data(
        self,
    ) -> None:
        """
        got_completion_data(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["got-completion-data"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class FilenameCompleterClass(GObject.GPointer):
    # gi Fields
    got_completion_data: got_completion_dataFilenameCompleterClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FilterInputStream(InputStream):
    """
    Base class for input stream implementations that perform some
    kind of filtering operation on a base stream. Typical examples
    of filtering operations are character set conversion, compression
    and byte order flipping.
    """

    class Props(InputStream.Props):
        base_stream: InputStream | None  # [base-stream]: changed because contained invalid characters
        close_base_stream: bool  # [close-base-stream]: changed because contained invalid characters

    # gi Fields
    base_stream: InputStream | None = ...
    # gi Methods
    def __init__(self, base_stream: InputStream | None = ..., close_base_stream: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_base_stream(self) -> InputStream: ...
    @property
    def get_close_base_stream(self) -> bool: ...
    def set_close_base_stream(self, close_base: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::close_base_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class FilterInputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: InputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class FilterOutputStream(OutputStream):
    """
    Base class for output stream implementations that perform some
    kind of filtering operation on a base stream. Typical examples
    of filtering operations are character set conversion, compression
    and byte order flipping.
    """

    class Props(OutputStream.Props):
        base_stream: OutputStream | None  # [base-stream]: changed because contained invalid characters
        close_base_stream: bool  # [close-base-stream]: changed because contained invalid characters

    # gi Fields
    base_stream: OutputStream | None = ...
    # gi Methods
    def __init__(self, base_stream: OutputStream | None = ..., close_base_stream: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_base_stream(self) -> OutputStream: ...
    @property
    def get_close_base_stream(self) -> bool: ...
    def set_close_base_stream(self, close_base: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::close_base_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class FilterOutputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: OutputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class IOExtension(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_name(self) -> str: ...
    def get_priority(self) -> int: ...
    def get_type(self) -> GObject.GType: ...

    ...

class IOExtensionPoint(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_extension_by_name(self, name: str) -> IOExtension: ...
    def get_extensions(self) -> list: ...
    def get_required_type(self) -> GObject.GType: ...
    @staticmethod
    def implement(
        extension_point_name: str, type: GObject.GType, extension_name: str, priority: int
    ) -> IOExtension: ...
    @staticmethod
    def lookup(name: str) -> IOExtensionPoint: ...
    @staticmethod
    def register(name: str) -> IOExtensionPoint: ...
    def set_required_type(self, type: GObject.GType) -> None: ...

    ...

class IOModule(GObject.TypeModule):
    """
    Provides an interface and default functions for loading and unloading
    modules. This is used internally to make GIO extensible, but can also
    be used by others to implement module loading.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, filename: str) -> IOModule: ...
    @staticmethod
    def query() -> list: ...

    ...

class IOModuleClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class IOModuleScope(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def block(self, basename: str) -> None: ...
    def free(self) -> None: ...

    ...

class IOSchedulerJob(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def send_to_mainloop(
        self, func: GLib.SourceFunc, user_data: object | None = None, notify: GLib.DestroyNotify | None = None
    ) -> bool: ...
    @deprecated("deprecated")
    def send_to_mainloop_async(
        self, func: GLib.SourceFunc, user_data: object | None = None, notify: GLib.DestroyNotify | None = None
    ) -> None: ...

    ...

class IOStream(GObject.Object):
    """
    `GIOStream` represents an object that has both read and write streams.
    Generally the two streams act as separate input and output streams,
    but they share some common resources and state. For instance, for
    seekable streams, both streams may use the same position.

    Examples of `GIOStream` objects are [class@Gio.SocketConnection], which represents
    a two-way network connection; and [class@Gio.FileIOStream], which represents a
    file handle opened in read-write mode.

    To do the actual reading and writing you need to get the substreams
    with [method@Gio.IOStream.get_input_stream] and
    [method@Gio.IOStream.get_output_stream].

    The `GIOStream` object owns the input and the output streams, not the other
    way around, so keeping the substreams alive will not keep the `GIOStream`
    object alive. If the `GIOStream` object is freed it will be closed, thus
    closing the substreams, so even if the substreams stay alive they will
    always return `G_IO_ERROR_CLOSED` for all operations.

    To close a stream use [method@Gio.IOStream.close] which will close the common
    stream object and also the individual substreams. You can also close
    the substreams themselves. In most cases this only marks the
    substream as closed, so further I/O on it fails but common state in the
    `GIOStream` may still be open. However, some streams may support
    ‘half-closed’ states where one direction of the stream is actually shut down.

    Operations on `GIOStream`s cannot be started while another operation on the
    `GIOStream` or its substreams is in progress. Specifically, an application can
    read from the [class@Gio.InputStream] and write to the
    [class@Gio.OutputStream] simultaneously (either in separate threads, or as
    asynchronous operations in the same thread), but an application cannot start
    any `GIOStream` operation while there is a `GIOStream`, `GInputStream` or
    `GOutputStream` operation in progress, and an application can’t start any
    `GInputStream` or `GOutputStream` operation while there is a `GIOStream`
    operation in progress.

    This is a product of individual stream operations being associated with a
    given [type@GLib.MainContext] (the thread-default context at the time the
    operation was started), rather than entire streams being associated with a
    single `GMainContext`.

    GIO may run operations on `GIOStream`s from other (worker) threads, and this
    may be exposed to application code in the behaviour of wrapper streams, such
    as [class@Gio.BufferedInputStream] or [class@Gio.TlsConnection]. With such
    wrapper APIs, application code may only run operations on the base (wrapped)
    stream when the wrapper stream is idle. Note that the semantics of such
    operations may not be well-defined due to the state the wrapper stream leaves
    the base stream in (though they are guaranteed not to crash).
    """

    class Props(GObject.Object.Props):
        closed: bool
        input_stream: InputStream | None  # [input-stream]: changed because contained invalid characters
        output_stream: OutputStream | None  # [output-stream]: changed because contained invalid characters

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear_pending(self) -> None: ...
    def close(self, cancellable: Cancellable | None = None) -> bool: ...
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def close_finish(self, result: AsyncResult) -> bool: ...
    @property
    def get_input_stream(self) -> InputStream: ...
    @property
    def get_output_stream(self) -> OutputStream: ...
    def has_pending(self) -> bool: ...
    @property
    def is_closed(self) -> bool: ...
    def set_pending(self) -> bool: ...
    def splice_async(
        self,
        stream2: IOStream,
        flags: IOStreamSpliceFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @staticmethod
    def splice_finish(result: AsyncResult) -> bool: ...

    # python methods
    def do_close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        close_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_close_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        close_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_close_fn(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        close_fn(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_get_input_stream(
        self,
    ) -> InputStream:
        """
        get_input_stream(self) -> Gio.InputStream
        """
    def do_get_output_stream(
        self,
    ) -> OutputStream:
        """
        get_output_stream(self) -> Gio.OutputStream
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::closed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::output_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class IOStreamAdapter(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class IOStreamClass(GObject.GPointer):
    # gi Fields
    close_async: close_asyncIOStreamClassCB = ...
    close_finish: close_finishIOStreamClassCB = ...
    close_fn: close_fnIOStreamClassCB = ...
    get_input_stream: get_input_streamIOStreamClassCB = ...
    get_output_stream: get_output_streamIOStreamClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class IOStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Icon(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def deserialize(value: GLib.Variant) -> Icon | None: ...
    def equal(self, icon2: Icon | None = None) -> bool: ...
    def hash(self) -> int: ...
    @staticmethod
    def new_for_string(str: str) -> Icon: ...
    def serialize(self) -> GLib.Variant | None: ...
    def to_string(self) -> str | None: ...

    ...

class IconIface(GObject.GPointer):
    # gi Fields
    equal: equalIconIfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    hash: hashIconIfaceCB = ...
    serialize: serializeIconIfaceCB | None = ...
    to_tokens: to_tokensIconIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InetAddress(GObject.Object):
    """
    `GInetAddress` represents an IPv4 or IPv6 internet address. Use
    [method@Gio.Resolver.lookup_by_name] or
    [method@Gio.Resolver.lookup_by_name_async] to look up the `GInetAddress` for
    a hostname. Use [method@Gio.Resolver.lookup_by_address] or
    [method@Gio.Resolver.lookup_by_address_async] to look up the hostname for a
    `GInetAddress`.

    To actually connect to a remote host, you will need a
    [class@Gio.InetSocketAddress] (which includes a `GInetAddress` as well as a
    port number).
    """

    class Props(GObject.Object.Props):
        bytes: object | None
        family: SocketFamily
        is_any: bool  # [is-any]: changed because contained invalid characters
        is_link_local: bool  # [is-link-local]: changed because contained invalid characters
        is_loopback: bool  # [is-loopback]: changed because contained invalid characters
        is_mc_global: bool  # [is-mc-global]: changed because contained invalid characters
        is_mc_link_local: bool  # [is-mc-link-local]: changed because contained invalid characters
        is_mc_node_local: bool  # [is-mc-node-local]: changed because contained invalid characters
        is_mc_org_local: bool  # [is-mc-org-local]: changed because contained invalid characters
        is_mc_site_local: bool  # [is-mc-site-local]: changed because contained invalid characters
        is_multicast: bool  # [is-multicast]: changed because contained invalid characters
        is_site_local: bool  # [is-site-local]: changed because contained invalid characters

    # gi Methods
    def __init__(self, bytes: object | None = ..., family: SocketFamily = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def equal(self, other_address: InetAddress) -> bool: ...
    @property
    def get_family(self) -> SocketFamily: ...
    @property
    def get_is_any(self) -> bool: ...
    @property
    def get_is_link_local(self) -> bool: ...
    @property
    def get_is_loopback(self) -> bool: ...
    @property
    def get_is_mc_global(self) -> bool: ...
    @property
    def get_is_mc_link_local(self) -> bool: ...
    @property
    def get_is_mc_node_local(self) -> bool: ...
    @property
    def get_is_mc_org_local(self) -> bool: ...
    @property
    def get_is_mc_site_local(self) -> bool: ...
    @property
    def get_is_multicast(self) -> bool: ...
    @property
    def get_is_site_local(self) -> bool: ...
    def get_native_size(self) -> int: ...
    @classmethod
    def new_any(cls, family: SocketFamily) -> InetAddress: ...
    @classmethod
    def new_from_bytes(cls, bytes: list, family: SocketFamily) -> InetAddress: ...
    @classmethod
    def new_from_string(cls, string: str) -> InetAddress | None: ...
    @classmethod
    def new_loopback(cls, family: SocketFamily) -> InetAddress: ...
    def to_string(self) -> str: ...

    # python methods
    def do_to_string(
        self,
    ) -> str:
        """
        to_string(self) -> str
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_any"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_link_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_loopback"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_global"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_link_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_node_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_org_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_site_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_multicast"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_site_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class InetAddressClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    to_bytes: to_bytesInetAddressClassCB = ...
    to_string: to_stringInetAddressClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InetAddressMask(GObject.Object):
    """
    `GInetAddressMask` represents a range of IPv4 or IPv6 addresses
    described by a base address and a length indicating how many bits
    of the base address are relevant for matching purposes. These are
    often given in string form. For example, `10.0.0.0/8`, or `fe80::/10`.
    """

    class Props(GObject.Object.Props):
        address: InetAddress | None
        family: SocketFamily
        length: int

    # gi Methods
    def __init__(self, address: InetAddress | None = ..., length: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def equal(self, mask2: InetAddressMask) -> bool: ...
    @property
    def get_address(self) -> InetAddress: ...
    @property
    def get_family(self) -> SocketFamily: ...
    @property
    def get_length(self) -> int: ...
    def matches(self, address: InetAddress) -> bool: ...
    @classmethod
    def new(cls, addr: InetAddress, length: int) -> InetAddressMask: ...
    @classmethod
    def new_from_string(cls, mask_string: str) -> InetAddressMask: ...
    def to_string(self) -> str: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::length"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class InetAddressMaskClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InetAddressMaskPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InetAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InetSocketAddress(SocketAddress):
    """
    An IPv4 or IPv6 socket address. That is, the combination of a
    [class@Gio.InetAddress] and a port number.

    In UNIX terms, `GInetSocketAddress` corresponds to a
    [`struct sockaddr_in` or `struct sockaddr_in6`](man:sockaddr(3type)).
    """

    class Props(SocketAddress.Props):
        address: InetAddress | None
        flowinfo: int
        port: int
        scope_id: int  # [scope-id]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self, address: InetAddress | None = ..., flowinfo: int = ..., port: int = ..., scope_id: int = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_address(self) -> InetAddress: ...
    @property
    def get_flowinfo(self) -> int: ...
    @property
    def get_port(self) -> int: ...
    @property
    def get_scope_id(self) -> int: ...
    @classmethod
    def new(cls, address: InetAddress, port: int) -> SocketAddress: ...
    @classmethod
    def new_from_string(cls, address: str, port: int) -> SocketAddress | None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flowinfo"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::port"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scope_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class InetSocketAddressClass(GObject.GPointer):
    # gi Fields
    parent_class: SocketAddressClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InetSocketAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Initable(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def init(self, cancellable: Cancellable | None = None) -> bool: ...
    @deprecated("deprecated")
    @staticmethod
    def newv(
        object_type: GObject.GType, n_parameters: int, parameters: list, cancellable: Cancellable | None = None
    ) -> GObject.Object: ...

    ...

class InitableIface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    init: initInitableIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InputMessage(GObject.GPointer):
    # gi Fields
    address: SocketAddress | None = ...
    bytes_received: int = ...
    control_messages: list | None = ...
    flags: int = ...
    num_control_messages: int = ...
    num_vectors: int = ...
    vectors: list | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InputStream(GObject.Object):
    """
    `GInputStream` is a base class for implementing streaming input.

    It has functions to read from a stream ([method@Gio.InputStream.read]),
    to close a stream ([method@Gio.InputStream.close]) and to skip some content
    ([method@Gio.InputStream.skip]).

    To copy the content of an input stream to an output stream without
    manually handling the reads and writes, use [method@Gio.OutputStream.splice].

    See the documentation for [class@Gio.IOStream] for details of thread safety
    of streaming APIs.

    All of these functions have async variants too.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear_pending(self) -> None: ...
    def close(self, cancellable: Cancellable | None = None) -> bool: ...
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def close_finish(self, result: AsyncResult) -> bool: ...
    def has_pending(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def read(self, count: int, cancellable: Cancellable | None = None) -> tuple[int, list]: ...
    def read_all(self, count: int, cancellable: Cancellable | None = None) -> tuple[bool, list, int]: ...
    async def read_all_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> list: ...
    def read_all_finish(self, result: AsyncResult) -> tuple[bool, int]: ...
    async def read_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> list: ...
    def read_bytes(self, count: int, cancellable: Cancellable | None = None) -> GLib.Bytes: ...
    async def read_bytes_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def read_bytes_finish(self, result: AsyncResult) -> GLib.Bytes: ...
    def read_finish(self, result: AsyncResult) -> int: ...
    def set_pending(self) -> bool: ...
    def skip(self, count: int, cancellable: Cancellable | None = None) -> int: ...
    async def skip_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def skip_finish(self, result: AsyncResult) -> int: ...

    # python methods
    def do_close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        close_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_close_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        close_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_close_fn(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        close_fn(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_read_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> list | None:
        """
        read_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None) -> buffer:list
        """
    def do_read_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        read_finish(self, result:Gio.AsyncResult) -> int
        """
    def do_read_fn(
        self,
        buffer: typing.Any,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        read_fn(self, buffer=None, count:int, cancellable:Gio.Cancellable=None) -> int
        """
    def do_skip(
        self,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        skip(self, count:int, cancellable:Gio.Cancellable=None) -> int
        """
    def do_skip_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        skip_async(self, count:int, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_skip_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        skip_finish(self, result:Gio.AsyncResult) -> int
        """

    ...

class InputStreamClass(GObject.GPointer):
    # gi Fields
    close_async: close_asyncInputStreamClassCB = ...
    close_finish: close_finishInputStreamClassCB = ...
    close_fn: close_fnInputStreamClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    read_async: read_asyncInputStreamClassCB = ...
    read_finish: read_finishInputStreamClassCB = ...
    read_fn: read_fnInputStreamClassCB = ...
    skip: skipInputStreamClassCB = ...
    skip_async: skip_asyncInputStreamClassCB = ...
    skip_finish: skip_finishInputStreamClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class InputVector(GObject.GPointer):
    # gi Fields
    size: int = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ListModel(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_item(self, position: int) -> GObject.Object | None: ...
    def get_item_type(self) -> GObject.GType: ...
    def get_n_items(self) -> int: ...
    def items_changed(self, position: int, removed: int, added: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["items-changed"],
        handler: typing.Callable[[typing_extensions.Self, int, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ListModelInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_item: get_itemListModelInterfaceCB | None = ...
    get_item_type: get_item_typeListModelInterfaceCB = ...
    get_n_items: get_n_itemsListModelInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ListStore(GObject.Object):
    """
    `GListStore` is a simple implementation of [iface@Gio.ListModel] that stores
    all items in memory.

    It provides insertions, deletions, and lookups in logarithmic time
    with a fast path for the common case of iterating the list linearly.
    """

    class Props(GObject.Object.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        n_items: int  # [n-items]: changed because contained invalid characters

    # gi Methods
    def __init__(self, item_type: GObject.GType = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, item: GObject.Object) -> None: ...
    def find(self, item: GObject.Object) -> tuple[bool, int | None]: ...
    def find_with_equal_func(
        self, item: GObject.Object | None, equal_func: GLib.EqualFunc
    ) -> tuple[bool, int | None]: ...
    def find_with_equal_func_full(
        self, item: GObject.Object | None, equal_func: GLib.EqualFuncFull, user_data: object | None = None
    ) -> tuple[bool, int | None]: ...
    def insert(self, position: int, item: GObject.Object) -> None: ...
    def insert_sorted(
        self, item: GObject.Object, compare_func: GLib.CompareDataFunc, user_data: object | None = None
    ) -> int: ...
    @classmethod
    def new(cls, item_type: GObject.GType) -> ListStore: ...
    def remove(self, position: int) -> None: ...
    def remove_all(self) -> None: ...
    def sort(self, compare_func: GLib.CompareDataFunc, user_data: object | None = None) -> None: ...
    def splice(self, position: int, n_removals: int, additions: list, n_additions: int) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ListStoreClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class LoadableIcon(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def load(self, size: int, cancellable: Cancellable | None = None) -> tuple[InputStream, str | None]: ...
    async def load_async(
        self,
        size: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def load_finish(self, res: AsyncResult) -> tuple[InputStream, str | None]: ...

    ...

class LoadableIconIface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    load: loadLoadableIconIfaceCB = ...
    load_async: load_asyncLoadableIconIfaceCB = ...
    load_finish: load_finishLoadableIconIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MemoryInputStream(InputStream):
    """
    `GMemoryInputStream` is a class for using arbitrary
    memory chunks as input for GIO streaming input operations.

    As of GLib 2.34, `GMemoryInputStream` implements
    [iface@Gio.PollableInputStream].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_bytes(self, bytes: GLib.Bytes) -> None: ...
    def add_data(self, data: list, len: int, destroy: GLib.DestroyNotify | None = None) -> None: ...
    @classmethod
    def new(cls) -> InputStream: ...
    @classmethod
    def new_from_bytes(cls, bytes: GLib.Bytes) -> InputStream: ...
    @classmethod
    def new_from_data(cls, data: list, len: int, destroy: GLib.DestroyNotify | None = None) -> InputStream: ...

    ...

class MemoryInputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: InputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MemoryInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MemoryMonitor(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def dup_default() -> MemoryMonitor: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["low-memory-warning"],
        handler: typing.Callable[[typing_extensions.Self, MemoryMonitorWarningLevel], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class MemoryMonitorInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    low_memory_warning: low_memory_warningMemoryMonitorInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MemoryOutputStream(OutputStream):
    """
    `GMemoryOutputStream` is a class for using arbitrary
    memory chunks as output for GIO streaming output operations.

    As of GLib 2.34, `GMemoryOutputStream` trivially implements
    [iface@Gio.PollableOutputStream]: it always polls as ready.
    """

    class Props(OutputStream.Props):
        data: object | None
        data_size: int  # [data-size]: changed because contained invalid characters
        size: int

    # gi Methods
    def __init__(self, data: object | None = ..., size: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_data(self) -> object | None: ...
    @property
    def get_data_size(self) -> int: ...
    @property
    def get_size(self) -> int: ...
    @classmethod
    def new_resizable(cls) -> OutputStream: ...
    def steal_as_bytes(self) -> GLib.Bytes: ...
    def steal_data(self) -> object | None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::data"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::data_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class MemoryOutputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: OutputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MemoryOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Menu(MenuModel):
    """
    `GMenu` is a simple implementation of [class@Gio.MenuModel].
    You populate a `GMenu` by adding [class@Gio.MenuItem] instances to it.

    There are some convenience functions to allow you to directly
    add items (avoiding [class@Gio.MenuItem]) for the common cases. To add
    a regular item, use [method@Gio.Menu.insert]. To add a section, use
    [method@Gio.Menu.insert_section]. To add a submenu, use
    [method@Gio.Menu.insert_submenu].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, label: str | None = None, detailed_action: str | None = None) -> None: ...
    def append_item(self, item: MenuItem) -> None: ...
    def append_section(self, label: str | None, section: MenuModel) -> None: ...
    def append_submenu(self, label: str | None, submenu: MenuModel) -> None: ...
    def freeze(self) -> None: ...
    def insert(self, position: int, label: str | None = None, detailed_action: str | None = None) -> None: ...
    def insert_item(self, position: int, item: MenuItem) -> None: ...
    def insert_section(self, position: int, label: str | None, section: MenuModel) -> None: ...
    def insert_submenu(self, position: int, label: str | None, submenu: MenuModel) -> None: ...
    @classmethod
    def new(cls) -> Menu: ...
    def prepend(self, label: str | None = None, detailed_action: str | None = None) -> None: ...
    def prepend_item(self, item: MenuItem) -> None: ...
    def prepend_section(self, label: str | None, section: MenuModel) -> None: ...
    def prepend_submenu(self, label: str | None, submenu: MenuModel) -> None: ...
    def remove(self, position: int) -> None: ...
    def remove_all(self) -> None: ...

    ...

class MenuAttributeIter(GObject.Object):
    """
    #GMenuAttributeIter is an opaque structure type.  You must access it
    using the functions below.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_name(self) -> str: ...
    def get_next(self) -> tuple[bool, str | None, GLib.Variant | None]: ...
    def get_value(self) -> GLib.Variant: ...
    def next(self) -> bool: ...

    # python methods
    def do_get_next(
        self,
    ) -> tuple:
        """
        get_next(self) -> bool, out_name:str, value:GLib.Variant
        """

    ...

class MenuAttributeIterClass(GObject.GPointer):
    # gi Fields
    get_next: get_nextMenuAttributeIterClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MenuAttributeIterPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MenuItem(GObject.Object):
    """
    #GMenuItem is an opaque structure type.  You must access it using the
    functions below.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_attribute_value(
        self, attribute: str, expected_type: GLib.VariantType | None = None
    ) -> GLib.Variant | None: ...
    def get_link(self, link: str) -> MenuModel | None: ...
    @classmethod
    def new(cls, label: str | None = None, detailed_action: str | None = None) -> MenuItem: ...
    @classmethod
    def new_from_model(cls, model: MenuModel, item_index: int) -> MenuItem: ...
    @classmethod
    def new_section(cls, label: str | None, section: MenuModel) -> MenuItem: ...
    @classmethod
    def new_submenu(cls, label: str | None, submenu: MenuModel) -> MenuItem: ...
    def set_action_and_target_value(
        self, action: str | None = None, target_value: GLib.Variant | None = None
    ) -> None: ...
    def set_attribute_value(self, attribute: str, value: GLib.Variant | None = None) -> None: ...
    def set_detailed_action(self, detailed_action: str) -> None: ...
    def set_icon(self, icon: Icon) -> None: ...
    def set_label(self, label: str | None = None) -> None: ...
    def set_link(self, link: str, model: MenuModel | None = None) -> None: ...
    def set_section(self, section: MenuModel | None = None) -> None: ...
    def set_submenu(self, submenu: MenuModel | None = None) -> None: ...

    # python methods
    def set_attribute(
        self,
        attributes: typing.Any,
    ) -> typing.Any: ...

    ...

class MenuLinkIter(GObject.Object):
    """
    #GMenuLinkIter is an opaque structure type.  You must access it using
    the functions below.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_name(self) -> str: ...
    def get_next(self) -> tuple[bool, str | None, MenuModel | None]: ...
    def get_value(self) -> MenuModel: ...
    def next(self) -> bool: ...

    # python methods
    def do_get_next(
        self,
    ) -> tuple:
        """
        get_next(self) -> bool, out_link:str, value:Gio.MenuModel
        """

    ...

class MenuLinkIterClass(GObject.GPointer):
    # gi Fields
    get_next: get_nextMenuLinkIterClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MenuLinkIterPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MenuModel(GObject.Object):
    """
    `GMenuModel` represents the contents of a menu — an ordered list of
    menu items. The items are associated with actions, which can be
    activated through them. Items can be grouped in sections, and may
    have submenus associated with them. Both items and sections usually
    have some representation data, such as labels or icons. The type of
    the associated action (ie whether it is stateful, and what kind of
    state it has) can influence the representation of the item.

    The conceptual model of menus in `GMenuModel` is hierarchical:
    sections and submenus are again represented by `GMenuModel`s.
    Menus themselves do not define their own roles. Rather, the role
    of a particular `GMenuModel` is defined by the item that references
    it (or, in the case of the ‘root’ menu, is defined by the context
    in which it is used).

    As an example, consider the visible portions of this menu:

    ## An example menu

    ![](menu-example.png)

    While this kind of deeply nested menu is no longer considered good UI
    practice, it serves as a good example of the concepts in `GMenuModel`.
    There are 8 ‘menus’ visible in the screenshot: one menubar, two
    submenus and 5 sections:

    - the toplevel menubar (containing 4 items)
    - the View submenu (containing 3 sections)
    - the first section of the View submenu (containing 2 items)
    - the second section of the View submenu (containing 1 item)
    - the final section of the View submenu (containing 1 item)
    - the Highlight Mode submenu (containing 2 sections)
    - the Sources section (containing 2 items)
    - the Markup section (containing 2 items)

    The [example](#a-menu-example) illustrates the conceptual connection between
    these 8 menus. Each large block in the figure represents a menu and the
    smaller blocks within the large block represent items in that menu. Some
    items contain references to other menus.

    ## A menu example

    <picture>
      <source srcset="menu-model-dark.svg" media="(prefers-color-scheme: dark)">
      <img src="menu-model-light.svg" alt="menu model">
    </picture>

    Notice that the separators visible in the [example](#an-example-menu)
    appear nowhere in the [menu model](#a-menu-example). This is because
    separators are not explicitly represented in the menu model. Instead,
    a separator is inserted between any two non-empty sections of a menu.
    Section items can have labels just like any other item. In that case,
    a display system may show a section header instead of a separator.

    The motivation for this abstract model of application controls is
    that modern user interfaces tend to make these controls available
    outside the application. Examples include global menus, jumplists,
    dash boards, etc. To support such uses, it is necessary to ‘export’
    information about actions and their representation in menus, which
    is exactly what the action group exporter and the menu model exporter do for
    [iface@Gio.ActionGroup] and [class@Gio.MenuModel]. The client-side
    counterparts to make use of the exported information are
    [class@Gio.DBusActionGroup] and [class@Gio.DBusMenuModel].

    The API of `GMenuModel` is very generic, with iterators for the
    attributes and links of an item, see
    [method@Gio.MenuModel.iterate_item_attributes] and
    [method@Gio.MenuModel.iterate_item_links]. The ‘standard’ attributes and
    link types have predefined names: `G_MENU_ATTRIBUTE_LABEL`,
    `G_MENU_ATTRIBUTE_ACTION`, `G_MENU_ATTRIBUTE_TARGET`, `G_MENU_LINK_SECTION`
    and `G_MENU_LINK_SUBMENU`.

    Items in a `GMenuModel` represent active controls if they refer to
    an action that can get activated when the user interacts with the
    menu item. The reference to the action is encoded by the string ID
    in the `G_MENU_ATTRIBUTE_ACTION` attribute. An action ID uniquely
    identifies an action in an action group. Which action group(s) provide
    actions depends on the context in which the menu model is used.
    E.g. when the model is exported as the application menu of a
    [`GtkApplication`](https://docs.gtk.org/gtk4/class.Application.html),
    actions can be application-wide or window-specific (and thus come from
    two different action groups). By convention, the application-wide actions
    have names that start with `app.`, while the names of window-specific
    actions start with `win.`.

    While a wide variety of stateful actions is possible, the following
    is the minimum that is expected to be supported by all users of exported
    menu information:
    - an action with no parameter type and no state
    - an action with no parameter type and boolean state
    - an action with string parameter type and string state

    ## Stateless

    A stateless action typically corresponds to an ordinary menu item.

    Selecting such a menu item will activate the action (with no parameter).

    ## Boolean State

    An action with a boolean state will most typically be used with a ‘toggle’
    or ‘switch’ menu item. The state can be set directly, but activating the
    action (with no parameter) results in the state being toggled.

    Selecting a toggle menu item will activate the action. The menu item should
    be rendered as ‘checked’ when the state is true.

    ## String Parameter and State

    Actions with string parameters and state will most typically be used to
    represent an enumerated choice over the items available for a group of
    radio menu items. Activating the action with a string parameter is
    equivalent to setting that parameter as the state.

    Radio menu items, in addition to being associated with the action, will
    have a target value. Selecting that menu item will result in activation
    of the action with the target value as the parameter. The menu item should
    be rendered as ‘selected’ when the state of the action is equal to the
    target value of the menu item.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_item_attribute_value(
        self, item_index: int, attribute: str, expected_type: GLib.VariantType | None = None
    ) -> GLib.Variant | None: ...
    def get_item_link(self, item_index: int, link: str) -> MenuModel | None: ...
    def get_n_items(self) -> int: ...
    def is_mutable(self) -> bool: ...
    def items_changed(self, position: int, removed: int, added: int) -> None: ...
    def iterate_item_attributes(self, item_index: int) -> MenuAttributeIter: ...
    def iterate_item_links(self, item_index: int) -> MenuLinkIter: ...

    # python methods
    def do_get_item_attribute_value(
        self,
        item_index: int,
        attribute: str,
        expected_type: GLib.VariantType | None = None,
    ) -> GLib.Variant | None:
        """
        get_item_attribute_value(self, item_index:int, attribute:str, expected_type:GLib.VariantType=None) -> GLib.Variant or None
        """
    def do_get_item_attributes(
        self,
        item_index: int,
    ) -> dict:
        """
        get_item_attributes(self, item_index:int) -> attributes:dict
        """
    def do_get_item_link(
        self,
        item_index: int,
        link: str,
    ) -> MenuModel | None:
        """
        get_item_link(self, item_index:int, link:str) -> Gio.MenuModel or None
        """
    def do_get_item_links(
        self,
        item_index: int,
    ) -> dict:
        """
        get_item_links(self, item_index:int) -> links:dict
        """
    def do_get_n_items(
        self,
    ) -> int:
        """
        get_n_items(self) -> int
        """
    def do_is_mutable(
        self,
    ) -> bool:
        """
        is_mutable(self) -> bool
        """
    def do_iterate_item_attributes(
        self,
        item_index: int,
    ) -> MenuAttributeIter:
        """
        iterate_item_attributes(self, item_index:int) -> Gio.MenuAttributeIter
        """
    def do_iterate_item_links(
        self,
        item_index: int,
    ) -> MenuLinkIter:
        """
        iterate_item_links(self, item_index:int) -> Gio.MenuLinkIter
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["items-changed"],
        handler: typing.Callable[[typing_extensions.Self, int, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class MenuModelClass(GObject.GPointer):
    # gi Fields
    get_item_attribute_value: get_item_attribute_valueMenuModelClassCB | None = ...
    get_item_attributes: get_item_attributesMenuModelClassCB = ...
    get_item_link: get_item_linkMenuModelClassCB | None = ...
    get_item_links: get_item_linksMenuModelClassCB = ...
    get_n_items: get_n_itemsMenuModelClassCB = ...
    is_mutable: is_mutableMenuModelClassCB = ...
    iterate_item_attributes: iterate_item_attributesMenuModelClassCB = ...
    iterate_item_links: iterate_item_linksMenuModelClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MenuModelPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Mount(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_eject(self) -> bool: ...
    def can_unmount(self) -> bool: ...
    @deprecated("deprecated")
    async def eject(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def eject_finish(self, result: AsyncResult) -> bool: ...
    async def eject_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def eject_with_operation_finish(self, result: AsyncResult) -> bool: ...
    def get_default_location(self) -> File: ...
    def get_drive(self) -> Drive | None: ...
    def get_icon(self) -> Icon: ...
    def get_name(self) -> str: ...
    def get_root(self) -> File: ...
    def get_sort_key(self) -> str | None: ...
    def get_symbolic_icon(self) -> Icon: ...
    def get_uuid(self) -> str | None: ...
    def get_volume(self) -> Volume | None: ...
    async def guess_content_type(
        self,
        force_rescan: bool,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def guess_content_type_finish(self, result: AsyncResult) -> list: ...
    def guess_content_type_sync(self, force_rescan: bool, cancellable: Cancellable | None = None) -> list: ...
    def is_shadowed(self) -> bool: ...
    async def remount(
        self,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def remount_finish(self, result: AsyncResult) -> bool: ...
    def shadow(self) -> None: ...
    @deprecated("deprecated")
    async def unmount(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def unmount_finish(self, result: AsyncResult) -> bool: ...
    async def unmount_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def unmount_with_operation_finish(self, result: AsyncResult) -> bool: ...
    def unshadow(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["pre-unmount"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["unmounted"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class MountIface(GObject.GPointer):
    # gi Fields
    can_eject: can_ejectMountIfaceCB = ...
    can_unmount: can_unmountMountIfaceCB = ...
    changed: changedMountIfaceCB = ...
    eject: ejectMountIfaceCB = ...
    eject_finish: eject_finishMountIfaceCB = ...
    eject_with_operation: eject_with_operationMountIfaceCB = ...
    eject_with_operation_finish: eject_with_operation_finishMountIfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_default_location: get_default_locationMountIfaceCB = ...
    get_drive: get_driveMountIfaceCB | None = ...
    get_icon: get_iconMountIfaceCB = ...
    get_name: get_nameMountIfaceCB = ...
    get_root: get_rootMountIfaceCB = ...
    get_sort_key: get_sort_keyMountIfaceCB | None = ...
    get_symbolic_icon: get_symbolic_iconMountIfaceCB = ...
    get_uuid: get_uuidMountIfaceCB | None = ...
    get_volume: get_volumeMountIfaceCB | None = ...
    guess_content_type: guess_content_typeMountIfaceCB = ...
    guess_content_type_finish: guess_content_type_finishMountIfaceCB = ...
    guess_content_type_sync: guess_content_type_syncMountIfaceCB = ...
    pre_unmount: pre_unmountMountIfaceCB = ...
    remount: remountMountIfaceCB = ...
    remount_finish: remount_finishMountIfaceCB = ...
    unmount: unmountMountIfaceCB = ...
    unmount_finish: unmount_finishMountIfaceCB = ...
    unmount_with_operation: unmount_with_operationMountIfaceCB = ...
    unmount_with_operation_finish: unmount_with_operation_finishMountIfaceCB = ...
    unmounted: unmountedMountIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MountOperation(GObject.Object):
    """
    `GMountOperation` provides a mechanism for interacting with the user.
    It can be used for authenticating mountable operations, such as loop
    mounting files, hard drive partitions or server locations. It can
    also be used to ask the user questions or show a list of applications
    preventing unmount or eject operations from completing.

    Note that `GMountOperation` is used for more than just [iface@Gio.Mount]
    objects – for example it is also used in [method@Gio.Drive.start] and
    [method@Gio.Drive.stop].

    Users should instantiate a subclass of this that implements all the
    various callbacks to show the required dialogs, such as
    [`GtkMountOperation`](https://docs.gtk.org/gtk4/class.MountOperation.html).
    If no user interaction is desired (for example when automounting
    filesystems at login time), usually `NULL` can be passed, see each method
    taking a `GMountOperation` for details.

    Throughout the API, the term ‘TCRYPT’ is used to mean ‘compatible with TrueCrypt and VeraCrypt’.
    [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system for
    encrypting file containers, partitions or whole disks, typically used with Windows.
    [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of TrueCrypt with various
    improvements and auditing fixes.
    """

    class Props(GObject.Object.Props):
        anonymous: bool
        choice: int
        domain: str
        is_tcrypt_hidden_volume: bool  # [is-tcrypt-hidden-volume]: changed because contained invalid characters
        is_tcrypt_system_volume: bool  # [is-tcrypt-system-volume]: changed because contained invalid characters
        password: str
        password_save: PasswordSave  # [password-save]: changed because contained invalid characters
        pim: int
        username: str

    # gi Methods
    def __init__(
        self,
        anonymous: bool = ...,
        choice: int = ...,
        domain: str = ...,
        is_tcrypt_hidden_volume: bool = ...,
        is_tcrypt_system_volume: bool = ...,
        password: str = ...,
        password_save: PasswordSave = ...,
        pim: int = ...,
        username: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_anonymous(self) -> bool: ...
    @property
    def get_choice(self) -> int: ...
    @property
    def get_domain(self) -> str | None: ...
    @property
    def get_is_tcrypt_hidden_volume(self) -> bool: ...
    @property
    def get_is_tcrypt_system_volume(self) -> bool: ...
    @property
    def get_password(self) -> str | None: ...
    @property
    def get_password_save(self) -> PasswordSave: ...
    @property
    def get_pim(self) -> int: ...
    @property
    def get_username(self) -> str | None: ...
    @classmethod
    def new(cls) -> MountOperation: ...
    def reply(self, result: MountOperationResult) -> None: ...
    def set_anonymous(self, anonymous: bool) -> None: ...
    def set_choice(self, choice: int) -> None: ...
    def set_domain(self, domain: str | None = None) -> None: ...
    def set_is_tcrypt_hidden_volume(self, hidden_volume: bool) -> None: ...
    def set_is_tcrypt_system_volume(self, system_volume: bool) -> None: ...
    def set_password(self, password: str | None = None) -> None: ...
    def set_password_save(self, save: PasswordSave) -> None: ...
    def set_pim(self, pim: int) -> None: ...
    def set_username(self, username: str | None = None) -> None: ...

    # python methods
    def do_aborted(
        self,
    ) -> None:
        """
        aborted(self)
        """
    def do_ask_password(
        self,
        message: str,
        default_user: str,
        default_domain: str,
        flags: AskPasswordFlags,
    ) -> None:
        """
        ask_password(self, message:str, default_user:str, default_domain:str, flags:Gio.AskPasswordFlags)
        """
    def do_ask_question(
        self,
        message: str,
        choices: list,
    ) -> None:
        """
        ask_question(self, message:str, choices:list)
        """
    def do_reply(
        self,
        result: MountOperationResult,
    ) -> None:
        """
        reply(self, result:Gio.MountOperationResult)
        """
    def do_show_processes(
        self,
        message: str,
        processes: list,
        choices: list,
    ) -> None:
        """
        show_processes(self, message:str, processes:list, choices:list)
        """
    def do_show_unmount_progress(
        self,
        message: str,
        time_left: int,
        bytes_left: int,
    ) -> None:
        """
        show_unmount_progress(self, message:str, time_left:int, bytes_left:int)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["aborted"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["ask-password"],
        handler: typing.Callable[[typing_extensions.Self, str, str, str, AskPasswordFlags], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["ask-question"],
        handler: typing.Callable[[typing_extensions.Self, str, list], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["reply"],
        handler: typing.Callable[[typing_extensions.Self, MountOperationResult], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["show-processes"],
        handler: typing.Callable[[typing_extensions.Self, str, list, list], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["show-unmount-progress"],
        handler: typing.Callable[[typing_extensions.Self, str, int, int], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::anonymous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::choice"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::domain"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_tcrypt_hidden_volume"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_tcrypt_system_volume"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::password"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::password_save"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pim"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::username"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class MountOperationClass(GObject.GPointer):
    # gi Fields
    aborted: abortedMountOperationClassCB = ...
    ask_password: ask_passwordMountOperationClassCB = ...
    ask_question: ask_questionMountOperationClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    reply: replyMountOperationClassCB = ...
    show_processes: show_processesMountOperationClassCB = ...
    show_unmount_progress: show_unmount_progressMountOperationClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class MountOperationPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class NativeSocketAddress(SocketAddress):
    """
    A socket address of some unknown native type.

    This corresponds to a general `struct sockaddr` of a type not otherwise
    handled by GLib.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, native: object | None, len: int) -> SocketAddress: ...

    ...

class NativeSocketAddressClass(GObject.GPointer):
    # gi Fields
    parent_class: SocketAddressClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class NativeSocketAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class NativeVolumeMonitor(VolumeMonitor):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class NativeVolumeMonitorClass(GObject.GPointer):
    # gi Fields
    parent_class: VolumeMonitorClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class NetworkAddress(GObject.Object):
    """
    `GNetworkAddress` provides an easy way to resolve a hostname and
    then attempt to connect to that host, handling the possibility of
    multiple IP addresses and multiple address families.

    The enumeration results of resolved addresses *may* be cached as long
    as this object is kept alive which may have unexpected results if
    alive for too long.

    See [iface@Gio.SocketConnectable] for an example of using the connectable
    interface.
    """

    class Props(GObject.Object.Props):
        hostname: str
        port: int
        scheme: str

    # gi Methods
    def __init__(self, hostname: str = ..., port: int = ..., scheme: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_hostname(self) -> str: ...
    @property
    def get_port(self) -> int: ...
    @property
    def get_scheme(self) -> str | None: ...
    @classmethod
    def new(cls, hostname: str, port: int) -> NetworkAddress: ...
    @classmethod
    def new_loopback(cls, port: int) -> NetworkAddress: ...
    @staticmethod
    def parse(host_and_port: str, default_port: int) -> NetworkAddress: ...
    @staticmethod
    def parse_uri(uri: str, default_port: int) -> NetworkAddress: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hostname"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::port"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scheme"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class NetworkAddressClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class NetworkAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class NetworkMonitor(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        connectivity: NetworkConnectivity
        network_available: bool  # [network-available]: changed because contained invalid characters
        network_metered: bool  # [network-metered]: changed because contained invalid characters

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_reach(self, connectable: SocketConnectable, cancellable: Cancellable | None = None) -> bool: ...
    async def can_reach_async(
        self,
        connectable: SocketConnectable,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def can_reach_finish(self, result: AsyncResult) -> bool: ...
    @property
    def get_connectivity(self) -> NetworkConnectivity: ...
    @staticmethod
    def get_default() -> NetworkMonitor: ...
    @property
    def get_network_available(self) -> bool: ...
    @property
    def get_network_metered(self) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["network-changed"],
        handler: typing.Callable[[typing_extensions.Self, bool], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connectivity"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::network_available"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::network_metered"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class NetworkMonitorInterface(GObject.GPointer):
    # gi Fields
    can_reach: can_reachNetworkMonitorInterfaceCB = ...
    can_reach_async: can_reach_asyncNetworkMonitorInterfaceCB = ...
    can_reach_finish: can_reach_finishNetworkMonitorInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    network_changed: network_changedNetworkMonitorInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class NetworkService(GObject.Object):
    """
    Like [class@Gio.NetworkAddress] does with hostnames, `GNetworkService`
    provides an easy way to resolve a SRV record, and then attempt to
    connect to one of the hosts that implements that service, handling
    service priority/weighting, multiple IP addresses, and multiple
    address families.

    See [struct@Gio.SrvTarget] for more information about SRV records, and see
    [iface@Gio.SocketConnectable] for an example of using the connectable
    interface.
    """

    class Props(GObject.Object.Props):
        domain: str
        protocol: str
        scheme: str
        service: str

    # gi Methods
    def __init__(self, domain: str = ..., protocol: str = ..., scheme: str = ..., service: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_domain(self) -> str: ...
    @property
    def get_protocol(self) -> str: ...
    @property
    def get_scheme(self) -> str: ...
    @property
    def get_service(self) -> str: ...
    @classmethod
    def new(cls, service: str, protocol: str, domain: str) -> NetworkService: ...
    def set_scheme(self, scheme: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::domain"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scheme"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::service"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class NetworkServiceClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class NetworkServicePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Notification(GObject.Object):
    """
    `GNotification` is a mechanism for creating a notification to be shown
    to the user — typically as a pop-up notification presented by the
    desktop environment shell.

    The key difference between `GNotification` and other similar APIs is
    that, if supported by the desktop environment, notifications sent
    with `GNotification` will persist after the application has exited,
    and even across system reboots.

    Since the user may click on a notification while the application is
    not running, applications using `GNotification` should be able to be
    started as a D-Bus service, using [class@Gio.Application].

    In order for `GNotification` to work, the application must have installed
    a `.desktop` file. For example:
    ```
    [Desktop Entry]
    Name=Test Application
    Comment=Description of what Test Application does
    Exec=gnome-test-application
    Icon=org.gnome.TestApplication
    Terminal=false
    Type=Application
    Categories=GNOME;GTK;TestApplication Category;
    StartupNotify=true
    DBusActivatable=true
    X-GNOME-UsesNotifications=true
    ```

    The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
    that this application uses notifications, so it can be listed in the
    Control Center’s ‘Notifications’ panel.

    The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
    where `org.gnome.TestApplication` is the ID passed to
    [ctor@Gio.Application.new].

    User interaction with a notification (either the default action, or
    buttons) must be associated with actions on the application (ie:
    `app.` actions).  It is not possible to route user interaction
    through the notification itself, because the object will not exist if
    the application is autostarted as a result of a notification being
    clicked.

    A notification can be sent with [method@Gio.Application.send_notification].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_button(self, label: str, detailed_action: str) -> None: ...
    def add_button_with_target(self, label: str, action: str, target: GLib.Variant | None = None) -> None: ...
    @classmethod
    def new(cls, title: str) -> Notification: ...
    def set_body(self, body: str | None = None) -> None: ...
    def set_category(self, category: str | None = None) -> None: ...
    def set_default_action(self, detailed_action: str) -> None: ...
    def set_default_action_and_target(self, action: str, target: GLib.Variant | None = None) -> None: ...
    def set_icon(self, icon: Icon) -> None: ...
    def set_priority(self, priority: NotificationPriority) -> None: ...
    def set_title(self, title: str) -> None: ...
    @deprecated("deprecated")
    def set_urgent(self, urgent: bool) -> None: ...

    ...

class OutputMessage(GObject.GPointer):
    # gi Fields
    address: SocketAddress | None = ...
    bytes_sent: int = ...
    control_messages: list | None = ...
    num_control_messages: int = ...
    num_vectors: int = ...
    vectors: OutputVector | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class OutputStream(GObject.Object):
    """
    `GOutputStream` is a base class for implementing streaming output.

    It has functions to write to a stream ([method@Gio.OutputStream.write]),
    to close a stream ([method@Gio.OutputStream.close]) and to flush pending
    writes ([method@Gio.OutputStream.flush]).

    To copy the content of an input stream to an output stream without
    manually handling the reads and writes, use [method@Gio.OutputStream.splice].

    See the documentation for [class@Gio.IOStream] for details of thread safety
    of streaming APIs.

    All of these functions have async variants too.

    All classes derived from `GOutputStream` *should* implement synchronous
    writing, splicing, flushing and closing streams, but *may* implement
    asynchronous versions.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear_pending(self) -> None: ...
    def close(self, cancellable: Cancellable | None = None) -> bool: ...
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def close_finish(self, result: AsyncResult) -> bool: ...
    def flush(self, cancellable: Cancellable | None = None) -> bool: ...
    async def flush_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def flush_finish(self, result: AsyncResult) -> bool: ...
    def has_pending(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def is_closing(self) -> bool: ...
    def set_pending(self) -> bool: ...
    def splice(
        self, source: InputStream, flags: OutputStreamSpliceFlags, cancellable: Cancellable | None = None
    ) -> int: ...
    async def splice_async(
        self,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def splice_finish(self, result: AsyncResult) -> int: ...
    def write(self, buffer: list, count: int, cancellable: Cancellable | None = None) -> int: ...
    def write_all(
        self, buffer: list, count: int, cancellable: Cancellable | None = None
    ) -> tuple[bool, int | None]: ...
    async def write_all_async(
        self,
        buffer: list,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def write_all_finish(self, result: AsyncResult) -> tuple[bool, int | None]: ...
    async def write_async(
        self,
        buffer: list,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def write_bytes(self, bytes: GLib.Bytes, cancellable: Cancellable | None = None) -> int: ...
    async def write_bytes_async(
        self,
        bytes: GLib.Bytes,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def write_bytes_finish(self, result: AsyncResult) -> int: ...
    def write_finish(self, result: AsyncResult) -> int: ...
    def writev(
        self, vectors: list, n_vectors: int, cancellable: Cancellable | None = None
    ) -> tuple[bool, int | None]: ...
    def writev_all(
        self, vectors: list, n_vectors: int, cancellable: Cancellable | None = None
    ) -> tuple[bool, int | None]: ...
    async def writev_all_async(
        self,
        vectors: list,
        n_vectors: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def writev_all_finish(self, result: AsyncResult) -> tuple[bool, int | None]: ...
    async def writev_async(
        self,
        vectors: list,
        n_vectors: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def writev_finish(self, result: AsyncResult) -> tuple[bool, int | None]: ...

    # python methods
    def do_close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        close_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_close_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        close_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_close_fn(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        close_fn(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_flush(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        flush(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_flush_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        flush_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_flush_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        flush_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_splice(
        self,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        splice(self, source:Gio.InputStream, flags:Gio.OutputStreamSpliceFlags, cancellable:Gio.Cancellable=None) -> int
        """
    def do_splice_async(
        self,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        splice_async(self, source:Gio.InputStream, flags:Gio.OutputStreamSpliceFlags, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_splice_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        splice_finish(self, result:Gio.AsyncResult) -> int
        """
    def do_write_async(
        self,
        buffer: list | None,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        write_async(self, buffer:list=None, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_write_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        write_finish(self, result:Gio.AsyncResult) -> int
        """
    def do_write_fn(
        self,
        buffer: list | None = None,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        write_fn(self, buffer:list=None, cancellable:Gio.Cancellable=None) -> int
        """
    def do_writev_async(
        self,
        vectors: list,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        writev_async(self, vectors:list, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_writev_finish(
        self,
        result: AsyncResult,
    ) -> tuple:
        """
        writev_finish(self, result:Gio.AsyncResult) -> bool, bytes_written:int
        """
    def do_writev_fn(
        self,
        vectors: list,
        cancellable: Cancellable | None = None,
    ) -> tuple:
        """
        writev_fn(self, vectors:list, cancellable:Gio.Cancellable=None) -> bool, bytes_written:int
        """

    ...

class OutputStreamClass(GObject.GPointer):
    # gi Fields
    close_async: close_asyncOutputStreamClassCB = ...
    close_finish: close_finishOutputStreamClassCB = ...
    close_fn: close_fnOutputStreamClassCB = ...
    flush: flushOutputStreamClassCB = ...
    flush_async: flush_asyncOutputStreamClassCB = ...
    flush_finish: flush_finishOutputStreamClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    splice: spliceOutputStreamClassCB = ...
    splice_async: splice_asyncOutputStreamClassCB = ...
    splice_finish: splice_finishOutputStreamClassCB = ...
    write_async: write_asyncOutputStreamClassCB = ...
    write_finish: write_finishOutputStreamClassCB = ...
    write_fn: write_fnOutputStreamClassCB = ...
    writev_async: writev_asyncOutputStreamClassCB = ...
    writev_finish: writev_finishOutputStreamClassCB = ...
    writev_fn: writev_fnOutputStreamClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class OutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class OutputVector(GObject.GPointer):
    # gi Fields
    size: int = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Permission(GObject.Object):
    """
    A `GPermission` represents the status of the caller’s permission to
    perform a certain action.

    You can query if the action is currently allowed and if it is
    possible to acquire the permission so that the action will be allowed
    in the future.

    There is also an API to actually acquire the permission and one to
    release it.

    As an example, a `GPermission` might represent the ability for the
    user to write to a [class@Gio.Settings] object.  This `GPermission` object
    could then be used to decide if it is appropriate to show a “Click here to
    unlock” button in a dialog and to provide the mechanism to invoke
    when that button is clicked.
    """

    class Props(GObject.Object.Props):
        allowed: bool
        can_acquire: bool  # [can-acquire]: changed because contained invalid characters
        can_release: bool  # [can-release]: changed because contained invalid characters

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def acquire(self, cancellable: Cancellable | None = None) -> bool: ...
    async def acquire_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def acquire_finish(self, result: AsyncResult) -> bool: ...
    @property
    def get_allowed(self) -> bool: ...
    @property
    def get_can_acquire(self) -> bool: ...
    @property
    def get_can_release(self) -> bool: ...
    def impl_update(self, allowed: bool, can_acquire: bool, can_release: bool) -> None: ...
    def release(self, cancellable: Cancellable | None = None) -> bool: ...
    async def release_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def release_finish(self, result: AsyncResult) -> bool: ...

    # python methods
    def do_acquire(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        acquire(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_acquire_async(
        self,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        acquire_async(self, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_acquire_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        acquire_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_release(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        release(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_release_async(
        self,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        release_async(self, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_release_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        release_finish(self, result:Gio.AsyncResult) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::allowed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_acquire"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_release"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class PermissionClass(GObject.GPointer):
    # gi Fields
    acquire: acquirePermissionClassCB = ...
    acquire_async: acquire_asyncPermissionClassCB = ...
    acquire_finish: acquire_finishPermissionClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    release: releasePermissionClassCB = ...
    release_async: release_asyncPermissionClassCB = ...
    release_finish: release_finishPermissionClassCB = ...
    reserved: list | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PermissionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PollableInputStream(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_poll(self) -> bool: ...
    def create_source(self, cancellable: Cancellable | None = None) -> GLib.Source: ...
    def is_readable(self) -> bool: ...
    def read_nonblocking(self, count: int, cancellable: Cancellable | None = None) -> tuple[int, list]: ...

    ...

class PollableInputStreamInterface(GObject.GPointer):
    # gi Fields
    can_poll: can_pollPollableInputStreamInterfaceCB = ...
    create_source: create_sourcePollableInputStreamInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    is_readable: is_readablePollableInputStreamInterfaceCB = ...
    read_nonblocking: read_nonblockingPollableInputStreamInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PollableOutputStream(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_poll(self) -> bool: ...
    def create_source(self, cancellable: Cancellable | None = None) -> GLib.Source: ...
    def is_writable(self) -> bool: ...
    def write_nonblocking(self, buffer: list, count: int, cancellable: Cancellable | None = None) -> int: ...
    def writev_nonblocking(
        self, vectors: list, n_vectors: int, cancellable: Cancellable | None = None
    ) -> tuple[PollableReturn, int | None]: ...

    ...

class PollableOutputStreamInterface(GObject.GPointer):
    # gi Fields
    can_poll: can_pollPollableOutputStreamInterfaceCB = ...
    create_source: create_sourcePollableOutputStreamInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    is_writable: is_writablePollableOutputStreamInterfaceCB = ...
    write_nonblocking: write_nonblockingPollableOutputStreamInterfaceCB = ...
    writev_nonblocking: writev_nonblockingPollableOutputStreamInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PowerProfileMonitor(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        power_saver_enabled: bool  # [power-saver-enabled]: changed because contained invalid characters

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def dup_default() -> PowerProfileMonitor: ...
    @property
    def get_power_saver_enabled(self) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::power_saver_enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class PowerProfileMonitorInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class PropertyAction(GObject.Object):
    """
    A `GPropertyAction` is a way to get a [iface@Gio.Action] with a state value
    reflecting and controlling the value of a [class@GObject.Object] property.

    The state of the action will correspond to the value of the property.
    Changing it will change the property (assuming the requested value
    matches the requirements as specified in the [type@GObject.ParamSpec]).

    Only the most common types are presently supported.  Booleans are
    mapped to booleans, strings to strings, signed/unsigned integers to
    int32/uint32 and floats and doubles to doubles.

    If the property is an enum then the state will be string-typed and
    conversion will automatically be performed between the enum value and
    ‘nick’ string as per the [type@GObject.EnumValue] table.

    Flags types are not currently supported.

    Properties of object types, boxed types and pointer types are not
    supported and probably never will be.

    Properties of [type@GLib.Variant] types are not currently supported.

    If the property is boolean-valued then the action will have a `NULL`
    parameter type, and activating the action (with no parameter) will
    toggle the value of the property.

    In all other cases, the parameter type will correspond to the type of
    the property.

    The general idea here is to reduce the number of locations where a
    particular piece of state is kept (and therefore has to be synchronised
    between). `GPropertyAction` does not have a separate state that is kept
    in sync with the property value — its state is the property value.

    For example, it might be useful to create a [iface@Gio.Action] corresponding
    to the `visible-child-name` property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html)
    so that the current page can be switched from a menu.  The active radio
    indication in the menu is then directly determined from the active page of
    the `GtkStack`.

    An anti-example would be binding the `active-id` property on a
    [`GtkComboBox`](https://docs.gtk.org/gtk4/class.ComboBox.html). This is
    because the state of the combo box itself is probably uninteresting and is
    actually being used to control something else.

    Another anti-example would be to bind to the `visible-child-name`
    property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html) if
    this value is actually stored in [class@Gio.Settings].  In that case, the
    real source of the value is* [class@Gio.Settings].  If you want
    a [iface@Gio.Action] to control a setting stored in [class@Gio.Settings],
    see [method@Gio.Settings.create_action] instead, and possibly combine its
    use with [method@Gio.Settings.bind].
    """

    class Props(GObject.Object.Props):
        enabled: bool
        invert_boolean: bool  # [invert-boolean]: changed because contained invalid characters
        name: str
        object: GObject.Object | None
        parameter_type: GLib.VariantType | None  # [parameter-type]: changed because contained invalid characters
        property_name: str  # [property-name]: changed because contained invalid characters
        state: GLib.Variant | None
        state_type: GLib.VariantType | None  # [state-type]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self, invert_boolean: bool = ..., name: str = ..., object: GObject.Object | None = ..., property_name: str = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, name: str, object: GObject.Object, property_name: str) -> PropertyAction: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::invert_boolean"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::object"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parameter_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::property_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class Proxy(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def connect(
        self, connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | None = None
    ) -> IOStream:
        """
        [note from gi-stub-gen] Proxy has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    async def connect_async(
        self,
        connection: IOStream,
        proxy_address: ProxyAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def connect_finish(self, result: AsyncResult) -> IOStream: ...
    @staticmethod
    def get_default_for_protocol(protocol: str) -> Proxy | None: ...
    def supports_hostname(self) -> bool: ...

    ...

class ProxyAddress(InetSocketAddress):
    """
    A [class@Gio.InetSocketAddress] representing a connection via a proxy server.
    """

    class Props(InetSocketAddress.Props):
        destination_hostname: str  # [destination-hostname]: changed because contained invalid characters
        destination_port: int  # [destination-port]: changed because contained invalid characters
        destination_protocol: str  # [destination-protocol]: changed because contained invalid characters
        password: str
        protocol: str
        uri: str
        username: str

    # gi Methods
    def __init__(
        self,
        destination_hostname: str = ...,
        destination_port: int = ...,
        destination_protocol: str = ...,
        password: str = ...,
        protocol: str = ...,
        uri: str = ...,
        username: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_destination_hostname(self) -> str: ...
    @property
    def get_destination_port(self) -> int: ...
    @property
    def get_destination_protocol(self) -> str: ...
    @property
    def get_password(self) -> str | None: ...
    @property
    def get_protocol(self) -> str: ...
    @property
    def get_uri(self) -> str | None: ...
    @property
    def get_username(self) -> str | None: ...
    @classmethod
    def new(
        cls,
        inetaddr: InetAddress,
        port: int,
        protocol: str,
        dest_hostname: str,
        dest_port: int,
        username: str | None = None,
        password: str | None = None,
    ) -> SocketAddress: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::destination_hostname"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::destination_port"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::destination_protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::password"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::username"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ProxyAddressClass(GObject.GPointer):
    # gi Fields
    parent_class: InetSocketAddressClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ProxyAddressEnumerator(SocketAddressEnumerator):
    """
    `GProxyAddressEnumerator` is a wrapper around
    [class@Gio.SocketAddressEnumerator] which takes the [class@Gio.SocketAddress]
    instances returned by the [class@Gio.SocketAddressEnumerator]
    and wraps them in [class@Gio.ProxyAddress] instances, using the given
    [property@Gio.ProxyAddressEnumerator:proxy-resolver].

    This enumerator will be returned (for example, by
    [method@Gio.SocketConnectable.enumerate]) as appropriate when a proxy is
    configured; there should be no need to manually wrap a
    [class@Gio.SocketAddressEnumerator] instance with one.
    """

    class Props(SocketAddressEnumerator.Props):
        connectable: SocketConnectable | None
        default_port: int  # [default-port]: changed because contained invalid characters
        proxy_resolver: ProxyResolver | None  # [proxy-resolver]: changed because contained invalid characters
        uri: str

    # gi Methods
    def __init__(
        self,
        connectable: SocketConnectable | None = ...,
        default_port: int = ...,
        proxy_resolver: ProxyResolver | None = ...,
        uri: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connectable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_port"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::proxy_resolver"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ProxyAddressEnumeratorClass(GObject.GPointer):
    # gi Fields
    parent_class: SocketAddressEnumeratorClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ProxyAddressEnumeratorPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ProxyAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ProxyInterface(GObject.GPointer):
    # gi Fields
    connect: connectProxyInterfaceCB = ...
    connect_async: connect_asyncProxyInterfaceCB = ...
    connect_finish: connect_finishProxyInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    supports_hostname: supports_hostnameProxyInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ProxyResolver(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_default() -> ProxyResolver: ...
    def is_supported(self) -> bool: ...
    def lookup(self, uri: str, cancellable: Cancellable | None = None) -> list: ...
    async def lookup_async(
        self,
        uri: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def lookup_finish(self, result: AsyncResult) -> list: ...

    ...

class ProxyResolverInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    is_supported: is_supportedProxyResolverInterfaceCB = ...
    lookup: lookupProxyResolverInterfaceCB = ...
    lookup_async: lookup_asyncProxyResolverInterfaceCB = ...
    lookup_finish: lookup_finishProxyResolverInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class RemoteActionGroup(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def activate_action_full(
        self, action_name: str, parameter: GLib.Variant | None, platform_data: GLib.Variant
    ) -> None: ...
    def change_action_state_full(self, action_name: str, value: GLib.Variant, platform_data: GLib.Variant) -> None: ...

    ...

class RemoteActionGroupInterface(GObject.GPointer):
    # gi Fields
    activate_action_full: activate_action_fullRemoteActionGroupInterfaceCB = ...
    change_action_state_full: change_action_state_fullRemoteActionGroupInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Resolver(GObject.Object):
    """
    The object that handles DNS resolution. Use [func@Gio.Resolver.get_default]
    to get the default resolver.

    `GResolver` provides cancellable synchronous and asynchronous DNS
    resolution, for hostnames ([method@Gio.Resolver.lookup_by_address],
    [method@Gio.Resolver.lookup_by_name] and their async variants) and SRV
    (service) records ([method@Gio.Resolver.lookup_service]).

    [class@Gio.NetworkAddress] and [class@Gio.NetworkService] provide wrappers
    around `GResolver` functionality that also implement
    [iface@Gio.SocketConnectable], making it easy to connect to a remote
    host/service.

    The default resolver (see [func@Gio.Resolver.get_default]) has a timeout of
    30s set on it since GLib 2.78. Earlier versions of GLib did not support
    resolver timeouts.

    This is an abstract type; subclasses of it implement different resolvers for
    different platforms and situations.
    """

    class Props(GObject.Object.Props):
        timeout: int

    # gi Methods
    def __init__(self, timeout: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_default() -> Resolver: ...
    @property
    def get_timeout(self) -> int: ...
    def lookup_by_address(self, address: InetAddress, cancellable: Cancellable | None = None) -> str: ...
    async def lookup_by_address_async(
        self,
        address: InetAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def lookup_by_address_finish(self, result: AsyncResult) -> str: ...
    def lookup_by_name(self, hostname: str, cancellable: Cancellable | None = None) -> list: ...
    async def lookup_by_name_async(
        self,
        hostname: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def lookup_by_name_finish(self, result: AsyncResult) -> list: ...
    def lookup_by_name_with_flags(
        self, hostname: str, flags: ResolverNameLookupFlags, cancellable: Cancellable | None = None
    ) -> list: ...
    async def lookup_by_name_with_flags_async(
        self,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def lookup_by_name_with_flags_finish(self, result: AsyncResult) -> list: ...
    def lookup_records(
        self, rrname: str, record_type: ResolverRecordType, cancellable: Cancellable | None = None
    ) -> list: ...
    async def lookup_records_async(
        self,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def lookup_records_finish(self, result: AsyncResult) -> list: ...
    def lookup_service(
        self, service: str, protocol: str, domain: str, cancellable: Cancellable | None = None
    ) -> list: ...
    async def lookup_service_async(
        self,
        service: str,
        protocol: str,
        domain: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def lookup_service_finish(self, result: AsyncResult) -> list: ...
    def set_default(self) -> None: ...
    def set_timeout(self, timeout_ms: int) -> None: ...

    # python methods
    def do_lookup_by_address(
        self,
        address: InetAddress,
        cancellable: Cancellable | None = None,
    ) -> str:
        """
        lookup_by_address(self, address:Gio.InetAddress, cancellable:Gio.Cancellable=None) -> str
        """
    def do_lookup_by_address_async(
        self,
        address: InetAddress,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_by_address_async(self, address:Gio.InetAddress, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_by_address_finish(
        self,
        result: AsyncResult,
    ) -> str:
        """
        lookup_by_address_finish(self, result:Gio.AsyncResult) -> str
        """
    def do_lookup_by_name(
        self,
        hostname: str,
        cancellable: Cancellable | None = None,
    ) -> list:
        """
        lookup_by_name(self, hostname:str, cancellable:Gio.Cancellable=None) -> list
        """
    def do_lookup_by_name_async(
        self,
        hostname: str,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_by_name_async(self, hostname:str, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_by_name_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_by_name_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_lookup_by_name_with_flags(
        self,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list:
        """
        lookup_by_name_with_flags(self, hostname:str, flags:Gio.ResolverNameLookupFlags, cancellable:Gio.Cancellable=None) -> list
        """
    def do_lookup_by_name_with_flags_async(
        self,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_by_name_with_flags_async(self, hostname:str, flags:Gio.ResolverNameLookupFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_by_name_with_flags_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_by_name_with_flags_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_lookup_records(
        self,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
    ) -> list:
        """
        lookup_records(self, rrname:str, record_type:Gio.ResolverRecordType, cancellable:Gio.Cancellable=None) -> list
        """
    def do_lookup_records_async(
        self,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_records_async(self, rrname:str, record_type:Gio.ResolverRecordType, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_records_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_records_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_lookup_service_async(
        self,
        rrname: str,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_service_async(self, rrname:str, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_service_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_service_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_reload(
        self,
    ) -> None:
        """
        reload(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["reload"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ResolverClass(GObject.GPointer):
    # gi Fields
    lookup_by_address: lookup_by_addressResolverClassCB = ...
    lookup_by_address_async: lookup_by_address_asyncResolverClassCB = ...
    lookup_by_address_finish: lookup_by_address_finishResolverClassCB = ...
    lookup_by_name: lookup_by_nameResolverClassCB = ...
    lookup_by_name_async: lookup_by_name_asyncResolverClassCB = ...
    lookup_by_name_finish: lookup_by_name_finishResolverClassCB = ...
    lookup_by_name_with_flags: lookup_by_name_with_flagsResolverClassCB = ...
    lookup_by_name_with_flags_async: lookup_by_name_with_flags_asyncResolverClassCB = ...
    lookup_by_name_with_flags_finish: lookup_by_name_with_flags_finishResolverClassCB = ...
    lookup_records: lookup_recordsResolverClassCB = ...
    lookup_records_async: lookup_records_asyncResolverClassCB = ...
    lookup_records_finish: lookup_records_finishResolverClassCB = ...
    lookup_service_async: lookup_service_asyncResolverClassCB = ...
    lookup_service_finish: lookup_service_finishResolverClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    reload: reloadResolverClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ResolverPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Resource(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def _register(self) -> None: ...
    def _unregister(self) -> None: ...
    def enumerate_children(self, path: str, lookup_flags: ResourceLookupFlags) -> list: ...
    def get_info(self, path: str, lookup_flags: ResourceLookupFlags) -> tuple[bool, int | None, int | None]: ...
    def has_children(self, path: str) -> bool: ...
    @staticmethod
    def load(filename: str) -> Resource: ...
    def lookup_data(self, path: str, lookup_flags: ResourceLookupFlags) -> GLib.Bytes: ...
    @classmethod
    def new_from_data(cls, data: GLib.Bytes) -> Resource: ...
    def open_stream(self, path: str, lookup_flags: ResourceLookupFlags) -> InputStream: ...
    def ref(self) -> Resource: ...
    def unref(self) -> None: ...

    ...

class Seekable(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_seek(self) -> bool: ...
    def can_truncate(self) -> bool: ...
    def seek(self, offset: int, type: GLib.SeekType, cancellable: Cancellable | None = None) -> bool: ...
    def tell(self) -> int: ...
    def truncate(self, offset: int, cancellable: Cancellable | None = None) -> bool: ...

    ...

class SeekableIface(GObject.GPointer):
    # gi Fields
    can_seek: can_seekSeekableIfaceCB = ...
    can_truncate: can_truncateSeekableIfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    seek: seekSeekableIfaceCB = ...
    tell: tellSeekableIfaceCB = ...
    truncate_fn: truncate_fnSeekableIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Settings(GObject.Object):
    """
    The `GSettings` class provides a convenient API for storing and retrieving
    application settings.

    Reads and writes can be considered to be non-blocking.  Reading
    settings with `GSettings` is typically extremely fast: on
    approximately the same order of magnitude (but slower than) a
    [struct@GLib.HashTable] lookup.  Writing settings is also extremely fast in
    terms of time to return to your application, but can be extremely expensive
    for other threads and other processes.  Many settings backends
    (including dconf) have lazy initialisation which means in the common
    case of the user using their computer without modifying any settings
    a lot of work can be avoided.  For dconf, the D-Bus service doesn’t
    even need to be started in this case.  For this reason, you should
    only ever modify `GSettings` keys in response to explicit user action.
    Particular care should be paid to ensure that modifications are not
    made during startup — for example, when setting the initial value
    of preferences widgets.  The built-in [method@Gio.Settings.bind]
    functionality is careful not to write settings in response to notify signals
    as a result of modifications that it makes to widgets.

    When creating a `GSettings` instance, you have to specify a schema
    that describes the keys in your settings and their types and default
    values, as well as some other information.

    Normally, a schema has a fixed path that determines where the settings
    are stored in the conceptual global tree of settings. However, schemas
    can also be ‘[relocatable](#relocatable-schemas)’, i.e. not equipped with
    a fixed path. This is
    useful e.g. when the schema describes an ‘account’, and you want to be
    able to store a arbitrary number of accounts.

    Paths must start with and end with a forward slash character (`/`)
    and must not contain two sequential slash characters.  Paths should
    be chosen based on a domain name associated with the program or
    library to which the settings belong.  Examples of paths are
    `/org/gtk/settings/file-chooser/` and `/ca/desrt/dconf-editor/`.
    Paths should not start with `/apps/`, `/desktop/` or `/system/` as
    they often did in GConf.

    Unlike other configuration systems (like GConf), GSettings does not
    restrict keys to basic types like strings and numbers. GSettings stores
    values as [struct@GLib.Variant], and allows any [type@GLib.VariantType] for
    keys. Key names are restricted to lowercase characters, numbers and `-`.
    Furthermore, the names must begin with a lowercase character, must not end
    with a `-`, and must not contain consecutive dashes.

    Similar to GConf, the default values in GSettings schemas can be
    localized, but the localized values are stored in gettext catalogs
    and looked up with the domain that is specified in the
    `gettext-domain` attribute of the `<schemalist>` or `<schema>`
    elements and the category that is specified in the `l10n` attribute of
    the `<default>` element. The string which is translated includes all text in
    the `<default>` element, including any surrounding quotation marks.

    The `l10n` attribute must be set to `messages` or `time`, and sets the
    [locale category for
    translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
    The `messages` category should be used by default; use `time` for
    translatable date or time formats. A translation comment can be added as an
    XML comment immediately above the `<default>` element — it is recommended to
    add these comments to aid translators understand the meaning and
    implications of the default value. An optional translation `context`
    attribute can be set on the `<default>` element to disambiguate multiple
    defaults which use the same string.

    For example:
    ```xml
     <!-- Translators: A list of words which are not allowed to be typed, in
          GVariant serialization syntax.
          See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
     <default l10n='messages' context='Banned words'>['bad', 'words']</default>
    ```

    Translations of default values must remain syntactically valid serialized
    [struct@GLib.Variant]s (e.g. retaining any surrounding quotation marks) or
    runtime errors will occur.

    GSettings uses schemas in a compact binary form that is created
    by the [`glib-compile-schemas`](glib-compile-schemas.html)
    utility. The input is a schema description in an XML format.

    A DTD for the gschema XML format can be found here:
    [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)

    The [`glib-compile-schemas`](glib-compile-schemas.html) tool expects schema
    files to have the extension `.gschema.xml`.

    At runtime, schemas are identified by their ID (as specified in the
    `id` attribute of the `<schema>` element). The convention for schema
    IDs is to use a dotted name, similar in style to a D-Bus bus name,
    e.g. `org.gnome.SessionManager`. In particular, if the settings are
    for a specific service that owns a D-Bus bus name, the D-Bus bus name
    and schema ID should match. For schemas which deal with settings not
    associated with one named application, the ID should not use
    StudlyCaps, e.g. `org.gnome.font-rendering`.

    In addition to [struct@GLib.Variant] types, keys can have types that have
    enumerated types. These can be described by a `<choice>`,
    `<enum>` or `<flags>` element, as seen in the
    second example below. The underlying type of such a key
    is string, but you can use [method@Gio.Settings.get_enum],
    [method@Gio.Settings.set_enum], [method@Gio.Settings.get_flags],
    [method@Gio.Settings.set_flags] access the numeric values corresponding to
    the string value of enum and flags keys.

    An example for default value:
    ```xml
    <schemalist>
      <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">

        <key name="greeting" type="s">
          <default l10n="messages">"Hello, earthlings"</default>
          <summary>A greeting</summary>
          <description>
            Greeting of the invading martians
          </description>
        </key>

        <key name="box" type="(ii)">
          <default>(20,30)</default>
        </key>

        <key name="empty-string" type="s">
          <default>""</default>
          <summary>Empty strings have to be provided in GVariant form</summary>
        </key>

      </schema>
    </schemalist>
    ```

    An example for ranges, choices and enumerated types:
    ```xml
    <schemalist>

      <enum id="org.gtk.Test.myenum">
        <value nick="first" value="1"/>
        <value nick="second" value="2"/>
      </enum>

      <flags id="org.gtk.Test.myflags">
        <value nick="flag1" value="1"/>
        <value nick="flag2" value="2"/>
        <value nick="flag3" value="4"/>
      </flags>

      <schema id="org.gtk.Test">

        <key name="key-with-range" type="i">
          <range min="1" max="100"/>
          <default>10</default>
        </key>

        <key name="key-with-choices" type="s">
          <choices>
            <choice value='Elisabeth'/>
            <choice value='Annabeth'/>
            <choice value='Joe'/>
          </choices>
          <aliases>
            <alias value='Anna' target='Annabeth'/>
            <alias value='Beth' target='Elisabeth'/>
          </aliases>
          <default>'Joe'</default>
        </key>

        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
          <default>'first'</default>
        </key>

        <key name='flags-key' flags='org.gtk.Test.myflags'>
          <default>["flag1","flag2"]</default>
        </key>
      </schema>
    </schemalist>
    ```

    ## Vendor overrides

    Default values are defined in the schemas that get installed by
    an application. Sometimes, it is necessary for a vendor or distributor
    to adjust these defaults. Since patching the XML source for the schema
    is inconvenient and error-prone,
    [`glib-compile-schemas`](glib-compile-schemas.html) reads so-called ‘vendor
    override’ files. These are keyfiles in the same directory as the XML
    schema sources which can override default values. The schema ID serves
    as the group name in the key file, and the values are expected in
    serialized [struct@GLib.Variant] form, as in the following example:
    ```
    [org.gtk.Example]
    key1='string'
    key2=1.5
    ```

    `glib-compile-schemas` expects schema files to have the extension
    `.gschema.override`.

    ## Delay-apply mode

    By default, values set on a [class@Gio.Settings] instance immediately start
    to be written to the backend (although these writes may not complete by the
    time that [method@Gio.Settings.set]) returns; see [func@Gio.Settings.sync]).

    In order to allow groups of settings to be changed simultaneously and
    atomically, GSettings also supports a ‘delay-apply’ mode. In this mode,
    updated values are kept locally in the [class@Gio.Settings] instance until
    they are explicitly applied by calling [method@Gio.Settings.apply].

    For example, this could be useful for a preferences dialog where the
    preferences all need to be applied simultaneously when the user clicks ‘Save’.

    Switching a [class@Gio.Settings] instance to ‘delay-apply’ mode is a one-time
    irreversible operation: from that point onwards, *all* changes made to that
    [class@Gio.Settings] have to be explicitly applied by calling
    [method@Gio.Settings.apply]. The ‘delay-apply’ mode is also propagated to any
    child settings objects subsequently created using
    [method@Gio.Settings.get_child].

    At any point, the set of unapplied changes can be queried using
    [property@Gio.Settings:has-unapplied], and discarded by calling
    [method@Gio.Settings.revert].

    ## Binding

    A very convenient feature of GSettings lets you bind [class@GObject.Object]
    properties directly to settings, using [method@Gio.Settings.bind]. Once a
    [class@GObject.Object] property has been bound to a setting, changes on
    either side are automatically propagated to the other side. GSettings handles
    details like mapping between [class@GObject.Object] and [struct@GLib.Variant]
    types, and preventing infinite cycles.

    This makes it very easy to hook up a preferences dialog to the
    underlying settings. To make this even more convenient, GSettings
    looks for a boolean property with the name `sensitivity` and
    automatically binds it to the writability of the bound setting.
    If this ‘magic’ gets in the way, it can be suppressed with the
    `G_SETTINGS_BIND_NO_SENSITIVITY` flag.

    ## Relocatable schemas

    A relocatable schema is one with no `path` attribute specified on its
    `<schema>` element. By using [ctor@Gio.Settings.new_with_path], a `GSettings`
    object can be instantiated for a relocatable schema, assigning a path to the
    instance. Paths passed to [ctor@Gio.Settings.new_with_path] will typically be
    constructed dynamically from a constant prefix plus some form of instance
    identifier; but they must still be valid GSettings paths. Paths could also
    be constant and used with a globally installed schema originating from a
    dependency library.

    For example, a relocatable schema could be used to store geometry information
    for different windows in an application. If the schema ID was
    `org.foo.MyApp.Window`, it could be instantiated for paths
    `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
    `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
    they can be specified as `<child>` elements in the parent schema, e.g.:
    ```xml
    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
      <child name="main" schema="org.foo.MyApp.Window"/>
    </schema>
    ```

    ## Build system integration

    ### Meson

    GSettings is natively supported by Meson’s [GNOME module](https://mesonbuild.com/Gnome-module.html).

    You can install the schemas as any other data file:

    ```
    install_data(
      'org.foo.MyApp.gschema.xml',
      install_dir: get_option('datadir') / 'glib-2.0/schemas',
    )
    ```

    You can use `gnome.post_install()` function to compile the schemas on
    installation:

    ```
    gnome = import('gnome')
    gnome.post_install(
      glib_compile_schemas: true,
    )
    ```

    If an enumerated type defined in a C header file is to be used in a GSettings
    schema, it can either be defined manually using an `<enum>` element in the
    schema XML, or it can be extracted automatically from the C header. This
    approach is preferred, as it ensures the two representations are always
    synchronised. To do so, you will need to use the `gnome.mkenums()` function
    with the following templates:

    ```
    schemas_enums = gnome.mkenums('org.foo.MyApp.enums.xml',
      comments: '<!-- @comment@ -->',
      fhead: '<schemalist>',
      vhead: '  <@type@ id="org.foo.MyApp.@EnumName@">',
      vprod: '    <value nick="@valuenick@" value="@valuenum@"/>',
      vtail: '  </@type@>',
      ftail: '</schemalist>',
      sources: enum_sources,
      install_header: true,
      install_dir: get_option('datadir') / 'glib-2.0/schemas',
    )
    ```

    It is recommended to validate your schemas as part of the test suite for
    your application:

    ```
    test('validate-schema',
      find_program('glib-compile-schemas'),
      args: ['--strict', '--dry-run', meson.current_source_dir()],
    )
    ```

    If your application allows running uninstalled, you should also use the
    `gnome.compile_schemas()` function to compile the schemas in the current
    build directory:

    ```
    gnome.compile_schemas()
    ```

    ### Autotools

    GSettings comes with autotools integration to simplify compiling and
    installing schemas. To add GSettings support to an application, add the
    following to your `configure.ac`:
    ```
    GLIB_GSETTINGS
    ```

    In the appropriate `Makefile.am`, use the following snippet to compile and
    install the named schema:
    ```
    gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
    EXTRA_DIST = $(gsettings_SCHEMAS)

    @GSETTINGS_RULES@
    ```

    If an enumerated type defined in a C header file is to be used in a GSettings
    schema, it can either be defined manually using an `<enum>` element in the
    schema XML, or it can be extracted automatically from the C header. This
    approach is preferred, as it ensures the two representations are always
    synchronised. To do so, add the following to the relevant `Makefile.am`:
    ```
    gsettings_ENUM_NAMESPACE = org.foo.MyApp
    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
    ```

    `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
    which are specified in `gsettings_ENUM_FILES`. This will generate a
    `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
    automatically included in the schema compilation, install and uninstall
    rules. It should not be committed to version control or included in
    `EXTRA_DIST`.

    ## Localization

    No changes are needed to the build system to mark a schema XML file for
    translation. Assuming it sets the `gettext-domain` attribute, a schema may
    be marked for translation by adding it to `POTFILES.in`, assuming gettext
    0.19 or newer is in use (the preferred method for translation):
    ```
    data/org.foo.MyApp.gschema.xml
    ```

    Alternatively, if intltool 0.50.1 is in use:
    ```
    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
    ```

    GSettings will use gettext to look up translations for the `<summary>` and
    `<description>` elements, and also any `<default>` elements which have a
    `l10n` attribute set.

    Translations **must not** be included in the `.gschema.xml` file by the build
    system, for example by using a rule to generate the XML file from a template.
    """

    class Props(GObject.Object.Props):
        backend: SettingsBackend | None
        delay_apply: bool  # [delay-apply]: changed because contained invalid characters
        has_unapplied: bool  # [has-unapplied]: changed because contained invalid characters
        path: str
        schema: str
        schema_id: str  # [schema-id]: changed because contained invalid characters
        settings_schema: SettingsSchema | None  # [settings-schema]: changed because contained invalid characters

    # gi Methods
    def apply(self) -> None: ...
    def bind(self, key: str, object: GObject.Object, property: str, flags: SettingsBindFlags) -> None: ...
    def bind_with_mapping(
        self,
        key: str,
        object: GObject.Object,
        property: str,
        flags: SettingsBindFlags,
        get_mapping: GObject.Closure | None = None,
        set_mapping: GObject.Closure | None = None,
    ) -> None: ...
    def bind_writable(self, key: str, object: GObject.Object, property: str, inverted: bool) -> None: ...
    def create_action(self, key: str) -> Action: ...
    def delay(self) -> None: ...
    def get_boolean(self, key: str) -> bool: ...
    def get_child(self, name: str) -> Settings: ...
    def get_default_value(self, key: str) -> GLib.Variant | None: ...
    def get_double(self, key: str) -> float: ...
    def get_enum(self, key: str) -> int: ...
    def get_flags(self, key: str) -> int: ...
    @property
    def get_has_unapplied(self) -> bool: ...
    def get_int(self, key: str) -> int: ...
    def get_int64(self, key: str) -> int: ...
    def get_mapped(self, key: str, mapping: SettingsGetMapping, user_data: object | None = None) -> object | None: ...
    @deprecated("deprecated")
    def get_range(self, key: str) -> GLib.Variant: ...
    def get_string(self, key: str) -> str: ...
    def get_strv(self, key: str) -> list: ...
    def get_uint(self, key: str) -> int: ...
    def get_uint64(self, key: str) -> int: ...
    def get_user_value(self, key: str) -> GLib.Variant | None: ...
    def get_value(self, key: str) -> GLib.Variant: ...
    def is_writable(self, name: str) -> bool: ...
    def list_children(self) -> list: ...
    @deprecated("deprecated")
    def list_keys(self) -> list: ...
    @deprecated("deprecated")
    @staticmethod
    def list_relocatable_schemas() -> list: ...
    @deprecated("deprecated")
    @staticmethod
    def list_schemas() -> list: ...
    @classmethod
    def new(cls, schema_id: str) -> Settings: ...
    @classmethod
    def new_full(
        cls, schema: SettingsSchema, backend: SettingsBackend | None = None, path: str | None = None
    ) -> Settings: ...
    @classmethod
    def new_with_backend(cls, schema_id: str, backend: SettingsBackend) -> Settings: ...
    @classmethod
    def new_with_backend_and_path(cls, schema_id: str, backend: SettingsBackend, path: str) -> Settings: ...
    @classmethod
    def new_with_path(cls, schema_id: str, path: str) -> Settings: ...
    @deprecated("deprecated")
    def range_check(self, key: str, value: GLib.Variant) -> bool: ...
    def reset(self, key: str) -> None: ...
    def revert(self) -> None: ...
    def set_boolean(self, key: str, value: bool) -> bool: ...
    def set_double(self, key: str, value: float) -> bool: ...
    def set_enum(self, key: str, value: int) -> bool: ...
    def set_flags(self, key: str, value: int) -> bool: ...
    def set_int(self, key: str, value: int) -> bool: ...
    def set_int64(self, key: str, value: int) -> bool: ...
    def set_string(self, key: str, value: str) -> bool: ...
    def set_strv(self, key: str, value: list | None = None) -> bool: ...
    def set_uint(self, key: str, value: int) -> bool: ...
    def set_uint64(self, key: str, value: int) -> bool: ...
    def set_value(self, key: str, value: GLib.Variant) -> bool: ...
    @staticmethod
    def sync() -> None: ...
    @staticmethod
    def unbind(object: GObject.Object, property: str) -> None: ...

    # python methods
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initializer for a GObject based classes with support for property
        sets through the use of explicit keyword arguments.
        """
    def keys(
        self,
    ) -> typing.Any: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["change-event"],
        handler: typing.Callable[[typing_extensions.Self, list | None, int], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["changed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["writable-change-event"],
        handler: typing.Callable[[typing_extensions.Self, int], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["writable-changed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::backend"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::delay_apply"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_unapplied"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::schema"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::schema_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::settings_schema"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class SettingsBackend(GObject.Object):
    """
    The `GSettingsBackend` interface defines a generic interface for
    non-strictly-typed data that is stored in a hierarchy. To implement
    an alternative storage backend for [class@Gio.Settings], you need to
    implement the `GSettingsBackend` interface and then make it implement the
    extension point `G_SETTINGS_BACKEND_EXTENSION_POINT_NAME`.

    The interface defines methods for reading and writing values, a
    method for determining if writing of certain values will fail
    (lockdown) and a change notification mechanism.

    The semantics of the interface are very precisely defined and
    implementations must carefully adhere to the expectations of
    callers that are documented on each of the interface methods.

    Some of the `GSettingsBackend` functions accept or return a
    [struct@GLib.Tree]. These trees always have strings as keys and
    [struct@GLib.Variant] as values.

    The `GSettingsBackend` API is exported to allow third-party
    implementations, but does not carry the same stability guarantees
    as the public GIO API. For this reason, you have to define the
    C preprocessor symbol `G_SETTINGS_ENABLE_BACKEND` before including
    `gio/gsettingsbackend.h`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def changed(self, key: str, origin_tag: object | None = None) -> None: ...
    def changed_tree(self, tree: GLib.Tree, origin_tag: object | None = None) -> None: ...
    @staticmethod
    def flatten_tree(tree: GLib.Tree) -> tuple[str, list, list | None]: ...
    @staticmethod
    def get_default() -> SettingsBackend: ...
    def keys_changed(self, path: str, items: list, origin_tag: object | None = None) -> None: ...
    def path_changed(self, path: str, origin_tag: object | None = None) -> None: ...
    def path_writable_changed(self, path: str) -> None: ...
    def writable_changed(self, key: str) -> None: ...

    # python methods
    def do_get_writable(
        self,
        key: str,
    ) -> bool:
        """
        get_writable(self, key:str) -> bool
        """
    def do_read(
        self,
        key: str,
        expected_type: GLib.VariantType,
        default_value: bool,
    ) -> GLib.Variant:
        """
        read(self, key:str, expected_type:GLib.VariantType, default_value:bool) -> GLib.Variant
        """
    def do_read_user_value(
        self,
        key: str,
        expected_type: GLib.VariantType,
    ) -> GLib.Variant:
        """
        read_user_value(self, key:str, expected_type:GLib.VariantType) -> GLib.Variant
        """
    def do_reset(
        self,
        key: str,
        origin_tag: typing.Any = None,
    ) -> None:
        """
        reset(self, key:str, origin_tag=None)
        """
    def do_subscribe(
        self,
        name: str,
    ) -> None:
        """
        subscribe(self, name:str)
        """
    def do_sync(
        self,
    ) -> None:
        """
        sync(self)
        """
    def do_unsubscribe(
        self,
        name: str,
    ) -> None:
        """
        unsubscribe(self, name:str)
        """
    def do_write(
        self,
        key: str,
        value: GLib.Variant,
        origin_tag: typing.Any = None,
    ) -> bool:
        """
        write(self, key:str, value:GLib.Variant, origin_tag=None) -> bool
        """
    def do_write_tree(
        self,
        tree: GLib.Tree,
        origin_tag: typing.Any = None,
    ) -> bool:
        """
        write_tree(self, tree:GLib.Tree, origin_tag=None) -> bool
        """

    ...

class SettingsBackendClass(GObject.GPointer):
    # gi Fields
    get_writable: get_writableSettingsBackendClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    read: readSettingsBackendClassCB = ...
    read_user_value: read_user_valueSettingsBackendClassCB = ...
    reset: resetSettingsBackendClassCB = ...
    subscribe: subscribeSettingsBackendClassCB = ...
    sync: syncSettingsBackendClassCB = ...
    unsubscribe: unsubscribeSettingsBackendClassCB = ...
    write: writeSettingsBackendClassCB = ...
    write_tree: write_treeSettingsBackendClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SettingsBackendPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SettingsClass(GObject.GPointer):
    # gi Fields
    change_event: change_eventSettingsClassCB = ...
    changed: changedSettingsClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    writable_change_event: writable_change_eventSettingsClassCB = ...
    writable_changed: writable_changedSettingsClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SettingsPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SettingsSchema(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_id(self) -> str: ...
    def get_key(self, name: str) -> SettingsSchemaKey: ...
    def get_path(self) -> str | None: ...
    def has_key(self, name: str) -> bool: ...
    def list_children(self) -> list: ...
    def list_keys(self) -> list: ...
    def ref(self) -> SettingsSchema: ...
    def unref(self) -> None: ...

    ...

class SettingsSchemaKey(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_default_value(self) -> GLib.Variant: ...
    def get_description(self) -> str | None: ...
    def get_name(self) -> str: ...
    def get_range(self) -> GLib.Variant: ...
    def get_summary(self) -> str | None: ...
    def get_value_type(self) -> GLib.VariantType: ...
    def range_check(self, value: GLib.Variant) -> bool: ...
    def ref(self) -> SettingsSchemaKey: ...
    def unref(self) -> None: ...

    ...

class SettingsSchemaSource(GObject.GBoxed):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_default() -> SettingsSchemaSource | None: ...
    def list_schemas(self, recursive: bool) -> tuple[list, list]: ...
    def lookup(self, schema_id: str, recursive: bool) -> SettingsSchema | None: ...
    @classmethod
    def new_from_directory(
        cls, directory: str, parent: SettingsSchemaSource | None, trusted: bool
    ) -> SettingsSchemaSource: ...
    def ref(self) -> SettingsSchemaSource: ...
    def unref(self) -> None: ...

    ...

class SimpleAction(GObject.Object):
    """
    A `GSimpleAction` is the obvious simple implementation of the
    [iface@Gio.Action] interface. This is the easiest way to create an action for
    purposes of adding it to a [class@Gio.SimpleActionGroup].
    """

    class Props(GObject.Object.Props):
        enabled: bool
        name: str
        parameter_type: GLib.VariantType | None  # [parameter-type]: changed because contained invalid characters
        state: GLib.Variant | None
        state_type: GLib.VariantType | None  # [state-type]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        enabled: bool = ...,
        name: str = ...,
        parameter_type: GLib.VariantType | None = ...,
        state: GLib.Variant | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, name: str, parameter_type: GLib.VariantType | None = None) -> SimpleAction: ...
    @classmethod
    def new_stateful(cls, name: str, parameter_type: GLib.VariantType | None, state: GLib.Variant) -> SimpleAction: ...
    def set_enabled(self, enabled: bool) -> None: ...
    def set_state(self, value: GLib.Variant) -> None: ...
    def set_state_hint(self, state_hint: GLib.Variant | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate"],
        handler: typing.Callable[[typing_extensions.Self, GLib.Variant | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["change-state"],
        handler: typing.Callable[[typing_extensions.Self, GLib.Variant | None], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parameter_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class SimpleActionGroup(GObject.Object):
    """
    `GSimpleActionGroup` is a hash table filled with [iface@Gio.Action] objects,
    implementing the [iface@Gio.ActionGroup] and [iface@Gio.ActionMap]
    interfaces.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_entries(self, entries: list, n_entries: int, user_data: object | None = None) -> None: ...
    @deprecated("deprecated")
    def insert(self, action: Action) -> None: ...
    @deprecated("deprecated")
    def lookup(self, action_name: str) -> Action: ...
    @classmethod
    def new(cls) -> SimpleActionGroup: ...
    @deprecated("deprecated")
    def remove(self, action_name: str) -> None: ...

    ...

class SimpleActionGroupClass(GObject.GPointer):
    # gi Fields
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SimpleActionGroupPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SimpleAsyncResult(GObject.Object):
    """
    As of GLib 2.46, `GSimpleAsyncResult` is deprecated in favor of
    [class@Gio.Task], which provides a simpler API.

    `GSimpleAsyncResult` implements [iface@Gio.AsyncResult].

    `GSimpleAsyncResult` handles [type@Gio.AsyncReadyCallback]s, error
    reporting, operation cancellation and the final state of an operation,
    completely transparent to the application. Results can be returned
    as a pointer e.g. for functions that return data that is collected
    asynchronously, a boolean value for checking the success or failure
    of an operation, or a `gssize` for operations which return the number
    of bytes modified by the operation; all of the simple return cases
    are covered.

    Most of the time, an application will not need to know of the details
    of this API; it is handled transparently, and any necessary operations
    are handled by [iface@Gio.AsyncResult]’s interface. However, if implementing
    a new GIO module, for writing language bindings, or for complex
    applications that need better control of how asynchronous operations
    are completed, it is important to understand this functionality.

    `GSimpleAsyncResult`s are tagged with the calling function to ensure
    that asynchronous functions and their finishing functions are used
    together correctly.

    To create a new `GSimpleAsyncResult`, call [ctor@Gio.SimpleAsyncResult.new].
    If the result needs to be created for a `GError`, use
    [ctor@Gio.SimpleAsyncResult.new_from_error] or
    [ctor@Gio.SimpleAsyncResult.new_take_error]. If a `GError` is not available
    (e.g. the asynchronous operation doesn’t take a `GError` argument),
    but the result still needs to be created for an error condition, use
    [ctor@Gio.SimpleAsyncResult.new_error] (or
    [method@Gio.SimpleAsyncResult.set_error_va] if your application or binding
    requires passing a variable argument list directly), and the error can then
    be propagated through the use of
    [method@Gio.SimpleAsyncResult.propagate_error].

    An asynchronous operation can be made to ignore a cancellation event by
    calling [method@Gio.SimpleAsyncResult.set_handle_cancellation] with a
    `GSimpleAsyncResult` for the operation and `FALSE`. This is useful for
    operations that are dangerous to cancel, such as close (which would
    cause a leak if cancelled before being run).

    `GSimpleAsyncResult` can integrate into GLib’s event loop,
    [type@GLib.MainLoop], or it can use [type@GLib.Thread]s.
    [method@Gio.SimpleAsyncResult.complete] will finish an I/O task directly
    from the point where it is called.
    [method@Gio.SimpleAsyncResult.complete_in_idle] will finish it from an idle
    handler in the  thread-default main context (see
    [method@GLib.MainContext.push_thread_default]) where the `GSimpleAsyncResult`
    was created. [method@Gio.SimpleAsyncResult.run_in_thread] will run the job in
    a separate thread and then use
    [method@Gio.SimpleAsyncResult.complete_in_idle] to deliver the result.

    To set the results of an asynchronous function,
    [method@Gio.SimpleAsyncResult.set_op_res_gpointer],
    [method@Gio.SimpleAsyncResult.set_op_res_gboolean], and
    [method@Gio.SimpleAsyncResult.set_op_res_gssize]
    are provided, setting the operation's result to a `gpointer`, `gboolean`, or
    `gssize`, respectively.

    Likewise, to get the result of an asynchronous function,
    [method@Gio.SimpleAsyncResult.get_op_res_gpointer],
    [method@Gio.SimpleAsyncResult.get_op_res_gboolean], and
    [method@Gio.SimpleAsyncResult.get_op_res_gssize] are
    provided, getting the operation’s result as a `gpointer`, `gboolean`, and
    `gssize`, respectively.

    For the details of the requirements implementations must respect, see
    [iface@Gio.AsyncResult].  A typical implementation of an asynchronous
    operation using `GSimpleAsyncResult` looks something like this:

    ```c
    static void
    baked_cb (Cake    *cake,
              gpointer user_data)
    {
      // In this example, this callback is not given a reference to the cake,
      // so the GSimpleAsyncResult has to take a reference to it.
      GSimpleAsyncResult *result = user_data;

      if (cake == NULL)
        g_simple_async_result_set_error (result,
                                         BAKER_ERRORS,
                                         BAKER_ERROR_NO_FLOUR,
                                         "Go to the supermarket");
      else
        g_simple_async_result_set_op_res_gpointer (result,
                                                   g_object_ref (cake),
                                                   g_object_unref);


      // In this example, we assume that baked_cb is called as a callback from
      // the mainloop, so it's safe to complete the operation synchronously here.
      // If, however, _baker_prepare_cake () might call its callback without
      // first returning to the mainloop — inadvisable, but some APIs do so —
      // we would need to use g_simple_async_result_complete_in_idle().
      g_simple_async_result_complete (result);
      g_object_unref (result);
    }

    void
    baker_bake_cake_async (Baker              *self,
                           guint               radius,
                           GAsyncReadyCallback callback,
                           gpointer            user_data)
    {
      GSimpleAsyncResult *simple;
      Cake               *cake;

      if (radius < 3)
        {
          g_simple_async_report_error_in_idle (G_OBJECT (self),
                                               callback,
                                               user_data,
                                               BAKER_ERRORS,
                                               BAKER_ERROR_TOO_SMALL,
                                               "%ucm radius cakes are silly",
                                               radius);
          return;
        }

      simple = g_simple_async_result_new (G_OBJECT (self),
                                          callback,
                                          user_data,
                                          baker_bake_cake_async);
      cake = _baker_get_cached_cake (self, radius);

      if (cake != NULL)
        {
          g_simple_async_result_set_op_res_gpointer (simple,
                                                     g_object_ref (cake),
                                                     g_object_unref);
          g_simple_async_result_complete_in_idle (simple);
          g_object_unref (simple);
          // Drop the reference returned by _baker_get_cached_cake();
          // the GSimpleAsyncResult has taken its own reference.
          g_object_unref (cake);
          return;
        }

      _baker_prepare_cake (self, radius, baked_cb, simple);
    }

    Cake *
    baker_bake_cake_finish (Baker        *self,
                            GAsyncResult *result,
                            GError      **error)
    {
      GSimpleAsyncResult *simple;
      Cake               *cake;

      g_return_val_if_fail (g_simple_async_result_is_valid (result,
                                                            G_OBJECT (self),
                                                            baker_bake_cake_async),
                            NULL);

      simple = (GSimpleAsyncResult *) result;

      if (g_simple_async_result_propagate_error (simple, error))
        return NULL;

      cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
      return g_object_ref (cake);
    }
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def complete(self) -> None: ...
    @deprecated("deprecated")
    def complete_in_idle(self) -> None: ...
    @deprecated("deprecated")
    def get_op_res_gboolean(self) -> bool: ...
    @deprecated("deprecated")
    def get_op_res_gssize(self) -> int: ...
    @deprecated("deprecated")
    @staticmethod
    def is_valid(
        result: AsyncResult, source: GObject.Object | None = None, source_tag: object | None = None
    ) -> bool: ...
    @deprecated("deprecated")
    @classmethod
    def new(
        cls,
        source_object: GObject.Object | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
        source_tag: object | None = None,
    ) -> SimpleAsyncResult: ...
    @deprecated("deprecated")
    @classmethod
    def new_from_error(
        cls,
        source_object: GObject.Object | None,
        callback: AsyncReadyCallback | None,
        user_data: object | None,
        error: None,
    ) -> SimpleAsyncResult: ...
    @deprecated("deprecated")
    def propagate_error(self) -> bool: ...
    @deprecated("deprecated")
    def set_check_cancellable(self, check_cancellable: Cancellable | None = None) -> None: ...
    @deprecated("deprecated")
    def set_from_error(self, error: None) -> None: ...
    @deprecated("deprecated")
    def set_handle_cancellation(self, handle_cancellation: bool) -> None: ...
    @deprecated("deprecated")
    def set_op_res_gboolean(self, op_res: bool) -> None: ...
    @deprecated("deprecated")
    def set_op_res_gssize(self, op_res: int) -> None: ...

    ...

class SimpleAsyncResultClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SimpleIOStream(IOStream):
    """
    `GSimpleIOStream` creates a [class@Gio.IOStream] from an arbitrary
    [class@Gio.InputStream] and [class@Gio.OutputStream]. This allows any pair of
    input and output streams to be used with [class@Gio.IOStream] methods.

    This is useful when you obtained a [class@Gio.InputStream] and a
    [class@Gio.OutputStream] by other means, for instance creating them with
    platform specific methods as
    [`g_unix_input_stream_new()`](../gio-unix/ctor.UnixInputStream.new.html)
    (from `gio-unix-2.0.pc` / `GioUnix-2.0`), and you want to
    take advantage of the methods provided by [class@Gio.IOStream].
    """

    class Props(IOStream.Props):
        input_stream: InputStream | None  # [input-stream]: changed because contained invalid characters
        output_stream: OutputStream | None  # [output-stream]: changed because contained invalid characters

    # gi Methods
    def __init__(self, input_stream: InputStream | None = ..., output_stream: OutputStream | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, input_stream: InputStream, output_stream: OutputStream) -> IOStream: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::output_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class SimplePermission(Permission):
    """
    `GSimplePermission` is a trivial implementation of [class@Gio.Permission]
    that represents a permission that is either always or never allowed.  The
    value is given at construction and doesn’t change.

    Calling [method@Gio.Permission.acquire] or [method@Gio.Permission.release]
    on a `GSimplePermission` will result in errors.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, allowed: bool) -> Permission: ...

    ...

class SimpleProxyResolver(GObject.Object):
    """
    `GSimpleProxyResolver` is a simple [iface@Gio.ProxyResolver] implementation
    that handles a single default proxy, multiple URI-scheme-specific
    proxies, and a list of hosts that proxies should not be used for.

    `GSimpleProxyResolver` is never the default proxy resolver, but it
    can be used as the base class for another proxy resolver
    implementation, or it can be created and used manually, such as
    with [method@Gio.SocketClient.set_proxy_resolver].
    """

    class Props(GObject.Object.Props):
        default_proxy: str  # [default-proxy]: changed because contained invalid characters
        ignore_hosts: list | None  # [ignore-hosts]: changed because contained invalid characters

    # gi Methods
    def __init__(self, default_proxy: str = ..., ignore_hosts: list | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def new(default_proxy: str | None = None, ignore_hosts: list | None = None) -> ProxyResolver: ...
    def set_default_proxy(self, default_proxy: str | None = None) -> None: ...
    def set_ignore_hosts(self, ignore_hosts: list) -> None: ...
    def set_uri_proxy(self, uri_scheme: str, proxy: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_proxy"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ignore_hosts"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class SimpleProxyResolverClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SimpleProxyResolverPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Socket(GObject.Object):
    """
    A `GSocket` is a low-level networking primitive. It is a more or less
    direct mapping of the BSD socket API in a portable GObject based API.
    It supports both the UNIX socket implementations and winsock2 on Windows.

    `GSocket` is the platform independent base upon which the higher level
    network primitives are based. Applications are not typically meant to
    use it directly, but rather through classes like [class@Gio.SocketClient],
    [class@Gio.SocketService] and [class@Gio.SocketConnection]. However there may
    be cases where direct use of `GSocket` is useful.

    `GSocket` implements the [iface@Gio.Initable] interface, so if it is manually
    constructed by e.g. [ctor@GObject.Object.new] you must call
    [method@Gio.Initable.init] and check the results before using the object.
    This is done automatically in [ctor@Gio.Socket.new] and
    [ctor@Gio.Socket.new_from_fd], so these functions can return `NULL`.

    Sockets operate in two general modes, blocking or non-blocking. When
    in blocking mode all operations (which don’t take an explicit blocking
    parameter) block until the requested operation
    is finished or there is an error. In non-blocking mode all calls that
    would block return immediately with a `G_IO_ERROR_WOULD_BLOCK` error.
    To know when a call would successfully run you can call
    [method@Gio.Socket.condition_check], or [method@Gio.Socket.condition_wait].
    You can also use [method@Gio.Socket.create_source] and attach it to a
    [type@GLib.MainContext] to get callbacks when I/O is possible.
    Note that all sockets are always set to non blocking mode in the system, and
    blocking mode is emulated in `GSocket`.

    When working in non-blocking mode applications should always be able to
    handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other
    function said that I/O was possible. This can easily happen in case
    of a race condition in the application, but it can also happen for other
    reasons. For instance, on Windows a socket is always seen as writable
    until a write returns `G_IO_ERROR_WOULD_BLOCK`.

    `GSocket`s can be either connection oriented or datagram based.
    For connection oriented types you must first establish a connection by
    either connecting to an address or accepting a connection from another
    address. For connectionless socket types the target/source address is
    specified or received in each I/O operation.

    All socket file descriptors are set to be close-on-exec.

    Note that creating a `GSocket` causes the signal `SIGPIPE` to be
    ignored for the remainder of the program. If you are writing a
    command-line utility that uses `GSocket`, you may need to take into
    account the fact that your program will not automatically be killed
    if it tries to write to `stdout` after it has been closed.

    Like most other APIs in GLib, `GSocket` is not inherently thread safe. To use
    a `GSocket` concurrently from multiple threads, you must implement your own
    locking.

    ## Nagle’s algorithm

    Since GLib 2.80, `GSocket` will automatically set the `TCP_NODELAY` option on
    all `G_SOCKET_TYPE_STREAM` sockets. This disables
    [Nagle’s algorithm](https://en.wikipedia.org/wiki/Nagle%27s_algorithm) as it
    typically does more harm than good on modern networks.

    If your application needs Nagle’s algorithm enabled, call
    [method@Gio.Socket.set_option] after constructing a `GSocket` to enable it:
    ```c
    socket = g_socket_new (…, G_SOCKET_TYPE_STREAM, …);
    if (socket != NULL)
      {
        g_socket_set_option (socket, IPPROTO_TCP, TCP_NODELAY, FALSE, &local_error);
        // handle error if needed
      }
    ```
    """

    class Props(GObject.Object.Props):
        blocking: bool
        broadcast: bool
        family: SocketFamily
        fd: int
        keepalive: bool
        listen_backlog: int  # [listen-backlog]: changed because contained invalid characters
        local_address: SocketAddress | None  # [local-address]: changed because contained invalid characters
        multicast_loopback: bool  # [multicast-loopback]: changed because contained invalid characters
        multicast_ttl: int  # [multicast-ttl]: changed because contained invalid characters
        protocol: SocketProtocol
        remote_address: SocketAddress | None  # [remote-address]: changed because contained invalid characters
        timeout: int
        ttl: int
        type: SocketType

    # gi Methods
    def __init__(
        self,
        blocking: bool = ...,
        broadcast: bool = ...,
        family: SocketFamily = ...,
        fd: int = ...,
        keepalive: bool = ...,
        listen_backlog: int = ...,
        multicast_loopback: bool = ...,
        multicast_ttl: int = ...,
        protocol: SocketProtocol = ...,
        timeout: int = ...,
        ttl: int = ...,
        type: SocketType = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def accept(self, cancellable: Cancellable | None = None) -> Socket: ...
    def bind(self, address: SocketAddress, allow_reuse: bool) -> bool: ...
    def check_connect_result(self) -> bool: ...
    def close(self) -> bool: ...
    def condition_check(self, condition: GLib.IOCondition) -> GLib.IOCondition: ...
    def condition_timed_wait(
        self, condition: GLib.IOCondition, timeout_us: int, cancellable: Cancellable | None = None
    ) -> bool: ...
    def condition_wait(self, condition: GLib.IOCondition, cancellable: Cancellable | None = None) -> bool: ...
    def connect(self, address: SocketAddress, cancellable: Cancellable | None = None) -> bool:
        """
        [note from gi-stub-gen] Socket has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    def connection_factory_create_connection(self) -> SocketConnection: ...
    def get_available_bytes(self) -> int: ...
    @property
    def get_blocking(self) -> bool: ...
    @property
    def get_broadcast(self) -> bool: ...
    def get_credentials(self) -> Credentials: ...
    @property
    def get_family(self) -> SocketFamily: ...
    @property
    def get_fd(self) -> int: ...
    @property
    def get_keepalive(self) -> bool: ...
    @property
    def get_listen_backlog(self) -> int: ...
    @property
    def get_local_address(self) -> SocketAddress: ...
    @property
    def get_multicast_loopback(self) -> bool: ...
    @property
    def get_multicast_ttl(self) -> int: ...
    def get_option(self, level: int, optname: int) -> tuple[bool, int]: ...
    @property
    def get_protocol(self) -> SocketProtocol: ...
    @property
    def get_remote_address(self) -> SocketAddress: ...
    def get_socket_type(self) -> SocketType: ...
    @property
    def get_timeout(self) -> int: ...
    @property
    def get_ttl(self) -> int: ...
    def is_closed(self) -> bool: ...
    def is_connected(self) -> bool: ...
    def join_multicast_group(self, group: InetAddress, source_specific: bool, iface: str | None = None) -> bool: ...
    def join_multicast_group_ssm(
        self, group: InetAddress, source_specific: InetAddress | None = None, iface: str | None = None
    ) -> bool: ...
    def leave_multicast_group(self, group: InetAddress, source_specific: bool, iface: str | None = None) -> bool: ...
    def leave_multicast_group_ssm(
        self, group: InetAddress, source_specific: InetAddress | None = None, iface: str | None = None
    ) -> bool: ...
    def listen(self) -> bool: ...
    @classmethod
    def new(cls, family: SocketFamily, type: SocketType, protocol: SocketProtocol) -> Socket: ...
    @classmethod
    def new_from_fd(cls, fd: int) -> Socket: ...
    def receive(self, size: int, cancellable: Cancellable | None = None) -> tuple[int, list]: ...
    def receive_bytes(self, size: int, timeout_us: int, cancellable: Cancellable | None = None) -> GLib.Bytes: ...
    def receive_bytes_from(
        self, size: int, timeout_us: int, cancellable: Cancellable | None = None
    ) -> tuple[GLib.Bytes, SocketAddress | None]: ...
    def receive_from(
        self, size: int, cancellable: Cancellable | None = None
    ) -> tuple[int, SocketAddress | None, list]: ...
    def receive_message(
        self, vectors: list, num_vectors: int, flags: int, cancellable: Cancellable | None = None
    ) -> tuple[int, SocketAddress | None, list | None, int, int]: ...
    def receive_messages(
        self, messages: list, num_messages: int, flags: int, cancellable: Cancellable | None = None
    ) -> int: ...
    def receive_with_blocking(
        self, size: int, blocking: bool, cancellable: Cancellable | None = None
    ) -> tuple[int, list]: ...
    def send(self, buffer: list, size: int, cancellable: Cancellable | None = None) -> int: ...
    def send_message(
        self,
        address: SocketAddress | None,
        vectors: list,
        num_vectors: int,
        messages: list | None,
        num_messages: int,
        flags: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...
    def send_message_with_timeout(
        self,
        address: SocketAddress | None,
        vectors: list,
        num_vectors: int,
        messages: list | None,
        num_messages: int,
        flags: int,
        timeout_us: int,
        cancellable: Cancellable | None = None,
    ) -> tuple[PollableReturn, int | None]: ...
    def send_messages(
        self, messages: list, num_messages: int, flags: int, cancellable: Cancellable | None = None
    ) -> int: ...
    def send_to(
        self, address: SocketAddress | None, buffer: list, size: int, cancellable: Cancellable | None = None
    ) -> int: ...
    def send_with_blocking(
        self, buffer: list, size: int, blocking: bool, cancellable: Cancellable | None = None
    ) -> int: ...
    def set_blocking(self, blocking: bool) -> None: ...
    def set_broadcast(self, broadcast: bool) -> None: ...
    def set_keepalive(self, keepalive: bool) -> None: ...
    def set_listen_backlog(self, backlog: int) -> None: ...
    def set_multicast_loopback(self, loopback: bool) -> None: ...
    def set_multicast_ttl(self, ttl: int) -> None: ...
    def set_option(self, level: int, optname: int, value: int) -> bool: ...
    def set_timeout(self, timeout: int) -> None: ...
    def set_ttl(self, ttl: int) -> None: ...
    def shutdown(self, shutdown_read: bool, shutdown_write: bool) -> bool: ...
    def speaks_ipv4(self) -> bool: ...

    ...

class SocketAddress(GObject.Object):
    """
    `GSocketAddress` is the equivalent of
    [`struct sockaddr`](man:sockaddr(3type)) and its subtypes in the BSD sockets
    API. This is an abstract class; use [class@Gio.InetSocketAddress] for
    internet sockets, or [class@Gio.UnixSocketAddress] for UNIX domain sockets.
    """

    class Props(GObject.Object.Props):
        family: SocketFamily

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_family(self) -> SocketFamily: ...
    def get_native_size(self) -> int: ...
    @classmethod
    def new_from_native(cls, native: object, len: int) -> SocketAddress: ...
    def to_native(self, dest: object | None, destlen: int) -> bool: ...

    # python methods
    def do_get_family(
        self,
    ) -> SocketFamily:
        """
        get_family(self) -> Gio.SocketFamily
        """
    def do_get_native_size(
        self,
    ) -> int:
        """
        get_native_size(self) -> int
        """
    def do_to_native(
        self,
        dest: typing.Any,
        destlen: int,
    ) -> bool:
        """
        to_native(self, dest=None, destlen:int) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class SocketAddressClass(GObject.GPointer):
    # gi Fields
    get_family: get_familySocketAddressClassCB = ...
    get_native_size: get_native_sizeSocketAddressClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    to_native: to_nativeSocketAddressClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketAddressEnumerator(GObject.Object):
    """
    `GSocketAddressEnumerator` is an enumerator type for
    [class@Gio.SocketAddress] instances. It is returned by enumeration functions
    such as [method@Gio.SocketConnectable.enumerate], which returns a
    `GSocketAddressEnumerator` to list each [class@Gio.SocketAddress] which could
    be used to connect to that [iface@Gio.SocketConnectable].

    Enumeration is typically a blocking operation, so the asynchronous methods
    [method@Gio.SocketAddressEnumerator.next_async] and
    [method@Gio.SocketAddressEnumerator.next_finish] should be used where
    possible.

    Each `GSocketAddressEnumerator` can only be enumerated once. Once
    [method@Gio.SocketAddressEnumerator.next] has returned `NULL`, further
    enumeration with that `GSocketAddressEnumerator` is not possible, and it can
    be unreffed.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def next(self, cancellable: Cancellable | None = None) -> SocketAddress | None: ...
    async def next_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def next_finish(self, result: AsyncResult) -> SocketAddress | None: ...

    # python methods
    def do_next(
        self,
        cancellable: Cancellable | None = None,
    ) -> SocketAddress | None:
        """
        next(self, cancellable:Gio.Cancellable=None) -> Gio.SocketAddress or None
        """
    def do_next_async(
        self,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        next_async(self, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_next_finish(
        self,
        result: AsyncResult,
    ) -> SocketAddress | None:
        """
        next_finish(self, result:Gio.AsyncResult) -> Gio.SocketAddress or None
        """

    ...

class SocketAddressEnumeratorClass(GObject.GPointer):
    # gi Fields
    next: nextSocketAddressEnumeratorClassCB | None = ...
    next_async: next_asyncSocketAddressEnumeratorClassCB = ...
    next_finish: next_finishSocketAddressEnumeratorClassCB | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketClient(GObject.Object):
    """
    `GSocketClient` is a lightweight high-level utility class for connecting to
    a network host using a connection oriented socket type.

    You create a `GSocketClient` object, set any options you want, and then
    call a sync or async connect operation, which returns a
    [class@Gio.SocketConnection] subclass on success.

    The type of the [class@Gio.SocketConnection] object returned depends on the
    type of the underlying socket that is in use. For instance, for a TCP/IP
    connection it will be a [class@Gio.TcpConnection].

    As `GSocketClient` is a lightweight object, you don't need to cache it. You
    can just create a new one any time you need one.
    """

    class Props(GObject.Object.Props):
        enable_proxy: bool  # [enable-proxy]: changed because contained invalid characters
        family: SocketFamily
        local_address: SocketAddress | None  # [local-address]: changed because contained invalid characters
        protocol: SocketProtocol
        proxy_resolver: ProxyResolver | None  # [proxy-resolver]: changed because contained invalid characters
        timeout: int
        tls: bool
        tls_validation_flags: (
            TlsCertificateFlags  # [tls-validation-flags]: changed because contained invalid characters
        )
        type: SocketType

    # gi Methods
    def __init__(
        self,
        enable_proxy: bool = ...,
        family: SocketFamily = ...,
        local_address: SocketAddress | None = ...,
        protocol: SocketProtocol = ...,
        proxy_resolver: ProxyResolver | None = ...,
        timeout: int = ...,
        tls: bool = ...,
        tls_validation_flags: TlsCertificateFlags = ...,
        type: SocketType = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_application_proxy(self, protocol: str) -> None: ...
    def connect(self, connectable: SocketConnectable, cancellable: Cancellable | None = None) -> SocketConnection:
        """
        [note from gi-stub-gen] SocketClient has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    async def connect_async(
        self,
        connectable: SocketConnectable,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def connect_finish(self, result: AsyncResult) -> SocketConnection: ...
    def connect_to_host(
        self, host_and_port: str, default_port: int, cancellable: Cancellable | None = None
    ) -> SocketConnection: ...
    async def connect_to_host_async(
        self,
        host_and_port: str,
        default_port: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def connect_to_host_finish(self, result: AsyncResult) -> SocketConnection: ...
    def connect_to_service(
        self, domain: str, service: str, cancellable: Cancellable | None = None
    ) -> SocketConnection: ...
    async def connect_to_service_async(
        self,
        domain: str,
        service: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def connect_to_service_finish(self, result: AsyncResult) -> SocketConnection: ...
    def connect_to_uri(
        self, uri: str, default_port: int, cancellable: Cancellable | None = None
    ) -> SocketConnection: ...
    async def connect_to_uri_async(
        self,
        uri: str,
        default_port: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def connect_to_uri_finish(self, result: AsyncResult) -> SocketConnection: ...
    @property
    def get_enable_proxy(self) -> bool: ...
    @property
    def get_family(self) -> SocketFamily: ...
    @property
    def get_local_address(self) -> SocketAddress | None: ...
    @property
    def get_protocol(self) -> SocketProtocol: ...
    @property
    def get_proxy_resolver(self) -> ProxyResolver: ...
    def get_socket_type(self) -> SocketType: ...
    @property
    def get_timeout(self) -> int: ...
    @property
    def get_tls(self) -> bool: ...
    @deprecated("deprecated")
    @property
    def get_tls_validation_flags(self) -> TlsCertificateFlags: ...
    @classmethod
    def new(cls) -> SocketClient: ...
    def set_enable_proxy(self, enable: bool) -> None: ...
    def set_family(self, family: SocketFamily) -> None: ...
    def set_local_address(self, address: SocketAddress | None = None) -> None: ...
    def set_protocol(self, protocol: SocketProtocol) -> None: ...
    def set_proxy_resolver(self, proxy_resolver: ProxyResolver | None = None) -> None: ...
    def set_socket_type(self, type: SocketType) -> None: ...
    def set_timeout(self, timeout: int) -> None: ...
    def set_tls(self, tls: bool) -> None: ...
    @deprecated("deprecated")
    def set_tls_validation_flags(self, flags: TlsCertificateFlags) -> None: ...

    # python methods
    def do_event(
        self,
        event: SocketClientEvent,
        connectable: SocketConnectable,
        connection: IOStream,
    ) -> None:
        """
        event(self, event:Gio.SocketClientEvent, connectable:Gio.SocketConnectable, connection:Gio.IOStream)
        """

    ...

class SocketClientClass(GObject.GPointer):
    # gi Fields
    event: eventSocketClientClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketClientPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketConnectable(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def enumerate(self) -> SocketAddressEnumerator: ...
    def proxy_enumerate(self) -> SocketAddressEnumerator: ...
    def to_string(self) -> str: ...

    ...

class SocketConnectableIface(GObject.GPointer):
    # gi Fields
    enumerate: enumerateSocketConnectableIfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    proxy_enumerate: proxy_enumerateSocketConnectableIfaceCB = ...
    to_string: to_stringSocketConnectableIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketConnection(IOStream):
    """
    `GSocketConnection` is a [class@Gio.IOStream] for a connected socket. They
    can be created either by [class@Gio.SocketClient] when connecting to a host,
    or by [class@Gio.SocketListener] when accepting a new client.

    The type of the `GSocketConnection` object returned from these calls
    depends on the type of the underlying socket that is in use. For
    instance, for a TCP/IP connection it will be a [class@Gio.TcpConnection].

    Choosing what type of object to construct is done with the socket
    connection factory, and it is possible for third parties to register
    custom socket connection types for specific combination of socket
    family/type/protocol using [func@Gio.SocketConnection.factory_register_type].

    To close a `GSocketConnection`, use [method@Gio.IOStream.close]. Closing both
    substreams of the [class@Gio.IOStream] separately will not close the
    underlying [class@Gio.Socket].
    """

    class Props(IOStream.Props):
        socket: Socket | None

    # gi Methods
    def __init__(self, socket: Socket | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def connect(self, address: SocketAddress, cancellable: Cancellable | None = None) -> bool:
        """
        [note from gi-stub-gen] SocketConnection has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    async def connect_async(
        self,
        address: SocketAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def connect_finish(self, result: AsyncResult) -> bool: ...
    @staticmethod
    def factory_lookup_type(family: SocketFamily, type: SocketType, protocol_id: int) -> GObject.GType: ...
    @staticmethod
    def factory_register_type(g_type: GObject.GType, family: SocketFamily, type: SocketType, protocol: int) -> None: ...
    def get_local_address(self) -> SocketAddress: ...
    def get_remote_address(self) -> SocketAddress: ...
    @property
    def get_socket(self) -> Socket: ...
    def is_connected(self) -> bool: ...

    ...

class SocketConnectionClass(GObject.GPointer):
    # gi Fields
    parent_class: IOStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketControlMessage(GObject.Object):
    """
    A `GSocketControlMessage` is a special-purpose utility message that
    can be sent to or received from a [class@Gio.Socket]. These types of
    messages are often called ‘ancillary data’.

    The message can represent some sort of special instruction to or
    information from the socket or can represent a special kind of
    transfer to the peer (for example, sending a file descriptor over
    a UNIX socket).

    These messages are sent with [method@Gio.Socket.send_message] and received
    with [method@Gio.Socket.receive_message].

    To extend the set of control message that can be sent, subclass this
    class and override the `get_size`, `get_level`, `get_type` and `serialize`
    methods.

    To extend the set of control messages that can be received, subclass
    this class and implement the `deserialize` method. Also, make sure your
    class is registered with the [type@GObject.Type] type system before calling
    [method@Gio.Socket.receive_message] to read such a message.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def deserialize(level: int, type: int, size: int, data: list) -> SocketControlMessage | None: ...
    def get_level(self) -> int: ...
    def get_msg_type(self) -> int: ...
    def get_size(self) -> int: ...
    def serialize(self, data: object) -> None: ...

    # python methods
    def do_get_level(
        self,
    ) -> int:
        """
        get_level(self) -> int
        """
    def do_get_size(
        self,
    ) -> int:
        """
        get_size(self) -> int
        """
    def do_get_type(
        self,
    ) -> int:
        """
        get_type(self) -> int
        """
    def do_serialize(
        self,
        data: typing.Any,
    ) -> None:
        """
        serialize(self, data)
        """

    ...

class SocketControlMessageClass(GObject.GPointer):
    # gi Fields
    get_level: get_levelSocketControlMessageClassCB = ...
    get_size: get_sizeSocketControlMessageClassCB = ...
    get_type: get_typeSocketControlMessageClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    serialize: serializeSocketControlMessageClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketControlMessagePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketListener(GObject.Object):
    """
    A `GSocketListener` is an object that keeps track of a set
    of server sockets and helps you accept sockets from any of the
    socket, either sync or async.

    Add addresses and ports to listen on using
    [method@Gio.SocketListener.add_address] and
    [method@Gio.SocketListener.add_inet_port]. These will be listened on until
    [method@Gio.SocketListener.close] is called. Dropping your final reference to
    the `GSocketListener` will not cause [method@Gio.SocketListener.close] to be
    called implicitly, as some references to the `GSocketListener` may be held
    internally.

    If you want to implement a network server, also look at
    [class@Gio.SocketService] and [class@Gio.ThreadedSocketService] which are
    subclasses of `GSocketListener` that make this even easier.
    """

    class Props(GObject.Object.Props):
        listen_backlog: int  # [listen-backlog]: changed because contained invalid characters

    # gi Methods
    def __init__(self, listen_backlog: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def accept(self, cancellable: Cancellable | None = None) -> tuple[SocketConnection, GObject.Object | None]: ...
    async def accept_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def accept_finish(self, result: AsyncResult) -> tuple[SocketConnection, GObject.Object | None]: ...
    def accept_socket(self, cancellable: Cancellable | None = None) -> tuple[Socket, GObject.Object | None]: ...
    async def accept_socket_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def accept_socket_finish(self, result: AsyncResult) -> tuple[Socket, GObject.Object | None]: ...
    def add_address(
        self,
        address: SocketAddress,
        type: SocketType,
        protocol: SocketProtocol,
        source_object: GObject.Object | None = None,
    ) -> tuple[bool, SocketAddress | None]: ...
    def add_any_inet_port(self, source_object: GObject.Object | None = None) -> int: ...
    def add_inet_port(self, port: int, source_object: GObject.Object | None = None) -> bool: ...
    def add_socket(self, socket: Socket, source_object: GObject.Object | None = None) -> bool: ...
    def close(self) -> None: ...
    @classmethod
    def new(cls) -> SocketListener: ...
    def set_backlog(self, listen_backlog: int) -> None: ...

    # python methods
    def do_changed(
        self,
    ) -> None:
        """
        changed(self)
        """
    def do_event(
        self,
        event: SocketListenerEvent,
        socket: Socket,
    ) -> None:
        """
        event(self, event:Gio.SocketListenerEvent, socket:Gio.Socket)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["event"],
        handler: typing.Callable[[typing_extensions.Self, SocketListenerEvent, Socket], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::listen_backlog"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class SocketListenerClass(GObject.GPointer):
    # gi Fields
    changed: changedSocketListenerClassCB = ...
    event: eventSocketListenerClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketListenerPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketService(SocketListener):
    """
    A `GSocketService` is an object that represents a service that
    is provided to the network or over local sockets.  When a new
    connection is made to the service the [signal@Gio.SocketService::incoming]
    signal is emitted.

    A `GSocketService` is a subclass of [class@Gio.SocketListener] and you need
    to add the addresses you want to accept connections on with the
    [class@Gio.SocketListener] APIs.

    There are two options for implementing a network service based on
    `GSocketService`. The first is to create the service using
    [ctor@Gio.SocketService.new] and to connect to the
    [signal@Gio.SocketService::incoming] signal. The second is to subclass
    `GSocketService` and override the default signal handler implementation.

    In either case, the handler must immediately return, or else it
    will block additional incoming connections from being serviced.
    If you are interested in writing connection handlers that contain
    blocking code then see [class@Gio.ThreadedSocketService].

    The socket service runs on the main loop of the
    thread-default context (see
    [method@GLib.MainContext.push_thread_default]) of the thread it is
    created in, and is not threadsafe in general. However, the calls to start and
    stop the service are thread-safe so these can be used from threads that
    handle incoming clients.
    """

    class Props(SocketListener.Props):
        active: bool

    # gi Methods
    def __init__(self, active: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def is_active(self) -> bool: ...
    @classmethod
    def new(cls) -> SocketService: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

    # python methods
    def do_incoming(
        self,
        connection: SocketConnection,
        source_object: GObject.Object,
    ) -> bool:
        """
        incoming(self, connection:Gio.SocketConnection, source_object:GObject.Object) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["incoming"],
        handler: typing.Callable[[typing_extensions.Self, SocketConnection, GObject.Object | None], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class SocketServiceClass(GObject.GPointer):
    # gi Fields
    incoming: incomingSocketServiceClassCB = ...
    parent_class: SocketListenerClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SocketServicePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class SrvTarget(GObject.GBoxed):
    # gi Methods
    def copy(self) -> SrvTarget: ...
    def free(self) -> None: ...
    def get_hostname(self) -> str: ...
    def get_port(self) -> int: ...
    def get_priority(self) -> int: ...
    def get_weight(self) -> int: ...
    @classmethod
    def new(cls, hostname: str, port: int, priority: int, weight: int) -> SrvTarget: ...

    # python methods
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    ...

class StaticResource(GObject.GPointer):
    # gi Fields
    data: int = ...
    data_len: int = ...
    next: StaticResource | None = ...
    resource: Resource | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def fini(self) -> None: ...
    def get_resource(self) -> Resource: ...
    def init(self) -> None: ...

    ...

class Subprocess(GObject.Object):
    """
    `GSubprocess` allows the creation of and interaction with child
    processes.

    Processes can be communicated with using standard GIO-style APIs (ie:
    [class@Gio.InputStream], [class@Gio.OutputStream]). There are GIO-style APIs
    to wait for process termination (ie: cancellable and with an asynchronous
    variant).

    There is an API to force a process to terminate, as well as a
    race-free API for sending UNIX signals to a subprocess.

    One major advantage that GIO brings over the core GLib library is
    comprehensive API for asynchronous I/O, such
    [method@Gio.OutputStream.splice_async].  This makes `GSubprocess`
    significantly more powerful and flexible than equivalent APIs in
    some other languages such as the `subprocess.py`
    included with Python.  For example, using `GSubprocess` one could
    create two child processes, reading standard output from the first,
    processing it, and writing to the input stream of the second, all
    without blocking the main loop.

    A powerful [method@Gio.Subprocess.communicate] API is provided similar to the
    `communicate()` method of `subprocess.py`. This enables very easy
    interaction with a subprocess that has been opened with pipes.

    `GSubprocess` defaults to tight control over the file descriptors open
    in the child process, avoiding dangling-FD issues that are caused by
    a simple `fork()`/`exec()`.  The only open file descriptors in the
    spawned process are ones that were explicitly specified by the
    `GSubprocess` API (unless `G_SUBPROCESS_FLAGS_INHERIT_FDS` was
    specified).

    `GSubprocess` will quickly reap all child processes as they exit,
    avoiding ‘zombie processes’ remaining around for long periods of
    time.  [method@Gio.Subprocess.wait] can be used to wait for this to happen,
    but it will happen even without the call being explicitly made.

    As a matter of principle, `GSubprocess` has no API that accepts
    shell-style space-separated strings.  It will, however, match the
    typical shell behaviour of searching the `PATH` for executables that do
    not contain a directory separator in their name. By default, the `PATH`
    of the current process is used.  You can specify
    `G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP` to use the `PATH` of the
    launcher environment instead.

    `GSubprocess` attempts to have a very simple API for most uses (ie:
    spawning a subprocess with arguments and support for most typical
    kinds of input and output redirection).  See [ctor@Gio.Subprocess.new]. The
    [class@Gio.SubprocessLauncher] API is provided for more complicated cases
    (advanced types of redirection, environment variable manipulation,
    change of working directory, child setup functions, etc).

    A typical use of `GSubprocess` will involve calling
    [ctor@Gio.Subprocess.new], followed by [method@Gio.Subprocess.wait_async] or
    [method@Gio.Subprocess.wait].  After the process exits, the status can be
    checked using functions such as [method@Gio.Subprocess.get_if_exited] (which
    are similar to the familiar `WIFEXITED`-style POSIX macros).

    Note that as of GLib 2.82, creating a `GSubprocess` causes the signal
    `SIGPIPE` to be ignored for the remainder of the program. If you are writing
    a command-line utility that uses `GSubprocess`, you may need to take into
    account the fact that your program will not automatically be killed
    if it tries to write to `stdout` after it has been closed.
    """

    class Props(GObject.Object.Props):
        argv: list | None
        flags: SubprocessFlags

    # gi Methods
    def __init__(self, argv: list | None = ..., flags: SubprocessFlags = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def communicate(
        self, stdin_buf: GLib.Bytes | None = None, cancellable: Cancellable | None = None
    ) -> tuple[bool, GLib.Bytes | None, GLib.Bytes | None]: ...
    async def communicate_async(
        self,
        stdin_buf: GLib.Bytes | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def communicate_finish(self, result: AsyncResult) -> tuple[bool, GLib.Bytes | None, GLib.Bytes | None]: ...
    def communicate_utf8(
        self, stdin_buf: str | None = None, cancellable: Cancellable | None = None
    ) -> tuple[bool, str | None, str | None]: ...
    async def communicate_utf8_async(
        self,
        stdin_buf: str | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def communicate_utf8_finish(self, result: AsyncResult) -> tuple[bool, str | None, str | None]: ...
    def force_exit(self) -> None: ...
    def get_exit_status(self) -> int: ...
    def get_identifier(self) -> str | None: ...
    def get_if_exited(self) -> bool: ...
    def get_if_signaled(self) -> bool: ...
    def get_status(self) -> int: ...
    def get_stderr_pipe(self) -> InputStream | None: ...
    def get_stdin_pipe(self) -> OutputStream | None: ...
    def get_stdout_pipe(self) -> InputStream | None: ...
    def get_successful(self) -> bool: ...
    def get_term_sig(self) -> int: ...
    @classmethod
    def new(cls, argv: list, flags: SubprocessFlags) -> Subprocess: ...
    def send_signal(self, signal_num: int) -> None: ...
    def wait(self, cancellable: Cancellable | None = None) -> bool: ...
    async def wait_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def wait_check(self, cancellable: Cancellable | None = None) -> bool: ...
    async def wait_check_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def wait_check_finish(self, result: AsyncResult) -> bool: ...
    def wait_finish(self, result: AsyncResult) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::argv"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class SubprocessLauncher(GObject.Object):
    """
    This class contains a set of options for launching child processes,
    such as where its standard input and output will be directed, the
    argument list, the environment, and more.

    While the [class@Gio.Subprocess] class has high level functions covering
    popular cases, use of this class allows access to more advanced
    options.  It can also be used to launch multiple subprocesses with
    a similar configuration.
    """

    class Props(GObject.Object.Props):
        flags: SubprocessFlags

    # gi Methods
    def __init__(self, flags: SubprocessFlags = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def close(self) -> None: ...
    def getenv(self, variable: str) -> str | None: ...
    @classmethod
    def new(cls, flags: SubprocessFlags) -> SubprocessLauncher: ...
    def set_cwd(self, cwd: str) -> None: ...
    def set_environ(self, env: list) -> None: ...
    def set_flags(self, flags: SubprocessFlags) -> None: ...
    def set_stderr_file_path(self, path: str | None = None) -> None: ...
    def set_stdin_file_path(self, path: str | None = None) -> None: ...
    def set_stdout_file_path(self, path: str | None = None) -> None: ...
    def setenv(self, variable: str, value: str, overwrite: bool) -> None: ...
    def spawnv(self, argv: list) -> Subprocess: ...
    def take_fd(self, source_fd: int, target_fd: int) -> None: ...
    def take_stderr_fd(self, fd: int) -> None: ...
    def take_stdin_fd(self, fd: int) -> None: ...
    def take_stdout_fd(self, fd: int) -> None: ...
    def unsetenv(self, variable: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class Task(GObject.Object):
    """
    A `GTask` represents and manages a cancellable ‘task’.

    ## Asynchronous operations

    The most common usage of `GTask` is as a [iface@Gio.AsyncResult], to
    manage data during an asynchronous operation. You call
    [ctor@Gio.Task.new] in the ‘start’ method, followed by
    [method@Gio.Task.set_task_data] and the like if you need to keep some
    additional data associated with the task, and then pass the
    task object around through your asynchronous operation.
    Eventually, you will call a method such as
    [method@Gio.Task.return_pointer] or [method@Gio.Task.return_error], which
    will save the value you give it and then invoke the task’s callback
    function in the thread-default main context (see
    [method@GLib.MainContext.push_thread_default])
    where it was created (waiting until the next iteration of the main
    loop first, if necessary). The caller will pass the `GTask` back to
    the operation’s finish function (as a [iface@Gio.AsyncResult]), and you can
    use [method@Gio.Task.propagate_pointer] or the like to extract the
    return value.

    Using `GTask` requires the thread-default [struct@GLib.MainContext] from when
    the `GTask` was constructed to be running at least until the task has
    completed and its data has been freed.

    If a `GTask` has been constructed and its callback set, it is an error to
    not call `g_task_return_*()` on it. GLib will warn at runtime if this happens
    (since 2.76).

    Here is an example for using `GTask` as a [iface@Gio.AsyncResult]:
    ```c
    typedef struct {
      CakeFrostingType frosting;
      char *message;
    } DecorationData;

    static void
    decoration_data_free (DecorationData *decoration)
    {
      g_free (decoration->message);
      g_slice_free (DecorationData, decoration);
    }

    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      DecorationData *decoration = g_task_get_task_data (task);
      GError *error = NULL;

      if (cake == NULL)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }

      if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
        {
          g_object_unref (cake);
          // g_task_return_error() takes ownership of error
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }

      g_task_return_pointer (task, cake, g_object_unref);
      g_object_unref (task);
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      DecorationData *decoration;
      Cake  *cake;

      task = g_task_new (self, cancellable, callback, user_data);
      if (radius < 3)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
                                   "%ucm radius cakes are silly",
                                   radius);
          g_object_unref (task);
          return;
        }

      cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
      if (cake != NULL)
        {
          // _baker_get_cached_cake() returns a reffed cake
          g_task_return_pointer (task, cake, g_object_unref);
          g_object_unref (task);
          return;
        }

      decoration = g_slice_new (DecorationData);
      decoration->frosting = frosting;
      decoration->message = g_strdup (message);
      g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);

      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
    ```

    ## Chained asynchronous operations

    `GTask` also tries to simplify asynchronous operations that
    internally chain together several smaller asynchronous
    operations. [method@Gio.Task.get_cancellable], [method@Gio.Task.get_context],
    and [method@Gio.Task.get_priority] allow you to get back the task’s
    [class@Gio.Cancellable], [struct@GLib.MainContext], and
    [I/O priority](iface.AsyncResult.html#io-priority)
    when starting a new subtask, so you don’t have to keep track
    of them yourself. [method@Gio.Task.attach_source] simplifies the case
    of waiting for a source to fire (automatically using the correct
    [struct@GLib.MainContext] and priority).

    Here is an example for chained asynchronous operations:
    ```c
    typedef struct {
      Cake *cake;
      CakeFrostingType frosting;
      char *message;
    } BakingData;

    static void
    decoration_data_free (BakingData *bd)
    {
      if (bd->cake)
        g_object_unref (bd->cake);
      g_free (bd->message);
      g_slice_free (BakingData, bd);
    }

    static void
    decorated_cb (Cake         *cake,
                  GAsyncResult *result,
                  gpointer      user_data)
    {
      GTask *task = user_data;
      GError *error = NULL;

      if (!cake_decorate_finish (cake, result, &error))
        {
          g_object_unref (cake);
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }

      // baking_data_free() will drop its ref on the cake, so we have to
      // take another here to give to the caller.
      g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
      g_object_unref (task);
    }

    static gboolean
    decorator_ready (gpointer user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);

      cake_decorate_async (bd->cake, bd->frosting, bd->message,
                           g_task_get_cancellable (task),
                           decorated_cb, task);

      return G_SOURCE_REMOVE;
    }

    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);
      GError *error = NULL;

      if (cake == NULL)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }

      bd->cake = cake;

      // Bail out now if the user has already cancelled
      if (g_task_return_error_if_cancelled (task))
        {
          g_object_unref (task);
          return;
        }

      if (cake_decorator_available (cake))
        decorator_ready (task);
      else
        {
          GSource *source;

          source = cake_decorator_wait_source_new (cake);
          // Attach @source to @task’s GMainContext and have it call
          // decorator_ready() when it is ready.
          g_task_attach_source (task, source, decorator_ready);
          g_source_unref (source);
        }
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           gint                 priority,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      BakingData *bd;

      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_priority (task, priority);

      bd = g_slice_new0 (BakingData);
      bd->frosting = frosting;
      bd->message = g_strdup (message);
      g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);

      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
    ```

    ## Asynchronous operations from synchronous ones

    You can use [method@Gio.Task.run_in_thread] to turn a synchronous
    operation into an asynchronous one, by running it in a thread.
    When it completes, the result will be dispatched to the thread-default
    main context (see [method@GLib.MainContext.push_thread_default])
    where the `GTask` was created.

    Running a task in a thread:
    ```c
    typedef struct {
      guint radius;
      CakeFlavor flavor;
      CakeFrostingType frosting;
      char *message;
    } CakeData;

    static void
    cake_data_free (CakeData *cake_data)
    {
      g_free (cake_data->message);
      g_slice_free (CakeData, cake_data);
    }

    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = NULL;

      cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
                        cake_data->frosting, cake_data->message,
                        cancellable, &error);
      if (cake)
        g_task_return_pointer (task, cake, g_object_unref);
      else
        g_task_return_error (task, error);
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;

      cake_data = g_slice_new (CakeData);
      cake_data->radius = radius;
      cake_data->flavor = flavor;
      cake_data->frosting = frosting;
      cake_data->message = g_strdup (message);
      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_run_in_thread (task, bake_cake_thread);
      g_object_unref (task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
    ```

    ## Adding cancellability to uncancellable tasks

    Finally, [method@Gio.Task.run_in_thread] and
    [method@Gio.Task.run_in_thread_sync] can be used to turn an uncancellable
    operation into a cancellable one. If you call
    [method@Gio.Task.set_return_on_cancel], passing `TRUE`, then if the task’s
    [class@Gio.Cancellable] is cancelled, it will return control back to the
    caller immediately, while allowing the task thread to continue running in the
    background (and simply discarding its result when it finally does finish).
    Provided that the task thread is careful about how it uses
    locks and other externally-visible resources, this allows you
    to make ‘GLib-friendly’ asynchronous and cancellable
    synchronous variants of blocking APIs.

    Cancelling a task:
    ```c
    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = NULL;

      cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
                        cake_data->frosting, cake_data->message,
                        &error);
      if (error)
        {
          g_task_return_error (task, error);
          return;
        }

      // If the task has already been cancelled, then we don’t want to add
      // the cake to the cake cache. Likewise, we don’t  want to have the
      // task get cancelled in the middle of updating the cache.
      // g_task_set_return_on_cancel() will return %TRUE here if it managed
      // to disable return-on-cancel, or %FALSE if the task was cancelled
      // before it could.
      if (g_task_set_return_on_cancel (task, FALSE))
        {
          // If the caller cancels at this point, their
          // GAsyncReadyCallback won’t be invoked until we return,
          // so we don’t have to worry that this code will run at
          // the same time as that code does. But if there were
          // other functions that might look at the cake cache,
          // then we’d probably need a GMutex here as well.
          baker_add_cake_to_cache (baker, cake);
          g_task_return_pointer (task, cake, g_object_unref);
        }
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;

      cake_data = g_slice_new (CakeData);

      ...

      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, TRUE);
      g_task_run_in_thread (task, bake_cake_thread);
    }

    Cake *
    baker_bake_cake_sync (Baker               *self,
                          guint                radius,
                          CakeFlavor           flavor,
                          CakeFrostingType     frosting,
                          const char          *message,
                          GCancellable        *cancellable,
                          GError             **error)
    {
      CakeData *cake_data;
      GTask *task;
      Cake *cake;

      cake_data = g_slice_new (CakeData);

      ...

      task = g_task_new (self, cancellable, NULL, NULL);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, TRUE);
      g_task_run_in_thread_sync (task, bake_cake_thread);

      cake = g_task_propagate_pointer (task, error);
      g_object_unref (task);
      return cake;
    }
    ```

    ## Porting from [class@Gio.SimpleAsyncResult]

    `GTask`’s API attempts to be simpler than [class@Gio.SimpleAsyncResult]’s
    in several ways:

    - You can save task-specific data with [method@Gio.Task.set_task_data], and
      retrieve it later with [method@Gio.Task.get_task_data]. This replaces the
      abuse of [method@Gio.SimpleAsyncResult.set_op_res_gpointer] for the same
      purpose with [class@Gio.SimpleAsyncResult].
    - In addition to the task data, `GTask` also keeps track of the
      [priority](iface.AsyncResult.html#io-priority), [class@Gio.Cancellable],
      and [struct@GLib.MainContext] associated with the task, so tasks that
      consist of a chain of simpler asynchronous operations will have easy access
      to those values when starting each sub-task.
    - [method@Gio.Task.return_error_if_cancelled] provides simplified
      handling for cancellation. In addition, cancellation
      overrides any other `GTask` return value by default, like
      [class@Gio.SimpleAsyncResult] does when
      [method@Gio.SimpleAsyncResult.set_check_cancellable] is called.
      (You can use [method@Gio.Task.set_check_cancellable] to turn off that
      behavior.) On the other hand, [method@Gio.Task.run_in_thread]
      guarantees that it will always run your
      `task_func`, even if the task’s [class@Gio.Cancellable]
      is already cancelled before the task gets a chance to run;
      you can start your `task_func` with a
      [method@Gio.Task.return_error_if_cancelled] check if you need the
      old behavior.
    - The ‘return’ methods (eg, [method@Gio.Task.return_pointer])
      automatically cause the task to be ‘completed’ as well, and
      there is no need to worry about the ‘complete’ vs ‘complete in idle’
      distinction. (`GTask` automatically figures out
      whether the task’s callback can be invoked directly, or
      if it needs to be sent to another [struct@GLib.MainContext], or delayed
      until the next iteration of the current [struct@GLib.MainContext].)
    - The ‘finish’ functions for `GTask` based operations are generally
      much simpler than [class@Gio.SimpleAsyncResult] ones, normally consisting
      of only a single call to [method@Gio.Task.propagate_pointer] or the like.
      Since [method@Gio.Task.propagate_pointer] ‘steals’ the return value from
      the `GTask`, it is not necessary to juggle pointers around to
      prevent it from being freed twice.
    - With [class@Gio.SimpleAsyncResult], it was common to call
      [method@Gio.SimpleAsyncResult.propagate_error] from the
      `_finish()` wrapper function, and have
      virtual method implementations only deal with successful
      returns. This behavior is deprecated, because it makes it
      difficult for a subclass to chain to a parent class’s async
      methods. Instead, the wrapper function should just be a
      simple wrapper, and the virtual method should call an
      appropriate `g_task_propagate_` function.
      Note that wrapper methods can now use
      [method@Gio.AsyncResult.legacy_propagate_error] to do old-style
      [class@Gio.SimpleAsyncResult] error-returning behavior, and
      [method@Gio.AsyncResult.is_tagged] to check if a result is tagged as
      having come from the `_async()` wrapper
      function (for ‘short-circuit’ results, such as when passing
      `0` to [method@Gio.InputStream.read_async]).

    ## Thread-safety considerations

    Due to some infelicities in the API design, there is a
    thread-safety concern that users of `GTask` have to be aware of:

    If the `main` thread drops its last reference to the source object
    or the task data before the task is finalized, then the finalizers
    of these objects may be called on the worker thread.

    This is a problem if the finalizers use non-threadsafe API, and
    can lead to hard-to-debug crashes. Possible workarounds include:

    - Clear task data in a signal handler for `notify::completed`
    - Keep iterating a main context in the main thread and defer
      dropping the reference to the source object to that main
      context when the task is finalized
    """

    class Props(GObject.Object.Props):
        completed: bool

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_cancellable(self) -> Cancellable | None: ...
    def get_check_cancellable(self) -> bool: ...
    @property
    def get_completed(self) -> bool: ...
    def get_context(self) -> GLib.MainContext: ...
    def get_name(self) -> str | None: ...
    def get_priority(self) -> int: ...
    def get_return_on_cancel(self) -> bool: ...
    def get_source_object(self) -> GObject.Object | None: ...
    def get_source_tag(self) -> object | None: ...
    def get_task_data(self) -> object | None: ...
    def had_error(self) -> bool: ...
    @staticmethod
    def is_valid(result: AsyncResult, source_object: GObject.Object | None = None) -> bool: ...
    @classmethod
    def new(
        cls,
        source_object: GObject.Object | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        callback_data: object | None = None,
    ) -> Task: ...
    def propagate_boolean(self) -> bool: ...
    def propagate_int(self) -> int: ...
    def propagate_pointer(self) -> object | None: ...
    def propagate_value(self) -> tuple[bool, GObject.Value]: ...
    @staticmethod
    def report_error(
        source_object: GObject.Object | None,
        callback: AsyncReadyCallback | None,
        callback_data: object | None,
        source_tag: object | None,
        error: None,
    ) -> None: ...
    def return_boolean(self, result: bool) -> None: ...
    def return_error(self, error: None) -> None: ...
    def return_error_if_cancelled(self) -> bool: ...
    def return_int(self, result: int) -> None: ...
    def return_new_error_literal(self, domain: int, code: int, message: str) -> None: ...
    def return_pointer(
        self, result: object | None = None, result_destroy: GLib.DestroyNotify | None = None
    ) -> None: ...
    def return_value(self, result: GObject.Value | None = None) -> None: ...
    def run_in_thread(self, task_func: TaskThreadFunc) -> None: ...
    def run_in_thread_sync(self, task_func: TaskThreadFunc) -> None: ...
    def set_check_cancellable(self, check_cancellable: bool) -> None: ...
    def set_name(self, name: str | None = None) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_return_on_cancel(self, return_on_cancel: bool) -> bool: ...
    def set_source_tag(self, source_tag: object | None = None) -> None: ...
    def set_static_name(self, name: str | None = None) -> None: ...
    def set_task_data(
        self, task_data: object | None = None, task_data_destroy: GLib.DestroyNotify | None = None
    ) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::completed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class TaskClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TcpConnection(SocketConnection):
    """
    This is the subclass of [class@Gio.SocketConnection] that is created
    for TCP/IP sockets.
    """

    class Props(SocketConnection.Props):
        graceful_disconnect: bool  # [graceful-disconnect]: changed because contained invalid characters

    # gi Methods
    def __init__(self, graceful_disconnect: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_graceful_disconnect(self) -> bool: ...
    def set_graceful_disconnect(self, graceful_disconnect: bool) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::graceful_disconnect"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class TcpConnectionClass(GObject.GPointer):
    # gi Fields
    parent_class: SocketConnectionClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TcpConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TcpWrapperConnection(TcpConnection):
    """
    A `GTcpWrapperConnection` can be used to wrap a [class@Gio.IOStream] that is
    based on a [class@Gio.Socket], but which is not actually a
    [class@Gio.SocketConnection]. This is used by [class@Gio.SocketClient] so
    that it can always return a [class@Gio.SocketConnection], even when the
    connection it has actually created is not directly a
    [class@Gio.SocketConnection].
    """

    class Props(TcpConnection.Props):
        base_io_stream: IOStream | None  # [base-io-stream]: changed because contained invalid characters

    # gi Methods
    def __init__(self, base_io_stream: IOStream | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_base_io_stream(self) -> IOStream: ...
    @classmethod
    def new(cls, base_io_stream: IOStream, socket: Socket) -> SocketConnection: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_io_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class TcpWrapperConnectionClass(GObject.GPointer):
    # gi Fields
    parent_class: TcpConnectionClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TcpWrapperConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TestDBus(GObject.Object):
    """
    A helper class for testing code which uses D-Bus without touching the user’s
    session bus.

    Note that `GTestDBus` modifies the user’s environment, calling
    [`setenv()`](man:setenv(3)). This is not thread-safe, so all `GTestDBus`
    calls should be completed before threads are spawned, or should have
    appropriate locking to ensure no access conflicts to environment variables
    shared between `GTestDBus` and other threads.

    ## Creating unit tests using `GTestDBus`

    Testing of D-Bus services can be tricky because normally we only ever run
    D-Bus services over an existing instance of the D-Bus daemon thus we
    usually don’t activate D-Bus services that are not yet installed into the
    target system. The `GTestDBus` object makes this easier for us by taking care
    of the lower level tasks such as running a private D-Bus daemon and looking
    up uninstalled services in customizable locations, typically in your source
    code tree.

    The first thing you will need is a separate service description file for the
    D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
    is a good place to put this file.

    The service file should list your service along with an absolute path to the
    uninstalled service executable in your source tree. Using autotools we would
    achieve this by adding a file such as `my-server.service.in` in the services
    directory and have it processed by configure.

    ```
    [D-BUS Service]
    Name=org.gtk.GDBus.Examples.ObjectManager
    Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
    ```

    You will also need to indicate this service directory in your test
    fixtures, so you will need to pass the path while compiling your
    test cases. Typically this is done with autotools with an added
    preprocessor flag specified to compile your tests such as:

    ```
    -DTEST_SERVICES=""$(abs_top_builddir)/tests/services""
    ```

    Once you have a service definition file which is local to your source tree,
    you can proceed to set up a GTest fixture using the `GTestDBus` scaffolding.

    An example of a test fixture for D-Bus services can be found
    here:
    [gdbus-test-fixture.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-test-fixture.c)

    Note that these examples only deal with isolating the D-Bus aspect of your
    service. To successfully run isolated unit tests on your service you may need
    some additional modifications to your test case fixture. For example; if your
    service uses [class@Gio.Settings] and installs a schema then it is important
    that your test service not load the schema in the ordinary installed location
    (chances are that your service and schema files are not yet installed, or
    worse; there is an older version of the schema file sitting in the install
    location).

    Most of the time we can work around these obstacles using the
    environment. Since the environment is inherited by the D-Bus daemon
    created by `GTestDBus` and then in turn inherited by any services the
    D-Bus daemon activates, using the setup routine for your fixture is
    a practical place to help sandbox your runtime environment. For the
    rather typical GSettings case we can work around this by setting
    `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
    in the above `fixture_setup()` routine.

    The GSettings schemas need to be locally pre-compiled for this to work. This
    can be achieved by compiling the schemas locally as a step before running
    test cases, an autotools setup might do the following in the directory
    holding schemas:

    ```
        all-am:
                $(GLIB_COMPILE_SCHEMAS) .

        CLEANFILES += gschemas.compiled
    ```
    """

    class Props(GObject.Object.Props):
        flags: TestDBusFlags

    # gi Methods
    def __init__(self, flags: TestDBusFlags = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_service_dir(self, path: str) -> None: ...
    def down(self) -> None: ...
    def get_bus_address(self) -> str | None: ...
    @property
    def get_flags(self) -> TestDBusFlags: ...
    @classmethod
    def new(cls, flags: TestDBusFlags) -> TestDBus: ...
    def stop(self) -> None: ...
    @staticmethod
    def unset() -> None: ...
    def up(self) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ThemedIcon(GObject.Object):
    """
    `GThemedIcon` is an implementation of [iface@Gio.Icon] that supports icon
    themes.

    `GThemedIcon` contains a list of all of the icons present in an icon
    theme, so that icons can be looked up quickly. `GThemedIcon` does
    not provide actual pixmaps for icons, just the icon names.
    Ideally something like [method@Gtk.IconTheme.choose_icon] should be used to
    resolve the list of names so that fallback icons work nicely with
    themes that inherit other themes.
    """

    class Props(GObject.Object.Props):
        name: str
        names: list | None
        use_default_fallbacks: bool  # [use-default-fallbacks]: changed because contained invalid characters

    # gi Methods
    def __init__(self, name: str = ..., names: list | None = ..., use_default_fallbacks: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append_name(self, iconname: str) -> None: ...
    @property
    def get_names(self) -> list: ...
    @classmethod
    def new(cls, iconname: str) -> ThemedIcon: ...
    @classmethod
    def new_from_names(cls, iconnames: list, len: int) -> ThemedIcon: ...
    @classmethod
    def new_with_default_fallbacks(cls, iconname: str) -> ThemedIcon: ...
    def prepend_name(self, iconname: str) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::names"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_default_fallbacks"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ThemedIconClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ThreadedResolver(Resolver):
    """
    #GThreadedResolver is an implementation of #GResolver which calls the libc
    lookup functions in threads to allow them to run asynchronously.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ThreadedResolverClass(GObject.GPointer):
    # gi Fields
    parent_class: ResolverClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ThreadedSocketService(SocketService):
    """
    A `GThreadedSocketService` is a simple subclass of [class@Gio.SocketService]
    that handles incoming connections by creating a worker thread and
    dispatching the connection to it by emitting the
    [signal@Gio.ThreadedSocketService::run signal] in the new thread.

    The signal handler may perform blocking I/O and need not return
    until the connection is closed.

    The service is implemented using a thread pool, so there is a
    limited amount of threads available to serve incoming requests.
    The service automatically stops the [class@Gio.SocketService] from accepting
    new connections when all threads are busy.

    As with [class@Gio.SocketService], you may connect to
    [signal@Gio.ThreadedSocketService::run], or subclass and override the default
    handler.
    """

    class Props(SocketService.Props):
        max_threads: int  # [max-threads]: changed because contained invalid characters

    # gi Methods
    def __init__(self, max_threads: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, max_threads: int) -> SocketService: ...

    # python methods
    def do_run(
        self,
        connection: SocketConnection,
        source_object: GObject.Object,
    ) -> bool:
        """
        run(self, connection:Gio.SocketConnection, source_object:GObject.Object) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["run"],
        handler: typing.Callable[[typing_extensions.Self, SocketConnection, GObject.Object | None], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_threads"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ThreadedSocketServiceClass(GObject.GPointer):
    # gi Fields
    parent_class: SocketServiceClass | None = ...
    run: runThreadedSocketServiceClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ThreadedSocketServicePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsBackend(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_certificate_type(self) -> GObject.GType: ...
    def get_client_connection_type(self) -> GObject.GType: ...
    @staticmethod
    def get_default() -> TlsBackend: ...
    def get_default_database(self) -> TlsDatabase: ...
    def get_dtls_client_connection_type(self) -> GObject.GType: ...
    def get_dtls_server_connection_type(self) -> GObject.GType: ...
    def get_file_database_type(self) -> GObject.GType: ...
    def get_server_connection_type(self) -> GObject.GType: ...
    def set_default_database(self, database: TlsDatabase | None = None) -> None: ...
    def supports_dtls(self) -> bool: ...
    def supports_tls(self) -> bool: ...

    ...

class TlsBackendInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_certificate_type: get_certificate_typeTlsBackendInterfaceCB = ...
    get_client_connection_type: get_client_connection_typeTlsBackendInterfaceCB = ...
    get_default_database: get_default_databaseTlsBackendInterfaceCB = ...
    get_dtls_client_connection_type: get_dtls_client_connection_typeTlsBackendInterfaceCB = ...
    get_dtls_server_connection_type: get_dtls_server_connection_typeTlsBackendInterfaceCB = ...
    get_file_database_type: get_file_database_typeTlsBackendInterfaceCB = ...
    get_server_connection_type: get_server_connection_typeTlsBackendInterfaceCB = ...
    supports_dtls: supports_dtlsTlsBackendInterfaceCB = ...
    supports_tls: supports_tlsTlsBackendInterfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsCertificate(GObject.Object):
    """
    A certificate used for TLS authentication and encryption.
    This can represent either a certificate only (eg, the certificate
    received by a client from a server), or the combination of
    a certificate and a private key (which is needed when acting as a
    [iface@Gio.TlsServerConnection]).
    """

    class Props(GObject.Object.Props):
        certificate: list | None
        certificate_pem: str  # [certificate-pem]: changed because contained invalid characters
        dns_names: list | None  # [dns-names]: changed because contained invalid characters
        ip_addresses: list | None  # [ip-addresses]: changed because contained invalid characters
        issuer: TlsCertificate | None
        issuer_name: str  # [issuer-name]: changed because contained invalid characters
        not_valid_after: GLib.DateTime | None  # [not-valid-after]: changed because contained invalid characters
        not_valid_before: GLib.DateTime | None  # [not-valid-before]: changed because contained invalid characters
        password: str
        pkcs11_uri: str  # [pkcs11-uri]: changed because contained invalid characters
        pkcs12_data: list | None  # [pkcs12-data]: changed because contained invalid characters
        private_key: list | None  # [private-key]: changed because contained invalid characters
        private_key_pem: str  # [private-key-pem]: changed because contained invalid characters
        private_key_pkcs11_uri: str  # [private-key-pkcs11-uri]: changed because contained invalid characters
        subject_name: str  # [subject-name]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        certificate: list | None = ...,
        certificate_pem: str = ...,
        issuer: TlsCertificate | None = ...,
        password: str = ...,
        pkcs11_uri: str = ...,
        pkcs12_data: list | None = ...,
        private_key: list | None = ...,
        private_key_pem: str = ...,
        private_key_pkcs11_uri: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_dns_names(self) -> list | None: ...
    @property
    def get_ip_addresses(self) -> list | None: ...
    @property
    def get_issuer(self) -> TlsCertificate | None: ...
    @property
    def get_issuer_name(self) -> str | None: ...
    @property
    def get_not_valid_after(self) -> GLib.DateTime | None: ...
    @property
    def get_not_valid_before(self) -> GLib.DateTime | None: ...
    @property
    def get_subject_name(self) -> str | None: ...
    def is_same(self, cert_two: TlsCertificate) -> bool: ...
    @staticmethod
    def list_new_from_file(file: str) -> list: ...
    @classmethod
    def new_from_file(cls, file: str) -> TlsCertificate: ...
    @classmethod
    def new_from_file_with_password(cls, file: str, password: str) -> TlsCertificate: ...
    @classmethod
    def new_from_files(cls, cert_file: str, key_file: str) -> TlsCertificate: ...
    @classmethod
    def new_from_pem(cls, data: str, length: int) -> TlsCertificate: ...
    @classmethod
    def new_from_pkcs11_uris(cls, pkcs11_uri: str, private_key_pkcs11_uri: str | None = None) -> TlsCertificate: ...
    @classmethod
    def new_from_pkcs12(cls, data: list, length: int, password: str | None = None) -> TlsCertificate: ...
    def verify(
        self, identity: SocketConnectable | None = None, trusted_ca: TlsCertificate | None = None
    ) -> TlsCertificateFlags: ...

    # python methods
    def do_verify(
        self,
        identity: SocketConnectable | None = None,
        trusted_ca: TlsCertificate | None = None,
    ) -> TlsCertificateFlags:
        """
        verify(self, identity:Gio.SocketConnectable=None, trusted_ca:Gio.TlsCertificate=None) -> Gio.TlsCertificateFlags
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::certificate_pem"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::dns_names"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ip_addresses"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::issuer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::issuer_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::not_valid_after"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::not_valid_before"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::password"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pkcs11_uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pkcs12_data"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::private_key"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::private_key_pem"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::private_key_pkcs11_uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::subject_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class TlsCertificateClass(GObject.GPointer):
    # gi Fields
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    verify: verifyTlsCertificateClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsCertificatePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsClientConnection(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        accepted_cas: list | None  # [accepted-cas]: changed because contained invalid characters
        server_identity: SocketConnectable | None  # [server-identity]: changed because contained invalid characters
        use_ssl3: bool  # [use-ssl3]: changed because contained invalid characters
        validation_flags: TlsCertificateFlags  # [validation-flags]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        server_identity: SocketConnectable | None = ...,
        use_ssl3: bool = ...,
        validation_flags: TlsCertificateFlags = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def copy_session_state(self, source: TlsClientConnection) -> None: ...
    @property
    def get_accepted_cas(self) -> list: ...
    @property
    def get_server_identity(self) -> SocketConnectable | None: ...
    @deprecated("deprecated")
    @property
    def get_use_ssl3(self) -> bool: ...
    @deprecated("deprecated")
    @property
    def get_validation_flags(self) -> TlsCertificateFlags: ...
    @staticmethod
    def new(base_io_stream: IOStream, server_identity: SocketConnectable | None = None) -> TlsClientConnection: ...
    def set_server_identity(self, identity: SocketConnectable) -> None: ...
    @deprecated("deprecated")
    def set_use_ssl3(self, use_ssl3: bool) -> None: ...
    @deprecated("deprecated")
    def set_validation_flags(self, flags: TlsCertificateFlags) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accepted_cas"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::server_identity"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_ssl3"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::validation_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class TlsClientConnectionInterface(GObject.GPointer):
    # gi Fields
    copy_session_state: copy_session_stateTlsClientConnectionInterfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsConnection(IOStream):
    """
    `GTlsConnection` is the base TLS connection class type, which wraps
    a [class@Gio.IOStream] and provides TLS encryption on top of it. Its
    subclasses, [iface@Gio.TlsClientConnection] and
    [iface@Gio.TlsServerConnection], implement client-side and server-side TLS,
    respectively.

    For DTLS (Datagram TLS) support, see [iface@Gio.DtlsConnection].
    """

    class Props(IOStream.Props):
        advertised_protocols: list | None  # [advertised-protocols]: changed because contained invalid characters
        base_io_stream: IOStream | None  # [base-io-stream]: changed because contained invalid characters
        certificate: TlsCertificate | None
        ciphersuite_name: str  # [ciphersuite-name]: changed because contained invalid characters
        database: TlsDatabase | None
        interaction: TlsInteraction | None
        negotiated_protocol: str  # [negotiated-protocol]: changed because contained invalid characters
        peer_certificate: TlsCertificate | None  # [peer-certificate]: changed because contained invalid characters
        peer_certificate_errors: (
            TlsCertificateFlags  # [peer-certificate-errors]: changed because contained invalid characters
        )
        protocol_version: TlsProtocolVersion  # [protocol-version]: changed because contained invalid characters
        rehandshake_mode: TlsRehandshakeMode  # [rehandshake-mode]: changed because contained invalid characters
        require_close_notify: bool  # [require-close-notify]: changed because contained invalid characters
        use_system_certdb: bool  # [use-system-certdb]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        advertised_protocols: list | None = ...,
        base_io_stream: IOStream | None = ...,
        certificate: TlsCertificate | None = ...,
        database: TlsDatabase | None = ...,
        interaction: TlsInteraction | None = ...,
        rehandshake_mode: TlsRehandshakeMode = ...,
        require_close_notify: bool = ...,
        use_system_certdb: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def emit_accept_certificate(self, peer_cert: TlsCertificate, errors: TlsCertificateFlags) -> bool: ...
    @property
    def get_certificate(self) -> TlsCertificate | None: ...
    def get_channel_binding_data(self, type: TlsChannelBindingType) -> tuple[bool, list | None]: ...
    @property
    def get_ciphersuite_name(self) -> str | None: ...
    @property
    def get_database(self) -> TlsDatabase | None: ...
    @property
    def get_interaction(self) -> TlsInteraction | None: ...
    @property
    def get_negotiated_protocol(self) -> str | None: ...
    @property
    def get_peer_certificate(self) -> TlsCertificate | None: ...
    @property
    def get_peer_certificate_errors(self) -> TlsCertificateFlags: ...
    @property
    def get_protocol_version(self) -> TlsProtocolVersion: ...
    @deprecated("deprecated")
    @property
    def get_rehandshake_mode(self) -> TlsRehandshakeMode: ...
    @property
    def get_require_close_notify(self) -> bool: ...
    @deprecated("deprecated")
    @property
    def get_use_system_certdb(self) -> bool: ...
    def handshake(self, cancellable: Cancellable | None = None) -> bool: ...
    async def handshake_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def handshake_finish(self, result: AsyncResult) -> bool: ...
    def set_advertised_protocols(self, protocols: list | None = None) -> None: ...
    def set_certificate(self, certificate: TlsCertificate) -> None: ...
    def set_database(self, database: TlsDatabase | None = None) -> None: ...
    def set_interaction(self, interaction: TlsInteraction | None = None) -> None: ...
    @deprecated("deprecated")
    def set_rehandshake_mode(self, mode: TlsRehandshakeMode) -> None: ...
    def set_require_close_notify(self, require_close_notify: bool) -> None: ...
    @deprecated("deprecated")
    def set_use_system_certdb(self, use_system_certdb: bool) -> None: ...

    # python methods
    def do_accept_certificate(
        self,
        peer_cert: TlsCertificate,
        errors: TlsCertificateFlags,
    ) -> bool:
        """
        accept_certificate(self, peer_cert:Gio.TlsCertificate, errors:Gio.TlsCertificateFlags) -> bool
        """
    def do_get_binding_data(
        self,
        type: TlsChannelBindingType,
        data: list,
    ) -> bool:
        """
        get_binding_data(self, type:Gio.TlsChannelBindingType, data:list) -> bool
        """
    def do_get_negotiated_protocol(
        self,
    ) -> str | None:
        """
        get_negotiated_protocol(self) -> str or None
        """
    def do_handshake(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        handshake(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_handshake_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        handshake_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_handshake_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        handshake_finish(self, result:Gio.AsyncResult) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["accept-certificate"],
        handler: typing.Callable[[typing_extensions.Self, TlsCertificate, TlsCertificateFlags], bool],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::advertised_protocols"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_io_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ciphersuite_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::database"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::interaction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::negotiated_protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::peer_certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::peer_certificate_errors"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::protocol_version"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rehandshake_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::require_close_notify"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_system_certdb"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class TlsConnectionClass(GObject.GPointer):
    # gi Fields
    accept_certificate: accept_certificateTlsConnectionClassCB = ...
    get_binding_data: get_binding_dataTlsConnectionClassCB = ...
    get_negotiated_protocol: get_negotiated_protocolTlsConnectionClassCB | None = ...
    handshake: handshakeTlsConnectionClassCB = ...
    handshake_async: handshake_asyncTlsConnectionClassCB = ...
    handshake_finish: handshake_finishTlsConnectionClassCB = ...
    padding: list | None = ...
    parent_class: IOStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsDatabase(GObject.Object):
    """
    `GTlsDatabase` is used to look up certificates and other information
    from a certificate or key store. It is an abstract base class which
    TLS library specific subtypes override.

    A `GTlsDatabase` may be accessed from multiple threads by the TLS backend.
    All implementations are required to be fully thread-safe.

    Most common client applications will not directly interact with
    `GTlsDatabase`. It is used internally by [class@Gio.TlsConnection].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def create_certificate_handle(self, certificate: TlsCertificate) -> str | None: ...
    def lookup_certificate_for_handle(
        self,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate | None: ...
    async def lookup_certificate_for_handle_async(
        self,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def lookup_certificate_for_handle_finish(self, result: AsyncResult) -> TlsCertificate: ...
    def lookup_certificate_issuer(
        self,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate: ...
    async def lookup_certificate_issuer_async(
        self,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def lookup_certificate_issuer_finish(self, result: AsyncResult) -> TlsCertificate: ...
    def lookup_certificates_issued_by(
        self,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list: ...
    async def lookup_certificates_issued_by_async(
        self,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def lookup_certificates_issued_by_finish(self, result: AsyncResult) -> list: ...
    def verify_chain(
        self,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificateFlags: ...
    async def verify_chain_async(
        self,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def verify_chain_finish(self, result: AsyncResult) -> TlsCertificateFlags: ...

    # python methods
    def do_create_certificate_handle(
        self,
        certificate: TlsCertificate,
    ) -> str | None:
        """
        create_certificate_handle(self, certificate:Gio.TlsCertificate) -> str or None
        """
    def do_lookup_certificate_for_handle(
        self,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate | None:
        """
        lookup_certificate_for_handle(self, handle:str, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None) -> Gio.TlsCertificate or None
        """
    def do_lookup_certificate_for_handle_async(
        self,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_certificate_for_handle_async(self, handle:str, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_certificate_for_handle_finish(
        self,
        result: AsyncResult,
    ) -> TlsCertificate:
        """
        lookup_certificate_for_handle_finish(self, result:Gio.AsyncResult) -> Gio.TlsCertificate
        """
    def do_lookup_certificate_issuer(
        self,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate:
        """
        lookup_certificate_issuer(self, certificate:Gio.TlsCertificate, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None) -> Gio.TlsCertificate
        """
    def do_lookup_certificate_issuer_async(
        self,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_certificate_issuer_async(self, certificate:Gio.TlsCertificate, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_certificate_issuer_finish(
        self,
        result: AsyncResult,
    ) -> TlsCertificate:
        """
        lookup_certificate_issuer_finish(self, result:Gio.AsyncResult) -> Gio.TlsCertificate
        """
    def do_lookup_certificates_issued_by(
        self,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list:
        """
        lookup_certificates_issued_by(self, issuer_raw_dn:list, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None) -> list
        """
    def do_lookup_certificates_issued_by_async(
        self,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_certificates_issued_by_async(self, issuer_raw_dn:list, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_certificates_issued_by_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_certificates_issued_by_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_verify_chain(
        self,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificateFlags:
        """
        verify_chain(self, chain:Gio.TlsCertificate, purpose:str, identity:Gio.SocketConnectable=None, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseVerifyFlags, cancellable:Gio.Cancellable=None) -> Gio.TlsCertificateFlags
        """
    def do_verify_chain_async(
        self,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        verify_chain_async(self, chain:Gio.TlsCertificate, purpose:str, identity:Gio.SocketConnectable=None, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseVerifyFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_verify_chain_finish(
        self,
        result: AsyncResult,
    ) -> TlsCertificateFlags:
        """
        verify_chain_finish(self, result:Gio.AsyncResult) -> Gio.TlsCertificateFlags
        """

    ...

class TlsDatabaseClass(GObject.GPointer):
    # gi Fields
    create_certificate_handle: create_certificate_handleTlsDatabaseClassCB | None = ...
    lookup_certificate_for_handle: lookup_certificate_for_handleTlsDatabaseClassCB | None = ...
    lookup_certificate_for_handle_async: lookup_certificate_for_handle_asyncTlsDatabaseClassCB = ...
    lookup_certificate_for_handle_finish: lookup_certificate_for_handle_finishTlsDatabaseClassCB = ...
    lookup_certificate_issuer: lookup_certificate_issuerTlsDatabaseClassCB = ...
    lookup_certificate_issuer_async: lookup_certificate_issuer_asyncTlsDatabaseClassCB = ...
    lookup_certificate_issuer_finish: lookup_certificate_issuer_finishTlsDatabaseClassCB = ...
    lookup_certificates_issued_by: lookup_certificates_issued_byTlsDatabaseClassCB = ...
    lookup_certificates_issued_by_async: lookup_certificates_issued_by_asyncTlsDatabaseClassCB = ...
    lookup_certificates_issued_by_finish: lookup_certificates_issued_by_finishTlsDatabaseClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    verify_chain: verify_chainTlsDatabaseClassCB = ...
    verify_chain_async: verify_chain_asyncTlsDatabaseClassCB = ...
    verify_chain_finish: verify_chain_finishTlsDatabaseClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsDatabasePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsFileDatabase(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        anchors: str

    # gi Methods
    def __init__(self, anchors: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def new(anchors: str) -> TlsFileDatabase: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::anchors"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class TlsFileDatabaseInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    padding: list | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsInteraction(GObject.Object):
    """
    `GTlsInteraction` provides a mechanism for the TLS connection and database
    code to interact with the user. It can be used to ask the user for passwords.

    To use a `GTlsInteraction` with a TLS connection use
    [method@Gio.TlsConnection.set_interaction].

    Callers should instantiate a derived class that implements the various
    interaction methods to show the required dialogs.

    Callers should use the 'invoke' functions like
    [method@Gio.TlsInteraction.invoke_ask_password] to run interaction methods.
    These functions make sure that the interaction is invoked in the main loop
    and not in the current thread, if the current thread is not running the
    main loop.

    Derived classes can choose to implement whichever interactions methods they’d
    like to support by overriding those virtual methods in their class
    initialization function. Any interactions not implemented will return
    `G_TLS_INTERACTION_UNHANDLED`. If a derived class implements an async method,
    it must also implement the corresponding finish method.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def ask_password(self, password: TlsPassword, cancellable: Cancellable | None = None) -> TlsInteractionResult: ...
    async def ask_password_async(
        self,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def ask_password_finish(self, result: AsyncResult) -> TlsInteractionResult: ...
    def invoke_ask_password(
        self, password: TlsPassword, cancellable: Cancellable | None = None
    ) -> TlsInteractionResult: ...
    def invoke_request_certificate(
        self, connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | None = None
    ) -> TlsInteractionResult: ...
    def request_certificate(
        self, connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | None = None
    ) -> TlsInteractionResult: ...
    async def request_certificate_async(
        self,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def request_certificate_finish(self, result: AsyncResult) -> TlsInteractionResult: ...

    # python methods
    def do_ask_password(
        self,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
    ) -> TlsInteractionResult:
        """
        ask_password(self, password:Gio.TlsPassword, cancellable:Gio.Cancellable=None) -> Gio.TlsInteractionResult
        """
    def do_ask_password_async(
        self,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        ask_password_async(self, password:Gio.TlsPassword, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_ask_password_finish(
        self,
        result: AsyncResult,
    ) -> TlsInteractionResult:
        """
        ask_password_finish(self, result:Gio.AsyncResult) -> Gio.TlsInteractionResult
        """
    def do_request_certificate(
        self,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsInteractionResult:
        """
        request_certificate(self, connection:Gio.TlsConnection, flags:Gio.TlsCertificateRequestFlags, cancellable:Gio.Cancellable=None) -> Gio.TlsInteractionResult
        """
    def do_request_certificate_async(
        self,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        request_certificate_async(self, connection:Gio.TlsConnection, flags:Gio.TlsCertificateRequestFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_request_certificate_finish(
        self,
        result: AsyncResult,
    ) -> TlsInteractionResult:
        """
        request_certificate_finish(self, result:Gio.AsyncResult) -> Gio.TlsInteractionResult
        """

    ...

class TlsInteractionClass(GObject.GPointer):
    # gi Fields
    ask_password: ask_passwordTlsInteractionClassCB = ...
    ask_password_async: ask_password_asyncTlsInteractionClassCB = ...
    ask_password_finish: ask_password_finishTlsInteractionClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    request_certificate: request_certificateTlsInteractionClassCB = ...
    request_certificate_async: request_certificate_asyncTlsInteractionClassCB = ...
    request_certificate_finish: request_certificate_finishTlsInteractionClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsInteractionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsPassword(GObject.Object):
    """
    An abstract interface representing a password used in TLS. Often used in
    user interaction such as unlocking a key storage token.
    """

    class Props(GObject.Object.Props):
        description: str
        flags: TlsPasswordFlags
        warning: str

    # gi Methods
    def __init__(self, description: str = ..., flags: TlsPasswordFlags = ..., warning: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_description(self) -> str: ...
    @property
    def get_flags(self) -> TlsPasswordFlags: ...
    def get_value(self) -> tuple[list, int | None]: ...
    @property
    def get_warning(self) -> str: ...
    @classmethod
    def new(cls, flags: TlsPasswordFlags, description: str) -> TlsPassword: ...
    def set_description(self, description: str) -> None: ...
    def set_flags(self, flags: TlsPasswordFlags) -> None: ...
    def set_value(self, value: list, length: int) -> None: ...
    def set_value_full(self, value: list, length: int, destroy: GLib.DestroyNotify | None = None) -> None: ...
    def set_warning(self, warning: str) -> None: ...

    # python methods
    def do_get_default_warning(
        self,
    ) -> str:
        """
        get_default_warning(self) -> str
        """
    def do_get_value(
        self,
    ) -> list:
        """
        get_value(self) -> list
        """
    def do_set_value(
        self,
        value: list,
        destroy: typing.Callable | None = None,
    ) -> None:
        """
        set_value(self, value:list, destroy:GLib.DestroyNotify=None)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::description"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::warning"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class TlsPasswordClass(GObject.GPointer):
    # gi Fields
    get_default_warning: get_default_warningTlsPasswordClassCB = ...
    get_value: get_valueTlsPasswordClassCB = ...
    padding: list | None = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    set_value: set_valueTlsPasswordClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsPasswordPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class TlsServerConnection(GObject.GInterface):
    class Props(GObject.GInterface.Props):
        authentication_mode: (
            TlsAuthenticationMode  # [authentication-mode]: changed because contained invalid characters
        )

    # gi Methods
    def __init__(self, authentication_mode: TlsAuthenticationMode = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def new(base_io_stream: IOStream, certificate: TlsCertificate | None = None) -> TlsServerConnection: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::authentication_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class TlsServerConnectionInterface(GObject.GPointer):
    # gi Fields
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixConnection(SocketConnection):
    """
    This is the subclass of [class@Gio.SocketConnection] that is created
    for UNIX domain sockets.

    It contains functions to do some of the UNIX socket specific
    functionality like passing file descriptors.

    Since GLib 2.72, `GUnixConnection` is available on all platforms. It requires
    underlying system support (such as Windows 10 with `AF_UNIX`) at run time.

    Before GLib 2.72, `<gio/gunixconnection.h>` belonged to the UNIX-specific GIO
    interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
    using it. This is no longer necessary since GLib 2.72.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def receive_credentials(self, cancellable: Cancellable | None = None) -> Credentials: ...
    async def receive_credentials_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def receive_credentials_finish(self, result: AsyncResult) -> Credentials: ...
    def receive_fd(self, cancellable: Cancellable | None = None) -> int: ...
    def send_credentials(self, cancellable: Cancellable | None = None) -> bool: ...
    async def send_credentials_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def send_credentials_finish(self, result: AsyncResult) -> bool: ...
    def send_fd(self, fd: int, cancellable: Cancellable | None = None) -> bool: ...

    ...

class UnixConnectionClass(GObject.GPointer):
    # gi Fields
    parent_class: SocketConnectionClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixCredentialsMessage(SocketControlMessage):
    """
    This [class@Gio.SocketControlMessage] contains a [class@Gio.Credentials]
    instance.  It may be sent using [method@Gio.Socket.send_message] and received
    using [method@Gio.Socket.receive_message] over UNIX sockets (ie: sockets in
    the `G_SOCKET_FAMILY_UNIX` family).

    For an easier way to send and receive credentials over
    stream-oriented UNIX sockets, see
    [method@Gio.UnixConnection.send_credentials] and
    [method@Gio.UnixConnection.receive_credentials]. To receive credentials of
    a foreign process connected to a socket, use
    [method@Gio.Socket.get_credentials].

    Since GLib 2.72, `GUnixCredentialMessage` is available on all platforms. It
    requires underlying system support (such as Windows 10 with `AF_UNIX`) at run
    time.

    Before GLib 2.72, `<gio/gunixcredentialsmessage.h>` belonged to the UNIX-specific
    GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
    when using it. This is no longer necessary since GLib 2.72.
    """

    class Props(SocketControlMessage.Props):
        credentials: Credentials | None

    # gi Methods
    def __init__(self, credentials: Credentials | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_credentials(self) -> Credentials: ...
    @staticmethod
    def is_supported() -> bool: ...
    @classmethod
    def new(cls) -> SocketControlMessage: ...
    @classmethod
    def new_with_credentials(cls, credentials: Credentials) -> SocketControlMessage: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::credentials"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class UnixCredentialsMessageClass(GObject.GPointer):
    # gi Fields
    parent_class: SocketControlMessageClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixCredentialsMessagePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixFDList(GObject.Object):
    """
    A `GUnixFDList` contains a list of file descriptors.  It owns the file
    descriptors that it contains, closing them when finalized.

    It may be wrapped in a
    [`GUnixFDMessage`](../gio-unix/class.UnixFDMessage.html) and sent over a
    [class@Gio.Socket] in the `G_SOCKET_FAMILY_UNIX` family by using
    [method@Gio.Socket.send_message] and received using
    [method@Gio.Socket.receive_message].

    Before 2.74, `<gio/gunixfdlist.h>` belonged to the UNIX-specific GIO
    interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
    using it.

    Since 2.74, the API is available for Windows.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, fd: int) -> int: ...
    def get(self, index_: int) -> int: ...
    def get_length(self) -> int: ...
    @classmethod
    def new(cls) -> UnixFDList: ...
    @classmethod
    def new_from_array(cls, fds: list, n_fds: int) -> UnixFDList: ...
    def peek_fds(self) -> tuple[list, int | None]: ...
    def steal_fds(self) -> tuple[list, int | None]: ...

    ...

class UnixFDListClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixFDListPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixFDMessageClass(GObject.GPointer):
    # gi Fields
    parent_class: SocketControlMessageClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixFDMessagePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixInputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: InputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixMountMonitorClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixOutputStreamClass(GObject.GPointer):
    # gi Fields
    parent_class: OutputStreamClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixSocketAddress(SocketAddress):
    """
    Support for UNIX-domain (also known as local) sockets, corresponding to
    `struct sockaddr_un`.

    UNIX domain sockets are generally visible in the filesystem.
    However, some systems support abstract socket names which are not
    visible in the filesystem and not affected by the filesystem
    permissions, visibility, etc. Currently this is only supported
    under Linux. If you attempt to use abstract sockets on other
    systems, function calls may return `G_IO_ERROR_NOT_SUPPORTED`
    errors. You can use [func@Gio.UnixSocketAddress.abstract_names_supported]
    to see if abstract names are supported.

    Since GLib 2.72, `GUnixSocketAddress` is available on all platforms. It
    requires underlying system support (such as Windows 10 with `AF_UNIX`) at
    run time.

    Before GLib 2.72, `<gio/gunixsocketaddress.h>` belonged to the UNIX-specific
    GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
    when using it. This is no longer necessary since GLib 2.72.
    """

    class Props(SocketAddress.Props):
        abstract: bool
        address_type: UnixSocketAddressType  # [address-type]: changed because contained invalid characters
        path: str
        path_as_array: list | None  # [path-as-array]: changed because contained invalid characters

    # gi Methods
    def __init__(
        self,
        abstract: bool = ...,
        address_type: UnixSocketAddressType = ...,
        path: str = ...,
        path_as_array: list | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def abstract_names_supported() -> bool: ...
    @property
    def get_address_type(self) -> UnixSocketAddressType: ...
    @deprecated("deprecated")
    def get_is_abstract(self) -> bool: ...
    @property
    def get_path(self) -> str: ...
    def get_path_len(self) -> int: ...
    @classmethod
    def new(cls, path: str) -> SocketAddress: ...
    @deprecated("deprecated")
    @classmethod
    def new_abstract(cls, path: list, path_len: int) -> SocketAddress: ...
    @classmethod
    def new_with_type(cls, path: list, path_len: int, type: UnixSocketAddressType) -> SocketAddress: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::abstract"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::path_as_array"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class UnixSocketAddressClass(GObject.GPointer):
    # gi Fields
    parent_class: SocketAddressClass | None = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class UnixSocketAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Vfs(GObject.Object):
    """
    Entry point for using GIO functionality.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_default() -> Vfs: ...
    def get_file_for_path(self, path: str) -> File: ...
    def get_file_for_uri(self, uri: str) -> File: ...
    @staticmethod
    def get_local() -> Vfs: ...
    def get_supported_uri_schemes(self) -> list: ...
    def is_active(self) -> bool: ...
    def parse_name(self, parse_name: str) -> File: ...
    def register_uri_scheme(
        self,
        scheme: str,
        uri_func: VfsFileLookupFunc | None = None,
        uri_data: object | None = None,
        uri_destroy: GLib.DestroyNotify | None = None,
        parse_name_func: VfsFileLookupFunc | None = None,
        parse_name_data: object | None = None,
        parse_name_destroy: GLib.DestroyNotify | None = None,
    ) -> bool: ...
    def unregister_uri_scheme(self, scheme: str) -> bool: ...

    # python methods
    def do_add_writable_namespaces(
        self,
        list: FileAttributeInfoList,
    ) -> None:
        """
        add_writable_namespaces(self, list:Gio.FileAttributeInfoList)
        """
    def do_get_file_for_path(
        self,
        path: str,
    ) -> File:
        """
        get_file_for_path(self, path:str) -> Gio.File
        """
    def do_get_file_for_uri(
        self,
        uri: str,
    ) -> File:
        """
        get_file_for_uri(self, uri:str) -> Gio.File
        """
    def do_get_supported_uri_schemes(
        self,
    ) -> list:
        """
        get_supported_uri_schemes(self) -> list
        """
    def do_is_active(
        self,
    ) -> bool:
        """
        is_active(self) -> bool
        """
    def do_local_file_add_info(
        self,
        filename: str,
        device: int,
        attribute_matcher: FileAttributeMatcher,
        info: FileInfo,
        cancellable: Cancellable | None,
        extra_data: typing.Any,
        free_extra_data: typing.Callable,
    ) -> None:
        """
        local_file_add_info(self, filename:str, device:int, attribute_matcher:Gio.FileAttributeMatcher, info:Gio.FileInfo, cancellable:Gio.Cancellable=None, extra_data=None, free_extra_data:GLib.DestroyNotify)
        """
    def do_local_file_moved(
        self,
        source: str,
        dest: str,
    ) -> None:
        """
        local_file_moved(self, source:str, dest:str)
        """
    def do_local_file_removed(
        self,
        filename: str,
    ) -> None:
        """
        local_file_removed(self, filename:str)
        """
    def do_local_file_set_attributes(
        self,
        filename: str,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        local_file_set_attributes(self, filename:str, info:Gio.FileInfo, flags:Gio.FileQueryInfoFlags, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_parse_name(
        self,
        parse_name: str,
    ) -> File:
        """
        parse_name(self, parse_name:str) -> Gio.File
        """

    ...

class VfsClass(GObject.GPointer):
    # gi Fields
    add_writable_namespaces: add_writable_namespacesVfsClassCB = ...
    get_file_for_path: get_file_for_pathVfsClassCB = ...
    get_file_for_uri: get_file_for_uriVfsClassCB = ...
    get_supported_uri_schemes: get_supported_uri_schemesVfsClassCB = ...
    is_active: is_activeVfsClassCB = ...
    local_file_add_info: local_file_add_infoVfsClassCB = ...
    local_file_moved: local_file_movedVfsClassCB = ...
    local_file_removed: local_file_removedVfsClassCB = ...
    local_file_set_attributes: local_file_set_attributesVfsClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    parse_name: parse_nameVfsClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class Volume(GObject.GInterface):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_eject(self) -> bool: ...
    def can_mount(self) -> bool: ...
    @deprecated("deprecated")
    async def eject(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    @deprecated("deprecated")
    def eject_finish(self, result: AsyncResult) -> bool: ...
    async def eject_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def eject_with_operation_finish(self, result: AsyncResult) -> bool: ...
    def enumerate_identifiers(self) -> list: ...
    def get_activation_root(self) -> File | None: ...
    def get_drive(self) -> Drive | None: ...
    def get_icon(self) -> Icon: ...
    def get_identifier(self, kind: str) -> str | None: ...
    def get_mount(self) -> Mount | None: ...
    def get_name(self) -> str: ...
    def get_sort_key(self) -> str | None: ...
    def get_symbolic_icon(self) -> Icon: ...
    def get_uuid(self) -> str | None: ...
    async def mount(
        self,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...
    def mount_finish(self, result: AsyncResult) -> bool: ...
    def should_automount(self) -> bool: ...

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["removed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class VolumeIface(GObject.GPointer):
    # gi Fields
    can_eject: can_ejectVolumeIfaceCB = ...
    can_mount: can_mountVolumeIfaceCB = ...
    changed: changedVolumeIfaceCB = ...
    eject: ejectVolumeIfaceCB = ...
    eject_finish: eject_finishVolumeIfaceCB = ...
    eject_with_operation: eject_with_operationVolumeIfaceCB = ...
    eject_with_operation_finish: eject_with_operation_finishVolumeIfaceCB = ...
    enumerate_identifiers: enumerate_identifiersVolumeIfaceCB = ...
    g_iface: GObject.TypeInterface | None = ...  # type: ignore
    get_activation_root: get_activation_rootVolumeIfaceCB | None = ...
    get_drive: get_driveVolumeIfaceCB | None = ...
    get_icon: get_iconVolumeIfaceCB = ...
    get_identifier: get_identifierVolumeIfaceCB | None = ...
    get_mount: get_mountVolumeIfaceCB | None = ...
    get_name: get_nameVolumeIfaceCB = ...
    get_sort_key: get_sort_keyVolumeIfaceCB | None = ...
    get_symbolic_icon: get_symbolic_iconVolumeIfaceCB = ...
    get_uuid: get_uuidVolumeIfaceCB | None = ...
    mount_finish: mount_finishVolumeIfaceCB = ...
    mount_fn: mount_fnVolumeIfaceCB = ...
    removed: removedVolumeIfaceCB = ...
    should_automount: should_automountVolumeIfaceCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class VolumeMonitor(GObject.Object):
    """
    `GVolumeMonitor` is for listing the user interesting devices and volumes
    on the computer. In other words, what a file selector or file manager
    would show in a sidebar.

    `GVolumeMonitor` is not
    thread-default-context aware (see
    [method@GLib.MainContext.push_thread_default]), and so should not be used
    other than from the main thread, with no thread-default-context active.

    In order to receive updates about volumes and mounts monitored through GVFS,
    a main loop must be running.
    """

    # gi Methods
    @deprecated("deprecated")
    @staticmethod
    def adopt_orphan_mount(mount: Mount) -> Volume: ...
    @staticmethod
    def get() -> VolumeMonitor: ...
    def get_connected_drives(self) -> list: ...
    def get_mount_for_uuid(self, uuid: str) -> Mount | None: ...
    def get_mounts(self) -> list: ...
    def get_volume_for_uuid(self, uuid: str) -> Volume | None: ...
    def get_volumes(self) -> list: ...

    # python methods
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-changed"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-connected"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-disconnected"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-eject-button"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-stop-button"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mount-added"],
        handler: typing.Callable[[typing_extensions.Self, Mount], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mount-changed"],
        handler: typing.Callable[[typing_extensions.Self, Mount], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mount-pre-unmount"],
        handler: typing.Callable[[typing_extensions.Self, Mount], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mount-removed"],
        handler: typing.Callable[[typing_extensions.Self, Mount], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["volume-added"],
        handler: typing.Callable[[typing_extensions.Self, Volume], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["volume-changed"],
        handler: typing.Callable[[typing_extensions.Self, Volume], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["volume-removed"],
        handler: typing.Callable[[typing_extensions.Self, Volume], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class VolumeMonitorClass(GObject.GPointer):
    # gi Fields
    drive_changed: drive_changedVolumeMonitorClassCB = ...
    drive_connected: drive_connectedVolumeMonitorClassCB = ...
    drive_disconnected: drive_disconnectedVolumeMonitorClassCB = ...
    drive_eject_button: drive_eject_buttonVolumeMonitorClassCB = ...
    drive_stop_button: drive_stop_buttonVolumeMonitorClassCB = ...
    get_connected_drives: get_connected_drivesVolumeMonitorClassCB = ...
    get_mount_for_uuid: get_mount_for_uuidVolumeMonitorClassCB | None = ...
    get_mounts: get_mountsVolumeMonitorClassCB = ...
    get_volume_for_uuid: get_volume_for_uuidVolumeMonitorClassCB | None = ...
    get_volumes: get_volumesVolumeMonitorClassCB = ...
    is_supported: is_supportedVolumeMonitorClassCB = ...
    mount_added: mount_addedVolumeMonitorClassCB = ...
    mount_changed: mount_changedVolumeMonitorClassCB = ...
    mount_pre_unmount: mount_pre_unmountVolumeMonitorClassCB = ...
    mount_removed: mount_removedVolumeMonitorClassCB = ...
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    volume_added: volume_addedVolumeMonitorClassCB = ...
    volume_changed: volume_changedVolumeMonitorClassCB = ...
    volume_removed: volume_removedVolumeMonitorClassCB = ...
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ZlibCompressor(GObject.Object):
    """
    `GZlibCompressor` is an implementation of [iface@Gio.Converter] that
    compresses data using zlib.
    """

    class Props(GObject.Object.Props):
        file_info: FileInfo | None  # [file-info]: changed because contained invalid characters
        format: ZlibCompressorFormat
        level: int

    # gi Methods
    def __init__(self, file_info: FileInfo | None = ..., format: ZlibCompressorFormat = ..., level: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_file_info(self) -> FileInfo | None: ...
    @classmethod
    def new(cls, format: ZlibCompressorFormat, level: int) -> ZlibCompressor: ...
    def set_file_info(self, file_info: FileInfo | None = None) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file_info"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::format"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::level"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ZlibCompressorClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

class ZlibDecompressor(GObject.Object):
    """
    `GZlibDecompressor` is an implementation of [iface@Gio.Converter] that
    decompresses data compressed with zlib.
    """

    class Props(GObject.Object.Props):
        file_info: FileInfo | None  # [file-info]: changed because contained invalid characters
        format: ZlibCompressorFormat

    # gi Methods
    def __init__(self, format: ZlibCompressorFormat = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @property
    def get_file_info(self) -> FileInfo | None: ...
    @classmethod
    def new(cls, format: ZlibCompressorFormat) -> ZlibDecompressor: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file_info"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::format"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
    ...

class ZlibDecompressorClass(GObject.GPointer):
    # gi Fields
    parent_class: GObject.ObjectClass | None = ...  # type: ignore
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    ...

###############################################################
# Callbacks
###############################################################

class activateActionEntryCB(typing.Protocol):
    """
    This callback was used in:
        ActionEntry.activate
    """
    #  action
    def __call__(
        self,
        action: SimpleAction,
        parameter: GLib.Variant,
        user_data: object | None = None,
    ) -> None: ...

class change_stateActionEntryCB(typing.Protocol):
    """
    This callback was used in:
        ActionEntry.change_state
    """
    #  action
    def __call__(
        self,
        action: SimpleAction,
        value: GLib.Variant,
        user_data: object | None = None,
    ) -> None: ...

class has_actionActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.has_action
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> bool: ...

class list_actionsActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.list_actions
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
    ) -> list: ...

class get_action_enabledActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_enabled
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> bool: ...

class get_action_parameter_typeActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_parameter_type
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> GLib.VariantType | None: ...

class get_action_state_typeActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_state_type
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> GLib.VariantType | None: ...

class get_action_state_hintActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_state_hint
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> GLib.Variant | None: ...

class get_action_stateActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_state
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> GLib.Variant | None: ...

class change_action_stateActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.change_action_state
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
        value: GLib.Variant,
    ) -> None: ...

class activate_actionActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.activate_action
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
        parameter: GLib.Variant | None = None,
    ) -> None: ...

class action_addedActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.action_added
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> None: ...

class action_removedActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.action_removed
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> None: ...

class action_enabled_changedActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.action_enabled_changed
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
        enabled: bool,
    ) -> None: ...

class action_state_changedActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.action_state_changed
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
        state: GLib.Variant,
    ) -> None: ...

class query_actionActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.query_action
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> tuple[
        bool, bool, GLib.VariantType | None, GLib.VariantType | None, GLib.Variant | None, GLib.Variant | None
    ]: ...

class get_nameActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_name
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> str: ...

class get_parameter_typeActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_parameter_type
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> GLib.VariantType | None: ...

class get_state_typeActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_state_type
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> GLib.VariantType | None: ...

class get_state_hintActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_state_hint
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> GLib.Variant | None: ...

class get_enabledActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_enabled
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> bool: ...

class get_stateActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_state
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> GLib.Variant | None: ...

class change_stateActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.change_state
    """
    #  action
    def __call__(
        self,
        action: Action,
        value: GLib.Variant,
    ) -> None: ...

class activateActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.activate
    """
    #  action
    def __call__(
        self,
        action: Action,
        parameter: GLib.Variant | None = None,
    ) -> None: ...

class lookup_actionActionMapInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionMapInterface.lookup_action
    """
    #  action_map
    def __call__(
        self,
        action_map: ActionMap,
        action_name: str,
    ) -> Action | None: ...

class add_actionActionMapInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionMapInterface.add_action
    """
    #  action_map
    def __call__(
        self,
        action_map: ActionMap,
        action: Action,
    ) -> None: ...

class remove_actionActionMapInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionMapInterface.remove_action
    """
    #  action_map
    def __call__(
        self,
        action_map: ActionMap,
        action_name: str,
    ) -> None: ...

class AsyncReadyCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.accept_async, Gio.accept_socket_async, Gio.acquire_async, Gio.app_info_get_default_for_type_async, Gio.app_info_get_default_for_uri_scheme_async, Gio.app_info_launch_default_for_uri_async, Gio.append_to_async, Gio.ask_password_async, Gio.async_initable_newv_async, Gio.bus_get, Gio.call, Gio.call_with_unix_fd_list, Gio.can_reach_async, Gio.close, Gio.close_async, Gio.communicate_async, Gio.communicate_utf8_async, Gio.connect_async, Gio.connect_to_host_async, Gio.connect_to_service_async, Gio.connect_to_uri_async, Gio.create_async, Gio.create_readwrite_async, Gio.dbus_address_get_stream, Gio.delete_async, Gio.eject, Gio.eject_mountable, Gio.eject_mountable_with_operation, Gio.eject_with_operation, Gio.enumerate_children_async, Gio.file_new_tmp_async, Gio.file_new_tmp_dir_async, Gio.fill_async, Gio.find_enclosing_mount_async, Gio.flush, Gio.flush_async, Gio.get_default_for_type_async, Gio.get_default_for_uri_scheme_async, Gio.guess_content_type, Gio.handshake_async, Gio.init_async, Gio.launch_default_for_uri_async, Gio.launch_uris_async, Gio.load_async, Gio.load_bytes_async, Gio.load_contents_async, Gio.lookup_async, Gio.lookup_by_address_async, Gio.lookup_by_name_async, Gio.lookup_by_name_with_flags_async, Gio.lookup_certificate_for_handle_async, Gio.lookup_certificate_issuer_async, Gio.lookup_certificates_issued_by_async, Gio.lookup_records_async, Gio.lookup_service_async, Gio.make_directory_async, Gio.make_symbolic_link_async, Gio.mount, Gio.mount_enclosing_volume, Gio.mount_mountable, Gio.new, Gio.new_for_address, Gio.new_for_bus, Gio.new_from_error, Gio.new_tmp_async, Gio.new_tmp_dir_async, Gio.newv_async, Gio.next_async, Gio.next_files_async, Gio.open_readwrite_async, Gio.poll_for_media, Gio.poll_mountable, Gio.query_default_handler_async, Gio.query_filesystem_info_async, Gio.query_info_async, Gio.read_all_async, Gio.read_async, Gio.read_bytes_async, Gio.read_line_async, Gio.read_until_async, Gio.read_upto_async, Gio.receive_credentials_async, Gio.release_async, Gio.remount, Gio.replace_async, Gio.replace_contents_async, Gio.replace_contents_bytes_async, Gio.replace_readwrite_async, Gio.report_error, Gio.request_certificate_async, Gio.send_credentials_async, Gio.send_message_with_reply, Gio.set_attributes_async, Gio.set_display_name_async, Gio.shutdown_async, Gio.simple_async_report_gerror_in_idle, Gio.skip_async, Gio.splice_async, Gio.start, Gio.start_mountable, Gio.stop, Gio.stop_mountable, Gio.trash_async, Gio.unmount, Gio.unmount_mountable, Gio.unmount_mountable_with_operation, Gio.unmount_with_operation, Gio.verify_chain_async, Gio.wait_async, Gio.wait_check_async, Gio.write_all_async, Gio.write_async, Gio.write_bytes_async, Gio.writev_all_async, Gio.writev_async
    """
    #  source_object
    def __call__(
        self,
        source_object: GObject.Object | None,
        res: AsyncResult,
        data: object | None = None,
    ) -> None: ...

class dupAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.dup
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> AppInfo: ...

class equalAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.equal
    """
    #  appinfo1
    def __call__(
        self,
        appinfo1: AppInfo,
        appinfo2: AppInfo,
    ) -> bool: ...

class get_idAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_id
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str | None: ...

class get_nameAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_name
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str: ...

class get_descriptionAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_description
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str | None: ...

class get_executableAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_executable
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str: ...

class get_iconAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_icon
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> Icon | None: ...

class launchAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.launch
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        files: list | None = None,
        context: AppLaunchContext | None = None,
    ) -> bool: ...

class supports_urisAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.supports_uris
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class supports_filesAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.supports_files
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class launch_urisAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.launch_uris
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        uris: list | None = None,
        context: AppLaunchContext | None = None,
    ) -> bool: ...

class should_showAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.should_show
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class set_as_default_for_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.set_as_default_for_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        content_type: str,
    ) -> bool: ...

class set_as_default_for_extensionAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.set_as_default_for_extension
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        extension: str,
    ) -> bool: ...

class add_supports_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.add_supports_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        content_type: str,
    ) -> bool: ...

class can_remove_supports_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.can_remove_supports_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class remove_supports_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.remove_supports_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        content_type: str,
    ) -> bool: ...

class can_deleteAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.can_delete
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class do_deleteAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.do_delete
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class get_commandlineAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_commandline
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str | None: ...

class get_display_nameAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_display_name
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str: ...

class set_as_last_used_for_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.set_as_last_used_for_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        content_type: str,
    ) -> bool: ...

class get_supported_typesAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_supported_types
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> list: ...

class launch_uris_asyncAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.launch_uris_async
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        uris: list | None = None,
        context: AppLaunchContext | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class launch_uris_finishAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.launch_uris_finish
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        result: AsyncResult,
    ) -> bool: ...

class get_displayAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.get_display
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        info: AppInfo,
        files: list,
    ) -> str | None: ...

class get_startup_notify_idAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.get_startup_notify_id
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        info: AppInfo | None = None,
        files: list | None = None,
    ) -> str | None: ...

class launch_failedAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.launch_failed
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        startup_notify_id: str,
    ) -> None: ...

class launchedAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.launched
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        info: AppInfo,
        platform_data: GLib.Variant,
    ) -> None: ...

class launch_startedAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.launch_started
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        info: AppInfo,
        platform_data: GLib.Variant,
    ) -> None: ...

class startupApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.startup
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class activateApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.activate
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class openApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.open
    """
    #  application
    def __call__(
        self,
        application: Application,
        files: list,
        n_files: int,
        hint: str,
    ) -> None: ...

class command_lineApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.command_line
    """
    #  application
    def __call__(
        self,
        application: Application,
        command_line: ApplicationCommandLine,
    ) -> int: ...

class local_command_lineApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.local_command_line
    """
    #  application
    def __call__(
        self,
        application: Application,
        arguments: list,
    ) -> tuple[bool, list, int]: ...

class before_emitApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.before_emit
    """
    #  application
    def __call__(
        self,
        application: Application,
        platform_data: GLib.Variant,
    ) -> None: ...

class after_emitApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.after_emit
    """
    #  application
    def __call__(
        self,
        application: Application,
        platform_data: GLib.Variant,
    ) -> None: ...

class add_platform_dataApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.add_platform_data
    """
    #  application
    def __call__(
        self,
        application: Application,
        builder: GLib.VariantBuilder,
    ) -> None: ...

class quit_mainloopApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.quit_mainloop
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class run_mainloopApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.run_mainloop
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class shutdownApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.shutdown
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class dbus_registerApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.dbus_register
    """
    #  application
    def __call__(
        self,
        application: Application,
        connection: DBusConnection,
        object_path: str,
    ) -> bool: ...

class dbus_unregisterApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.dbus_unregister
    """
    #  application
    def __call__(
        self,
        application: Application,
        connection: DBusConnection,
        object_path: str,
    ) -> None: ...

class handle_local_optionsApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.handle_local_options
    """
    #  application
    def __call__(
        self,
        application: Application,
        options: GLib.VariantDict,
    ) -> int: ...

class name_lostApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.name_lost
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> bool: ...

class print_literalApplicationCommandLineClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationCommandLineClass.print_literal
    """
    #  cmdline
    def __call__(
        self,
        cmdline: ApplicationCommandLine,
        message: str,
    ) -> None: ...

class printerr_literalApplicationCommandLineClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationCommandLineClass.printerr_literal
    """
    #  cmdline
    def __call__(
        self,
        cmdline: ApplicationCommandLine,
        message: str,
    ) -> None: ...

class get_stdinApplicationCommandLineClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationCommandLineClass.get_stdin
    """
    #  cmdline
    def __call__(
        self,
        cmdline: ApplicationCommandLine,
    ) -> InputStream | None: ...

class doneApplicationCommandLineClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationCommandLineClass.done
    """
    #  cmdline
    def __call__(
        self,
        cmdline: ApplicationCommandLine,
    ) -> None: ...

class init_asyncAsyncInitableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncInitableIface.init_async
    """
    #  initable
    def __call__(
        self,
        initable: AsyncInitable,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class init_finishAsyncInitableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncInitableIface.init_finish
    """
    #  initable
    def __call__(
        self,
        initable: AsyncInitable,
        res: AsyncResult,
    ) -> bool: ...

class get_user_dataAsyncResultIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncResultIface.get_user_data
    """
    #  res
    def __call__(
        self,
        res: AsyncResult,
    ) -> object | None: ...

class get_source_objectAsyncResultIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncResultIface.get_source_object
    """
    #  res
    def __call__(
        self,
        res: AsyncResult,
    ) -> GObject.Object | None: ...

class is_taggedAsyncResultIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncResultIface.is_tagged
    """
    #  res
    def __call__(
        self,
        res: AsyncResult,
        source_tag: object | None = None,
    ) -> bool: ...

class fillBufferedInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferedInputStreamClass.fill
    """
    #  stream
    def __call__(
        self,
        stream: BufferedInputStream,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class fill_asyncBufferedInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferedInputStreamClass.fill_async
    """
    #  stream
    def __call__(
        self,
        stream: BufferedInputStream,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class fill_finishBufferedInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferedInputStreamClass.fill_finish
    """
    #  stream
    def __call__(
        self,
        stream: BufferedInputStream,
        result: AsyncResult,
    ) -> int: ...

class cancelledCancellableClassCB(typing.Protocol):
    """
    This callback was used in:
        CancellableClass.cancelled
    """
    #  cancellable
    def __call__(
        self,
        cancellable: Cancellable | None = None,
    ) -> None: ...

class convertConverterIfaceCB(typing.Protocol):
    """
    This callback was used in:
        ConverterIface.convert
    """
    #  converter
    def __call__(
        self,
        converter: Converter,
        inbuf: list | None,
        inbuf_size: int,
        outbuf: list,
        outbuf_size: int,
        flags: ConverterFlags,
    ) -> tuple[ConverterResult, int, int]: ...

class resetConverterIfaceCB(typing.Protocol):
    """
    This callback was used in:
        ConverterIface.reset
    """
    #  converter
    def __call__(
        self,
        converter: Converter,
    ) -> None: ...

class DBusMessageFilterFunction(typing.Protocol):
    """
    This callback was used in:
        Gio.add_filter
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        message: DBusMessage,
        incoming: bool,
        user_data: object | None = None,
    ) -> DBusMessage | None: ...

class DBusSignalCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.signal_subscribe
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender_name: str | None,
        object_path: str,
        interface_name: str,
        signal_name: str,
        parameters: GLib.Variant,
        user_data: object | None = None,
    ) -> None: ...

class get_infoDBusInterfaceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceIface.get_info
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterface,
    ) -> DBusInterfaceInfo: ...

class get_objectDBusInterfaceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceIface.get_object
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterface,
    ) -> DBusObject | None: ...

class set_objectDBusInterfaceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceIface.set_object
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterface,
        object: DBusObject | None = None,
    ) -> None: ...

class dup_objectDBusInterfaceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceIface.dup_object
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterface,
    ) -> DBusObject | None: ...

class get_infoDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.get_info
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
    ) -> DBusInterfaceInfo: ...

class get_vtableDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.get_vtable
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
    ) -> DBusInterfaceVTable: ...

class get_propertiesDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.get_properties
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
    ) -> GLib.Variant: ...

class flushDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.flush
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
    ) -> None: ...

class g_authorize_methodDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.g_authorize_method
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
        invocation: DBusMethodInvocation,
    ) -> bool: ...

class DBusInterfaceMethodCallFuncDBusInterfaceVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceVTable.method_call
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str | None,
        object_path: str,
        interface_name: str | None,
        method_name: str,
        parameters: GLib.Variant,
        invocation: DBusMethodInvocation,
        user_data: object | None = None,
    ) -> None: ...

class DBusInterfaceGetPropertyFuncDBusInterfaceVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceVTable.get_property
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str | None,
        object_path: str,
        interface_name: str,
        property_name: str,
        error: None,
        user_data: object | None = None,
    ) -> GLib.Variant: ...

class DBusInterfaceSetPropertyFuncDBusInterfaceVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceVTable.set_property
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str | None,
        object_path: str,
        interface_name: str,
        property_name: str,
        value: GLib.Variant,
        error: None,
        user_data: object | None = None,
    ) -> bool: ...

class get_object_pathDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.get_object_path
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
    ) -> str: ...

class get_interfacesDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.get_interfaces
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
    ) -> list: ...

class get_interfaceDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.get_interface
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
        interface_name: str,
    ) -> DBusInterface | None: ...

class interface_addedDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.interface_added
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
        interface_: DBusInterface,
    ) -> None: ...

class interface_removedDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.interface_removed
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
        interface_: DBusInterface,
    ) -> None: ...

class DBusProxyTypeFunc(typing.Protocol):
    """
    This callback was used in:
        Gio.new, Gio.new_for_bus, Gio.new_for_bus_sync, Gio.new_sync
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManagerClient,
        object_path: str,
        interface_name: str | None = None,
        data: object | None = None,
    ) -> GObject.GType: ...

class interface_proxy_signalDBusObjectManagerClientClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerClientClass.interface_proxy_signal
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManagerClient,
        object_proxy: DBusObjectProxy,
        interface_proxy: DBusProxy,
        sender_name: str,
        signal_name: str,
        parameters: GLib.Variant,
    ) -> None: ...

class interface_proxy_properties_changedDBusObjectManagerClientClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerClientClass.interface_proxy_properties_changed
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManagerClient,
        object_proxy: DBusObjectProxy,
        interface_proxy: DBusProxy,
        changed_properties: GLib.Variant,
        invalidated_properties: str,
    ) -> None: ...

class get_object_pathDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.get_object_path
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
    ) -> str: ...

class get_objectsDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.get_objects
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
    ) -> list: ...

class get_objectDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.get_object
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object_path: str,
    ) -> DBusObject | None: ...

class get_interfaceDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.get_interface
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object_path: str,
        interface_name: str,
    ) -> DBusInterface | None: ...

class object_addedDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.object_added
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object: DBusObject,
    ) -> None: ...

class object_removedDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.object_removed
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object: DBusObject,
    ) -> None: ...

class interface_addedDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.interface_added
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object: DBusObject,
        interface_: DBusInterface,
    ) -> None: ...

class interface_removedDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.interface_removed
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object: DBusObject,
        interface_: DBusInterface,
    ) -> None: ...

class authorize_methodDBusObjectSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectSkeletonClass.authorize_method
    """
    #  object
    def __call__(
        self,
        object: DBusObjectSkeleton,
        interface_: DBusInterfaceSkeleton,
        invocation: DBusMethodInvocation,
    ) -> bool: ...

class g_properties_changedDBusProxyClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusProxyClass.g_properties_changed
    """
    #  proxy
    def __call__(
        self,
        proxy: DBusProxy,
        changed_properties: GLib.Variant,
        invalidated_properties: str,
    ) -> None: ...

class g_signalDBusProxyClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusProxyClass.g_signal
    """
    #  proxy
    def __call__(
        self,
        proxy: DBusProxy,
        sender_name: str,
        signal_name: str,
        parameters: GLib.Variant,
    ) -> None: ...

class DBusSubtreeEnumerateFuncDBusSubtreeVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusSubtreeVTable.enumerate
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str,
        object_path: str,
        user_data: object | None = None,
    ) -> list: ...

class DBusSubtreeIntrospectFuncDBusSubtreeVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusSubtreeVTable.introspect
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str,
        object_path: str,
        node: str,
        user_data: object | None = None,
    ) -> list | None: ...

class DBusSubtreeDispatchFuncDBusSubtreeVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusSubtreeVTable.dispatch
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str,
        object_path: str,
        interface_name: str,
        node: str,
        out_user_data: object,
        user_data: object | None = None,
    ) -> DBusInterfaceVTable | None: ...

class receive_messagesDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.receive_messages
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        messages: list,
        num_messages: int,
        flags: int,
        timeout: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class send_messagesDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.send_messages
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        messages: list,
        num_messages: int,
        flags: int,
        timeout: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class create_sourceDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.create_source
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        condition: GLib.IOCondition,
        cancellable: Cancellable | None = None,
    ) -> GLib.Source: ...

class condition_checkDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.condition_check
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        condition: GLib.IOCondition,
    ) -> GLib.IOCondition: ...

class condition_waitDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.condition_wait
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        condition: GLib.IOCondition,
        timeout: int,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class authorizeDebugControllerDBusClassCB(typing.Protocol):
    """
    This callback was used in:
        DebugControllerDBusClass.authorize
    """
    #  controller
    def __call__(
        self,
        controller: DebugControllerDBus,
        invocation: DBusMethodInvocation,
    ) -> bool: ...

class DesktopAppLaunchCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.launch_uris_as_manager, Gio.launch_uris_as_manager_with_fds
    """
    #  appinfo
    def __call__(
        self,
        appinfo: DesktopAppInfo,
        pid: int,
        user_data: object | None = None,
    ) -> None: ...

class get_default_for_uri_schemeDesktopAppInfoLookupIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DesktopAppInfoLookupIface.get_default_for_uri_scheme
    """
    #  lookup
    def __call__(
        self,
        lookup: DesktopAppInfoLookup,
        uri_scheme: str,
    ) -> AppInfo | None: ...

class changedDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.changed
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> None: ...

class disconnectedDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.disconnected
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> None: ...

class eject_buttonDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject_button
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> None: ...

class get_nameDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_name
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> str: ...

class get_iconDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_icon
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> Icon: ...

class has_volumesDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.has_volumes
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class get_volumesDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_volumes
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> list: ...

class is_media_removableDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.is_media_removable
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class has_mediaDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.has_media
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class is_media_check_automaticDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.is_media_check_automatic
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class can_ejectDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_eject
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class can_poll_for_mediaDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_poll_for_media
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class ejectDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class eject_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class poll_for_mediaDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.poll_for_media
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class poll_for_media_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.poll_for_media_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class get_identifierDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_identifier
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        kind: str,
    ) -> str | None: ...

class enumerate_identifiersDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.enumerate_identifiers
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> list: ...

class get_start_stop_typeDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_start_stop_type
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> DriveStartStopType: ...

class can_startDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_start
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class can_start_degradedDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_start_degraded
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class startDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.start
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        flags: DriveStartFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class start_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.start_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class can_stopDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_stop
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class stopDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.stop
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class stop_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.stop_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class stop_buttonDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.stop_button
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> None: ...

class eject_with_operationDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject_with_operation
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class eject_with_operation_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject_with_operation_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class get_sort_keyDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_sort_key
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> str | None: ...

class get_symbolic_iconDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_symbolic_icon
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> Icon: ...

class is_removableDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.is_removable
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class accept_certificateDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.accept_certificate
    """
    #  connection
    def __call__(
        self,
        connection: DtlsConnection,
        peer_cert: TlsCertificate,
        errors: TlsCertificateFlags,
    ) -> bool: ...

class handshakeDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.handshake
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class handshake_asyncDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.handshake_async
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class handshake_finishDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.handshake_finish
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        result: AsyncResult,
    ) -> bool: ...

class shutdownDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.shutdown
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        shutdown_read: bool,
        shutdown_write: bool,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class shutdown_asyncDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.shutdown_async
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        shutdown_read: bool,
        shutdown_write: bool,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class shutdown_finishDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.shutdown_finish
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        result: AsyncResult,
    ) -> bool: ...

class set_advertised_protocolsDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.set_advertised_protocols
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        protocols: list | None = None,
    ) -> None: ...

class get_negotiated_protocolDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.get_negotiated_protocol
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
    ) -> str | None: ...

class get_binding_dataDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.get_binding_data
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        type: TlsChannelBindingType,
        data: list,
    ) -> bool: ...

class FileProgressCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.copy, Gio.move
    """
    #  current_num_bytes
    def __call__(
        self,
        current_num_bytes: int,
        total_num_bytes: int,
        data: object | None = None,
    ) -> None: ...

class FileMeasureProgressCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.measure_disk_usage
    """
    #  reporting
    def __call__(
        self,
        reporting: bool,
        current_size: int,
        num_dirs: int,
        num_files: int,
        data: object | None = None,
    ) -> None: ...

class get_fdFileDescriptorBasedIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileDescriptorBasedIface.get_fd
    """
    #  fd_based
    def __call__(
        self,
        fd_based: FileDescriptorBased,
    ) -> int: ...

class next_fileFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.next_file
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        cancellable: Cancellable | None = None,
    ) -> FileInfo | None: ...

class close_fnFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.close_fn
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class next_files_asyncFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.next_files_async
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        num_files: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class next_files_finishFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.next_files_finish
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        result: AsyncResult,
    ) -> list: ...

class close_asyncFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.close_async
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class close_finishFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.close_finish
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        result: AsyncResult,
    ) -> bool: ...

class tellFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.tell
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
    ) -> int: ...

class can_seekFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.can_seek
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
    ) -> bool: ...

class seekFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.seek
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class can_truncateFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.can_truncate
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
    ) -> bool: ...

class truncate_fnFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.truncate_fn
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class query_infoFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.query_info
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_info_asyncFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.query_info_async
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class query_info_finishFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.query_info_finish
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        result: AsyncResult,
    ) -> FileInfo: ...

class get_etagFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.get_etag
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
    ) -> str | None: ...

class dupFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.dup
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> File: ...

class hashFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.hash
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> int: ...

class equalFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.equal
    """
    #  file1
    def __call__(
        self,
        file1: File,
        file2: File,
    ) -> bool: ...

class is_nativeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.is_native
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> bool: ...

class has_uri_schemeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.has_uri_scheme
    """
    #  file
    def __call__(
        self,
        file: File,
        uri_scheme: str,
    ) -> bool: ...

class get_uri_schemeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_uri_scheme
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str | None: ...

class get_basenameFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_basename
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str | None: ...

class get_pathFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_path
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str | None: ...

class get_uriFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_uri
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str: ...

class get_parse_nameFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_parse_name
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str: ...

class get_parentFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_parent
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> File | None: ...

class prefix_matchesFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.prefix_matches
    """
    #  prefix
    def __call__(
        self,
        prefix: File,
        file: File,
    ) -> bool: ...

class get_relative_pathFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_relative_path
    """
    #  parent
    def __call__(
        self,
        parent: File,
        descendant: File,
    ) -> str | None: ...

class resolve_relative_pathFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.resolve_relative_path
    """
    #  file
    def __call__(
        self,
        file: File,
        relative_path: str,
    ) -> File: ...

class get_child_for_display_nameFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_child_for_display_name
    """
    #  file
    def __call__(
        self,
        file: File,
        display_name: str,
    ) -> File: ...

class enumerate_childrenFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.enumerate_children
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> FileEnumerator: ...

class enumerate_children_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.enumerate_children_async
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class enumerate_children_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.enumerate_children_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileEnumerator: ...

class query_infoFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_info
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_info_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_info_async
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class query_info_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_info_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileInfo: ...

class query_filesystem_infoFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_filesystem_info
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_filesystem_info_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_filesystem_info_async
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class query_filesystem_info_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_filesystem_info_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileInfo: ...

class find_enclosing_mountFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.find_enclosing_mount
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> Mount: ...

class find_enclosing_mount_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.find_enclosing_mount_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class find_enclosing_mount_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.find_enclosing_mount_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> Mount: ...

class set_display_nameFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_display_name
    """
    #  file
    def __call__(
        self,
        file: File,
        display_name: str,
        cancellable: Cancellable | None = None,
    ) -> File: ...

class set_display_name_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_display_name_async
    """
    #  file
    def __call__(
        self,
        file: File,
        display_name: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class set_display_name_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_display_name_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> File: ...

class query_settable_attributesFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_settable_attributes
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> FileAttributeInfoList: ...

class query_writable_namespacesFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_writable_namespaces
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> FileAttributeInfoList: ...

class set_attributeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_attribute
    """
    #  file
    def __call__(
        self,
        file: File,
        attribute: str,
        type: FileAttributeType,
        value_p: object | None,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class set_attributes_from_infoFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_attributes_from_info
    """
    #  file
    def __call__(
        self,
        file: File,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class set_attributes_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_attributes_async
    """
    #  file
    def __call__(
        self,
        file: File,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class set_attributes_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_attributes_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> tuple[bool, FileInfo]: ...

class read_fnFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.read_fn
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> FileInputStream: ...

class read_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.read_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class read_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.read_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileInputStream: ...

class append_toFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.append_to
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileOutputStream: ...

class append_to_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.append_to_async
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class append_to_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.append_to_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileOutputStream: ...

class createFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileOutputStream: ...

class create_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_async
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class create_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileOutputStream: ...

class replaceFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace
    """
    #  file
    def __call__(
        self,
        file: File,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileOutputStream: ...

class replace_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_async
    """
    #  file
    def __call__(
        self,
        file: File,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class replace_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileOutputStream: ...

class delete_fileFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.delete_file
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class delete_file_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.delete_file_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class delete_file_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.delete_file_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class trashFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.trash
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class trash_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.trash_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class trash_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.trash_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class make_directoryFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_directory
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class make_directory_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_directory_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class make_directory_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_directory_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class make_symbolic_linkFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_symbolic_link
    """
    #  file
    def __call__(
        self,
        file: File,
        symlink_value: str,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class make_symbolic_link_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_symbolic_link_async
    """
    #  file
    def __call__(
        self,
        file: File,
        symlink_value: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class make_symbolic_link_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_symbolic_link_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class copyFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.copy
    """
    #  source
    def __call__(
        self,
        source: File,
        destination: File,
        flags: FileCopyFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        progress_callback_data: object | None = None,
    ) -> bool: ...

class copy_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.copy_async
    """
    #  source
    def __call__(
        self,
        source: File,
        destination: File,
        flags: FileCopyFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        progress_callback_data: object | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class copy_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.copy_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> bool: ...

class moveFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.move
    """
    #  source
    def __call__(
        self,
        source: File,
        destination: File,
        flags: FileCopyFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        progress_callback_data: object | None = None,
    ) -> bool: ...

class move_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.move_async
    """
    #  source
    def __call__(
        self,
        source: File,
        destination: File,
        flags: FileCopyFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        progress_callback_data: object | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class move_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.move_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class mount_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.mount_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class mount_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.mount_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> File: ...

class unmount_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.unmount_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class unmount_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.unmount_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class eject_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.eject_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class eject_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.eject_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class mount_enclosing_volumeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.mount_enclosing_volume
    """
    #  location
    def __call__(
        self,
        location: File,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class mount_enclosing_volume_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.mount_enclosing_volume_finish
    """
    #  location
    def __call__(
        self,
        location: File,
        result: AsyncResult,
    ) -> bool: ...

class monitor_dirFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.monitor_dir
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileMonitorFlags,
        cancellable: Cancellable | None = None,
    ) -> FileMonitor: ...

class monitor_fileFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.monitor_file
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileMonitorFlags,
        cancellable: Cancellable | None = None,
    ) -> FileMonitor: ...

class open_readwriteFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.open_readwrite
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> FileIOStream: ...

class open_readwrite_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.open_readwrite_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class open_readwrite_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.open_readwrite_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileIOStream: ...

class create_readwriteFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_readwrite
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileIOStream: ...

class create_readwrite_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_readwrite_async
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class create_readwrite_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_readwrite_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileIOStream: ...

class replace_readwriteFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_readwrite
    """
    #  file
    def __call__(
        self,
        file: File,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileIOStream: ...

class replace_readwrite_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_readwrite_async
    """
    #  file
    def __call__(
        self,
        file: File,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class replace_readwrite_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_readwrite_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileIOStream: ...

class start_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.start_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: DriveStartFlags,
        start_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class start_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.start_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class stop_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.stop_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class stop_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.stop_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class unmount_mountable_with_operationFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.unmount_mountable_with_operation
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class unmount_mountable_with_operation_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.unmount_mountable_with_operation_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class eject_mountable_with_operationFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.eject_mountable_with_operation
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class eject_mountable_with_operation_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.eject_mountable_with_operation_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class poll_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.poll_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class poll_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.poll_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class measure_disk_usageFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.measure_disk_usage
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileMeasureFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileMeasureProgressCallback | None = None,
        progress_data: object | None = None,
    ) -> tuple[bool, int | None, int | None, int | None]: ...

class measure_disk_usage_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.measure_disk_usage_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> tuple[bool, int | None, int | None, int | None]: ...

class query_existsFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_exists
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class tellFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.tell
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
    ) -> int: ...

class can_seekFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.can_seek
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
    ) -> bool: ...

class seekFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.seek
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class query_infoFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.query_info
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_info_asyncFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.query_info_async
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class query_info_finishFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.query_info_finish
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
        result: AsyncResult,
    ) -> FileInfo: ...

class changedFileMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileMonitorClass.changed
    """
    #  monitor
    def __call__(
        self,
        monitor: FileMonitor,
        file: File,
        other_file: File,
        event_type: FileMonitorEvent,
    ) -> None: ...

class cancelFileMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileMonitorClass.cancel
    """
    #  monitor
    def __call__(
        self,
        monitor: FileMonitor,
    ) -> bool: ...

class tellFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.tell
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
    ) -> int: ...

class can_seekFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.can_seek
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
    ) -> bool: ...

class seekFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.seek
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class can_truncateFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.can_truncate
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
    ) -> bool: ...

class truncate_fnFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.truncate_fn
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class query_infoFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.query_info
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_info_asyncFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.query_info_async
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class query_info_finishFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.query_info_finish
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        result: AsyncResult,
    ) -> FileInfo: ...

class get_etagFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.get_etag
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
    ) -> str | None: ...

class got_completion_dataFilenameCompleterClassCB(typing.Protocol):
    """
    This callback was used in:
        FilenameCompleterClass.got_completion_data
    """
    #  filename_completer
    def __call__(
        self,
        filename_completer: FilenameCompleter,
    ) -> None: ...

class get_input_streamIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.get_input_stream
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
    ) -> InputStream: ...

class get_output_streamIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.get_output_stream
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
    ) -> OutputStream: ...

class close_fnIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.close_fn
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class close_asyncIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.close_async
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class close_finishIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.close_finish
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
        result: AsyncResult,
    ) -> bool: ...

class hashIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        IconIface.hash
    """
    #  icon
    def __call__(
        self,
        icon: Icon,
    ) -> int: ...

class equalIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        IconIface.equal
    """
    #  icon1
    def __call__(
        self,
        icon1: Icon | None = None,
        icon2: Icon | None = None,
    ) -> bool: ...

class to_tokensIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        IconIface.to_tokens
    """
    #  icon
    def __call__(
        self,
        icon: Icon,
    ) -> tuple[bool, list, int]: ...

class serializeIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        IconIface.serialize
    """
    #  icon
    def __call__(
        self,
        icon: Icon,
    ) -> GLib.Variant | None: ...

class to_stringInetAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        InetAddressClass.to_string
    """
    #  address
    def __call__(
        self,
        address: InetAddress,
    ) -> str: ...

class to_bytesInetAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        InetAddressClass.to_bytes
    """
    #  address
    def __call__(
        self,
        address: InetAddress,
    ) -> int: ...

class initInitableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        InitableIface.init
    """
    #  initable
    def __call__(
        self,
        initable: Initable,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class read_fnInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.read_fn
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        buffer: object | None,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class skipInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.skip
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class close_fnInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.close_fn
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class read_asyncInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.read_async
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> list | None: ...

class read_finishInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.read_finish
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        result: AsyncResult,
    ) -> int: ...

class skip_asyncInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.skip_async
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class skip_finishInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.skip_finish
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        result: AsyncResult,
    ) -> int: ...

class close_asyncInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.close_async
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class close_finishInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.close_finish
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        result: AsyncResult,
    ) -> bool: ...

class get_item_typeListModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ListModelInterface.get_item_type
    """
    #  list
    def __call__(
        self,
        list: ListModel,
    ) -> GObject.GType: ...

class get_n_itemsListModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ListModelInterface.get_n_items
    """
    #  list
    def __call__(
        self,
        list: ListModel,
    ) -> int: ...

class get_itemListModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ListModelInterface.get_item
    """
    #  list
    def __call__(
        self,
        list: ListModel,
        position: int,
    ) -> GObject.Object | None: ...

class loadLoadableIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        LoadableIconIface.load
    """
    #  icon
    def __call__(
        self,
        icon: LoadableIcon,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> tuple[InputStream, str | None]: ...

class load_asyncLoadableIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        LoadableIconIface.load_async
    """
    #  icon
    def __call__(
        self,
        icon: LoadableIcon,
        size: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class load_finishLoadableIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        LoadableIconIface.load_finish
    """
    #  icon
    def __call__(
        self,
        icon: LoadableIcon,
        res: AsyncResult,
    ) -> tuple[InputStream, str | None]: ...

class low_memory_warningMemoryMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        MemoryMonitorInterface.low_memory_warning
    """
    #  monitor
    def __call__(
        self,
        monitor: MemoryMonitor,
        level: MemoryMonitorWarningLevel,
    ) -> None: ...

class get_nextMenuAttributeIterClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuAttributeIterClass.get_next
    """
    #  iter
    def __call__(
        self,
        iter: MenuAttributeIter,
    ) -> tuple[bool, str | None, GLib.Variant | None]: ...

class get_nextMenuLinkIterClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuLinkIterClass.get_next
    """
    #  iter
    def __call__(
        self,
        iter: MenuLinkIter,
    ) -> tuple[bool, str | None, MenuModel | None]: ...

class is_mutableMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.is_mutable
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
    ) -> bool: ...

class get_n_itemsMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_n_items
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
    ) -> int: ...

class get_item_attributesMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_item_attributes
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
    ) -> dict: ...

class iterate_item_attributesMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.iterate_item_attributes
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
    ) -> MenuAttributeIter: ...

class get_item_attribute_valueMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_item_attribute_value
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
        attribute: str,
        expected_type: GLib.VariantType | None = None,
    ) -> GLib.Variant | None: ...

class get_item_linksMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_item_links
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
    ) -> dict: ...

class iterate_item_linksMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.iterate_item_links
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
    ) -> MenuLinkIter: ...

class get_item_linkMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_item_link
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
        link: str,
    ) -> MenuModel | None: ...

class changedMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.changed
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> None: ...

class unmountedMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmounted
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> None: ...

class get_rootMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_root
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> File: ...

class get_nameMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_name
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> str: ...

class get_iconMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_icon
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> Icon: ...

class get_uuidMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_uuid
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> str | None: ...

class get_volumeMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_volume
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> Volume | None: ...

class get_driveMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_drive
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> Drive | None: ...

class can_unmountMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.can_unmount
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> bool: ...

class can_ejectMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.can_eject
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> bool: ...

class unmountMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmount
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class unmount_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmount_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class ejectMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.eject
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class eject_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.eject_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class remountMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.remount
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class remount_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.remount_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class guess_content_typeMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.guess_content_type
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        force_rescan: bool,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class guess_content_type_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.guess_content_type_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> list: ...

class guess_content_type_syncMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.guess_content_type_sync
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        force_rescan: bool,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class pre_unmountMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.pre_unmount
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> None: ...

class unmount_with_operationMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmount_with_operation
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class unmount_with_operation_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmount_with_operation_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class eject_with_operationMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.eject_with_operation
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class eject_with_operation_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.eject_with_operation_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class get_default_locationMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_default_location
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> File: ...

class get_sort_keyMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_sort_key
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> str | None: ...

class get_symbolic_iconMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_symbolic_icon
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> Icon: ...

class ask_passwordMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.ask_password
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        message: str,
        default_user: str,
        default_domain: str,
        flags: AskPasswordFlags,
    ) -> None: ...

class ask_questionMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.ask_question
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        message: str,
        choices: list,
    ) -> None: ...

class replyMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.reply
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        result: MountOperationResult,
    ) -> None: ...

class abortedMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.aborted
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
    ) -> None: ...

class show_processesMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.show_processes
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        message: str,
        processes: list,
        choices: list,
    ) -> None: ...

class show_unmount_progressMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.show_unmount_progress
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        message: str,
        time_left: int,
        bytes_left: int,
    ) -> None: ...

class network_changedNetworkMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        NetworkMonitorInterface.network_changed
    """
    #  monitor
    def __call__(
        self,
        monitor: NetworkMonitor,
        network_available: bool,
    ) -> None: ...

class can_reachNetworkMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        NetworkMonitorInterface.can_reach
    """
    #  monitor
    def __call__(
        self,
        monitor: NetworkMonitor,
        connectable: SocketConnectable,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class can_reach_asyncNetworkMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        NetworkMonitorInterface.can_reach_async
    """
    #  monitor
    def __call__(
        self,
        monitor: NetworkMonitor,
        connectable: SocketConnectable,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class can_reach_finishNetworkMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        NetworkMonitorInterface.can_reach_finish
    """
    #  monitor
    def __call__(
        self,
        monitor: NetworkMonitor,
        result: AsyncResult,
    ) -> bool: ...

class write_fnOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.write_fn
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        buffer: list | None,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class spliceOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.splice
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class flushOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.flush
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class close_fnOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.close_fn
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class write_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.write_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        buffer: list | None,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class write_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.write_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> int: ...

class splice_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.splice_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class splice_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.splice_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> int: ...

class flush_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.flush_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class flush_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.flush_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> bool: ...

class close_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.close_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class close_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.close_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> bool: ...

class writev_fnOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.writev_fn
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        vectors: list,
        n_vectors: int,
        cancellable: Cancellable | None = None,
    ) -> tuple[bool, int | None]: ...

class writev_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.writev_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        vectors: list,
        n_vectors: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class writev_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.writev_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> tuple[bool, int | None]: ...

class acquirePermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.acquire
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class acquire_asyncPermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.acquire_async
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class acquire_finishPermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.acquire_finish
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        result: AsyncResult,
    ) -> bool: ...

class releasePermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.release
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class release_asyncPermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.release_async
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class release_finishPermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.release_finish
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        result: AsyncResult,
    ) -> bool: ...

class can_pollPollableInputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableInputStreamInterface.can_poll
    """
    #  stream
    def __call__(
        self,
        stream: PollableInputStream,
    ) -> bool: ...

class is_readablePollableInputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableInputStreamInterface.is_readable
    """
    #  stream
    def __call__(
        self,
        stream: PollableInputStream,
    ) -> bool: ...

class create_sourcePollableInputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableInputStreamInterface.create_source
    """
    #  stream
    def __call__(
        self,
        stream: PollableInputStream,
        cancellable: Cancellable | None = None,
    ) -> GLib.Source: ...

class read_nonblockingPollableInputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableInputStreamInterface.read_nonblocking
    """
    #  stream
    def __call__(
        self,
        stream: PollableInputStream,
        count: int,
    ) -> tuple[int, list | None]: ...

class can_pollPollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.can_poll
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
    ) -> bool: ...

class is_writablePollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.is_writable
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
    ) -> bool: ...

class create_sourcePollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.create_source
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
        cancellable: Cancellable | None = None,
    ) -> GLib.Source: ...

class write_nonblockingPollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.write_nonblocking
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
        buffer: list | None,
        count: int,
    ) -> int: ...

class writev_nonblockingPollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.writev_nonblocking
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
        vectors: list,
        n_vectors: int,
    ) -> tuple[PollableReturn, int | None]: ...

class connectProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyInterface.connect
    """
    #  proxy
    def __call__(
        self,
        proxy: Proxy,
        connection: IOStream,
        proxy_address: ProxyAddress,
        cancellable: Cancellable | None = None,
    ) -> IOStream: ...

class connect_asyncProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyInterface.connect_async
    """
    #  proxy
    def __call__(
        self,
        proxy: Proxy,
        connection: IOStream,
        proxy_address: ProxyAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class connect_finishProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyInterface.connect_finish
    """
    #  proxy
    def __call__(
        self,
        proxy: Proxy,
        result: AsyncResult,
    ) -> IOStream: ...

class supports_hostnameProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyInterface.supports_hostname
    """
    #  proxy
    def __call__(
        self,
        proxy: Proxy,
    ) -> bool: ...

class is_supportedProxyResolverInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyResolverInterface.is_supported
    """
    #  resolver
    def __call__(
        self,
        resolver: ProxyResolver,
    ) -> bool: ...

class lookupProxyResolverInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyResolverInterface.lookup
    """
    #  resolver
    def __call__(
        self,
        resolver: ProxyResolver,
        uri: str,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class lookup_asyncProxyResolverInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyResolverInterface.lookup_async
    """
    #  resolver
    def __call__(
        self,
        resolver: ProxyResolver,
        uri: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class lookup_finishProxyResolverInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyResolverInterface.lookup_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: ProxyResolver,
        result: AsyncResult,
    ) -> list: ...

class activate_action_fullRemoteActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        RemoteActionGroupInterface.activate_action_full
    """
    #  remote
    def __call__(
        self,
        remote: RemoteActionGroup,
        action_name: str,
        parameter: GLib.Variant | None,
        platform_data: GLib.Variant,
    ) -> None: ...

class change_action_state_fullRemoteActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        RemoteActionGroupInterface.change_action_state_full
    """
    #  remote
    def __call__(
        self,
        remote: RemoteActionGroup,
        action_name: str,
        value: GLib.Variant,
        platform_data: GLib.Variant,
    ) -> None: ...

class reloadResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.reload
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
    ) -> None: ...

class lookup_by_nameResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        hostname: str,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class lookup_by_name_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        hostname: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class lookup_by_name_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> list: ...

class lookup_by_addressResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_address
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        address: InetAddress,
        cancellable: Cancellable | None = None,
    ) -> str: ...

class lookup_by_address_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_address_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        address: InetAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class lookup_by_address_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_address_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> str: ...

class lookup_service_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_service_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        rrname: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class lookup_service_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_service_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> list: ...

class lookup_recordsResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_records
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class lookup_records_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_records_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class lookup_records_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_records_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> list: ...

class lookup_by_name_with_flags_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_with_flags_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class lookup_by_name_with_flags_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_with_flags_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> list: ...

class lookup_by_name_with_flagsResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_with_flags
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class tellSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.tell
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
    ) -> int: ...

class can_seekSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.can_seek
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
    ) -> bool: ...

class seekSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.seek
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class can_truncateSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.can_truncate
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
    ) -> bool: ...

class truncate_fnSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.truncate_fn
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
        offset: int,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class SettingsGetMapping(typing.Protocol):
    """
    This callback was used in:
        Gio.get_mapped
    """
    #  value
    def __call__(
        self,
        value: GLib.Variant | None = None,
        user_data: object | None = None,
    ) -> tuple[bool, object | None]: ...

class readSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.read
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
        expected_type: GLib.VariantType,
        default_value: bool,
    ) -> GLib.Variant: ...

class get_writableSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.get_writable
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
    ) -> bool: ...

class writeSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.write
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
        value: GLib.Variant,
        origin_tag: object | None = None,
    ) -> bool: ...

class write_treeSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.write_tree
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        tree: GLib.Tree,
        origin_tag: object | None = None,
    ) -> bool: ...

class resetSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.reset
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
        origin_tag: object | None = None,
    ) -> None: ...

class subscribeSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.subscribe
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        name: str,
    ) -> None: ...

class unsubscribeSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.unsubscribe
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        name: str,
    ) -> None: ...

class syncSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.sync
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
    ) -> None: ...

class read_user_valueSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.read_user_value
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
        expected_type: GLib.VariantType,
    ) -> GLib.Variant: ...

class writable_changedSettingsClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsClass.writable_changed
    """
    #  settings
    def __call__(
        self,
        settings: Settings,
        key: str,
    ) -> None: ...

class changedSettingsClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsClass.changed
    """
    #  settings
    def __call__(
        self,
        settings: Settings,
        key: str,
    ) -> None: ...

class writable_change_eventSettingsClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsClass.writable_change_event
    """
    #  settings
    def __call__(
        self,
        settings: Settings,
        key: int,
    ) -> bool: ...

class change_eventSettingsClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsClass.change_event
    """
    #  settings
    def __call__(
        self,
        settings: Settings,
        keys: int,
        n_keys: int,
    ) -> bool: ...

class get_familySocketAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressClass.get_family
    """
    #  address
    def __call__(
        self,
        address: SocketAddress,
    ) -> SocketFamily: ...

class get_native_sizeSocketAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressClass.get_native_size
    """
    #  address
    def __call__(
        self,
        address: SocketAddress,
    ) -> int: ...

class to_nativeSocketAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressClass.to_native
    """
    #  address
    def __call__(
        self,
        address: SocketAddress,
        dest: object | None,
        destlen: int,
    ) -> bool: ...

class nextSocketAddressEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressEnumeratorClass.next
    """
    #  enumerator
    def __call__(
        self,
        enumerator: SocketAddressEnumerator,
        cancellable: Cancellable | None = None,
    ) -> SocketAddress | None: ...

class next_asyncSocketAddressEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressEnumeratorClass.next_async
    """
    #  enumerator
    def __call__(
        self,
        enumerator: SocketAddressEnumerator,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class next_finishSocketAddressEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressEnumeratorClass.next_finish
    """
    #  enumerator
    def __call__(
        self,
        enumerator: SocketAddressEnumerator,
        result: AsyncResult,
    ) -> SocketAddress | None: ...

class eventSocketClientClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketClientClass.event
    """
    #  client
    def __call__(
        self,
        client: SocketClient,
        event: SocketClientEvent,
        connectable: SocketConnectable,
        connection: IOStream,
    ) -> None: ...

class enumerateSocketConnectableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SocketConnectableIface.enumerate
    """
    #  connectable
    def __call__(
        self,
        connectable: SocketConnectable,
    ) -> SocketAddressEnumerator: ...

class proxy_enumerateSocketConnectableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SocketConnectableIface.proxy_enumerate
    """
    #  connectable
    def __call__(
        self,
        connectable: SocketConnectable,
    ) -> SocketAddressEnumerator: ...

class to_stringSocketConnectableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SocketConnectableIface.to_string
    """
    #  connectable
    def __call__(
        self,
        connectable: SocketConnectable,
    ) -> str: ...

class get_sizeSocketControlMessageClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketControlMessageClass.get_size
    """
    #  message
    def __call__(
        self,
        message: SocketControlMessage,
    ) -> int: ...

class get_levelSocketControlMessageClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketControlMessageClass.get_level
    """
    #  message
    def __call__(
        self,
        message: SocketControlMessage,
    ) -> int: ...

class get_typeSocketControlMessageClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketControlMessageClass.get_type
    """
    #  message
    def __call__(
        self,
        message: SocketControlMessage,
    ) -> int: ...

class serializeSocketControlMessageClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketControlMessageClass.serialize
    """
    #  message
    def __call__(
        self,
        message: SocketControlMessage,
        data: object,
    ) -> None: ...

class changedSocketListenerClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketListenerClass.changed
    """
    #  listener
    def __call__(
        self,
        listener: SocketListener,
    ) -> None: ...

class eventSocketListenerClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketListenerClass.event
    """
    #  listener
    def __call__(
        self,
        listener: SocketListener,
        event: SocketListenerEvent,
        socket: Socket,
    ) -> None: ...

class incomingSocketServiceClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketServiceClass.incoming
    """
    #  service
    def __call__(
        self,
        service: SocketService,
        connection: SocketConnection,
        source_object: GObject.Object,
    ) -> bool: ...

class TaskThreadFunc(typing.Protocol):
    """
    This callback was used in:
        Gio.run_in_thread, Gio.run_in_thread_sync
    """
    #  task
    def __call__(
        self,
        task: Task,
        source_object: GObject.Object,
        task_data: object | None = None,
        cancellable: Cancellable | None = None,
    ) -> None: ...

class runThreadedSocketServiceClassCB(typing.Protocol):
    """
    This callback was used in:
        ThreadedSocketServiceClass.run
    """
    #  service
    def __call__(
        self,
        service: ThreadedSocketService,
        connection: SocketConnection,
        source_object: GObject.Object,
    ) -> bool: ...

class supports_tlsTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.supports_tls
    """
    #  backend
    def __call__(
        self,
        backend: TlsBackend,
    ) -> bool: ...

class get_certificate_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_certificate_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_client_connection_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_client_connection_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_server_connection_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_server_connection_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_file_database_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_file_database_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_default_databaseTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_default_database
    """
    #  backend
    def __call__(
        self,
        backend: TlsBackend,
    ) -> TlsDatabase: ...

class supports_dtlsTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.supports_dtls
    """
    #  backend
    def __call__(
        self,
        backend: TlsBackend,
    ) -> bool: ...

class get_dtls_client_connection_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_dtls_client_connection_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_dtls_server_connection_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_dtls_server_connection_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class verifyTlsCertificateClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsCertificateClass.verify
    """
    #  cert
    def __call__(
        self,
        cert: TlsCertificate,
        identity: SocketConnectable | None = None,
        trusted_ca: TlsCertificate | None = None,
    ) -> TlsCertificateFlags: ...

class copy_session_stateTlsClientConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsClientConnectionInterface.copy_session_state
    """
    #  conn
    def __call__(
        self,
        conn: TlsClientConnection,
        source: TlsClientConnection,
    ) -> None: ...

class accept_certificateTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.accept_certificate
    """
    #  connection
    def __call__(
        self,
        connection: TlsConnection,
        peer_cert: TlsCertificate,
        errors: TlsCertificateFlags,
    ) -> bool: ...

class handshakeTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.handshake
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class handshake_asyncTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.handshake_async
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class handshake_finishTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.handshake_finish
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
        result: AsyncResult,
    ) -> bool: ...

class get_binding_dataTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.get_binding_data
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
        type: TlsChannelBindingType,
        data: list,
    ) -> bool: ...

class get_negotiated_protocolTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.get_negotiated_protocol
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
    ) -> str | None: ...

class verify_chainTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.verify_chain
    """
    #  self
    def __call__(
        self: TlsDatabase,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificateFlags: ...

class verify_chain_asyncTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.verify_chain_async
    """
    #  self
    def __call__(
        self: TlsDatabase,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class verify_chain_finishTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.verify_chain_finish
    """
    #  self
    def __call__(
        self: TlsDatabase,
        result: AsyncResult,
    ) -> TlsCertificateFlags: ...

class create_certificate_handleTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.create_certificate_handle
    """
    #  self
    def __call__(
        self: TlsDatabase,
        certificate: TlsCertificate,
    ) -> str | None: ...

class lookup_certificate_for_handleTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_for_handle
    """
    #  self
    def __call__(
        self: TlsDatabase,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate | None: ...

class lookup_certificate_for_handle_asyncTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_for_handle_async
    """
    #  self
    def __call__(
        self: TlsDatabase,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class lookup_certificate_for_handle_finishTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_for_handle_finish
    """
    #  self
    def __call__(
        self: TlsDatabase,
        result: AsyncResult,
    ) -> TlsCertificate: ...

class lookup_certificate_issuerTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_issuer
    """
    #  self
    def __call__(
        self: TlsDatabase,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate: ...

class lookup_certificate_issuer_asyncTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_issuer_async
    """
    #  self
    def __call__(
        self: TlsDatabase,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class lookup_certificate_issuer_finishTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_issuer_finish
    """
    #  self
    def __call__(
        self: TlsDatabase,
        result: AsyncResult,
    ) -> TlsCertificate: ...

class lookup_certificates_issued_byTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificates_issued_by
    """
    #  self
    def __call__(
        self: TlsDatabase,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class lookup_certificates_issued_by_asyncTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificates_issued_by_async
    """
    #  self
    def __call__(
        self: TlsDatabase,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class lookup_certificates_issued_by_finishTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificates_issued_by_finish
    """
    #  self
    def __call__(
        self: TlsDatabase,
        result: AsyncResult,
    ) -> list: ...

class ask_passwordTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.ask_password
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
    ) -> TlsInteractionResult: ...

class ask_password_asyncTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.ask_password_async
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class ask_password_finishTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.ask_password_finish
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        result: AsyncResult,
    ) -> TlsInteractionResult: ...

class request_certificateTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.request_certificate
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsInteractionResult: ...

class request_certificate_asyncTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.request_certificate_async
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class request_certificate_finishTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.request_certificate_finish
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        result: AsyncResult,
    ) -> TlsInteractionResult: ...

class get_valueTlsPasswordClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsPasswordClass.get_value
    """
    #  password
    def __call__(
        self,
        password: TlsPassword,
    ) -> tuple[list, int | None]: ...

class set_valueTlsPasswordClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsPasswordClass.set_value
    """
    #  password
    def __call__(
        self,
        password: TlsPassword,
        value: list,
        length: int,
        destroy: GLib.DestroyNotify | None = None,  # type: ignore
    ) -> None: ...

class get_default_warningTlsPasswordClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsPasswordClass.get_default_warning
    """
    #  password
    def __call__(
        self,
        password: TlsPassword,
    ) -> str: ...

class VfsFileLookupFunc(typing.Protocol):
    """
    This callback was used in:
        Gio.register_uri_scheme
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        identifier: str,
        user_data: object | None = None,
    ) -> File | None: ...

class is_activeVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.is_active
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
    ) -> bool: ...

class get_file_for_pathVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.get_file_for_path
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        path: str,
    ) -> File: ...

class get_file_for_uriVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.get_file_for_uri
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        uri: str,
    ) -> File: ...

class get_supported_uri_schemesVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.get_supported_uri_schemes
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
    ) -> list: ...

class parse_nameVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.parse_name
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        parse_name: str,
    ) -> File: ...

class local_file_add_infoVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.local_file_add_info
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        filename: str,
        device: int,
        attribute_matcher: FileAttributeMatcher,
        info: FileInfo,
        cancellable: Cancellable | None,
        extra_data: object | None,
        free_extra_data: GLib.DestroyNotify,  # type: ignore
    ) -> None: ...

class add_writable_namespacesVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.add_writable_namespaces
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        list: FileAttributeInfoList,
    ) -> None: ...

class local_file_set_attributesVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.local_file_set_attributes
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        filename: str,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class local_file_removedVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.local_file_removed
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        filename: str,
    ) -> None: ...

class local_file_movedVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.local_file_moved
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        source: str,
        dest: str,
    ) -> None: ...

class changedVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.changed
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> None: ...

class removedVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.removed
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> None: ...

class get_nameVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_name
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> str: ...

class get_iconVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_icon
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> Icon: ...

class get_uuidVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_uuid
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> str | None: ...

class get_driveVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_drive
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> Drive | None: ...

class get_mountVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_mount
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> Mount | None: ...

class can_mountVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.can_mount
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> bool: ...

class can_ejectVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.can_eject
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> bool: ...

class mount_fnVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.mount_fn
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class mount_finishVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.mount_finish
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        result: AsyncResult,
    ) -> bool: ...

class ejectVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.eject
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class eject_finishVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.eject_finish
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        result: AsyncResult,
    ) -> bool: ...

class get_identifierVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_identifier
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        kind: str,
    ) -> str | None: ...

class enumerate_identifiersVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.enumerate_identifiers
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> list: ...

class should_automountVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.should_automount
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> bool: ...

class get_activation_rootVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_activation_root
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> File | None: ...

class eject_with_operationVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.eject_with_operation
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        user_data: object | None = None,
    ) -> None: ...

class eject_with_operation_finishVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.eject_with_operation_finish
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        result: AsyncResult,
    ) -> bool: ...

class get_sort_keyVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_sort_key
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> str | None: ...

class get_symbolic_iconVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_symbolic_icon
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> Icon: ...

class volume_addedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.volume_added
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        volume: Volume,
    ) -> None: ...

class volume_removedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.volume_removed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        volume: Volume,
    ) -> None: ...

class volume_changedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.volume_changed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        volume: Volume,
    ) -> None: ...

class mount_addedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.mount_added
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        mount: Mount,
    ) -> None: ...

class mount_removedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.mount_removed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        mount: Mount,
    ) -> None: ...

class mount_pre_unmountVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.mount_pre_unmount
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        mount: Mount,
    ) -> None: ...

class mount_changedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.mount_changed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        mount: Mount,
    ) -> None: ...

class drive_connectedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_connected
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class drive_disconnectedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_disconnected
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class drive_changedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_changed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class is_supportedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.is_supported
    """
    #
    def __call__(
        self,
    ) -> bool: ...

class get_connected_drivesVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_connected_drives
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
    ) -> list: ...

class get_volumesVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_volumes
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
    ) -> list: ...

class get_mountsVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_mounts
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
    ) -> list: ...

class get_volume_for_uuidVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_volume_for_uuid
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        uuid: str,
    ) -> Volume | None: ...

class get_mount_for_uuidVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_mount_for_uuid
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        uuid: str,
    ) -> Mount | None: ...

class drive_eject_buttonVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_eject_button
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class drive_stop_buttonVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_stop_button
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class IOSchedulerJobFunc(typing.Protocol):
    """
    This callback was used in:
        Gio.io_scheduler_push_job
    """
    #  job
    def __call__(
        self,
        job: IOSchedulerJob,
        cancellable: Cancellable | None = None,
        data: object | None = None,
    ) -> bool: ...

###############################################################
# Aliases
###############################################################

FDMessage = GioUnix.FDMessage
"""
[DEPRECATED] Gio.FDMessage is deprecated; use GioUnix.FDMessage instead
"""
FDMessageClass = GioUnix.FDMessageClass
"""
[DEPRECATED] Gio.FDMessageClass is deprecated; use GioUnix.FDMessageClass instead
"""
FDMessagePrivate = GioUnix.FDMessagePrivate
"""
[DEPRECATED] Gio.FDMessagePrivate is deprecated; use GioUnix.FDMessagePrivate instead
"""
MountEntry = GioUnix.MountEntry
"""
[DEPRECATED] Gio.MountEntry is deprecated; use GioUnix.MountEntry instead
"""
MountMonitor = GioUnix.MountMonitor
"""
[DEPRECATED] Gio.MountMonitor is deprecated; use GioUnix.MountMonitor instead
"""
MountMonitorClass = GioUnix.MountMonitorClass
"""
[DEPRECATED] Gio.MountMonitorClass is deprecated; use GioUnix.MountMonitorClass instead
"""
MountPoint = GioUnix.MountPoint
"""
[DEPRECATED] Gio.MountPoint is deprecated; use GioUnix.MountPoint instead
"""
UnixFDMessage = FDMessage
UnixInputStream = InputStream
UnixMountEntry = MountEntry
UnixMountMonitor = MountMonitor
UnixMountPoint = MountPoint
UnixOutputStream = OutputStream
_lock = _thread._lock  # type: ignore
_overrides_module = ...  # this very module ...
desktop_app_info_lookup_get_default_for_uri_scheme = GioUnix.desktop_app_info_lookup_get_default_for_uri_scheme
"""
[DEPRECATED] Gio.desktop_app_info_lookup_get_default_for_uri_scheme is deprecated; use GioUnix.desktop_app_info_lookup_get_default_for_uri_scheme instead
"""
file_descriptor_based_get_fd = GioUnix.file_descriptor_based_get_fd
"""
[DEPRECATED] Gio.file_descriptor_based_get_fd is deprecated; use GioUnix.file_descriptor_based_get_fd instead
"""
is_mount_path_system_internal = GioUnix.is_mount_path_system_internal
"""
[DEPRECATED] Gio.is_mount_path_system_internal is deprecated; use GioUnix.is_mount_path_system_internal instead
"""
is_system_device_path = GioUnix.is_system_device_path
"""
[DEPRECATED] Gio.is_system_device_path is deprecated; use GioUnix.is_system_device_path instead
"""
is_system_fs_type = GioUnix.is_system_fs_type
"""
[DEPRECATED] Gio.is_system_fs_type is deprecated; use GioUnix.is_system_fs_type instead
"""
mount_at = GioUnix.mount_at
"""
[DEPRECATED] Gio.mount_at is deprecated; use GioUnix.mount_at instead
"""
mount_compare = GioUnix.mount_compare
"""
[DEPRECATED] Gio.mount_compare is deprecated; use GioUnix.mount_compare instead
"""
mount_copy = GioUnix.mount_copy
"""
[DEPRECATED] Gio.mount_copy is deprecated; use GioUnix.mount_copy instead
"""
mount_entries_changed_since = GioUnix.mount_entries_changed_since
"""
[DEPRECATED] Gio.mount_entries_changed_since is deprecated; use GioUnix.mount_entries_changed_since instead
"""
mount_entries_get = GioUnix.mount_entries_get
"""
[DEPRECATED] Gio.mount_entries_get is deprecated; use GioUnix.mount_entries_get instead
"""
mount_entries_get_from_file = GioUnix.mount_entries_get_from_file
"""
[DEPRECATED] Gio.mount_entries_get_from_file is deprecated; use GioUnix.mount_entries_get_from_file instead
"""
mount_entry_at = GioUnix.mount_entry_at
"""
[DEPRECATED] Gio.mount_entry_at is deprecated; use GioUnix.mount_entry_at instead
"""
mount_entry_compare = GioUnix.mount_entry_compare
"""
[DEPRECATED] Gio.mount_entry_compare is deprecated; use GioUnix.mount_entry_compare instead
"""
mount_entry_copy = GioUnix.mount_entry_copy
"""
[DEPRECATED] Gio.mount_entry_copy is deprecated; use GioUnix.mount_entry_copy instead
"""
mount_entry_for = GioUnix.mount_entry_for
"""
[DEPRECATED] Gio.mount_entry_for is deprecated; use GioUnix.mount_entry_for instead
"""
mount_entry_free = GioUnix.mount_entry_free
"""
[DEPRECATED] Gio.mount_entry_free is deprecated; use GioUnix.mount_entry_free instead
"""
mount_entry_get_device_path = GioUnix.mount_entry_get_device_path
"""
[DEPRECATED] Gio.mount_entry_get_device_path is deprecated; use GioUnix.mount_entry_get_device_path instead
"""
mount_entry_get_fs_type = GioUnix.mount_entry_get_fs_type
"""
[DEPRECATED] Gio.mount_entry_get_fs_type is deprecated; use GioUnix.mount_entry_get_fs_type instead
"""
mount_entry_get_mount_path = GioUnix.mount_entry_get_mount_path
"""
[DEPRECATED] Gio.mount_entry_get_mount_path is deprecated; use GioUnix.mount_entry_get_mount_path instead
"""
mount_entry_get_options = GioUnix.mount_entry_get_options
"""
[DEPRECATED] Gio.mount_entry_get_options is deprecated; use GioUnix.mount_entry_get_options instead
"""
mount_entry_get_root_path = GioUnix.mount_entry_get_root_path
"""
[DEPRECATED] Gio.mount_entry_get_root_path is deprecated; use GioUnix.mount_entry_get_root_path instead
"""
mount_entry_guess_can_eject = GioUnix.mount_entry_guess_can_eject
"""
[DEPRECATED] Gio.mount_entry_guess_can_eject is deprecated; use GioUnix.mount_entry_guess_can_eject instead
"""
mount_entry_guess_icon = GioUnix.mount_entry_guess_icon
"""
[DEPRECATED] Gio.mount_entry_guess_icon is deprecated; use GioUnix.mount_entry_guess_icon instead
"""
mount_entry_guess_name = GioUnix.mount_entry_guess_name
"""
[DEPRECATED] Gio.mount_entry_guess_name is deprecated; use GioUnix.mount_entry_guess_name instead
"""
mount_entry_guess_should_display = GioUnix.mount_entry_guess_should_display
"""
[DEPRECATED] Gio.mount_entry_guess_should_display is deprecated; use GioUnix.mount_entry_guess_should_display instead
"""
mount_entry_guess_symbolic_icon = GioUnix.mount_entry_guess_symbolic_icon
"""
[DEPRECATED] Gio.mount_entry_guess_symbolic_icon is deprecated; use GioUnix.mount_entry_guess_symbolic_icon instead
"""
mount_entry_is_readonly = GioUnix.mount_entry_is_readonly
"""
[DEPRECATED] Gio.mount_entry_is_readonly is deprecated; use GioUnix.mount_entry_is_readonly instead
"""
mount_entry_is_system_internal = GioUnix.mount_entry_is_system_internal
"""
[DEPRECATED] Gio.mount_entry_is_system_internal is deprecated; use GioUnix.mount_entry_is_system_internal instead
"""
mount_for = GioUnix.mount_for
"""
[DEPRECATED] Gio.mount_for is deprecated; use GioUnix.mount_for instead
"""
mount_free = GioUnix.mount_free
"""
[DEPRECATED] Gio.mount_free is deprecated; use GioUnix.mount_free instead
"""
mount_get_device_path = GioUnix.mount_get_device_path
"""
[DEPRECATED] Gio.mount_get_device_path is deprecated; use GioUnix.mount_get_device_path instead
"""
mount_get_fs_type = GioUnix.mount_get_fs_type
"""
[DEPRECATED] Gio.mount_get_fs_type is deprecated; use GioUnix.mount_get_fs_type instead
"""
mount_get_mount_path = GioUnix.mount_get_mount_path
"""
[DEPRECATED] Gio.mount_get_mount_path is deprecated; use GioUnix.mount_get_mount_path instead
"""
mount_get_options = GioUnix.mount_get_options
"""
[DEPRECATED] Gio.mount_get_options is deprecated; use GioUnix.mount_get_options instead
"""
mount_get_root_path = GioUnix.mount_get_root_path
"""
[DEPRECATED] Gio.mount_get_root_path is deprecated; use GioUnix.mount_get_root_path instead
"""
mount_guess_can_eject = GioUnix.mount_guess_can_eject
"""
[DEPRECATED] Gio.mount_guess_can_eject is deprecated; use GioUnix.mount_guess_can_eject instead
"""
mount_guess_icon = GioUnix.mount_guess_icon
"""
[DEPRECATED] Gio.mount_guess_icon is deprecated; use GioUnix.mount_guess_icon instead
"""
mount_guess_name = GioUnix.mount_guess_name
"""
[DEPRECATED] Gio.mount_guess_name is deprecated; use GioUnix.mount_guess_name instead
"""
mount_guess_should_display = GioUnix.mount_guess_should_display
"""
[DEPRECATED] Gio.mount_guess_should_display is deprecated; use GioUnix.mount_guess_should_display instead
"""
mount_guess_symbolic_icon = GioUnix.mount_guess_symbolic_icon
"""
[DEPRECATED] Gio.mount_guess_symbolic_icon is deprecated; use GioUnix.mount_guess_symbolic_icon instead
"""
mount_is_readonly = GioUnix.mount_is_readonly
"""
[DEPRECATED] Gio.mount_is_readonly is deprecated; use GioUnix.mount_is_readonly instead
"""
mount_is_system_internal = GioUnix.mount_is_system_internal
"""
[DEPRECATED] Gio.mount_is_system_internal is deprecated; use GioUnix.mount_is_system_internal instead
"""
mount_point_at = GioUnix.mount_point_at
"""
[DEPRECATED] Gio.mount_point_at is deprecated; use GioUnix.mount_point_at instead
"""
mount_point_compare = GioUnix.mount_point_compare
"""
[DEPRECATED] Gio.mount_point_compare is deprecated; use GioUnix.mount_point_compare instead
"""
mount_point_copy = GioUnix.mount_point_copy
"""
[DEPRECATED] Gio.mount_point_copy is deprecated; use GioUnix.mount_point_copy instead
"""
mount_point_free = GioUnix.mount_point_free
"""
[DEPRECATED] Gio.mount_point_free is deprecated; use GioUnix.mount_point_free instead
"""
mount_point_get_device_path = GioUnix.mount_point_get_device_path
"""
[DEPRECATED] Gio.mount_point_get_device_path is deprecated; use GioUnix.mount_point_get_device_path instead
"""
mount_point_get_fs_type = GioUnix.mount_point_get_fs_type
"""
[DEPRECATED] Gio.mount_point_get_fs_type is deprecated; use GioUnix.mount_point_get_fs_type instead
"""
mount_point_get_mount_path = GioUnix.mount_point_get_mount_path
"""
[DEPRECATED] Gio.mount_point_get_mount_path is deprecated; use GioUnix.mount_point_get_mount_path instead
"""
mount_point_get_options = GioUnix.mount_point_get_options
"""
[DEPRECATED] Gio.mount_point_get_options is deprecated; use GioUnix.mount_point_get_options instead
"""
mount_point_guess_can_eject = GioUnix.mount_point_guess_can_eject
"""
[DEPRECATED] Gio.mount_point_guess_can_eject is deprecated; use GioUnix.mount_point_guess_can_eject instead
"""
mount_point_guess_icon = GioUnix.mount_point_guess_icon
"""
[DEPRECATED] Gio.mount_point_guess_icon is deprecated; use GioUnix.mount_point_guess_icon instead
"""
mount_point_guess_name = GioUnix.mount_point_guess_name
"""
[DEPRECATED] Gio.mount_point_guess_name is deprecated; use GioUnix.mount_point_guess_name instead
"""
mount_point_guess_symbolic_icon = GioUnix.mount_point_guess_symbolic_icon
"""
[DEPRECATED] Gio.mount_point_guess_symbolic_icon is deprecated; use GioUnix.mount_point_guess_symbolic_icon instead
"""
mount_point_is_loopback = GioUnix.mount_point_is_loopback
"""
[DEPRECATED] Gio.mount_point_is_loopback is deprecated; use GioUnix.mount_point_is_loopback instead
"""
mount_point_is_readonly = GioUnix.mount_point_is_readonly
"""
[DEPRECATED] Gio.mount_point_is_readonly is deprecated; use GioUnix.mount_point_is_readonly instead
"""
mount_point_is_user_mountable = GioUnix.mount_point_is_user_mountable
"""
[DEPRECATED] Gio.mount_point_is_user_mountable is deprecated; use GioUnix.mount_point_is_user_mountable instead
"""
mount_points_changed_since = GioUnix.mount_points_changed_since
"""
[DEPRECATED] Gio.mount_points_changed_since is deprecated; use GioUnix.mount_points_changed_since instead
"""
mount_points_get = GioUnix.mount_points_get
"""
[DEPRECATED] Gio.mount_points_get is deprecated; use GioUnix.mount_points_get instead
"""
mount_points_get_from_file = GioUnix.mount_points_get_from_file
"""
[DEPRECATED] Gio.mount_points_get_from_file is deprecated; use GioUnix.mount_points_get_from_file instead
"""
mounts_changed_since = GioUnix.mounts_changed_since
"""
[DEPRECATED] Gio.mounts_changed_since is deprecated; use GioUnix.mounts_changed_since instead
"""
mounts_get = GioUnix.mounts_get
"""
[DEPRECATED] Gio.mounts_get is deprecated; use GioUnix.mounts_get instead
"""
mounts_get_from_file = GioUnix.mounts_get_from_file
"""
[DEPRECATED] Gio.mounts_get_from_file is deprecated; use GioUnix.mounts_get_from_file instead
"""
###############################################################
# Constants
###############################################################

DBUS_METHOD_INVOCATION_HANDLED: bool = ...
DBUS_METHOD_INVOCATION_UNHANDLED: bool = ...
DEBUG_CONTROLLER_EXTENSION_POINT_NAME: str = ...
DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: str = ...
DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_DELETE: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_READ: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_RENAME: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_TRASH: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_WRITE: str = ...
FILE_ATTRIBUTE_DOS_IS_ARCHIVE: str = ...
FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: str = ...
FILE_ATTRIBUTE_DOS_IS_SYSTEM: str = ...
FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: str = ...
FILE_ATTRIBUTE_ETAG_VALUE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_FREE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_READONLY: str = ...
FILE_ATTRIBUTE_FILESYSTEM_REMOTE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_SIZE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_TYPE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_USED: str = ...
FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: str = ...
FILE_ATTRIBUTE_GVFS_BACKEND: str = ...
FILE_ATTRIBUTE_ID_FILE: str = ...
FILE_ATTRIBUTE_ID_FILESYSTEM: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_START: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: str = ...
FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: str = ...
FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: str = ...
FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: str = ...
FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: str = ...
FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: str = ...
FILE_ATTRIBUTE_OWNER_GROUP: str = ...
FILE_ATTRIBUTE_OWNER_USER: str = ...
FILE_ATTRIBUTE_OWNER_USER_REAL: str = ...
FILE_ATTRIBUTE_PREVIEW_ICON: str = ...
FILE_ATTRIBUTE_RECENT_MODIFIED: str = ...
FILE_ATTRIBUTE_SELINUX_CONTEXT: str = ...
FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: str = ...
FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: str = ...
FILE_ATTRIBUTE_STANDARD_COPY_NAME: str = ...
FILE_ATTRIBUTE_STANDARD_DESCRIPTION: str = ...
FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: str = ...
FILE_ATTRIBUTE_STANDARD_EDIT_NAME: str = ...
FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: str = ...
FILE_ATTRIBUTE_STANDARD_ICON: str = ...
FILE_ATTRIBUTE_STANDARD_IS_BACKUP: str = ...
FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: str = ...
FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: str = ...
FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: str = ...
FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: str = ...
FILE_ATTRIBUTE_STANDARD_NAME: str = ...
FILE_ATTRIBUTE_STANDARD_SIZE: str = ...
FILE_ATTRIBUTE_STANDARD_SORT_ORDER: str = ...
FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: str = ...
FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: str = ...
FILE_ATTRIBUTE_STANDARD_TARGET_URI: str = ...
FILE_ATTRIBUTE_STANDARD_TYPE: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: str = ...
FILE_ATTRIBUTE_TIME_ACCESS: str = ...
FILE_ATTRIBUTE_TIME_ACCESS_NSEC: str = ...
FILE_ATTRIBUTE_TIME_ACCESS_USEC: str = ...
FILE_ATTRIBUTE_TIME_CHANGED: str = ...
FILE_ATTRIBUTE_TIME_CHANGED_NSEC: str = ...
FILE_ATTRIBUTE_TIME_CHANGED_USEC: str = ...
FILE_ATTRIBUTE_TIME_CREATED: str = ...
FILE_ATTRIBUTE_TIME_CREATED_NSEC: str = ...
FILE_ATTRIBUTE_TIME_CREATED_USEC: str = ...
FILE_ATTRIBUTE_TIME_MODIFIED: str = ...
FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: str = ...
FILE_ATTRIBUTE_TIME_MODIFIED_USEC: str = ...
FILE_ATTRIBUTE_TRASH_DELETION_DATE: str = ...
FILE_ATTRIBUTE_TRASH_ITEM_COUNT: str = ...
FILE_ATTRIBUTE_TRASH_ORIG_PATH: str = ...
FILE_ATTRIBUTE_UNIX_BLOCKS: str = ...
FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: str = ...
FILE_ATTRIBUTE_UNIX_DEVICE: str = ...
FILE_ATTRIBUTE_UNIX_GID: str = ...
FILE_ATTRIBUTE_UNIX_INODE: str = ...
FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: str = ...
FILE_ATTRIBUTE_UNIX_MODE: str = ...
FILE_ATTRIBUTE_UNIX_NLINK: str = ...
FILE_ATTRIBUTE_UNIX_RDEV: str = ...
FILE_ATTRIBUTE_UNIX_UID: str = ...
MEMORY_MONITOR_EXTENSION_POINT_NAME: str = ...
MENU_ATTRIBUTE_ACTION: str = ...
MENU_ATTRIBUTE_ACTION_NAMESPACE: str = ...
MENU_ATTRIBUTE_ICON: str = ...
MENU_ATTRIBUTE_LABEL: str = ...
MENU_ATTRIBUTE_TARGET: str = ...
MENU_EXPORTER_MAX_SECTION_SIZE: int = ...
MENU_LINK_SECTION: str = ...
MENU_LINK_SUBMENU: str = ...
NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: str = ...
NETWORK_MONITOR_EXTENSION_POINT_NAME: str = ...
POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: str = ...
PROXY_EXTENSION_POINT_NAME: str = ...
PROXY_RESOLVER_EXTENSION_POINT_NAME: str = ...
SETTINGS_BACKEND_EXTENSION_POINT_NAME: str = ...
TLS_BACKEND_EXTENSION_POINT_NAME: str = ...
TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: str = ...
TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: str = ...
VFS_EXTENSION_POINT_NAME: str = ...
VOLUME_IDENTIFIER_KIND_CLASS: str = ...
VOLUME_IDENTIFIER_KIND_HAL_UDI: str = ...
VOLUME_IDENTIFIER_KIND_LABEL: str = ...
VOLUME_IDENTIFIER_KIND_NFS_MOUNT: str = ...
VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: str = ...
VOLUME_IDENTIFIER_KIND_UUID: str = ...
VOLUME_MONITOR_EXTENSION_POINT_NAME: str = ...
_namespace: str = ...
_version: str = ...
###############################################################
# Unknowns/Not Parsed
###############################################################
