# pyright: reportIncompatibleMethodOverride=false
"""
Stub template for a GI Repository Module.

Generated by gi-stub-gen, version 0.0.1.
Module: Gio
Date: 2025-12-26
"""
# we disable method override report for pyright in generated stubs,
# causes too many false positives

from __future__ import annotations
from typing_extensions import deprecated  # noqa: F401
import typing_extensions  # noqa: F401
import builtins  # noqa: F401

import _thread
import typing

# gi.repository imports needed by this Stub
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import GioUnix
###############################################################
# Functions
###############################################################

@staticmethod
def action_name_is_valid(
    action_name: str,
) -> bool:
    """
    Checks if `action_name` is valid.

    `action_name` is valid if it consists only of alphanumeric characters,
    plus `-` and `.`.  The empty string is not a valid action name.

    It is an error to call this function with a non-UTF-8 `action_name`.
    `action_name` must not be `None`.
    """
    ...

@staticmethod
def action_parse_detailed_name(
    detailed_name: str,
) -> tuple[bool, str, GLib.Variant | None]:
    """
    Parses a detailed action name into its separate name and target
    components.

    Detailed action names can have three formats.

    The first format is used to represent an action name with no target
    value and consists of just an action name containing no whitespace
    nor the characters `:`, `(` or `)`.  For example: `app.action`.

    The second format is used to represent an action with a target value
    that is a non-empty string consisting only of alphanumerics, plus `-`
    and `.`.  In that case, the action name and target value are
    separated by a double colon (`::`).  For example:
    `app.action::target`.

    The third format is used to represent an action with any type of
    target value, including strings.  The target value follows the action
    name, surrounded in parens.  For example: `app.action(42)`.  The
    target value is parsed using [func`GLib`.Variant.parse].  If a tuple-typed
    value is desired, it must be specified in the same way, resulting in
    two sets of parens, for example: `app.action((1,2,3))`.  A string
    target can be specified this way as well: `app.action('target')`.
    For strings, this third format must be used if target value is
    empty or contains characters other than alphanumerics, `-` and `.`.

    If this function returns `True`, a non-`None` value is guaranteed to be returned
    in `action_name` (if a pointer is passed in). A `None` value may still be
    returned in `target_value`, as the `detailed_name` may not contain a target.

    If returned, the [type`GLib`.Variant] in `target_value` is guaranteed to not be floating.
    """
    ...

@staticmethod
def action_print_detailed_name(
    action_name: str,
    target_value: GLib.Variant | None = None,
) -> str:
    """
    Formats a detailed action name from `action_name` and `target_value`.

    It is an error to call this function with an invalid action name.

    This function is the opposite of [func`Gio`.Action.parse_detailed_name].
    It will produce a string that can be parsed back to the `action_name`
    and `target_value` by that function.

    See that function for the types of strings that will be printed by
    this function.
    """
    ...

@staticmethod
def app_info_create_from_commandline(
    commandline: str,
    application_name: str | None,
    flags: AppInfoCreateFlags,
) -> AppInfo:
    """
    Creates a new [iface`Gio`.AppInfo] from the given information.

    Note that for `commandline`, the quoting rules of the `Exec` key of the
    [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
    are applied. For example, if the `commandline` contains
    percent-encoded URIs, the percent-character must be doubled in order to prevent it from
    being swallowed by `Exec` key unquoting. See
    [the specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html)
    for exact quoting rules.
    """
    ...

@staticmethod
def app_info_get_all() -> list:
    """
    Gets a list of all of the applications currently registered
    on this system.

    For desktop files, this includes applications that have
    [`NoDisplay=true`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-nodisplay)
    set or are excluded from display by means of
    [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-onlyshowin)
    or [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-notshowin).
    See [method`Gio`.AppInfo.should_show].

    The returned list does not include applications which have the
    [`Hidden` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-hidden)
    set.
    """
    ...

@staticmethod
def app_info_get_all_for_type(
    content_type: str,
) -> list:
    """
    Gets a list of all [iface`Gio`.AppInfo]s for a given content type,
    including the recommended and fallback [iface`Gio`.AppInfo]s. See
    [func`Gio`.AppInfo.get_recommended_for_type] and
    [func`Gio`.AppInfo.get_fallback_for_type].
    """
    ...

@staticmethod
def app_info_get_default_for_type(
    content_type: str,
    must_support_uris: bool,
) -> AppInfo | None:
    """
    Gets the default [iface`Gio`.AppInfo] for a given content type.
    """
    ...

@staticmethod
async def app_info_get_default_for_type_async(
    content_type: str,
    must_support_uris: bool,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    *user_data: object | None,
) -> None:
    """
    Asynchronously gets the default [iface`Gio`.AppInfo] for a given content
    type.
    """
    ...

@staticmethod
def app_info_get_default_for_type_finish(
    result: AsyncResult,
) -> AppInfo:
    """
    Finishes a default [iface`Gio`.AppInfo] lookup started by
    [func`Gio`.AppInfo.get_default_for_type_async].

    If no #[iface`Gio`.AppInfo] is found, then `error` will be set to
    [error`Gio`.IOErrorEnum.NOT_FOUND].
    """
    ...

@staticmethod
def app_info_get_default_for_uri_scheme(
    uri_scheme: str,
) -> AppInfo | None:
    """
    Gets the default application for handling URIs with the given URI scheme.

    A URI scheme is the initial part of the URI, up to but not including the `:`.
    For example, `http`, `ftp` or `sip`.
    """
    ...

@staticmethod
async def app_info_get_default_for_uri_scheme_async(
    uri_scheme: str,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    *user_data: object | None,
) -> None:
    """
    Asynchronously gets the default application for handling URIs with
    the given URI scheme. A URI scheme is the initial part
    of the URI, up to but not including the `:`, e.g. `http`,
    `ftp` or `sip`.
    """
    ...

@staticmethod
def app_info_get_default_for_uri_scheme_finish(
    result: AsyncResult,
) -> AppInfo:
    """
    Finishes a default [iface`Gio`.AppInfo] lookup started by
    [func`Gio`.AppInfo.get_default_for_uri_scheme_async].

    If no [iface`Gio`.AppInfo] is found, then `error` will be set to
    [error`Gio`.IOErrorEnum.NOT_FOUND].
    """
    ...

@staticmethod
def app_info_get_fallback_for_type(
    content_type: str,
) -> list:
    """
    Gets a list of fallback [iface`Gio`.AppInfo]s for a given content type, i.e.
    those applications which claim to support the given content type by MIME
    type subclassing and not directly.
    """
    ...

@staticmethod
def app_info_get_recommended_for_type(
    content_type: str,
) -> list:
    """
    Gets a list of recommended [iface`Gio`.AppInfo]s for a given content type,
    i.e. those applications which claim to support the given content type
    exactly, and not by MIME type subclassing.

    Note that the first application of the list is the last used one, i.e.
    the last one for which [method`Gio`.AppInfo.set_as_last_used_for_type] has
    been called.
    """
    ...

@staticmethod
def app_info_launch_default_for_uri(
    uri: str,
    context: AppLaunchContext | None = None,
) -> bool:
    """
    Utility function that launches the default application registered to handle
    the specified uri. Synchronous I/O is done on the uri to detect the type of
    the file if required.

    The D-Bus–activated applications don’t have to be started if your application
    terminates too soon after this function. To prevent this, use
    [func`Gio`.AppInfo.launch_default_for_uri_async] instead.
    """
    ...

@staticmethod
async def app_info_launch_default_for_uri_async(
    uri: str,
    context: AppLaunchContext | None = None,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    *user_data: object | None,
) -> None:
    """
    Async version of [func`Gio`.AppInfo.launch_default_for_uri].

    This version is useful if you are interested in receiving error information
    in the case where the application is sandboxed and the portal may present an
    application chooser dialog to the user.

    This is also useful if you want to be sure that the D-Bus–activated
    applications are really started before termination and if you are interested
    in receiving error information from their activation.
    """
    ...

@staticmethod
def app_info_launch_default_for_uri_finish(
    result: AsyncResult,
) -> bool:
    """
    Finishes an asynchronous launch-default-for-uri operation.
    """
    ...

@staticmethod
def app_info_reset_type_associations(
    content_type: str,
) -> None:
    """
    Removes all changes to the type associations done by
    [method`Gio`.AppInfo.set_as_default_for_type],
    [method`Gio`.AppInfo.set_as_default_for_extension],
    [method`Gio`.AppInfo.add_supports_type] or
    [method`Gio`.AppInfo.remove_supports_type].
    """
    ...

@deprecated("deprecated")
@staticmethod
def async_initable_newv_async(
    object_type: GObject.GType,
    n_parameters: int,
    parameters: GObject.Parameter,
    io_priority: int,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    *user_data: object | None,
) -> None:
    """
    Helper function for constructing GAsyncInitable object. This is
    similar to `g_object_newv` but also initializes the object asynchronously.

    When the initialization is finished, `callback` will be called. You can
    then call `g_async_initable_new_finish` to get the new object and check
    for any errors.
    """
    ...

@staticmethod
async def bus_get(
    bus_type: BusType,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    *user_data: object | None,
) -> None:
    """
    Asynchronously connects to the message bus specified by `bus_type`.

    When the operation is finished, `callback` will be invoked. You can
    then call `g_bus_get_finish` to get the result of the operation.

    This is an asynchronous failable function. See `g_bus_get_sync` for
    the synchronous version.
    """
    ...

@staticmethod
def bus_get_finish(
    res: AsyncResult,
) -> DBusConnection:
    """
    Finishes an operation started with `g_bus_get`.

    The returned object is a singleton, that is, shared with other
    callers of `g_bus_get` and `g_bus_get_sync` for `bus_type`. In the
    event that you need a private message bus connection, use
    `g_dbus_address_get_for_bus_sync` and
    `g_dbus_connection_new_for_address` with
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.

    Note that the returned GDBusConnection object will (usually) have
    the GDBusConnection:exit-on-close property set to True.
    """
    ...

@staticmethod
def bus_get_sync(
    bus_type: BusType,
    cancellable: Cancellable | None = None,
) -> DBusConnection:
    """
    Synchronously connects to the message bus specified by `bus_type`.
    Note that the returned object may shared with other callers,
    e.g. if two separate parts of a process calls this function with
    the same `bus_type`, they will share the same object.

    This is a synchronous failable function. See `g_bus_get` and
    `g_bus_get_finish` for the asynchronous version.

    The returned object is a singleton, that is, shared with other
    callers of `g_bus_get` and `g_bus_get_sync` for `bus_type`. In the
    event that you need a private message bus connection, use
    `g_dbus_address_get_for_bus_sync` and
    `g_dbus_connection_new_for_address` with
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.

    Note that the returned GDBusConnection object will (usually) have
    the GDBusConnection:exit-on-close property set to True.
    """
    ...

@staticmethod
def bus_own_name(
    bus_type: BusType,
    name: str,
    flags: BusNameOwnerFlags,
    bus_acquired_closure: GObject.Closure | None = None,
    name_acquired_closure: GObject.Closure | None = None,
    name_lost_closure: GObject.Closure | None = None,
) -> int:
    """
    Requests ownership of `name` on the bus specified by `bus_type`.

    It asynchronously calls `name_acquired_handler` and `name_lost_handler` when
    the name is acquired and lost, respectively.

    Callbacks will be invoked in the thread-default
    main context (see [method`GLib`.MainContext.push_thread_default])
    of the thread you are calling this function from.

    You are guaranteed that one of the `name_acquired_handler` and `name_lost_handler`
    callbacks will be invoked after calling this function — there are three
    possible cases:

    - `name_lost_handler` with a `None` connection (if a connection to the bus
      can’t be made).
    - `bus_acquired_handler` then `name_lost_handler` (if the name can’t be
      obtained).
    - `bus_acquired_handler` then `name_acquired_handler` (if the name was
      obtained).

    When you are done owning the name, call [func`Gio`.bus_unown_name] with the
    owner ID this function returns.

    If the name is acquired or lost (for example another application
    could acquire the name if you allow replacement or the application
    currently owning the name exits), the handlers are also invoked.
    If the [class`Gio`.DBusConnection] that is used for attempting to own the name
    closes, then `name_lost_handler` is invoked since it is no longer
    possible for other processes to access the process.

    You cannot use [func`Gio`.bus_own_name] several times for the same name (unless
    interleaved with calls to [func`Gio`.bus_unown_name]) — only the first call
    will work.

    Another guarantee is that invocations of `name_acquired_handler`
    and `name_lost_handler` are guaranteed to alternate; that
    is, if `name_acquired_handler` is invoked then you are
    guaranteed that the next time one of the handlers is invoked, it
    will be `name_lost_handler`. The reverse is also true.

    If you plan on exporting objects (using, for example,
    [method`Gio`.DBusConnection.register_object]), note that it is generally too late
    to export the objects in `name_acquired_handler`. Instead, you can do this
    in `bus_acquired_handler` since you are guaranteed that this will run
    before `name` is requested from the bus.

    This behavior makes it very simple to write applications that want
    to [own names](dbus-name-owning.html#d-bus-name-owning) and export objects.
    Simply register objects to be exported in `bus_acquired_handler` and
    unregister the objects (if any) in `name_lost_handler`.
    """
    ...

@staticmethod
def bus_own_name_on_connection(
    connection: DBusConnection,
    name: str,
    flags: BusNameOwnerFlags,
    name_acquired_closure: GObject.Closure | None = None,
    name_lost_closure: GObject.Closure | None = None,
) -> int:
    """
    Like [func`Gio`.bus_own_name] but takes a [class`Gio`.DBusConnection] instead
    of a [enum`Gio`.BusType].
    """
    ...

@staticmethod
def bus_unown_name(
    owner_id: int,
) -> None:
    """
    Stops owning a name.

    Note that there may still be D-Bus traffic to process (relating to owning
    and unowning the name) in the current thread-default
    [struct`GLib`.MainContext] after this function has returned. You should
    continue to iterate the [struct`GLib`.MainContext] until the
    [callback`GLib`.DestroyNotify] function passed to [func`Gio`.bus_own_name] is
    called, in order to avoid memory leaks through callbacks queued on the
    [struct`GLib`.MainContext] after it’s stopped being iterated.
    """
    ...

@staticmethod
def bus_unwatch_name(
    watcher_id: int,
) -> None:
    """
    Stops watching a name.

    Note that there may still be D-Bus traffic to process (relating to watching
    and unwatching the name) in the current thread-default GMainContext after
    this function has returned. You should continue to iterate the GMainContext
    until the GDestroyNotify function passed to `g_bus_watch_name` is called, in
    order to avoid memory leaks through callbacks queued on the GMainContext
    after it’s stopped being iterated.
    """
    ...

@staticmethod
def bus_watch_name(
    bus_type: BusType,
    name: str,
    flags: BusNameWatcherFlags,
    name_appeared_closure: GObject.Closure | None = None,
    name_vanished_closure: GObject.Closure | None = None,
) -> int:
    """
    Starts watching `name` on the bus specified by `bus_type` and calls
    `name_appeared_handler` and `name_vanished_handler` when the name is
    known to have an owner respectively known to lose its
    owner. Callbacks will be invoked in the thread-default main context
    (see [method`GLib`.MainContext.push_thread_default])
    of the thread you are calling this function from.

    You are guaranteed that one of the handlers will be invoked after
    calling this function. When you are done watching the name, just
    call `g_bus_unwatch_name` with the watcher id this function
    returns.

    If the name vanishes or appears (for example the application owning
    the name could restart), the handlers are also invoked. If the
    GDBusConnection that is used for watching the name disconnects, then
    `name_vanished_handler` is invoked since it is no longer
    possible to access the name.

    Another guarantee is that invocations of `name_appeared_handler`
    and `name_vanished_handler` are guaranteed to alternate; that
    is, if `name_appeared_handler` is invoked then you are
    guaranteed that the next time one of the handlers is invoked, it
    will be `name_vanished_handler`. The reverse is also true.

    This behavior makes it very simple to write applications that want
    to take action when a certain [name exists](dbus-name-watching.html#d-bus-name-watching).
    Basically, the application should create object proxies in
    `name_appeared_handler` and destroy them again (if any) in
    `name_vanished_handler`.
    """
    ...

@staticmethod
def bus_watch_name_on_connection(
    connection: DBusConnection,
    name: str,
    flags: BusNameWatcherFlags,
    name_appeared_closure: GObject.Closure | None = None,
    name_vanished_closure: GObject.Closure | None = None,
) -> int:
    """
    Like `g_bus_watch_name` but takes a GDBusConnection instead of a
    GBusType.
    """
    ...

@staticmethod
def content_type_can_be_executable(
    type: str,
) -> bool:
    """
    Checks if a content type can be executable. Note that for instance
    things like text files can be executables (i.e. scripts and batch files).
    """
    ...

@staticmethod
def content_type_equals(
    type1: str,
    type2: str,
) -> bool:
    """
    Compares two content types for equality.
    """
    ...

@staticmethod
def content_type_from_mime_type(
    mime_type: str,
) -> str | None:
    """
    Tries to find a content type based on the mime type name.
    """
    ...

@staticmethod
def content_type_get_description(
    type: str,
) -> str:
    """
    Gets the human readable description of the content type.
    """
    ...

@staticmethod
def content_type_get_generic_icon_name(
    type: str,
) -> str | None:
    """
    Gets the generic icon name for a content type.

    See the
    [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
    specification for more on the generic icon name.
    """
    ...

@staticmethod
def content_type_get_icon(
    type: str,
) -> Icon:
    """
    Gets the icon for a content type.
    """
    ...

@staticmethod
def content_type_get_mime_dirs() -> list:
    """
    Get the list of directories which MIME data is loaded from. See
    `g_content_type_set_mime_dirs` for details.
    """
    ...

@staticmethod
def content_type_get_mime_type(
    type: str,
) -> str | None:
    """
    Gets the mime type for the content type, if one is registered.
    """
    ...

@staticmethod
def content_type_get_symbolic_icon(
    type: str,
) -> Icon:
    """
    Gets the symbolic icon for a content type.
    """
    ...

@staticmethod
def content_type_guess(
    filename: str | None,
    data: list | None,
    data_size: int,
) -> tuple[str, bool]:
    """
    Guesses the content type based on example data. If the function is
    uncertain, `result_uncertain` will be set to True. Either `filename`
    or `data` may be None, in which case the guess will be based solely
    on the other argument.
    """
    ...

@staticmethod
def content_type_guess_for_tree(
    root: File,
) -> list:
    """
    Tries to guess the type of the tree with root `root`, by
    looking at the files it contains. The result is an array
    of content types, with the best guess coming first.

    The types returned all have the form x-content/foo, e.g.
    x-content/audio-cdda (for audio CDs) or x-content/image-dcf
    (for a camera memory card). See the
    [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
    specification for more on x-content types.

    This function is useful in the implementation of
    `g_mount_guess_content_type`.
    """
    ...

@staticmethod
def content_type_is_a(
    type: str,
    supertype: str,
) -> bool:
    """
    Determines if `type` is a subset of `supertype`.
    """
    ...

@staticmethod
def content_type_is_mime_type(
    type: str,
    mime_type: str,
) -> bool:
    """
    Determines if `type` is a subset of `mime_type`.
    Convenience wrapper around `g_content_type_is_a`.
    """
    ...

@staticmethod
def content_type_is_unknown(
    type: str,
) -> bool:
    """
    Checks if the content type is the generic "unknown" type.
    On UNIX this is the "application/octet-stream" mimetype,
    while on win32 it is "*" and on OSX it is a dynamic type
    or octet-stream.
    """
    ...

@staticmethod
def content_type_set_mime_dirs(
    dirs: list | None = None,
) -> None:
    """
    Set the list of directories used by GIO to load the MIME database.
    If `dirs` is None, the directories used are the default:

     - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
     - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`

    This function is intended to be used when writing tests that depend on
    information stored in the MIME database, in order to control the data.

    Typically, in case your tests use G_TEST_OPTION_ISOLATE_DIRS, but they
    depend on the system’s MIME database, you should call this function
    with `dirs` set to None before calling `g_test_init`, for instance:

    |[<!-- language="C" -->
      // Load MIME data from the system
      g_content_type_set_mime_dirs (None);
      // Isolate the environment
      g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, None);

      …

      return g_test_run ();
    ]|
    """
    ...

@staticmethod
def content_types_get_registered() -> list:
    """
    Gets a list of strings containing all the registered content types
    known to the system. The list and its data should be freed using
    `g_list_free_full (list, g_free)`.
    """
    ...

@staticmethod
def dbus_address_escape_value(
    string: str,
) -> str:
    """
    Escape `string` so it can appear in a D-Bus address as the value
    part of a key-value pair.

    For instance, if `string` is `/run/bus-for-:0`,
    this function would return `/run/bus-for-3A0`,
    which could be used in a D-Bus address like
    `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-3A0`.
    """
    ...

@staticmethod
def dbus_address_get_for_bus_sync(
    bus_type: BusType,
    cancellable: Cancellable | None = None,
) -> str:
    """
    Synchronously looks up the D-Bus address for the well-known message
    bus instance specified by `bus_type`. This may involve using various
    platform specific mechanisms.

    The returned address will be in the
    [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
    """
    ...

@staticmethod
async def dbus_address_get_stream(
    address: str,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    *user_data: object | None,
) -> None:
    """
    Asynchronously connects to an endpoint specified by `address` and
    sets up the connection so it is in a state to run the client-side
    of the D-Bus authentication conversation. `address` must be in the
    [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

    When the operation is finished, `callback` will be invoked. You can
    then call `g_dbus_address_get_stream_finish` to get the result of
    the operation.

    This is an asynchronous failable function. See
    `g_dbus_address_get_stream_sync` for the synchronous version.
    """
    ...

@staticmethod
def dbus_address_get_stream_finish(
    res: AsyncResult,
) -> tuple[IOStream, str | None]:
    """
    Finishes an operation started with `g_dbus_address_get_stream`.

    A server is not required to set a GUID, so `out_guid` may be set to None
    even on success.
    """
    ...

@staticmethod
def dbus_address_get_stream_sync(
    address: str,
    cancellable: Cancellable | None = None,
) -> tuple[IOStream, str | None]:
    """
    Synchronously connects to an endpoint specified by `address` and
    sets up the connection so it is in a state to run the client-side
    of the D-Bus authentication conversation. `address` must be in the
    [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

    A server is not required to set a GUID, so `out_guid` may be set to None
    even on success.

    This is a synchronous failable function. See
    `g_dbus_address_get_stream` for the asynchronous version.
    """
    ...

@staticmethod
def dbus_annotation_info_lookup(
    annotations: list | None,
    name: str,
) -> str | None:
    """
    Looks up the value of an annotation.

    The cost of this function is O(n) in number of annotations.
    """
    ...

@staticmethod
def dbus_error_encode_gerror(
    error: GLib.Error,
) -> str:
    """
    Creates a D-Bus error name to use for `error`. If `error` matches
    a registered error (cf. `g_dbus_error_register_error`), the corresponding
    D-Bus error name will be returned.

    Otherwise the a name of the form
    `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
    will be used. This allows other GDBus applications to map the error
    on the wire back to a GError using `g_dbus_error_new_for_dbus_error`.

    This function is typically only used in object mappings to put a
    GError on the wire. Regular applications should not use it.
    """
    ...

@staticmethod
def dbus_error_get_remote_error(
    error: GLib.Error,
) -> str | None:
    """
    Gets the D-Bus error name used for `error`, if any.

    This function is guaranteed to return a D-Bus error name for all
    GErrors returned from functions handling remote method calls
    (e.g. `g_dbus_connection_call_finish`) unless
    `g_dbus_error_strip_remote_error` has been used on `error`.
    """
    ...

@staticmethod
def dbus_error_is_remote_error(
    error: GLib.Error,
) -> bool:
    """
    Checks if `error` represents an error received via D-Bus from a remote peer. If so,
    use `g_dbus_error_get_remote_error` to get the name of the error.
    """
    ...

@staticmethod
def dbus_error_new_for_dbus_error(
    dbus_error_name: str,
    dbus_error_message: str,
) -> GLib.Error:
    """
    Creates a GError based on the contents of `dbus_error_name` and
    `dbus_error_message`.

    Errors registered with `g_dbus_error_register_error` will be looked
    up using `dbus_error_name` and if a match is found, the error domain
    and code is used. Applications can use `g_dbus_error_get_remote_error`
    to recover `dbus_error_name`.

    If a match against a registered error is not found and the D-Bus
    error name is in a form as returned by `g_dbus_error_encode_gerror`
    the error domain and code encoded in the name is used to
    create the GError. Also, `dbus_error_name` is added to the error message
    such that it can be recovered with `g_dbus_error_get_remote_error`.

    Otherwise, a GError with the error code G_IO_ERROR_DBUS_ERROR
    in the G_IO_ERROR error domain is returned. Also, `dbus_error_name` is
    added to the error message such that it can be recovered with
    `g_dbus_error_get_remote_error`.

    In all three cases, `dbus_error_name` can always be recovered from the
    returned GError using the `g_dbus_error_get_remote_error` function
    (unless `g_dbus_error_strip_remote_error` hasn't been used on the returned error).

    This function is typically only used in object mappings to prepare
    GError instances for applications. Regular applications should not use
    it.
    """
    ...

@staticmethod
def dbus_error_quark() -> int: ...
@staticmethod
def dbus_error_register_error(
    error_domain: int,
    error_code: int,
    dbus_error_name: str,
) -> bool:
    """
    Creates an association to map between `dbus_error_name` and
    GErrors specified by `error_domain` and `error_code`.

    This is typically done in the routine that returns the GQuark for
    an error domain.
    """
    ...

@staticmethod
def dbus_error_register_error_domain(
    error_domain_quark_name: str,
    quark_volatile: int,
    entries: list,
    num_entries: int,
) -> None:
    """
    Helper function for associating a GError error domain with D-Bus error names.

    While `quark_volatile` has a `volatile` qualifier, this is a historical
    artifact and the argument passed to it should not be `volatile`.
    """
    ...

@staticmethod
def dbus_error_strip_remote_error(
    error: GLib.Error,
) -> bool:
    """
    Looks for extra information in the error message used to recover
    the D-Bus error name and strips it if found. If stripped, the
    message field in `error` will correspond exactly to what was
    received on the wire.

    This is typically used when presenting errors to the end user.
    """
    ...

@staticmethod
def dbus_error_unregister_error(
    error_domain: int,
    error_code: int,
    dbus_error_name: str,
) -> bool:
    """
    Destroys an association previously set up with `g_dbus_error_register_error`.
    """
    ...

@staticmethod
def dbus_escape_object_path(
    s: str,
) -> str:
    """
    This is a language binding friendly version of `g_dbus_escape_object_path_bytestring`.
    """
    ...

@staticmethod
def dbus_escape_object_path_bytestring(
    bytes: list,
) -> str:
    """
    Escapes `bytes` for use in a D-Bus object path component.
    `bytes` is an array of zero or more nonzero bytes in an
    unspecified encoding, followed by a single zero byte.

    The escaping method consists of replacing all non-alphanumeric
    characters (see `g_ascii_isalnum`) with their hexadecimal value
    preceded by an underscore (`_`). For example:
    `foo.bar.baz` will become `foo_2ebar_2ebaz`.

    This method is appropriate to use when the input is nearly
    a valid object path component but is not when your input
    is far from being a valid object path component.
    Other escaping algorithms are also valid to use with
    D-Bus object paths.

    This can be reversed with `g_dbus_unescape_object_path`.
    """
    ...

@staticmethod
def dbus_generate_guid() -> str:
    """
    Generate a D-Bus GUID that can be used with
    e.g. `g_dbus_connection_new`.

    See the
    [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#uuids)
    regarding what strings are valid D-Bus GUIDs. The specification refers to
    these as ‘UUIDs’ whereas GLib (for historical reasons) refers to them as
    ‘GUIDs’. The terms are interchangeable.

    Note that D-Bus GUIDs do not follow
    [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
    """
    ...

@staticmethod
def dbus_gvalue_to_gvariant(
    gvalue: GObject.Value,
    type: GLib.VariantType,
) -> GLib.Variant:
    """
    Converts a GValue to a GVariant of the type indicated by the `type`
    parameter.

    The conversion is using the following rules:

    - `G_TYPE_STRING`: 's', 'o', 'g' or 'ay'
    - `G_TYPE_STRV`: 'as', 'ao' or 'aay'
    - `G_TYPE_BOOLEAN`: 'b'
    - `G_TYPE_UCHAR`: 'y'
    - `G_TYPE_INT`: 'i', 'n'
    - `G_TYPE_UINT`: 'u', 'q'
    - `G_TYPE_INT64`: 'x'
    - `G_TYPE_UINT64`: 't'
    - `G_TYPE_DOUBLE`: 'd'
    - `G_TYPE_VARIANT`: Any GVariantType

    This can fail if e.g. `gvalue` is of type G_TYPE_STRING and `type`
    is 'i', i.e. G_VARIANT_TYPE_INT32. It will also fail for any GType
    (including e.g. G_TYPE_OBJECT and G_TYPE_BOXED derived-types) not
    in the table above.

    Note that if `gvalue` is of type G_TYPE_VARIANT and its value is
    None, the empty GVariant instance (never None) for `type` is
    returned (e.g. 0 for scalar types, the empty string for string types,
    '/' for object path types, the empty array for any array type and so on).

    See the `g_dbus_gvariant_to_gvalue` function for how to convert a
    GVariant to a GValue.
    """
    ...

@staticmethod
def dbus_gvariant_to_gvalue(
    value: GLib.Variant,
) -> GObject.Value:
    """
    Converts a GVariant to a GValue. If `value` is floating, it is consumed.

    The rules specified in the `g_dbus_gvalue_to_gvariant` function are
    used - this function is essentially its reverse form. So, a GVariant
    containing any basic or string array type will be converted to a GValue
    containing a basic value or string array. Any other GVariant (handle,
    variant, tuple, dict entry) will be converted to a GValue containing that
    GVariant.

    The conversion never fails - a valid GValue is always returned in
    `out_gvalue`.
    """
    ...

@staticmethod
def dbus_is_address(
    string: str,
) -> bool:
    """
    Checks if `string` is a
    [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

    This doesn't check if `string` is actually supported by GDBusServer
    or GDBusConnection - use `g_dbus_is_supported_address` to do more
    checks.
    """
    ...

@staticmethod
def dbus_is_error_name(
    string: str,
) -> bool:
    """
    Check whether `string` is a valid D-Bus error name.

    This function returns the same result as `g_dbus_is_interface_name`,
    because D-Bus error names are defined to have exactly the
    same syntax as interface names.
    """
    ...

@staticmethod
def dbus_is_guid(
    string: str,
) -> bool:
    """
    Checks if `string` is a D-Bus GUID.

    See the documentation for `g_dbus_generate_guid` for more information about
    the format of a GUID.
    """
    ...

@staticmethod
def dbus_is_interface_name(
    string: str,
) -> bool:
    """
    Checks if `string` is a valid D-Bus interface name.
    """
    ...

@staticmethod
def dbus_is_member_name(
    string: str,
) -> bool:
    """
    Checks if `string` is a valid D-Bus member (e.g. signal or method) name.
    """
    ...

@staticmethod
def dbus_is_name(
    string: str,
) -> bool:
    """
    Checks if `string` is a valid D-Bus bus name (either unique or well-known).
    """
    ...

@staticmethod
def dbus_is_supported_address(
    string: str,
) -> bool:
    """
    Like `g_dbus_is_address` but also checks if the library supports the
    transports in `string` and that key/value pairs for each transport
    are valid. See the specification of the
    [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
    """
    ...

@staticmethod
def dbus_is_unique_name(
    string: str,
) -> bool:
    """
    Checks if `string` is a valid D-Bus unique bus name.
    """
    ...

@staticmethod
def dbus_unescape_object_path(
    s: str,
) -> list | None:
    """
    Unescapes an string that was previously escaped with
    `g_dbus_escape_object_path`. If the string is in a format that could
    not have been returned by `g_dbus_escape_object_path`, this function
    returns None.

    Encoding alphanumeric characters which do not need to be
    encoded is not allowed (e.g `_63` is not valid, the string
    should contain `c` instead).
    """
    ...

@staticmethod
def dtls_client_connection_new(
    base_socket: DatagramBased,
    server_identity: SocketConnectable | None = None,
) -> DtlsClientConnection:
    """
    Creates a new GDtlsClientConnection wrapping `base_socket` which is
    assumed to communicate with the server identified by `server_identity`.
    """
    ...

@staticmethod
def dtls_server_connection_new(
    base_socket: DatagramBased,
    certificate: TlsCertificate | None = None,
) -> DtlsServerConnection:
    """
    Creates a new GDtlsServerConnection wrapping `base_socket`.
    """
    ...

@staticmethod
def file_new_build_filenamev(
    args: list,
) -> File:
    """
    Constructs a GFile from a vector of elements using the correct
    separator for filenames.

    Using this function is equivalent to calling `g_build_filenamev`,
    followed by `g_file_new_for_path` on the result.
    """
    ...

@staticmethod
def file_new_for_commandline_arg(
    arg: str,
) -> File:
    """
    Creates a GFile with the given argument from the command line.
    The value of `arg` can be either a URI, an absolute path or a
    relative path resolved relative to the current working directory.
    This operation never fails, but the returned object might not
    support any I/O operation if `arg` points to a malformed path.

    Note that on Windows, this function expects its argument to be in
    UTF-8 -- not the system code page.  This means that you
    should not use this function with string from argv as it is passed
    to `main`.  `g_win32_get_command_line` will return a UTF-8 version of
    the commandline.  GApplication also uses UTF-8 but
    `g_application_command_line_create_file_for_arg` may be more useful
    for you there.  It is also always possible to use this function with
    GOptionContext arguments of type G_OPTION_ARG_FILENAME.
    """
    ...

@staticmethod
def file_new_for_commandline_arg_and_cwd(
    arg: str,
    cwd: str,
) -> File:
    """
    Creates a GFile with the given argument from the command line.

    This function is similar to `g_file_new_for_commandline_arg` except
    that it allows for passing the current working directory as an
    argument instead of using the current working directory of the
    process.

    This is useful if the commandline argument was given in a context
    other than the invocation of the current process.

    See also `g_application_command_line_create_file_for_arg`.
    """
    ...

@staticmethod
def file_new_for_path(
    path: str,
) -> File:
    """
    Constructs a GFile for a given path. This operation never
    fails, but the returned object might not support any I/O
    operation if `path` is malformed.
    """
    ...

@staticmethod
def file_new_for_uri(
    uri: str,
) -> File:
    """
    Constructs a GFile for a given URI. This operation never
    fails, but the returned object might not support any I/O
    operation if `uri` is malformed or if the uri type is
    not supported.
    """
    ...

@staticmethod
def file_new_tmp(
    tmpl: str | None = None,
) -> tuple[File, FileIOStream]:
    """
    Opens a file in the preferred directory for temporary files (as
    returned by `g_get_tmp_dir`) and returns a GFile and
    GFileIOStream pointing to it.

    `tmpl` should be a string in the GLib file name encoding
    containing a sequence of six 'X' characters, and containing no
    directory components. If it is None, a default template is used.

    Unlike the other GFile constructors, this will return None if
    a temporary file could not be created.
    """
    ...

@staticmethod
async def file_new_tmp_async(
    tmpl: str | None,
    io_priority: int,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    *user_data: object | None,
) -> None:
    """
    Asynchronously opens a file in the preferred directory for temporary files
     (as returned by `g_get_tmp_dir`) as `g_file_new_tmp`.

    `tmpl` should be a string in the GLib file name encoding
    containing a sequence of six 'X' characters, and containing no
    directory components. If it is None, a default template is used.
    """
    ...

@staticmethod
async def file_new_tmp_dir_async(
    tmpl: str | None,
    io_priority: int,
    cancellable: Cancellable | None = None,
    callback: AsyncReadyCallback | None = None,
    *user_data: object | None,
) -> None:
    """
    Asynchronously creates a directory in the preferred directory for
    temporary files (as returned by `g_get_tmp_dir`) as `g_dir_make_tmp`.

    `tmpl` should be a string in the GLib file name encoding
    containing a sequence of six 'X' characters, and containing no
    directory components. If it is None, a default template is used.
    """
    ...

@staticmethod
def file_new_tmp_dir_finish(
    result: AsyncResult,
) -> File:
    """
    Finishes a temporary directory creation started by
    `g_file_new_tmp_dir_async`.
    """
    ...

@staticmethod
def file_new_tmp_finish(
    result: AsyncResult,
) -> tuple[File, FileIOStream]:
    """
    Finishes a temporary file creation started by `g_file_new_tmp_async`.
    """
    ...

@staticmethod
def file_parse_name(
    parse_name: str,
) -> File:
    """
    Constructs a GFile with the given `parse_name` (i.e. something
    given by `g_file_get_parse_name`). This operation never fails,
    but the returned object might not support any I/O operation if
    the `parse_name` cannot be parsed.
    """
    ...

@staticmethod
def icon_deserialize(
    value: GLib.Variant,
) -> Icon | None:
    """
    Deserializes a GIcon previously serialized using `g_icon_serialize`.
    """
    ...

@staticmethod
def icon_new_for_string(
    str: str,
) -> Icon:
    """
    Generate a GIcon instance from `str`. This function can fail if
    `str` is not valid - see `g_icon_to_string` for discussion.

    If your application or library provides one or more GIcon
    implementations you need to ensure that each GType is registered
    with the type system prior to calling `g_icon_new_for_string`.
    """
    ...

@deprecated("deprecated")
@staticmethod
def initable_newv(
    object_type: GObject.GType,
    n_parameters: int,
    parameters: list,
    cancellable: Cancellable | None = None,
) -> GObject.Object:
    """
    Helper function for constructing GInitable object. This is
    similar to `g_object_newv` but also initializes the object
    and returns None, setting an error on failure.
    """
    ...

@staticmethod
def io_error_from_errno(
    err_no: int,
) -> IOErrorEnum:
    """
    Converts `errno.h` error codes into GIO error codes.

    The fallback value G_IO_ERROR_FAILED is returned for error codes not
    currently handled (but note that future GLib releases may return a more
    specific value instead).

    As `errno` is global and may be modified by intermediate function
    calls, you should save its value immediately after the call returns,
    and use the saved value instead of `errno`:


    |[<!-- language="C" -->
      int saved_errno;

      ret = read (blah);
      saved_errno = errno;

      g_io_error_from_errno (saved_errno);
    ]|
    """
    ...

@staticmethod
def io_error_from_file_error(
    file_error: GLib.FileError,
) -> IOErrorEnum:
    """
    Converts GFileError error codes into GIO error codes.
    """
    ...

@staticmethod
def io_error_quark() -> int:
    """
    Gets the GIO Error Quark.
    """
    ...

@staticmethod
def io_extension_point_implement(
    extension_point_name: str,
    type: GObject.GType,
    extension_name: str,
    priority: int,
) -> IOExtension:
    """
    Registers `type` as extension for the extension point with name
    `extension_point_name`.

    If `type` has already been registered as an extension for this
    extension point, the existing GIOExtension object is returned.
    """
    ...

@staticmethod
def io_extension_point_lookup(
    name: str,
) -> IOExtensionPoint:
    """
    Looks up an existing extension point.
    """
    ...

@staticmethod
def io_extension_point_register(
    name: str,
) -> IOExtensionPoint:
    """
    Registers an extension point.
    """
    ...

@staticmethod
def io_modules_load_all_in_directory(
    dirname: str,
) -> list:
    """
    Loads all the modules in the specified directory.

    If don't require all modules to be initialized (and thus registering
    all gtypes) then you can use `g_io_modules_scan_all_in_directory`
    which allows delayed/lazy loading of modules.
    """
    ...

@staticmethod
def io_modules_load_all_in_directory_with_scope(
    dirname: str,
    scope: IOModuleScope,
) -> list:
    """
    Loads all the modules in the specified directory.

    If don't require all modules to be initialized (and thus registering
    all gtypes) then you can use `g_io_modules_scan_all_in_directory`
    which allows delayed/lazy loading of modules.
    """
    ...

@staticmethod
def io_modules_scan_all_in_directory(
    dirname: str,
) -> None:
    """
    Scans all the modules in the specified directory, ensuring that
    any extension point implemented by a module is registered.

    This may not actually load and initialize all the types in each
    module, some modules may be lazily loaded and initialized when
    an extension point it implements is used with e.g.
    `g_io_extension_point_get_extensions` or
    `g_io_extension_point_get_extension_by_name`.

    If you need to guarantee that all types are loaded in all the modules,
    use `g_io_modules_load_all_in_directory`.
    """
    ...

@staticmethod
def io_modules_scan_all_in_directory_with_scope(
    dirname: str,
    scope: IOModuleScope,
) -> None:
    """
    Scans all the modules in the specified directory, ensuring that
    any extension point implemented by a module is registered.

    This may not actually load and initialize all the types in each
    module, some modules may be lazily loaded and initialized when
    an extension point it implements is used with e.g.
    `g_io_extension_point_get_extensions` or
    `g_io_extension_point_get_extension_by_name`.

    If you need to guarantee that all types are loaded in all the modules,
    use `g_io_modules_load_all_in_directory`.
    """
    ...

@deprecated("deprecated")
@staticmethod
def io_scheduler_cancel_all_jobs() -> None:
    """
    Cancels all cancellable I/O jobs.

    A job is cancellable if a GCancellable was passed into
    `g_io_scheduler_push_job`.
    """
    ...

@deprecated("deprecated")
@staticmethod
def io_scheduler_push_job(
    job_func: IOSchedulerJobFunc,
    *user_data: object | None,
    io_priority: int,
    cancellable: Cancellable | None = None,
) -> None:
    """
    Schedules the I/O job to run in another thread.

    `notify` will be called on `user_data` after `job_func` has returned,
    regardless whether the job was cancelled or has run to completion.

    If `cancellable` is not None, it can be used to cancel the I/O job
    by calling `g_cancellable_cancel` or by calling
    `g_io_scheduler_cancel_all_jobs`.
    """
    ...

@staticmethod
def keyfile_settings_backend_new(
    filename: str,
    root_path: str,
    root_group: str | None = None,
) -> SettingsBackend:
    """
    Creates a keyfile-backed [class`Gio`.SettingsBackend].

    The filename of the keyfile to use is given by `filename`.

    All settings read to or written from the backend must fall under the
    path given in `root_path` (which must start and end with a slash and
    not contain two consecutive slashes).  `root_path` may be `"/"`.

    If `root_group` is non-`None` then it specifies the name of the keyfile
    group used for keys that are written directly below `root_path`.  For
    example, if `root_path` is `"/apps/example/"` and `root_group` is
    `"toplevel"`, then setting the key `"/apps/example/enabled"` to true will
    cause the following to appear in the keyfile:

    ```
    [toplevel]
    enabled=true
    ```

    If `root_group` is `None` then it is not permitted to store keys
    directly below the `root_path`.

    For keys not stored directly below `root_path` (ie: in a sub-path),
    the name of the subpath (with the final slash stripped) is used as
    the name of the keyfile group.  To continue the example, if
    `"/apps/example/profiles/default/font-size"` were set to
    `12` then the following would appear in the keyfile:

    ```
    [profiles/default]
    font-size=12
    ```

    The backend will refuse writes (and return writability as being
    false) for keys outside of `root_path` and, in the event that
    `root_group` is `None`, also for keys directly under `root_path`.
    Writes will also be refused if the backend detects that it has the
    inability to rewrite the keyfile (ie: the containing directory is not
    writable).

    There is no checking done for your key namespace clashing with the
    syntax of the key file format.  For example, if you have `[` or `]`
    characters in your path names or `=` in your key names you may be in
    trouble.

    The backend reads default values from a keyfile called `defaults` in
    the directory specified by the `GKeyfileSettingsBackend:defaults-dir`
    property, and a list of locked keys from a text file with the name `locks` in
    the same location.
    """
    ...

@staticmethod
def memory_monitor_dup_default() -> MemoryMonitor:
    """
    Gets a reference to the default GMemoryMonitor for the system.
    """
    ...

@staticmethod
def memory_settings_backend_new() -> SettingsBackend:
    """
    Creates a memory-backed GSettingsBackend.

    This backend allows changes to settings, but does not write them
    to any backing storage, so the next time you run your application,
    the memory backend will start out with the default values again.
    """
    ...

@staticmethod
def network_monitor_get_default() -> NetworkMonitor:
    """
    Gets the default GNetworkMonitor for the system.
    """
    ...

@staticmethod
def networking_init() -> None:
    """
    Initializes the platform networking libraries (eg, on Windows, this
    calls `WSAStartup`). GLib will call this itself if it is needed, so
    you only need to call it if you directly call system networking
    functions (without calling any GLib networking functions first).
    """
    ...

@staticmethod
def null_settings_backend_new() -> SettingsBackend:
    """
    Creates a readonly GSettingsBackend.

    This backend does not allow changes to settings, so all settings
    will always have their default values.
    """
    ...

@staticmethod
def pollable_source_new(
    pollable_stream: GObject.Object,
) -> GLib.Source:
    """
    Utility method for GPollableInputStream and GPollableOutputStream
    implementations. Creates a new GSource that expects a callback of
    type GPollableSourceFunc. The new source does not actually do
    anything on its own; use `g_source_add_child_source` to add other
    sources to it to cause it to trigger.
    """
    ...

@staticmethod
def pollable_source_new_full(
    pollable_stream: GObject.Object,
    child_source: GLib.Source | None = None,
    cancellable: Cancellable | None = None,
) -> GLib.Source:
    """
    Utility method for GPollableInputStream and GPollableOutputStream
    implementations. Creates a new GSource, as with
    `g_pollable_source_new`, but also attaching `child_source` (with a
    dummy callback), and `cancellable`, if they are non-None.
    """
    ...

@staticmethod
def pollable_stream_read(
    stream: InputStream,
    buffer: list,
    count: int,
    blocking: bool,
    cancellable: Cancellable | None = None,
) -> int:
    """
    Tries to read from `stream`, as with `g_input_stream_read` (if
    `blocking` is True) or `g_pollable_input_stream_read_nonblocking`
    (if `blocking` is False). This can be used to more easily share
    code between blocking and non-blocking implementations of a method.

    If `blocking` is False, then `stream` must be a
    GPollableInputStream for which `g_pollable_input_stream_can_poll`
    returns True, or else the behavior is undefined. If `blocking` is
    True, then `stream` does not need to be a GPollableInputStream.
    """
    ...

@staticmethod
def pollable_stream_write(
    stream: OutputStream,
    buffer: list,
    count: int,
    blocking: bool,
    cancellable: Cancellable | None = None,
) -> int:
    """
    Tries to write to `stream`, as with `g_output_stream_write` (if
    `blocking` is True) or `g_pollable_output_stream_write_nonblocking`
    (if `blocking` is False). This can be used to more easily share
    code between blocking and non-blocking implementations of a method.

    If `blocking` is False, then `stream` must be a
    GPollableOutputStream for which
    `g_pollable_output_stream_can_poll` returns True or else the
    behavior is undefined. If `blocking` is True, then `stream` does not
    need to be a GPollableOutputStream.
    """
    ...

@staticmethod
def pollable_stream_write_all(
    stream: OutputStream,
    buffer: list,
    count: int,
    blocking: bool,
    cancellable: Cancellable | None = None,
) -> tuple[bool, int]:
    """
    Tries to write `count` bytes to `stream`, as with
    `g_output_stream_write_all`, but using `g_pollable_stream_write`
    rather than `g_output_stream_write`.

    On a successful write of `count` bytes, True is returned, and
    `bytes_written` is set to `count`.

    If there is an error during the operation (including
    G_IO_ERROR_WOULD_BLOCK in the non-blocking case), False is
    returned and `error` is set to indicate the error status,
    `bytes_written` is updated to contain the number of bytes written
    into the stream before the error occurred.

    As with `g_pollable_stream_write`, if `blocking` is False, then
    `stream` must be a GPollableOutputStream for which
    `g_pollable_output_stream_can_poll` returns True or else the
    behavior is undefined. If `blocking` is True, then `stream` does not
    need to be a GPollableOutputStream.
    """
    ...

@staticmethod
def power_profile_monitor_dup_default() -> PowerProfileMonitor:
    """
    Gets a reference to the default GPowerProfileMonitor for the system.
    """
    ...

@staticmethod
def proxy_get_default_for_protocol(
    protocol: str,
) -> Proxy | None:
    """
    Find the `gio-proxy` extension point for a proxy implementation that supports
    the specified protocol.
    """
    ...

@staticmethod
def proxy_resolver_get_default() -> ProxyResolver:
    """
    Gets the default GProxyResolver for the system.
    """
    ...

@staticmethod
def resolver_error_quark() -> int:
    """
    Gets the GResolver Error Quark.
    """
    ...

@staticmethod
def resource_error_quark() -> int:
    """
    Gets the [struct`Gio`.Resource] Error Quark.
    """
    ...

@staticmethod
def resource_load(
    filename: str,
) -> Resource:
    """
    Loads a binary resource bundle and creates a [struct`Gio`.Resource]
    representation of it, allowing you to query it for data.

    If you want to use this resource in the global resource namespace you need
    to register it with [func`Gio`.resources_register].

    If `filename` is empty or the data in it is corrupt,
    G_RESOURCE_ERROR_INTERNAL will be returned. If `filename` doesn’t exist, or
    there is an error in reading it, an error from [ctor`GLib`.MappedFile.new]
    will be returned.
    """
    ...

@staticmethod
def resources_enumerate_children(
    path: str,
    lookup_flags: ResourceLookupFlags,
) -> list:
    """
    Returns all the names of children at the specified `path` in the set of
    globally registered resources.

    The return result is a `None` terminated list of strings which should
    be released with [func`GLib`.strfreev].

    `lookup_flags` controls the behaviour of the lookup.
    """
    ...

@staticmethod
def resources_get_info(
    path: str,
    lookup_flags: ResourceLookupFlags,
) -> tuple[bool, int, int]:
    """
    Looks for a file at the specified `path` in the set of
    globally registered resources and if found returns information about it.

    `lookup_flags` controls the behaviour of the lookup.
    """
    ...

@staticmethod
def resources_has_children(
    path: str,
) -> bool:
    """
    Returns whether the specified `path` in the set of
    globally registered resources has children.
    """
    ...

@staticmethod
def resources_lookup_data(
    path: str,
    lookup_flags: ResourceLookupFlags,
) -> GLib.Bytes:
    """
    Looks for a file at the specified `path` in the set of
    globally registered resources and returns a [struct`GLib`.Bytes] that
    lets you directly access the data in memory.

    The data is always followed by a zero byte, so you
    can safely use the data as a C string. However, that byte
    is not included in the size of the [struct`GLib`.Bytes].

    For uncompressed resource files this is a pointer directly into
    the resource bundle, which is typically in some read-only data section
    in the program binary. For compressed files we allocate memory on
    the heap and automatically uncompress the data.

    `lookup_flags` controls the behaviour of the lookup.
    """
    ...

@staticmethod
def resources_open_stream(
    path: str,
    lookup_flags: ResourceLookupFlags,
) -> InputStream:
    """
    Looks for a file at the specified `path` in the set of
    globally registered resources and returns a [class`Gio`.InputStream]
    that lets you read the data.

    `lookup_flags` controls the behaviour of the lookup.
    """
    ...

@staticmethod
def resources_register(
    resource: Resource,
) -> None:
    """
    Registers the resource with the process-global set of resources.

    Once a resource is registered the files in it can be accessed
    with the global resource lookup functions like
    [func`Gio`.resources_lookup_data].
    """
    ...

@staticmethod
def resources_unregister(
    resource: Resource,
) -> None:
    """
    Unregisters the resource from the process-global set of resources.
    """
    ...

@staticmethod
def settings_schema_source_get_default() -> SettingsSchemaSource | None:
    """
    Gets the default system schema source.

    This function is not required for normal uses of GSettings but it
    may be useful to authors of plugin management systems or to those who
    want to introspect the content of schemas.

    If no schemas are installed, None will be returned.

    The returned source may actually consist of multiple schema sources
    from different directories, depending on which directories were given
    in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
    lookups performed against the default source should probably be done
    recursively.
    """
    ...

@deprecated("deprecated")
@staticmethod
def simple_async_report_gerror_in_idle(
    object: GObject.Object | None,
    callback: AsyncReadyCallback | None,
    *user_data: object | None,
    error: GLib.Error,
) -> None:
    """
    Reports an error in an idle function. Similar to
    `g_simple_async_report_error_in_idle`, but takes a GError rather
    than building a new one.
    """
    ...

@staticmethod
def tls_backend_get_default() -> TlsBackend:
    """
    Gets the default GTlsBackend for the system.
    """
    ...

@staticmethod
def tls_channel_binding_error_quark() -> int:
    """
    Gets the TLS channel binding error quark.
    """
    ...

@staticmethod
def tls_client_connection_new(
    base_io_stream: IOStream,
    server_identity: SocketConnectable | None = None,
) -> TlsClientConnection:
    """
    Creates a new GTlsClientConnection wrapping `base_io_stream` (which
    must have pollable input and output streams) which is assumed to
    communicate with the server identified by `server_identity`.

    See the documentation for GTlsConnection:base-io-stream for restrictions
    on when application code can run operations on the `base_io_stream` after
    this function has returned.
    """
    ...

@staticmethod
def tls_error_quark() -> int:
    """
    Gets the TLS error quark.
    """
    ...

@staticmethod
def tls_file_database_new(
    anchors: str,
) -> TlsFileDatabase:
    """
    Creates a new GTlsFileDatabase which uses anchor certificate authorities
    in `anchors` to verify certificate chains.

    The certificates in `anchors` must be PEM encoded.
    """
    ...

@staticmethod
def tls_server_connection_new(
    base_io_stream: IOStream,
    certificate: TlsCertificate | None = None,
) -> TlsServerConnection:
    """
    Creates a new GTlsServerConnection wrapping `base_io_stream` (which
    must have pollable input and output streams).

    See the documentation for GTlsConnection:base-io-stream for restrictions
    on when application code can run operations on the `base_io_stream` after
    this function has returned.
    """
    ...

@staticmethod
def unix_is_mount_path_system_internal(
    mount_path: str,
) -> bool:
    """
    Determines if `mount_path` is considered an implementation of the
    OS.

    This is primarily used for hiding mountable and mounted volumes
    that only are used in the OS and has little to no relevance to the
    casual user.
    """
    ...

@staticmethod
def unix_is_system_device_path(
    device_path: str,
) -> bool:
    """
    Determines if `device_path` is considered a block device path which is only
    used in implementation of the OS.

    This is primarily used for hiding mounted volumes that are intended as APIs
    for programs to read, and system administrators at a shell; rather than
    something that should, for example, appear in a GUI. For example, the Linux
    `/proc` filesystem.

    The list of device paths considered ‘system’ ones may change over time.
    """
    ...

@staticmethod
def unix_is_system_fs_type(
    fs_type: str,
) -> bool:
    """
    Determines if `fs_type` is considered a type of file system which is only
    used in implementation of the OS.

    This is primarily used for hiding mounted volumes that are intended as APIs
    for programs to read, and system administrators at a shell; rather than
    something that should, for example, appear in a GUI. For example, the Linux
    `/proc` filesystem.

    The list of file system types considered ‘system’ ones may change over time.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_at(
    mount_path: str,
) -> tuple[GioUnix.MountEntry | None, int]:
    """
    Gets a [struct`GioUnix`.MountEntry] for a given mount path.

    If `time_read` is set, it will be filled with a Unix timestamp for checking
    if the mounts have changed since with
    [func`GioUnix`.mount_entries_changed_since].

    If more mounts have the same mount path, the last matching mount
    is returned.

    This will return `None` if there is no mount point at `mount_path`.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_compare(
    mount1: GioUnix.MountEntry,
    mount2: GioUnix.MountEntry,
) -> int:
    """
    Compares two Unix mounts.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_copy(
    mount_entry: GioUnix.MountEntry,
) -> GioUnix.MountEntry:
    """
    Makes a copy of `mount_entry`.
    """
    ...

@staticmethod
def unix_mount_entries_changed_since(
    time: int,
) -> bool:
    """
    Checks if the Unix mounts have changed since a given Unix time.

    This can only work reliably if a [class`GioUnix`.MountMonitor] is running in
    the process, otherwise changes in the mount entries file (such as
    `/proc/self/mountinfo` on Linux) cannot be detected and, as a result, this
    function has to conservatively always return `True`.

    It is more efficient to use [signal`GioUnix`.MountMonitor::mounts-changed] to
    be signalled of changes to the mount entries, rather than polling using this
    function. This function is more appropriate for infrequently determining
    cache validity.
    """
    ...

@staticmethod
def unix_mount_entries_get() -> tuple[list, int]:
    """
    Gets a list of [struct`GioUnix`.MountEntry] instances representing the Unix
    mounts.

    If `time_read` is set, it will be filled with the mount timestamp, allowing
    for checking if the mounts have changed with
    [func`GioUnix`.mount_entries_changed_since].
    """
    ...

@staticmethod
def unix_mount_entries_get_from_file(
    table_path: str,
) -> tuple[list | None, int, int]:
    """
    Gets an array of [struct`Gio`.UnixMountEntry]s containing the Unix mounts
    listed in `table_path`.

    This is a generalized version of [func`GioUnix`.mount_entries_get], mainly
    intended for internal testing use. Note that [func`GioUnix`.mount_entries_get]
    may parse multiple hierarchical table files, so this function is not a direct
    superset of its functionality.

    If there is an error reading or parsing the file, `None` will be returned
    and both out parameters will be set to `0`.
    """
    ...

@staticmethod
def unix_mount_entry_at(
    mount_path: str,
) -> tuple[GioUnix.MountEntry | None, int]:
    """
    Gets a [struct`GioUnix`.MountEntry] for a given mount path.

    If `time_read` is set, it will be filled with a Unix timestamp for checking
    if the mounts have changed since with
    [func`GioUnix`.mount_entries_changed_since].

    If more mounts have the same mount path, the last matching mount
    is returned.

    This will return `None` if there is no mount point at `mount_path`.
    """
    ...

@staticmethod
def unix_mount_entry_for(
    file_path: str,
) -> tuple[GioUnix.MountEntry | None, int]:
    """
    Gets a [struct`GioUnix`.MountEntry] for a given file path.

    If `time_read` is set, it will be filled with a Unix timestamp for checking
    if the mounts have changed since with
    [func`GioUnix`.mount_entries_changed_since].

    If more mounts have the same mount path, the last matching mount
    is returned.

    This will return `None` if looking up the mount entry fails, if
    `file_path` doesn’t exist or there is an I/O error.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_for(
    file_path: str,
) -> tuple[GioUnix.MountEntry | None, int]:
    """
    Gets a [struct`GioUnix`.MountEntry] for a given file path.

    If `time_read` is set, it will be filled with a Unix timestamp for checking
    if the mounts have changed since with
    [func`GioUnix`.mount_entries_changed_since].

    If more mounts have the same mount path, the last matching mount
    is returned.

    This will return `None` if looking up the mount entry fails, if
    `file_path` doesn’t exist or there is an I/O error.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_free(
    mount_entry: GioUnix.MountEntry,
) -> None:
    """
    Frees a Unix mount.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_get_device_path(
    mount_entry: GioUnix.MountEntry,
) -> str:
    """
    Gets the device path for a Unix mount.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_get_fs_type(
    mount_entry: GioUnix.MountEntry,
) -> str:
    """
    Gets the filesystem type for the Unix mount.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_get_mount_path(
    mount_entry: GioUnix.MountEntry,
) -> str:
    """
    Gets the mount path for a Unix mount.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_get_options(
    mount_entry: GioUnix.MountEntry,
) -> str | None:
    """
    Gets a comma separated list of mount options for the Unix mount.

    For example: `rw,relatime,seclabel,data=ordered`.

    This is similar to [func`GioUnix`.MountPoint.get_options], but it takes
    a [struct`GioUnix`.MountEntry] as an argument.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_get_root_path(
    mount_entry: GioUnix.MountEntry,
) -> str | None:
    """
    Gets the root of the mount within the filesystem. This is useful e.g. for
    mounts created by bind operation, or btrfs subvolumes.

    For example, the root path is equal to `/` for a mount created by
    `mount /dev/sda1 /mnt/foo` and `/bar` for
    `mount --bind /mnt/foo/bar /mnt/bar`.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_guess_can_eject(
    mount_entry: GioUnix.MountEntry,
) -> bool:
    """
    Guesses whether a Unix mount entry can be ejected.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_guess_icon(
    mount_entry: GioUnix.MountEntry,
) -> Icon:
    """
    Guesses the icon of a Unix mount entry.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_guess_name(
    mount_entry: GioUnix.MountEntry,
) -> str:
    """
    Guesses the name of a Unix mount entry.

    The result is a translated string.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_guess_should_display(
    mount_entry: GioUnix.MountEntry,
) -> bool:
    """
    Guesses whether a Unix mount entry should be displayed in the UI.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_guess_symbolic_icon(
    mount_entry: GioUnix.MountEntry,
) -> Icon:
    """
    Guesses the symbolic icon of a Unix mount entry.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_is_readonly(
    mount_entry: GioUnix.MountEntry,
) -> bool:
    """
    Checks if a Unix mount is mounted read only.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mount_is_system_internal(
    mount_entry: GioUnix.MountEntry,
) -> bool:
    """
    Checks if a Unix mount is a system mount.

    This is the Boolean OR of
    [func`GioUnix`.is_system_fs_type], [func`GioUnix`.is_system_device_path] and
    [func`GioUnix`.is_mount_path_system_internal] on `mount_entry`’s properties.

    The definition of what a ‘system’ mount entry is may change over time as new
    file system types and device paths are ignored.
    """
    ...

@staticmethod
def unix_mount_point_at(
    mount_path: str,
) -> tuple[GioUnix.MountPoint | None, int]:
    """
    Gets a [struct`GioUnix`.MountPoint] for a given mount path.

    If `time_read` is set, it will be filled with a Unix timestamp for checking if
    the mount points have changed since with
    [func`GioUnix`.mount_points_changed_since].

    If more mount points have the same mount path, the last matching mount point
    is returned.
    """
    ...

@staticmethod
def unix_mount_points_changed_since(
    time: int,
) -> bool:
    """
    Checks if the Unix mount points have changed since a given Unix time.

    Unlike [func`GioUnix`.mount_entries_changed_since], this function can work
    reliably without a [class`GioUnix`.MountMonitor] running, as it accesses the
    static mount point information (such as `/etc/fstab` on Linux), which has a
    valid modification time.

    It is more efficient to use [signal`GioUnix`.MountMonitor::mountpoints-changed]
    to be signalled of changes to the mount points, rather than polling using
    this function. This function is more appropriate for infrequently determining
    cache validity.
    """
    ...

@staticmethod
def unix_mount_points_get() -> tuple[list, int]:
    """
    Gets a list of [struct`GioUnix`.MountPoint] instances representing the Unix
    mount points.

    If `time_read` is set, it will be filled with the mount timestamp, allowing
    for checking if the mounts have changed with
    [func`GioUnix`.mount_points_changed_since].
    """
    ...

@staticmethod
def unix_mount_points_get_from_file(
    table_path: str,
) -> tuple[list | None, int, int]:
    """
    Gets an array of [struct`Gio`.UnixMountPoint]s containing the Unix mount
    points listed in `table_path`.

    This is a generalized version of [func`GioUnix`.mount_points_get], mainly
    intended for internal testing use. Note that [func`GioUnix`.mount_points_get]
    may parse multiple hierarchical table files, so this function is not a direct
    superset of its functionality.

    If there is an error reading or parsing the file, `None` will be returned
    and both out parameters will be set to `0`.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mounts_changed_since(
    time: int,
) -> bool:
    """
    Checks if the Unix mounts have changed since a given Unix time.
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mounts_get() -> tuple[list, int]:
    """
    Gets a list of [struct`GioUnix`.MountEntry] instances representing the Unix
    mounts.

    If `time_read` is set, it will be filled with the mount timestamp, allowing
    for checking if the mounts have changed with
    [func`GioUnix`.mount_entries_changed_since].
    """
    ...

@deprecated("deprecated")
@staticmethod
def unix_mounts_get_from_file(
    table_path: str,
) -> tuple[list | None, int, int]:
    """
    Gets an array of [struct`Gio`.UnixMountEntry]s containing the Unix mounts
    listed in `table_path`.

    This is a generalized version of [func`GioUnix`.mount_entries_get], mainly
    intended for internal testing use. Note that [func`GioUnix`.mount_entries_get]
    may parse multiple hierarchical table files, so this function is not a direct
    superset of its functionality.

    If there is an error reading or parsing the file, `None` will be returned
    and both out parameters will be set to `0`.
    """
    ...

###############################################################
# Enums/Flags
###############################################################

class AppInfoCreateFlags(GObject.GFlags):
    """
    Flags used when creating a GAppInfo."""

    NONE = 0
    """
    No flags.
    """
    NEEDS_TERMINAL = 1
    """
    Application opens in a terminal window.
    """
    SUPPORTS_URIS = 2
    """
    Application supports URI arguments.
    """
    SUPPORTS_STARTUP_NOTIFICATION = 4
    """
    Application supports startup notification. Since 2.26
    """

class ApplicationFlags(GObject.GFlags):
    """
    Flags used to define the behaviour of a GApplication."""

    FLAGS_NONE = 0
    """
    Default flags.
    """
    DEFAULT_FLAGS = 0
    """
    Default flags.
    """
    IS_SERVICE = 1
    """
    Run as a service. In this mode, registration
         fails if the service is already running, and the application
         will initially wait up to 10 seconds for an initial activation
         message to arrive.
    """
    IS_LAUNCHER = 2
    """
    Don't try to become the primary instance.
    """
    HANDLES_OPEN = 4
    """
    This application handles opening files (in
        the primary instance). Note that this flag only affects the default
        implementation of `local_command_line`, and has no effect if
        G_APPLICATION_HANDLES_COMMAND_LINE is given.
        See `g_application_run` for details.
    """
    HANDLES_COMMAND_LINE = 8
    """
    This application handles command line
        arguments (in the primary instance). Note that this flag only affect
        the default implementation of `local_command_line`.
        See `g_application_run` for details.
    """
    SEND_ENVIRONMENT = 16
    """
    Send the environment of the
        launching process to the primary instance. Set this flag if your
        application is expected to behave differently depending on certain
        environment variables. For instance, an editor might be expected
        to use the `GIT_COMMITTER_NAME` environment variable
        when editing a git commit message. The environment is available
        to the GApplication::command-line signal handler, via
        `g_application_command_line_getenv`.
    """
    NON_UNIQUE = 32
    """
    Make no attempts to do any of the typical
        single-instance application negotiation, even if the application
        ID is given.  The application neither attempts to become the
        owner of the application ID nor does it check if an existing
        owner already exists.  Everything occurs in the local process.
        Since: 2.30.
    """
    CAN_OVERRIDE_APP_ID = 64
    """
    Allow users to override the
        application ID from the command line with `--gapplication-app-id`.
        Since: 2.48
    """
    ALLOW_REPLACEMENT = 128
    """
    Allow another instance to take over
        the bus name. Since: 2.60
    """
    REPLACE = 256
    """
    Take over from another instance. This flag is
        usually set by passing `--gapplication-replace` on the commandline.
        Since: 2.60
    """

class AskPasswordFlags(GObject.GFlags):
    """
    GAskPasswordFlags are used to request specific information from the
    user, or to notify the user of their choices in an authentication
    situation."""

    NEED_PASSWORD = 1
    """
    operation requires a password.
    """
    NEED_USERNAME = 2
    """
    operation requires a username.
    """
    NEED_DOMAIN = 4
    """
    operation requires a domain.
    """
    SAVING_SUPPORTED = 8
    """
    operation supports saving settings.
    """
    ANONYMOUS_SUPPORTED = 16
    """
    operation supports anonymous users.
    """
    TCRYPT = 32
    """
    operation takes TCRYPT parameters (Since: 2.58)
    """

class BusNameOwnerFlags(GObject.GFlags):
    """
    Flags used in `g_bus_own_name`."""

    NONE = 0
    """
    No flags set.
    """
    ALLOW_REPLACEMENT = 1
    """
    Allow another message bus connection to claim the name.
    """
    REPLACE = 2
    """
    If another message bus connection owns the name and have
    specified G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
    """
    DO_NOT_QUEUE = 4
    """
    If another message bus connection owns the name, immediately
    return an error from `g_bus_own_name` rather than entering the waiting queue for that name. (Since 2.54)
    """

class BusNameWatcherFlags(GObject.GFlags):
    """
    Flags used in `g_bus_watch_name`."""

    NONE = 0
    """
    No flags set.
    """
    AUTO_START = 1
    """
    If no-one owns the name when
    beginning to watch the name, ask the bus to launch an owner for the
    name.
    """

class BusType(GObject.GEnum):
    """
    An enumeration for well-known message buses."""

    STARTER = -1
    """
    An alias for the message bus that activated the process, if any.
    """
    NONE = 0
    """
    Not a message bus.
    """
    SYSTEM = 1
    """
    The system-wide message bus.
    """
    SESSION = 2
    """
    The login session message bus.
    """

class ConverterFlags(GObject.GFlags):
    """
    Flags used when calling a `g_converter_convert`."""

    NONE = 0
    """
    No flags.
    """
    INPUT_AT_END = 1
    """
    At end of input data
    """
    FLUSH = 2
    """
    Flush data
    """

class ConverterResult(GObject.GEnum):
    """
    Results returned from `g_converter_convert`."""

    ERROR = 0
    """
    There was an error during conversion.
    """
    CONVERTED = 1
    """
    Some data was consumed or produced
    """
    FINISHED = 2
    """
    The conversion is finished
    """
    FLUSHED = 3
    """
    Flushing is finished
    """

class CredentialsType(GObject.GEnum):
    """
    Enumeration describing different kinds of native credential types."""

    INVALID = 0
    """
    Indicates an invalid native credential type.
    """
    LINUX_UCRED = 1
    """
    The native credentials type is a `struct ucred`.
    """
    FREEBSD_CMSGCRED = 2
    """
    The native credentials type is a `struct cmsgcred`.
    """
    OPENBSD_SOCKPEERCRED = 3
    """
    The native credentials type is a `struct sockpeercred`. Added in 2.30.
    """
    SOLARIS_UCRED = 4
    """
    The native credentials type is a `ucred_t`. Added in 2.40.
    """
    NETBSD_UNPCBID = 5
    """
    The native credentials type is a `struct unpcbid`. Added in 2.42.
    """
    APPLE_XUCRED = 6
    """
    The native credentials type is a `struct xucred`. Added in 2.66.
    """
    WIN32_PID = 7
    """
    The native credentials type is a PID `DWORD`. Added in 2.72.
    """

class DBusCallFlags(GObject.GFlags):
    """
    Flags used in `g_dbus_connection_call` and similar APIs."""

    NONE = 0
    """
    No flags set.
    """
    NO_AUTO_START = 1
    """
    The bus must not launch
    an owner for the destination name in response to this method
    invocation.
    """
    ALLOW_INTERACTIVE_AUTHORIZATION = 2
    """
    the caller is prepared to
    wait for interactive authorization. Since 2.46.
    """

class DBusCapabilityFlags(GObject.GFlags):
    """
    Capabilities negotiated with the remote peer."""

    NONE = 0
    """
    No flags set.
    """
    UNIX_FD_PASSING = 1
    """
    The connection
    supports exchanging UNIX file descriptors with the remote peer.
    """

class DBusConnectionFlags(GObject.GFlags):
    """
    Flags used when creating a new GDBusConnection."""

    NONE = 0
    """
    No flags set.
    """
    AUTHENTICATION_CLIENT = 1
    """
    Perform authentication against server.
    """
    AUTHENTICATION_SERVER = 2
    """
    Perform authentication against client.
    """
    AUTHENTICATION_ALLOW_ANONYMOUS = 4
    """
    When
    authenticating as a server, allow the anonymous authentication
    method.
    """
    MESSAGE_BUS_CONNECTION = 8
    """
    Pass this flag if connecting to a peer that is a
    message bus. This means that the `Hello` method will be invoked as part of the connection setup.
    """
    DELAY_MESSAGE_PROCESSING = 16
    """
    If set, processing of D-Bus messages is
    delayed until `g_dbus_connection_start_message_processing` is called.
    """
    AUTHENTICATION_REQUIRE_SAME_USER = 32
    """
    When authenticating
    as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)
    """
    CROSS_NAMESPACE = 64
    """
    When authenticating, try to use
     protocols that work across a Linux user namespace boundary, even if this
     reduces interoperability with older D-Bus implementations. This currently
     affects client-side `EXTERNAL` authentication, for which this flag makes
     connections to a server in another user namespace succeed, but causes
     a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74
    """

class DBusError(GObject.GEnum):
    """
    Error codes for the G_DBUS_ERROR error domain."""

    FAILED = 0
    """
    A generic error; "something went wrong" - see the error message for
    more.
    """
    NO_MEMORY = 1
    """
    There was not enough memory to complete an operation.
    """
    SERVICE_UNKNOWN = 2
    """
    The bus doesn't know how to launch a service to supply the bus name
    you wanted.
    """
    NAME_HAS_NO_OWNER = 3
    """
    The bus name you referenced doesn't exist (i.e. no application owns
    it).
    """
    NO_REPLY = 4
    """
    No reply to a message expecting one, usually means a timeout occurred.
    """
    IO_ERROR = 5
    """
    Something went wrong reading or writing to a socket, for example.
    """
    BAD_ADDRESS = 6
    """
    A D-Bus bus address was malformed.
    """
    NOT_SUPPORTED = 7
    """
    Requested operation isn't supported (like ENOSYS on UNIX).
    """
    LIMITS_EXCEEDED = 8
    """
    Some limited resource is exhausted.
    """
    ACCESS_DENIED = 9
    """
    Security restrictions don't allow doing what you're trying to do.
    """
    AUTH_FAILED = 10
    """
    Authentication didn't work.
    """
    NO_SERVER = 11
    """
    Unable to connect to server (probably caused by ECONNREFUSED on a
    socket).
    """
    TIMEOUT = 12
    """
    Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
    G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
    this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
    exists. We can't fix it for compatibility reasons so just be
    careful.
    """
    NO_NETWORK = 13
    """
    No network access (probably ENETUNREACH on a socket).
    """
    ADDRESS_IN_USE = 14
    """
    Can't bind a socket since its address is in use (i.e. EADDRINUSE).
    """
    DISCONNECTED = 15
    """
    The connection is disconnected and you're trying to use it.
    """
    INVALID_ARGS = 16
    """
    Invalid arguments passed to a method call.
    """
    FILE_NOT_FOUND = 17
    """
    Missing file.
    """
    FILE_EXISTS = 18
    """
    Existing file and the operation you're using does not silently overwrite.
    """
    UNKNOWN_METHOD = 19
    """
    Method name you invoked isn't known by the object you invoked it on.
    """
    TIMED_OUT = 20
    """
    Certain timeout errors, e.g. while starting a service. Warning: this is
    confusingly-named given that G_DBUS_ERROR_TIMEOUT also exists. We
    can't fix it for compatibility reasons so just be careful.
    """
    MATCH_RULE_NOT_FOUND = 21
    """
    Tried to remove or modify a match rule that didn't exist.
    """
    MATCH_RULE_INVALID = 22
    """
    The match rule isn't syntactically valid.
    """
    SPAWN_EXEC_FAILED = 23
    """
    While starting a new process, the `exec` call failed.
    """
    SPAWN_FORK_FAILED = 24
    """
    While starting a new process, the `fork` call failed.
    """
    SPAWN_CHILD_EXITED = 25
    """
    While starting a new process, the child exited with a status code.
    """
    SPAWN_CHILD_SIGNALED = 26
    """
    While starting a new process, the child exited on a signal.
    """
    SPAWN_FAILED = 27
    """
    While starting a new process, something went wrong.
    """
    SPAWN_SETUP_FAILED = 28
    """
    We failed to setup the environment correctly.
    """
    SPAWN_CONFIG_INVALID = 29
    """
    We failed to setup the config parser correctly.
    """
    SPAWN_SERVICE_INVALID = 30
    """
    Bus name was not valid.
    """
    SPAWN_SERVICE_NOT_FOUND = 31
    """
    Service file not found in system-services directory.
    """
    SPAWN_PERMISSIONS_INVALID = 32
    """
    Permissions are incorrect on the setuid helper.
    """
    SPAWN_FILE_INVALID = 33
    """
    Service file invalid (Name, User or Exec missing).
    """
    SPAWN_NO_MEMORY = 34
    """
    Tried to get a UNIX process ID and it wasn't available.
    """
    UNIX_PROCESS_ID_UNKNOWN = 35
    """
    Tried to get a UNIX process ID and it wasn't available.
    """
    INVALID_SIGNATURE = 36
    """
    A type signature is not valid.
    """
    INVALID_FILE_CONTENT = 37
    """
    A file contains invalid syntax or is otherwise broken.
    """
    SELINUX_SECURITY_CONTEXT_UNKNOWN = 38
    """
    Asked for SELinux security context and it wasn't available.
    """
    ADT_AUDIT_DATA_UNKNOWN = 39
    """
    Asked for ADT audit data and it wasn't available.
    """
    OBJECT_PATH_IN_USE = 40
    """
    There's already an object with the requested object path.
    """
    UNKNOWN_OBJECT = 41
    """
    Object you invoked a method on isn't known. Since 2.42
    """
    UNKNOWN_INTERFACE = 42
    """
    Interface you invoked a method on isn't known by the object. Since 2.42
    """
    UNKNOWN_PROPERTY = 43
    """
    Property you tried to access isn't known by the object. Since 2.42
    """
    PROPERTY_READ_ONLY = 44
    """
    Property you tried to set is read-only. Since 2.42
    """

class DBusInterfaceSkeletonFlags(GObject.GFlags):
    """
    Flags describing the behavior of a GDBusInterfaceSkeleton instance."""

    NONE = 0
    """
    No flags set.
    """
    HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1
    """
    Each method invocation is handled in
      a thread dedicated to the invocation. This means that the method implementation can use blocking IO
      without blocking any other part of the process. It also means that the method implementation must
      use locking to access data structures used by other threads.
    """

class DBusMessageByteOrder(GObject.GEnum):
    """
    Enumeration used to describe the byte order of a D-Bus message."""

    BIG_ENDIAN = 66
    """
    The byte order is big endian.
    """
    LITTLE_ENDIAN = 108
    """
    The byte order is little endian.
    """

class DBusMessageFlags(GObject.GFlags):
    """
    Message flags used in GDBusMessage."""

    NONE = 0
    """
    No flags set.
    """
    NO_REPLY_EXPECTED = 1
    """
    A reply is not expected.
    """
    NO_AUTO_START = 2
    """
    The bus must not launch an
    owner for the destination name in response to this message.
    """
    ALLOW_INTERACTIVE_AUTHORIZATION = 4
    """
    If set on a method
    call, this flag means that the caller is prepared to wait for interactive
    authorization. Since 2.46.
    """

class DBusMessageHeaderField(GObject.GEnum):
    """
    Header fields used in GDBusMessage."""

    INVALID = 0
    """
    Not a valid header field.
    """
    PATH = 1
    """
    The object path.
    """
    INTERFACE = 2
    """
    The interface name.
    """
    MEMBER = 3
    """
    The method or signal name.
    """
    ERROR_NAME = 4
    """
    The name of the error that occurred.
    """
    REPLY_SERIAL = 5
    """
    The serial number the message is a reply to.
    """
    DESTINATION = 6
    """
    The name the message is intended for.
    """
    SENDER = 7
    """
    Unique name of the sender of the message (filled in by the bus).
    """
    SIGNATURE = 8
    """
    The signature of the message body.
    """
    NUM_UNIX_FDS = 9
    """
    The number of UNIX file descriptors that accompany the message.
    """

class DBusMessageType(GObject.GEnum):
    """
    Message types used in GDBusMessage."""

    INVALID = 0
    """
    Message is of invalid type.
    """
    METHOD_CALL = 1
    """
    Method call.
    """
    METHOD_RETURN = 2
    """
    Method reply.
    """
    ERROR = 3
    """
    Error reply.
    """
    SIGNAL = 4
    """
    Signal emission.
    """

class DBusObjectManagerClientFlags(GObject.GFlags):
    """
    Flags used when constructing a GDBusObjectManagerClient."""

    NONE = 0
    """
    No flags set.
    """
    DO_NOT_AUTO_START = 1
    """
    If not set and the
      manager is for a well-known name, then request the bus to launch
      an owner for the name if no-one owns the name. This flag can only
      be used in managers for well-known names.
    """

class DBusPropertyInfoFlags(GObject.GFlags):
    """
    Flags describing the access control of a D-Bus property."""

    NONE = 0
    """
    No flags set.
    """
    READABLE = 1
    """
    Property is readable.
    """
    WRITABLE = 2
    """
    Property is writable.
    """

class DBusProxyFlags(GObject.GFlags):
    """
    Flags used when constructing an instance of a GDBusProxy derived class."""

    NONE = 0
    """
    No flags set.
    """
    DO_NOT_LOAD_PROPERTIES = 1
    """
    Don't load properties.
    """
    DO_NOT_CONNECT_SIGNALS = 2
    """
    Don't connect to signals on the remote object.
    """
    DO_NOT_AUTO_START = 4
    """
    If the proxy is for a well-known name,
    do not ask the bus to launch an owner during proxy initialization or a method call.
    This flag is only meaningful in proxies for well-known names.
    """
    GET_INVALIDATED_PROPERTIES = 8
    """
    If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the GDBusProxy::g-properties-changed signal. When the value is received the GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.
    """
    DO_NOT_AUTO_START_AT_CONSTRUCTION = 16
    """
    If the proxy is for a well-known name,
    do not ask the bus to launch an owner during proxy initialization, but allow it to be
    autostarted by a method call. This flag is only meaningful in proxies for well-known names,
    and only if G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
    """
    NO_MATCH_RULE = 32
    """
    Don't actually send the AddMatch D-Bus
       call for this signal subscription. This gives you more control
       over which match rules you add (but you must add them manually). (Since: 2.72)
    """

class DBusSendMessageFlags(GObject.GFlags):
    """
    Flags used when sending GDBusMessages on a GDBusConnection."""

    NONE = 0
    """
    No flags set.
    """
    PRESERVE_SERIAL = 1
    """
    Do not automatically
    assign a serial number from the GDBusConnection object when
    sending a message.
    """

class DBusServerFlags(GObject.GFlags):
    """
    Flags used when creating a GDBusServer."""

    NONE = 0
    """
    No flags set.
    """
    RUN_IN_THREAD = 1
    """
    All GDBusServer::new-connection
    signals will run in separated dedicated threads (see signal for
    details).
    """
    AUTHENTICATION_ALLOW_ANONYMOUS = 2
    """
    Allow the anonymous
    authentication method.
    """
    AUTHENTICATION_REQUIRE_SAME_USER = 4
    """
    Require the UID of the
    peer to be the same as the UID of the server when authenticating. (Since: 2.68)
    """

class DBusSignalFlags(GObject.GFlags):
    """
    Flags used when subscribing to signals via `g_dbus_connection_signal_subscribe`."""

    NONE = 0
    """
    No flags set.
    """
    NO_MATCH_RULE = 1
    """
    Don't actually send the AddMatch
    D-Bus call for this signal subscription.  This gives you more control
    over which match rules you add (but you must add them manually).
    """
    MATCH_ARG0_NAMESPACE = 2
    """
    Match first arguments that
    contain a bus or interface name with the given namespace.
    """
    MATCH_ARG0_PATH = 4
    """
    Match first arguments that
    contain an object path that is either equivalent to the given path,
    or one of the paths is a subpath of the other.
    """

class DBusSubtreeFlags(GObject.GFlags):
    """
    Flags passed to `g_dbus_connection_register_subtree`."""

    NONE = 0
    """
    No flags set.
    """
    DISPATCH_TO_UNENUMERATED_NODES = 1
    """
    Method calls to objects not in the enumerated range
                                                          will still be dispatched. This is useful if you want
                                                          to dynamically spawn objects in the subtree.
    """

class DataStreamByteOrder(GObject.GEnum):
    """
    GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
    across various machine architectures."""

    BIG_ENDIAN = 0
    """
    Selects Big Endian byte order.
    """
    LITTLE_ENDIAN = 1
    """
    Selects Little Endian byte order.
    """
    HOST_ENDIAN = 2
    """
    Selects endianness based on host machine's architecture.
    """

class DataStreamNewlineType(GObject.GEnum):
    """
    GDataStreamNewlineType is used when checking for or setting the line endings for a given file."""

    LF = 0
    """
    Selects "LF" line endings, common on most modern UNIX platforms.
    """
    CR = 1
    """
    Selects "CR" line endings.
    """
    CR_LF = 2
    """
    Selects "CR, LF" line ending, common on Microsoft Windows.
    """
    ANY = 3
    """
    Automatically try to handle any line ending type.
    """

class DriveStartFlags(GObject.GFlags):
    """
    Flags used when starting a drive."""

    NONE = 0
    """
    No flags set.
    """

class DriveStartStopType(GObject.GEnum):
    """
    Enumeration describing how a drive can be started/stopped."""

    UNKNOWN = 0
    """
    Unknown or drive doesn't support
       start/stop.
    """
    SHUTDOWN = 1
    """
    The stop method will physically
       shut down the drive and e.g. power down the port the drive is
       attached to.
    """
    NETWORK = 2
    """
    The start/stop methods are used
       for connecting/disconnect to the drive over the network.
    """
    MULTIDISK = 3
    """
    The start/stop methods will
       assemble/disassemble a virtual drive from several physical
       drives.
    """
    PASSWORD = 4
    """
    The start/stop methods will
       unlock/lock the disk (for example using the ATA `SECURITY UNLOCK
       DEVICE` command)
    """

class EmblemOrigin(GObject.GEnum):
    """
    GEmblemOrigin is used to add information about the origin of the emblem
    to GEmblem."""

    UNKNOWN = 0
    """
    Emblem of unknown origin
    """
    DEVICE = 1
    """
    Emblem adds device-specific information
    """
    LIVEMETADATA = 2
    """
    Emblem depicts live metadata, such as "readonly"
    """
    TAG = 3
    """
    Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
    """

class FileAttributeInfoFlags(GObject.GFlags):
    """
    Flags specifying the behaviour of an attribute."""

    NONE = 0
    """
    no flags set.
    """
    COPY_WITH_FILE = 1
    """
    copy the attribute values when the file is copied.
    """
    COPY_WHEN_MOVED = 2
    """
    copy the attribute values when the file is moved.
    """

class FileAttributeStatus(GObject.GEnum):
    """
    Used by `g_file_set_attributes_from_info` when setting file attributes."""

    UNSET = 0
    """
    Attribute value is unset (empty).
    """
    SET = 1
    """
    Attribute value is set.
    """
    ERROR_SETTING = 2
    """
    Indicates an error in setting the value.
    """

class FileAttributeType(GObject.GEnum):
    """
    The data types for file attributes."""

    INVALID = 0
    """
    indicates an invalid or uninitialized type.
    """
    STRING = 1
    """
    a null terminated UTF8 string.
    """
    BYTE_STRING = 2
    """
    a zero terminated string of non-zero bytes.
    """
    BOOLEAN = 3
    """
    a boolean value.
    """
    UINT32 = 4
    """
    an unsigned 4-byte/32-bit integer.
    """
    INT32 = 5
    """
    a signed 4-byte/32-bit integer.
    """
    UINT64 = 6
    """
    an unsigned 8-byte/64-bit integer.
    """
    INT64 = 7
    """
    a signed 8-byte/64-bit integer.
    """
    OBJECT = 8
    """
    a GObject.
    """
    STRINGV = 9
    """
    a None terminated char **. Since 2.22
    """

class FileCopyFlags(GObject.GFlags):
    """
    Flags used when copying or moving files."""

    NONE = 0
    """
    No flags set.
    """
    OVERWRITE = 1
    """
    Overwrite any existing files
    """
    BACKUP = 2
    """
    Make a backup of any existing files.
    """
    NOFOLLOW_SYMLINKS = 4
    """
    Don't follow symlinks.
    """
    ALL_METADATA = 8
    """
    Copy all file metadata instead of just default set used for copy (see GFileInfo).
    """
    NO_FALLBACK_FOR_MOVE = 16
    """
    Don't use copy and delete fallback if native move not supported.
    """
    TARGET_DEFAULT_PERMS = 32
    """
    Leaves target file with default perms, instead of setting the source file perms.
    """
    TARGET_DEFAULT_MODIFIED_TIME = 64
    """
    Use default modification
        timestamps instead of copying them from the source file. Since 2.80
    """

class FileCreateFlags(GObject.GFlags):
    """
    Flags used when an operation may create a file."""

    NONE = 0
    """
    No flags set.
    """
    PRIVATE = 1
    """
    Create a file that can only be
       accessed by the current user.
    """
    REPLACE_DESTINATION = 2
    """
    Replace the destination
       as if it didn't exist before. Don't try to keep any old
       permissions, replace instead of following links. This
       is generally useful if you're doing a "copy over"
       rather than a "save new version of" replace operation.
       You can think of it as "unlink destination" before
       writing to it, although the implementation may not
       be exactly like that. This flag can only be used with
       `g_file_replace` and its variants, including `g_file_replace_contents`.
       Since 2.20
    """

class FileMeasureFlags(GObject.GFlags):
    """
    Flags that can be used with `g_file_measure_disk_usage`."""

    NONE = 0
    """
    No flags set.
    """
    REPORT_ANY_ERROR = 2
    """
    Report any error encountered
      while traversing the directory tree.  Normally errors are only
      reported for the toplevel file.
    """
    APPARENT_SIZE = 4
    """
    Tally usage based on apparent file
      sizes.  Normally, the block-size is used, if available, as this is a
      more accurate representation of disk space used.
      Compare with `du --apparent-size`.
      Since GLib 2.78. and similarly to `du` since GNU Coreutils 9.2, this will
      ignore the sizes of file types other than regular files and links, as the
      sizes of other file types are not specified in a standard way.
    """
    NO_XDEV = 8
    """
    Do not cross mount point boundaries.
      Compare with `du -x`.
    """

class FileMonitorEvent(GObject.GEnum):
    """
    Specifies what type of event a monitor event is."""

    CHANGED = 0
    """
    a file changed.
    """
    CHANGES_DONE_HINT = 1
    """
    a hint that this was probably the last change in a set of changes.
    """
    DELETED = 2
    """
    a file was deleted.
    """
    CREATED = 3
    """
    a file was created.
    """
    ATTRIBUTE_CHANGED = 4
    """
    a file attribute was changed.
    """
    PRE_UNMOUNT = 5
    """
    the file location will soon be unmounted.
    """
    UNMOUNTED = 6
    """
    the file location was unmounted.
    """
    MOVED = 7
    """
    the file was moved -- only sent if the
      (deprecated) G_FILE_MONITOR_SEND_MOVED flag is set
    """
    RENAMED = 8
    """
    the file was renamed within the
      current directory -- only sent if the G_FILE_MONITOR_WATCH_MOVES
      flag is set.  Since: 2.46.
    """
    MOVED_IN = 9
    """
    the file was moved into the
      monitored directory from another location -- only sent if the
      G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
    """
    MOVED_OUT = 10
    """
    the file was moved out of the
      monitored directory to another location -- only sent if the
      G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
    """

class FileMonitorFlags(GObject.GFlags):
    """
    Flags used to set what a GFileMonitor will watch for."""

    NONE = 0
    """
    No flags set.
    """
    WATCH_MOUNTS = 1
    """
    Watch for mount events.
    """
    SEND_MOVED = 2
    """
    Pair DELETED and CREATED events caused
      by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
      event instead (NB: not supported on all backends; the default
      behaviour -without specifying this flag- is to send single DELETED
      and CREATED events).  Deprecated since 2.46: use
      G_FILE_MONITOR_WATCH_MOVES instead.
    """
    WATCH_HARD_LINKS = 4
    """
    Watch for changes to the file made
      via another hard link. Since 2.36.
    """
    WATCH_MOVES = 8
    """
    Watch for rename operations on a
      monitored directory.  This causes G_FILE_MONITOR_EVENT_RENAMED,
      G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT
      events to be emitted when possible.  Since: 2.46.
    """

class FileQueryInfoFlags(GObject.GFlags):
    """
    Flags used when querying a GFileInfo."""

    NONE = 0
    """
    No flags set.
    """
    NOFOLLOW_SYMLINKS = 1
    """
    Don't follow symlinks.
    """

class FileType(GObject.GEnum):
    """
    Indicates the file's on-disk type.

    On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type;
    use GFileInfo and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
    whether a file is a symlink or not. This is due to the fact that NTFS does
    not have a single filesystem object type for symbolic links - it has
    files that symlink to files, and directories that symlink to directories.
    GFileType enumeration cannot precisely represent this important distinction,
    which is why all Windows symlinks will continue to be reported as
    G_FILE_TYPE_REGULAR or G_FILE_TYPE_DIRECTORY."""

    UNKNOWN = 0
    """
    File's type is unknown.
    """
    REGULAR = 1
    """
    File handle represents a regular file.
    """
    DIRECTORY = 2
    """
    File handle represents a directory.
    """
    SYMBOLIC_LINK = 3
    """
    File handle represents a symbolic link
       (Unix systems).
    """
    SPECIAL = 4
    """
    File is a "special" file, such as a socket, fifo,
       block device, or character device.
    """
    SHORTCUT = 5
    """
    File is a shortcut (Windows systems).
    """
    MOUNTABLE = 6
    """
    File is a mountable location.
    """

class FilesystemPreviewType(GObject.GEnum):
    """
    Indicates a hint from the file system whether files should be
    previewed in a file manager. Returned as the value of the key
    G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW."""

    IF_ALWAYS = 0
    """
    Only preview files if user has explicitly requested it.
    """
    IF_LOCAL = 1
    """
    Preview files if user has requested preview of "local" files.
    """
    NEVER = 2
    """
    Never preview files.
    """

class IOErrorEnum(GObject.GEnum):
    """
    Error codes returned by GIO functions.

    Note that this domain may be extended in future GLib releases. In
    general, new error codes either only apply to new APIs, or else
    replace G_IO_ERROR_FAILED in cases that were not explicitly
    distinguished before. You should therefore avoid writing code like
    |[<!-- language="C" -->
    if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
      {
        // Assume that this is EPRINTERONFIRE
        ...
      }
    ]|
    but should instead treat all unrecognized error codes the same as
    G_IO_ERROR_FAILED.

    See also GPollableReturn for a cheaper way of returning
    G_IO_ERROR_WOULD_BLOCK to callers without allocating a GError."""

    FAILED = 0
    """
    Generic error condition for when an operation fails
        and no more specific GIOErrorEnum value is defined.
    """
    NOT_FOUND = 1
    """
    File not found.
    """
    EXISTS = 2
    """
    File already exists.
    """
    IS_DIRECTORY = 3
    """
    File is a directory.
    """
    NOT_DIRECTORY = 4
    """
    File is not a directory.
    """
    NOT_EMPTY = 5
    """
    File is a directory that isn't empty.
    """
    NOT_REGULAR_FILE = 6
    """
    File is not a regular file.
    """
    NOT_SYMBOLIC_LINK = 7
    """
    File is not a symbolic link.
    """
    NOT_MOUNTABLE_FILE = 8
    """
    File cannot be mounted.
    """
    FILENAME_TOO_LONG = 9
    """
    Filename is too many characters.
    """
    INVALID_FILENAME = 10
    """
    Filename is invalid or contains invalid characters.
    """
    TOO_MANY_LINKS = 11
    """
    File contains too many symbolic links.
    """
    NO_SPACE = 12
    """
    No space left on drive.
    """
    INVALID_ARGUMENT = 13
    """
    Invalid argument.
    """
    PERMISSION_DENIED = 14
    """
    Permission denied.
    """
    NOT_SUPPORTED = 15
    """
    Operation (or one of its parameters) not supported
    """
    NOT_MOUNTED = 16
    """
    File isn't mounted.
    """
    ALREADY_MOUNTED = 17
    """
    File is already mounted.
    """
    CLOSED = 18
    """
    File was closed.
    """
    CANCELLED = 19
    """
    Operation was cancelled. See GCancellable.
    """
    PENDING = 20
    """
    Operations are still pending.
    """
    READ_ONLY = 21
    """
    File is read only.
    """
    CANT_CREATE_BACKUP = 22
    """
    Backup couldn't be created.
    """
    WRONG_ETAG = 23
    """
    File's Entity Tag was incorrect.
    """
    TIMED_OUT = 24
    """
    Operation timed out.
    """
    WOULD_RECURSE = 25
    """
    Operation would be recursive.
    """
    BUSY = 26
    """
    File is busy.
    """
    WOULD_BLOCK = 27
    """
    Operation would block.
    """
    HOST_NOT_FOUND = 28
    """
    Host couldn't be found (remote operations).
    """
    WOULD_MERGE = 29
    """
    Operation would merge files.
    """
    FAILED_HANDLED = 30
    """
    Operation failed and a helper program has
        already interacted with the user. Do not display any error dialog.
    """
    TOO_MANY_OPEN_FILES = 31
    """
    The current process has too many files
        open and can't open any more. Duplicate descriptors do count toward
        this limit. Since 2.20
    """
    NOT_INITIALIZED = 32
    """
    The object has not been initialized. Since 2.22
    """
    ADDRESS_IN_USE = 33
    """
    The requested address is already in use. Since 2.22
    """
    PARTIAL_INPUT = 34
    """
    Need more input to finish operation. Since 2.24
    """
    INVALID_DATA = 35
    """
    The input data was invalid. Since 2.24
    """
    DBUS_ERROR = 36
    """
    A remote object generated an error that
        doesn't correspond to a locally registered GError error
        domain. Use `g_dbus_error_get_remote_error` to extract the D-Bus
        error name and `g_dbus_error_strip_remote_error` to fix up the
        message so it matches what was received on the wire. Since 2.26.
    """
    HOST_UNREACHABLE = 37
    """
    Host unreachable. Since 2.26
    """
    NETWORK_UNREACHABLE = 38
    """
    Network unreachable. Since 2.26
    """
    CONNECTION_REFUSED = 39
    """
    Connection refused. Since 2.26
    """
    PROXY_FAILED = 40
    """
    Connection to proxy server failed. Since 2.26
    """
    PROXY_AUTH_FAILED = 41
    """
    Proxy authentication failed. Since 2.26
    """
    PROXY_NEED_AUTH = 42
    """
    Proxy server needs authentication. Since 2.26
    """
    PROXY_NOT_ALLOWED = 43
    """
    Proxy connection is not allowed by ruleset.
        Since 2.26
    """
    BROKEN_PIPE = 44
    """
    Broken pipe. Since 2.36
    """
    CONNECTION_CLOSED = 44
    """
    Connection closed by peer. Note that this
        is the same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some
        "connection closed" errors returned G_IO_ERROR_BROKEN_PIPE, but others
        returned G_IO_ERROR_FAILED. Now they should all return the same
        value, which has this more logical name. Since 2.44.
    """
    NOT_CONNECTED = 45
    """
    Transport endpoint is not connected. Since 2.44
    """
    MESSAGE_TOO_LARGE = 46
    """
    Message too large. Since 2.48.
    """
    NO_SUCH_DEVICE = 47
    """
    No such device found. Since 2.74
    """
    DESTINATION_UNSET = 48
    """
    Destination address unset. Since 2.80
    """

class IOModuleScopeFlags(GObject.GEnum):
    """
    Flags for use with `g_io_module_scope_new`."""

    NONE = 0
    """
    No module scan flags
    """
    BLOCK_DUPLICATES = 1
    """
    When using this scope to load or
        scan modules, automatically block a modules which has the same base
        basename as previously loaded module.
    """

class IOStreamSpliceFlags(GObject.GFlags):
    """
    GIOStreamSpliceFlags determine how streams should be spliced."""

    NONE = 0
    """
    Do not close either stream.
    """
    CLOSE_STREAM1 = 1
    """
    Close the first stream after
        the splice.
    """
    CLOSE_STREAM2 = 2
    """
    Close the second stream after
        the splice.
    """
    WAIT_FOR_BOTH = 4
    """
    Wait for both splice operations to finish
        before calling the callback.
    """

class MemoryMonitorWarningLevel(GObject.GEnum):
    """
    Memory availability warning levels.

    Note that because new values might be added, it is recommended that applications check
    GMemoryMonitorWarningLevel as ranges, for example:
    |[<!-- language="C" -->
    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
      drop_caches ();
    ]|"""

    LOW = 50
    """
    Memory on the device is low, processes
      should free up unneeded resources (for example, in-memory caches) so they can
      be used elsewhere.
    """
    MEDIUM = 100
    """
    Same as `G_MEMORY_MONITOR_WARNING_LEVEL_LOW`
      but the device has even less free memory, so processes should try harder to free
      up unneeded resources. If your process does not need to stay running, it is a
      good time for it to quit.
    """
    CRITICAL = 255
    """
    The system will soon start terminating
      processes to reclaim memory, including background processes.
    """

class MountMountFlags(GObject.GFlags):
    """
    Flags used when mounting a mount."""

    NONE = 0
    """
    No flags set.
    """

class MountOperationResult(GObject.GEnum):
    """
    GMountOperationResult is returned as a result when a request for
    information is send by the mounting operation."""

    HANDLED = 0
    """
    The request was fulfilled and the
        user specified data is now available
    """
    ABORTED = 1
    """
    The user requested the mount operation
        to be aborted
    """
    UNHANDLED = 2
    """
    The request was unhandled (i.e. not
        implemented)
    """

class MountUnmountFlags(GObject.GFlags):
    """
    Flags used when an unmounting a mount."""

    NONE = 0
    """
    No flags set.
    """
    FORCE = 1
    """
    Unmount even if there are outstanding
     file operations on the mount.
    """

class NetworkConnectivity(GObject.GEnum):
    """
    The host's network connectivity state, as reported by GNetworkMonitor."""

    LOCAL = 1
    """
    The host is not configured with a
      route to the Internet; it may or may not be connected to a local
      network.
    """
    LIMITED = 2
    """
    The host is connected to a network, but
      does not appear to be able to reach the full Internet, perhaps
      due to upstream network problems.
    """
    PORTAL = 3
    """
    The host is behind a captive portal and
      cannot reach the full Internet.
    """
    FULL = 4
    """
    The host is connected to a network, and
      appears to be able to reach the full Internet.
    """

class NotificationPriority(GObject.GEnum):
    """
    Priority levels for GNotifications."""

    NORMAL = 0
    """
    the default priority, to be used for the
      majority of notifications (for example email messages, software updates,
      completed download/sync operations)
    """
    LOW = 1
    """
    for notifications that do not require
      immediate attention - typically used for contextual background
      information, such as contact birthdays or local weather
    """
    HIGH = 2
    """
    for events that require more attention,
      usually because responses are time-sensitive (for example chat and SMS
      messages or alarms)
    """
    URGENT = 3
    """
    for urgent notifications, or notifications
      that require a response in a short space of time (for example phone calls
      or emergency warnings)
    """

class OutputStreamSpliceFlags(GObject.GFlags):
    """
    GOutputStreamSpliceFlags determine how streams should be spliced."""

    NONE = 0
    """
    Do not close either stream.
    """
    CLOSE_SOURCE = 1
    """
    Close the source stream after
        the splice.
    """
    CLOSE_TARGET = 2
    """
    Close the target stream after
        the splice.
    """

class PasswordSave(GObject.GEnum):
    """
    GPasswordSave is used to indicate the lifespan of a saved password.

    Gvfs stores passwords in the Gnome keyring when this flag allows it
    to, and later retrieves it again from there."""

    NEVER = 0
    """
    never save a password.
    """
    FOR_SESSION = 1
    """
    save a password for the session.
    """
    PERMANENTLY = 2
    """
    save a password permanently.
    """

class PollableReturn(GObject.GEnum):
    """
    Return value for various IO operations that signal errors via the
    return value and not necessarily via a GError.

    This enum exists to be able to return errors to callers without having to
    allocate a GError. Allocating GErrors can be quite expensive for
    regularly happening errors like G_IO_ERROR_WOULD_BLOCK.

    In case of G_POLLABLE_RETURN_FAILED a GError should be set for the
    operation to give details about the error that happened."""

    FAILED = 0
    """
    Generic error condition for when an operation fails.
    """
    OK = 1
    """
    The operation was successfully finished.
    """
    WOULD_BLOCK = -27
    """
    The operation would block.
    """

class ResolverError(GObject.GEnum):
    """
    An error code used with G_RESOLVER_ERROR in a GError returned
    from a GResolver routine."""

    NOT_FOUND = 0
    """
    the requested name/address/service was not
        found
    """
    TEMPORARY_FAILURE = 1
    """
    the requested information could not
        be looked up due to a network error or similar problem
    """
    INTERNAL = 2
    """
    unknown error
    """

class ResolverNameLookupFlags(GObject.GFlags):
    """
    Flags to modify lookup behavior."""

    DEFAULT = 0
    """
    default behavior (same as `g_resolver_lookup_by_name`)
    """
    IPV4_ONLY = 1
    """
    only resolve ipv4 addresses
    """
    IPV6_ONLY = 2
    """
    only resolve ipv6 addresses
    """

class ResolverRecordType(GObject.GEnum):
    """
    The type of record that `g_resolver_lookup_records` or
    `g_resolver_lookup_records_async` should retrieve. The records are returned
    as lists of GVariant tuples. Each record type has different values in
    the variant tuples returned.

    G_RESOLVER_RECORD_SRV records are returned as variants with the signature
    `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
    weight, a `guint16` with the port, and a string of the hostname.

    G_RESOLVER_RECORD_MX records are returned as variants with the signature
    `(qs)`, representing a `guint16` with the preference, and a string containing
    the mail exchanger hostname.

    G_RESOLVER_RECORD_TXT records are returned as variants with the signature
    `(as)`, representing an array of the strings in the text record. Note: Most TXT
    records only contain a single string, but
    [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
    record to contain multiple strings. The RFC which defines the interpretation
    of a specific TXT record will likely require concatenation of multiple
    strings if they are present, as with
    [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).

    G_RESOLVER_RECORD_SOA records are returned as variants with the signature
    `(ssuuuuu)`, representing a string containing the primary name server, a
    string containing the administrator, the serial as a `guint32`, the refresh
    interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
    as a `guint32`, and the TTL as a `guint32`.

    G_RESOLVER_RECORD_NS records are returned as variants with the signature
    `(s)`, representing a string of the hostname of the name server."""

    SRV = 1
    """
    look up DNS SRV records for a domain
    """
    MX = 2
    """
    look up DNS MX records for a domain
    """
    TXT = 3
    """
    look up DNS TXT records for a name
    """
    SOA = 4
    """
    look up DNS SOA records for a zone
    """
    NS = 5
    """
    look up DNS NS records for a domain
    """

class ResourceError(GObject.GEnum):
    """
    An error code used with G_RESOURCE_ERROR in a GError returned
    from a GResource routine."""

    NOT_FOUND = 0
    """
    no file was found at the requested path
    """
    INTERNAL = 1
    """
    unknown error
    """

class ResourceFlags(GObject.GFlags):
    """
    GResourceFlags give information about a particular file inside a resource
    bundle."""

    NONE = 0
    """
    No flags set.
    """
    COMPRESSED = 1
    """
    The file is compressed.
    """

class ResourceLookupFlags(GObject.GFlags):
    """
    GResourceLookupFlags determine how resource path lookups are handled."""

    NONE = 0
    """
    No flags set.
    """

class SettingsBindFlags(GObject.GFlags):
    """
    Flags used when creating a binding.

    These flags determine in which direction the binding works. The default is to
    synchronize in both directions."""

    DEFAULT = 0
    """
    Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
    """
    GET = 1
    """
    Update the [class`GObject`.Object] property when the setting changes.
      It is an error to use this flag if the property is not writable.
    """
    SET = 2
    """
    Update the setting when the [class`GObject`.Object] property changes.
      It is an error to use this flag if the property is not readable.
    """
    NO_SENSITIVITY = 4
    """
    Do not try to bind a ‘sensitivity’ property to the writability of the setting
    """
    GET_NO_CHANGES = 8
    """
    When set in addition to [flags`Gio`.SettingsBindFlags.GET],
      set the [class`GObject`.Object] property
      value initially from the setting, but do not listen for changes of the setting
    """
    INVERT_BOOLEAN = 16
    """
    When passed to [method`Gio`.Settings.bind],
      uses a pair of mapping functions that invert
      the boolean value when mapping between the setting and the property.  The setting and property must both
      be booleans.  You cannot pass this flag to [method`Gio`.Settings.bind_with_mapping].
    """

class SocketClientEvent(GObject.GEnum):
    """
    Describes an event occurring on a GSocketClient. See the
    GSocketClient::event signal for more details.

    Additional values may be added to this type in the future."""

    RESOLVING = 0
    """
    The client is doing a DNS lookup.
    """
    RESOLVED = 1
    """
    The client has completed a DNS lookup.
    """
    CONNECTING = 2
    """
    The client is connecting to a remote
      host (either a proxy or the destination server).
    """
    CONNECTED = 3
    """
    The client has connected to a remote
      host.
    """
    PROXY_NEGOTIATING = 4
    """
    The client is negotiating
      with a proxy to connect to the destination server.
    """
    PROXY_NEGOTIATED = 5
    """
    The client has negotiated
      with the proxy server.
    """
    TLS_HANDSHAKING = 6
    """
    The client is performing a
      TLS handshake.
    """
    TLS_HANDSHAKED = 7
    """
    The client has performed a
      TLS handshake.
    """
    COMPLETE = 8
    """
    The client is done with a particular
      GSocketConnectable.
    """

class SocketFamily(GObject.GEnum):
    """
    The protocol family of a GSocketAddress. (These values are
    identical to the system defines AF_INET, AF_INET6 and AF_UNIX,
    if available.)"""

    INVALID = 0
    """
    no address family
    """
    UNIX = 1
    """
    the UNIX domain family
    """
    IPV4 = 2
    """
    the IPv4 family
    """
    IPV6 = 10
    """
    the IPv6 family
    """

class SocketListenerEvent(GObject.GEnum):
    """
    Describes an event occurring on a GSocketListener. See the
    GSocketListener::event signal for more details.

    Additional values may be added to this type in the future."""

    BINDING = 0
    """
    The listener is about to bind a socket.
    """
    BOUND = 1
    """
    The listener has bound a socket.
    """
    LISTENING = 2
    """
    The listener is about to start
       listening on this socket.
    """
    LISTENED = 3
    """
    The listener is now listening on
      this socket.
    """

class SocketMsgFlags(GObject.GFlags):
    """
    Flags used in `g_socket_receive_message` and `g_socket_send_message`.
    The flags listed in the enum are some commonly available flags, but the
    values used for them are the same as on the platform, and any other flags
    are passed in/out as is. So to use a platform specific flag, just include
    the right system header and pass in the flag."""

    NONE = 0
    """
    No flags.
    """
    OOB = 1
    """
    Request to send/receive out of band data.
    """
    PEEK = 2
    """
    Read data from the socket without removing it from
        the queue.
    """
    DONTROUTE = 4
    """
    Don't use a gateway to send out the packet,
        only send to hosts on directly connected networks.
    """

class SocketProtocol(GObject.GEnum):
    """
    A protocol identifier is specified when creating a GSocket, which is a
    family/type specific identifier, where 0 means the default protocol for
    the particular family/type.

    This enum contains a set of commonly available and used protocols. You
    can also pass any other identifiers handled by the platform in order to
    use protocols not listed here."""

    UNKNOWN = -1
    """
    The protocol type is unknown
    """
    DEFAULT = 0
    """
    The default protocol for the family/type
    """
    TCP = 6
    """
    TCP over IP
    """
    UDP = 17
    """
    UDP over IP
    """
    SCTP = 132
    """
    SCTP over IP
    """

class SocketType(GObject.GEnum):
    """
    Flags used when creating a GSocket. Some protocols may not implement
    all the socket types."""

    INVALID = 0
    """
    Type unknown or wrong
    """
    STREAM = 1
    """
    Reliable connection-based byte streams (e.g. TCP).
    """
    DATAGRAM = 2
    """
    Connectionless, unreliable datagram passing.
        (e.g. UDP)
    """
    SEQPACKET = 3
    """
    Reliable connection-based passing of datagrams
        of fixed maximum length (e.g. SCTP).
    """

class SubprocessFlags(GObject.GFlags):
    """
    Flags to define the behaviour of a GSubprocess.

    Note that the default for stdin is to redirect from `/dev/null`.  For
    stdout and stderr the default are for them to inherit the
    corresponding descriptor from the calling process.

    Note that it is a programmer error to mix 'incompatible' flags.  For
    example, you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
    G_SUBPROCESS_FLAGS_STDOUT_SILENCE."""

    NONE = 0
    """
    No flags.
    """
    STDIN_PIPE = 1
    """
    create a pipe for the stdin of the
      spawned process that can be accessed with
      `g_subprocess_get_stdin_pipe`.
    """
    STDIN_INHERIT = 2
    """
    stdin is inherited from the
      calling process.
    """
    STDOUT_PIPE = 4
    """
    create a pipe for the stdout of the
      spawned process that can be accessed with
      `g_subprocess_get_stdout_pipe`.
    """
    STDOUT_SILENCE = 8
    """
    silence the stdout of the spawned
      process (ie: redirect to `/dev/null`).
    """
    STDERR_PIPE = 16
    """
    create a pipe for the stderr of the
      spawned process that can be accessed with
      `g_subprocess_get_stderr_pipe`.
    """
    STDERR_SILENCE = 32
    """
    silence the stderr of the spawned
      process (ie: redirect to `/dev/null`).
    """
    STDERR_MERGE = 64
    """
    merge the stderr of the spawned
      process with whatever the stdout happens to be.  This is a good way
      of directing both streams to a common log file, for example.
    """
    INHERIT_FDS = 128
    """
    spawned processes will inherit the
      file descriptors of their parent, unless those descriptors have
      been explicitly marked as close-on-exec.  This flag has no effect
      over the "standard" file descriptors (stdin, stdout, stderr).
    """
    SEARCH_PATH_FROM_ENVP = 256
    """
    if path searching is
      needed when spawning the subprocess, use the `PATH` in the launcher
      environment. (Since: 2.72)
    """

class TestDBusFlags(GObject.GFlags):
    """
    Flags to define future GTestDBus behaviour."""

    NONE = 0
    """
    No flags.
    """

class TlsAuthenticationMode(GObject.GEnum):
    """
    The client authentication mode for a GTlsServerConnection."""

    NONE = 0
    """
    client authentication not required
    """
    REQUESTED = 1
    """
    client authentication is requested
    """
    REQUIRED = 2
    """
    client authentication is required
    """

class TlsCertificateFlags(GObject.GFlags):
    """
    A set of flags describing TLS certification validation. This can be
    used to describe why a particular certificate was rejected (for
    example, in GTlsConnection::accept-certificate).

    GLib guarantees that if certificate verification fails, at least one
    flag will be set, but it does not guarantee that all possible flags
    will be set. Accordingly, you may not safely decide to ignore any
    particular type of error. For example, it would be incorrect to mask
    G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
    because this could potentially be the only error flag set even if
    other problems exist with the certificate."""

    NO_FLAGS = 0
    """
    No flags set. Since: 2.74
    """
    UNKNOWN_CA = 1
    """
    The signing certificate authority is
      not known.
    """
    BAD_IDENTITY = 2
    """
    The certificate does not match the
      expected identity of the site that it was retrieved from.
    """
    NOT_ACTIVATED = 4
    """
    The certificate's activation time
      is still in the future
    """
    EXPIRED = 8
    """
    The certificate has expired
    """
    REVOKED = 16
    """
    The certificate has been revoked
      according to the GTlsConnection's certificate revocation list.
    """
    INSECURE = 32
    """
    The certificate's algorithm is
      considered insecure.
    """
    GENERIC_ERROR = 64
    """
    Some other error occurred validating
      the certificate
    """
    VALIDATE_ALL = 127
    """
    the combination of all of the above
      flags
    """

class TlsCertificateRequestFlags(GObject.GEnum):
    """
    Flags for `g_tls_interaction_request_certificate`,
    `g_tls_interaction_request_certificate_async`, and
    `g_tls_interaction_invoke_request_certificate`."""

    NONE = 0
    """
    No flags
    """

class TlsChannelBindingError(GObject.GEnum):
    """
    An error code used with G_TLS_CHANNEL_BINDING_ERROR in a GError to
    indicate a TLS channel binding retrieval error."""

    NOT_IMPLEMENTED = 0
    """
    Either entire binding
       retrieval facility or specific binding type is not implemented in the
       TLS backend.
    """
    INVALID_STATE = 1
    """
    The handshake is not yet
       complete on the connection which is a strong requirement for any existing
       binding type.
    """
    NOT_AVAILABLE = 2
    """
    Handshake is complete but
       binding data is not available. That normally indicates the TLS
       implementation failed to provide the binding data. For example, some
       implementations do not provide a peer certificate for resumed connections.
    """
    NOT_SUPPORTED = 3
    """
    Binding type is not supported
       on the current connection. This error could be triggered when requesting
       `tls-server-end-point` binding data for a certificate which has no hash
       function or uses multiple hash functions.
    """
    GENERAL_ERROR = 4
    """
    Any other backend error
       preventing binding data retrieval.
    """

class TlsChannelBindingType(GObject.GEnum):
    """
    The type of TLS channel binding data to retrieve from GTlsConnection
    or GDtlsConnection, as documented by RFC 5929 or RFC 9266. The
    [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
    binding type is not currently implemented."""

    UNIQUE = 0
    """
    [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
       type
    """
    SERVER_END_POINT = 1
    """
    [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
       binding type
    """
    EXPORTER = 2
    """
    [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding
       type. Since: 2.74
    """

class TlsDatabaseLookupFlags(GObject.GEnum):
    """
    Flags for `g_tls_database_lookup_certificate_for_handle`,
    `g_tls_database_lookup_certificate_issuer`,
    and `g_tls_database_lookup_certificates_issued_by`."""

    NONE = 0
    """
    No lookup flags
    """
    KEYPAIR = 1
    """
    Restrict lookup to certificates that have
        a private key.
    """

class TlsDatabaseVerifyFlags(GObject.GFlags):
    """
    Flags for `g_tls_database_verify_chain`."""

    NONE = 0
    """
    No verification flags
    """

class TlsError(GObject.GEnum):
    """
    An error code used with G_TLS_ERROR in a GError returned from a
    TLS-related routine."""

    UNAVAILABLE = 0
    """
    No TLS provider is available
    """
    MISC = 1
    """
    Miscellaneous TLS error
    """
    BAD_CERTIFICATE = 2
    """
    The certificate presented could not
      be parsed or failed validation.
    """
    NOT_TLS = 3
    """
    The TLS handshake failed because the
      peer does not seem to be a TLS server.
    """
    HANDSHAKE = 4
    """
    The TLS handshake failed because the
      peer's certificate was not acceptable.
    """
    CERTIFICATE_REQUIRED = 5
    """
    The TLS handshake failed because
      the server requested a client-side certificate, but none was
      provided. See `g_tls_connection_set_certificate`.
    """
    EOF = 6
    """
    The TLS connection was closed without proper
      notice, which may indicate an attack. See
      `g_tls_connection_set_require_close_notify`.
    """
    INAPPROPRIATE_FALLBACK = 7
    """
    The TLS handshake failed
      because the client sent the fallback SCSV, indicating a protocol
      downgrade attack. Since: 2.60
    """
    BAD_CERTIFICATE_PASSWORD = 8
    """
    The certificate failed
      to load because a password was incorrect. Since: 2.72
    """

class TlsInteractionResult(GObject.GEnum):
    """
    GTlsInteractionResult is returned by various functions in GTlsInteraction
    when finishing an interaction request."""

    UNHANDLED = 0
    """
    The interaction was unhandled (i.e. not
        implemented).
    """
    HANDLED = 1
    """
    The interaction completed, and resulting data
        is available.
    """
    FAILED = 2
    """
    The interaction has failed, or was cancelled.
        and the operation should be aborted.
    """

class TlsPasswordFlags(GObject.GFlags):
    """
    Various flags for the password."""

    NONE = 0
    """
    No flags
    """
    RETRY = 2
    """
    The password was wrong, and the user should retry.
    """
    MANY_TRIES = 4
    """
    Hint to the user that the password has been
       wrong many times, and the user may not have many chances left.
    """
    FINAL_TRY = 8
    """
    Hint to the user that this is the last try to get
       this password right.
    """
    PKCS11_USER = 16
    """
    For PKCS #11, the user PIN is required.
       Since: 2.70.
    """
    PKCS11_SECURITY_OFFICER = 32
    """
    For PKCS #11, the security officer
       PIN is required. Since: 2.70.
    """
    PKCS11_CONTEXT_SPECIFIC = 64
    """
    For PKCS #11, the context-specific
       PIN is required. Since: 2.70.
    """

class TlsProtocolVersion(GObject.GEnum):
    """
    The TLS or DTLS protocol version used by a GTlsConnection or
    GDtlsConnection. The integer values of these versions are sequential
    to ensure newer known protocol versions compare greater than older
    known versions. Any known DTLS protocol version will compare greater
    than any SSL or TLS protocol version. The protocol version may be
    G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
    protocol version that GLib does not yet know about. This means that
    it's possible for an unknown DTLS protocol version to compare less
    than the TLS protocol versions."""

    UNKNOWN = 0
    """
    No protocol version or unknown protocol version
    """
    SSL_3_0 = 1
    """
    SSL 3.0, which is insecure and should not be used
    """
    TLS_1_0 = 2
    """
    TLS 1.0, which is insecure and should not be used
    """
    TLS_1_1 = 3
    """
    TLS 1.1, which is insecure and should not be used
    """
    TLS_1_2 = 4
    """
    TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
    """
    TLS_1_3 = 5
    """
    TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
    """
    DTLS_1_0 = 201
    """
    DTLS 1.0, which is insecure and should not be used
    """
    DTLS_1_2 = 202
    """
    DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
    """

class TlsRehandshakeMode(GObject.GEnum):
    """
    When to allow rehandshaking. See
    `g_tls_connection_set_rehandshake_mode`."""

    NEVER = 0
    """
    Never allow rehandshaking
    """
    SAFELY = 1
    """
    Allow safe rehandshaking only
    """
    UNSAFELY = 2
    """
    Allow unsafe rehandshaking
    """

class UnixSocketAddressType(GObject.GEnum):
    """
    The type of name used by a GUnixSocketAddress.
    G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
    socket bound to a filesystem path. G_UNIX_SOCKET_ADDRESS_ANONYMOUS
    indicates a socket not bound to any name (eg, a client-side socket,
    or a socket created with `socketpair`).

    For abstract sockets, there are two incompatible ways of naming
    them; the man pages suggest using the entire `struct sockaddr_un`
    as the name, padding the unused parts of the %sun_path field with
    zeroes; this corresponds to G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
    However, many programs instead just use a portion of %sun_path, and
    pass an appropriate smaller length to `bind` or `connect`. This is
    G_UNIX_SOCKET_ADDRESS_ABSTRACT."""

    INVALID = 0
    """
    invalid
    """
    ANONYMOUS = 1
    """
    anonymous
    """
    PATH = 2
    """
    a filesystem path
    """
    ABSTRACT = 3
    """
    an abstract name
    """
    ABSTRACT_PADDED = 4
    """
    an abstract name, 0-padded
      to the full length of a unix socket name
    """

class ZlibCompressorFormat(GObject.GEnum):
    """
    Used to select the type of data format to use for GZlibDecompressor
    and GZlibCompressor."""

    ZLIB = 0
    """
    deflate compression with zlib header
    """
    GZIP = 1
    """
    gzip file format
    """
    RAW = 2
    """
    deflate compression with no header
    """

###############################################################
# classes
###############################################################

class Action(GObject.GInterface):
    """
    `GAction` represents a single named action.

    The main interface to an action is that it can be activated with
    [method`Gio`.Action.activate]. This results in the 'activate' signal being
    emitted. An activation has a `GVariant` parameter (which may be
    `None`). The correct type for the parameter is determined by a static
    parameter type (which is given at construction time).

    An action may optionally have a state, in which case the state may be
    set with [method`Gio`.Action.change_state]. This call takes a [type`GLib`.Variant]. The
    correct type for the state is determined by a static state type
    (which is given at construction time).

    The state may have a hint associated with it, specifying its valid
    range.

    `GAction` is merely the interface to the concept of an action, as
    described above.  Various implementations of actions exist, including
    [class`Gio`.SimpleAction].

    In all cases, the implementing class is responsible for storing the
    name of the action, the parameter type, the enabled state, the optional
    state type and the state and emitting the appropriate signals when these
    change. The implementor is responsible for filtering calls to
    [method`Gio`.Action.activate] and [method`Gio`.Action.change_state]
    for type safety and for the state being enabled.

    Probably the only useful thing to do with a `GAction` is to put it
    inside of a [class`Gio`.SimpleActionGroup].
    """

    class Props(GObject.GInterface.Props):
        enabled: bool
        """
        If `action` is currently enabled.

        If the action is disabled then calls to [method`Gio`.Action.activate] and
        [method`Gio`.Action.change_state] have no effect.
        """
        name: str
        """
        The name of the action.  This is mostly meaningful for identifying
        the action once it has been added to a [type`Gio`.ActionGroup]. It is immutable.
        """
        parameter_type: GLib.VariantType | None  # [parameter-type]: changed because contained invalid characters
        """
        The type of the parameter that must be given when activating the
        action. This is immutable, and may be `None` if no parameter is needed when
        activating the action.
        """
        state: GLib.Variant | None
        """
        The state of the action, or `None` if the action is stateless.
        """
        state_type: GLib.VariantType | None  # [state-type]: changed because contained invalid characters
        """
        The [type`GLib`.VariantType] of the state that the action has, or `None` if the
        action is stateless. This is immutable.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def activate(self, parameter: GLib.Variant | None = None) -> None:
        """
            Activates the action.

        `parameter` must be the correct type of parameter for the action (ie:
        the parameter type given at construction time).  If the parameter
        type was `None` then `parameter` must also be `None`.

        If the `parameter` [type`GLib`.Variant] is floating, it is consumed.
        """
    def change_state(self, value: GLib.Variant) -> None:
        """
            Request for the state of `action` to be changed to `value`.

        The action must be stateful and `value` must be of the correct type.
        See [method`Gio`.Action.get_state_type].

        This call merely requests a change.  The action may refuse to change
        its state or may change its state to something other than `value`.
        See [method`Gio`.Action.get_state_hint].

        If the `value` [type`GLib`.Variant] is floating, it is consumed.
        """
    @builtins.property
    def get_enabled(self) -> bool:
        """
            Checks if `action` is currently enabled.

        An action must be enabled in order to be activated or in order to
        have its state changed from outside callers.
        """
    @builtins.property
    def get_name(self) -> str:
        """
        Queries the name of `action`.
        """
    @builtins.property
    def get_parameter_type(self) -> GLib.VariantType | None:
        """
            Queries the type of the parameter that must be given when activating
        `action`.

        When activating the action using [method`Gio`.Action.activate], the
        [type`GLib`.Variant] given to that function must be of the type returned by
        this function.

        In the case that this function returns `None`, you must not give any
        [type`GLib`.Variant], but `None` instead.
        """
    @builtins.property
    def get_state(self) -> GLib.Variant | None:
        """
            Queries the current state of `action`.

        If the action is not stateful then `None` will be returned.  If the
        action is stateful then the type of the return value is the type
        given by [method`Gio`.Action.get_state_type].

        The return value (if non-`None`) should be freed with
        [method`GLib`.Variant.unref] when it is no longer required.
        """
    def get_state_hint(self) -> GLib.Variant | None:
        """
            Requests a hint about the valid range of values for the state of
        `action`.

        If `None` is returned it either means that the action is not stateful
        or that there is no hint about the valid range of values for the
        state of the action.

        If a [type`GLib`.Variant] array is returned then each item in the array is a
        possible value for the state.  If a [type`GLib`.Variant] pair (ie: two-tuple) is
        returned then the tuple specifies the inclusive lower and upper bound
        of valid values for the state.

        In any case, the information is merely a hint.  It may be possible to
        have a state value outside of the hinted range and setting a value
        within the range may fail.

        The return value (if non-`None`) should be freed with
        [method`GLib`.Variant.unref] when it is no longer required.
        """
    @builtins.property
    def get_state_type(self) -> GLib.VariantType | None:
        """
            Queries the type of the state of `action`.

        If the action is stateful (e.g. created with
        [ctor`Gio`.SimpleAction.new_stateful]) then this function returns the
        [type`GLib`.VariantType] of the state.  This is the type of the initial value
        given as the state. All calls to [method`Gio`.Action.change_state] must give a
        [type`GLib`.Variant] of this type and [method`Gio`.Action.get_state] will return a
        [type`GLib`.Variant] of the same type.

        If the action is not stateful (e.g. created with [ctor`Gio`.SimpleAction.new])
        then this function will return `None`. In that case, [method`Gio`.Action.get_state]
        will return `None` and you must not call [method`Gio`.Action.change_state].
        """
    @staticmethod
    def name_is_valid(action_name: str) -> bool:
        """
            Checks if `action_name` is valid.

        `action_name` is valid if it consists only of alphanumeric characters,
        plus `-` and `.`.  The empty string is not a valid action name.

        It is an error to call this function with a non-UTF-8 `action_name`.
        `action_name` must not be `None`.
        """
    @staticmethod
    def parse_detailed_name(detailed_name: str) -> tuple[bool, str, GLib.Variant | None]:
        """
            Parses a detailed action name into its separate name and target
        components.

        Detailed action names can have three formats.

        The first format is used to represent an action name with no target
        value and consists of just an action name containing no whitespace
        nor the characters `:`, `(` or `)`.  For example: `app.action`.

        The second format is used to represent an action with a target value
        that is a non-empty string consisting only of alphanumerics, plus `-`
        and `.`.  In that case, the action name and target value are
        separated by a double colon (`::`).  For example:
        `app.action::target`.

        The third format is used to represent an action with any type of
        target value, including strings.  The target value follows the action
        name, surrounded in parens.  For example: `app.action(42)`.  The
        target value is parsed using [func`GLib`.Variant.parse].  If a tuple-typed
        value is desired, it must be specified in the same way, resulting in
        two sets of parens, for example: `app.action((1,2,3))`.  A string
        target can be specified this way as well: `app.action('target')`.
        For strings, this third format must be used if target value is
        empty or contains characters other than alphanumerics, `-` and `.`.

        If this function returns `True`, a non-`None` value is guaranteed to be returned
        in `action_name` (if a pointer is passed in). A `None` value may still be
        returned in `target_value`, as the `detailed_name` may not contain a target.

        If returned, the [type`GLib`.Variant] in `target_value` is guaranteed to not be floating.
        """
    @staticmethod
    def print_detailed_name(action_name: str, target_value: GLib.Variant | None = None) -> str:
        """
            Formats a detailed action name from `action_name` and `target_value`.

        It is an error to call this function with an invalid action name.

        This function is the opposite of [func`Gio`.Action.parse_detailed_name].
        It will produce a string that can be parsed back to the `action_name`
        and `target_value` by that function.

        See that function for the types of strings that will be printed by
        this function.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parameter_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ActionEntry(GObject.GPointer):
    """
    This struct defines a single action.  It is for use with
    [method`Gio`.ActionMap.add_action_entries].

    The order of the items in the structure are intended to reflect
    frequency of use.  It is permissible to use an incomplete initialiser
    in order to leave some of the later values as `None`.  All values
    after `name` are optional.  Additional optional fields may be added in
    the future.

    See [method`Gio`.ActionMap.add_action_entries] for an example.
    """

    # gi Fields
    @builtins.property
    def activate(self) -> activateActionEntryCB:
        """
          the callback to connect to the "activate" signal of the action.
        Since GLib 2.40, this can be `None` for stateful actions, in which case
        the default handler is used. For boolean-stated actions with no
        parameter, this is a toggle. For other state types (and parameter type
        equal to the state type) this will be a function that just calls
        `change_state` (which you should provide).
        """
    @builtins.property
    def change_state(self) -> change_stateActionEntryCB:
        """
          the callback to connect to the "change-state" signal of the
        action.  All stateful actions should provide a handler here; stateless
        actions should not.
        """
    name: str = ...
    """
    the name of the action

    """
    @builtins.property
    def padding(self) -> list | None: ...
    parameter_type: str = ...
    """
    the type of the parameter that must be passed to the
      activate function for this action, given as a single GVariant type string
      (or `None` for no parameter)

    """
    state: str = ...
    """
    the initial state for this action, given in
      [GVariant text format](gvariant-text-format.html).  The state is parsed
      with no extra type information, so type tags must be added to the string
      if they are necessary.  Stateless actions should give `None` here.

    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ActionGroup(GObject.GInterface):
    """
    `GActionGroup` represents a group of actions.

    Actions can be used to expose functionality in a structured way, either
    from one part of a program to another, or to the outside world. Action
    groups are often used together with a [type`Gio`.MenuModel] that provides additional
    representation data for displaying the actions to the user, e.g. in a menu.

    The main way to interact with the actions in a `GActionGroup` is to
    activate them with [method`Gio`.ActionGroup.activate_action]. Activating an
    action may require a [type`GLib`.Variant] parameter. The required type of the
    parameter can be inquired with [method`Gio`.ActionGroup.get_action_parameter_type].
    Actions may be disabled, see [method`Gio`.ActionGroup.get_action_enabled].
    Activating a disabled action has no effect.

    Actions may optionally have a state in the form of a [type`GLib`.Variant]. The current
    state of an action can be inquired with [method`Gio`.ActionGroup.get_action_state].
    Activating a stateful action may change its state, but it is also possible to
    set the state by calling [method`Gio`.ActionGroup.change_action_state].

    As typical example, consider a text editing application which has an
    option to change the current font to ‘bold’. A good way to represent
    this would be a stateful action, with a boolean state. Activating the
    action would toggle the state.

    Each action in the group has a unique name (which is a string).  All
    method calls, except [method`Gio`.ActionGroup.list_actions] take the name of
    an action as an argument.

    The `GActionGroup` API is meant to be the ‘public’ API to the action
    group. The calls here are exactly the interaction that ‘external
    forces’ (eg: UI, incoming D-Bus messages, etc.) are supposed to have
    with actions. ‘Internal’ APIs (ie: ones meant only to be accessed by
    the action group implementation) are found on subclasses. This is
    why you will find – for example – [method`Gio`.ActionGroup.get_action_enabled]
    but not an equivalent ``set_action_enabled`` method.

    Signals are emitted on the action group in response to state changes
    on individual actions.

    Implementations of `GActionGroup` should provide implementations for
    the virtual functions [method`Gio`.ActionGroup.list_actions] and
    [method`Gio`.ActionGroup.query_action]. The other virtual functions should
    not be implemented — their ‘wrappers’ are actually implemented with
    calls to [method`Gio`.ActionGroup.query_action].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def action_added(self, action_name: str) -> None:
        """
            Emits the [signal`Gio`.ActionGroup::action-added] signal on `action_group`.

        This function should only be called by [type`Gio`.ActionGroup] implementations.
        """
    def action_enabled_changed(self, action_name: str, enabled: bool) -> None:
        """
            Emits the [signal`Gio`.ActionGroup::action-enabled-changed] signal on `action_group`.

        This function should only be called by [type`Gio`.ActionGroup] implementations.
        """
    def action_removed(self, action_name: str) -> None:
        """
            Emits the [signal`Gio`.ActionGroup::action-removed] signal on `action_group`.

        This function should only be called by [type`Gio`.ActionGroup] implementations.
        """
    def action_state_changed(self, action_name: str, state: GLib.Variant) -> None:
        """
            Emits the [signal`Gio`.ActionGroup::action-state-changed] signal on `action_group`.

        This function should only be called by [type`Gio`.ActionGroup] implementations.
        """
    def activate_action(self, action_name: str, parameter: GLib.Variant | None = None) -> None:
        """
            Activate the named action within `action_group`.

        If the action is expecting a parameter, then the correct type of
        parameter must be given as `parameter`.  If the action is expecting no
        parameters then `parameter` must be `None`.  See
        [method`Gio`.ActionGroup.get_action_parameter_type].

        If the [type`Gio`.ActionGroup] implementation supports asynchronous remote
        activation over D-Bus, this call may return before the relevant
        D-Bus traffic has been sent, or any replies have been received. In
        order to block on such asynchronous activation calls,
        [method`Gio`.DBusConnection.flush] should be called prior to the code, which
        depends on the result of the action activation. Without flushing
        the D-Bus connection, there is no guarantee that the action would
        have been activated.

        The following code which runs in a remote app instance, shows an
        example of a ‘quit’ action being activated on the primary app
        instance over D-Bus. Here [method`Gio`.DBusConnection.flush] is called
        before ``exit``. Without ``g_dbus_connection_flush``, the ‘quit’ action
        may fail to be activated on the primary instance.

        ```c
        // call ‘quit’ action on primary instance
        g_action_group_activate_action (G_ACTION_GROUP (app), "quit", None);

        // make sure the action is activated now
        g_dbus_connection_flush (…);

        g_debug ("Application has been terminated. Exiting.");

        exit (0);
        ```
        """
    def change_action_state(self, action_name: str, value: GLib.Variant) -> None:
        """
            Request for the state of the named action within `action_group` to be
        changed to `value`.

        The action must be stateful and `value` must be of the correct type.
        See [method`Gio`.ActionGroup.get_action_state_type].

        This call merely requests a change.  The action may refuse to change
        its state or may change its state to something other than `value`.
        See [method`Gio`.ActionGroup.get_action_state_hint].

        If the `value` GVariant is floating, it is consumed.
        """
    def get_action_enabled(self, action_name: str) -> bool:
        """
            Checks if the named action within `action_group` is currently enabled.

        An action must be enabled in order to be activated or in order to
        have its state changed from outside callers.
        """
    def get_action_parameter_type(self, action_name: str) -> GLib.VariantType | None:
        """
            Queries the type of the parameter that must be given when activating
        the named action within `action_group`.

        When activating the action using [method`Gio`.ActionGroup.activate_action],
        the [type`GLib`.Variant] given to that function must be of the type returned
        by this function.

        In the case that this function returns `None`, you must not give any
        [type`GLib`.Variant], but `None` instead.

        The parameter type of a particular action will never change but it is
        possible for an action to be removed and for a new action to be added
        with the same name but a different parameter type.
        """
    def get_action_state(self, action_name: str) -> GLib.Variant | None:
        """
            Queries the current state of the named action within `action_group`.

        If the action is not stateful then `None` will be returned.  If the
        action is stateful then the type of the return value is the type
        given by [method`Gio`.ActionGroup.get_action_state_type].

        The return value (if non-`None`) should be freed with
        [method`GLib`.Variant.unref] when it is no longer required.
        """
    def get_action_state_hint(self, action_name: str) -> GLib.Variant | None:
        """
            Requests a hint about the valid range of values for the state of the
        named action within `action_group`.

        If `None` is returned it either means that the action is not stateful
        or that there is no hint about the valid range of values for the
        state of the action.

        If a [type`GLib`.Variant] array is returned then each item in the array is a
        possible value for the state.  If a [type`GLib`.Variant] pair (ie: two-tuple) is
        returned then the tuple specifies the inclusive lower and upper bound
        of valid values for the state.

        In any case, the information is merely a hint.  It may be possible to
        have a state value outside of the hinted range and setting a value
        within the range may fail.

        The return value (if non-`None`) should be freed with
        [method`GLib`.Variant.unref] when it is no longer required.
        """
    def get_action_state_type(self, action_name: str) -> GLib.VariantType | None:
        """
            Queries the type of the state of the named action within
        `action_group`.

        If the action is stateful then this function returns the
        [type`GLib`.VariantType] of the state.  All calls to
        [method`Gio`.ActionGroup.change_action_state] must give a [type`GLib`.Variant] of this
        type and [method`Gio`.ActionGroup.get_action_state] will return a [type`GLib`.Variant]
        of the same type.

        If the action is not stateful then this function will return `None`.
        In that case, [method`Gio`.ActionGroup.get_action_state] will return `None`
        and you must not call [method`Gio`.ActionGroup.change_action_state].

        The state type of a particular action will never change but it is
        possible for an action to be removed and for a new action to be added
        with the same name but a different state type.
        """
    def has_action(self, action_name: str) -> bool:
        """
        Checks if the named action exists within `action_group`.
        """
    def list_actions(self) -> list:
        """
            Lists the actions contained within `action_group`.

        The caller is responsible for freeing the list with [func`GLib`.strfreev] when
        it is no longer required.
        """
    def query_action(
        self, action_name: str
    ) -> tuple[bool, bool, GLib.VariantType, GLib.VariantType, GLib.Variant, GLib.Variant]:
        """
            Queries all aspects of the named action within an `action_group`.

        This function acquires the information available from
        [method`Gio`.ActionGroup.has_action], [method`Gio`.ActionGroup.get_action_enabled],
        [method`Gio`.ActionGroup.get_action_parameter_type],
        [method`Gio`.ActionGroup.get_action_state_type],
        [method`Gio`.ActionGroup.get_action_state_hint] and
        [method`Gio`.ActionGroup.get_action_state] with a single function call.

        This provides two main benefits.

        The first is the improvement in efficiency that comes with not having
        to perform repeated lookups of the action in order to discover
        different things about it.  The second is that implementing
        [type`Gio`.ActionGroup] can now be done by only overriding this one virtual
        function.

        The interface provides a default implementation of this function that
        calls the individual functions, as required, to fetch the
        information.  The interface also provides default implementations of
        those functions that call this function.  All implementations,
        therefore, must override either this function or all of the others.

        If the action exists, `True` is returned and any of the requested
        fields (as indicated by having a non-`None` reference passed in) are
        filled.  If the action doesn’t exist, `False` is returned and the
        fields may or may not have been modified.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["action-added"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int:
        """
            Signals that a new action was just added to the group.

        This signal is emitted after the action has been added
        and is now visible.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["action-enabled-changed"],
        handler: typing.Callable[[typing_extensions.Self, str, bool], None],
        *args: typing.Any,
    ) -> int:
        """
        Signals that the enabled status of the named action has changed.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["action-removed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int:
        """
            Signals that an action is just about to be removed from the group.

        This signal is emitted before the action is removed, so the action
        is still visible and can be queried from the signal handler.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["action-state-changed"],
        handler: typing.Callable[[typing_extensions.Self, str, GLib.Variant], None],
        *args: typing.Any,
    ) -> int:
        """
        Signals that the state of the named action has changed.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ActionGroupInterface(GObject.GPointer):
    """
    The virtual function table for [type`Gio`.ActionGroup].
    """

    # gi Fields
    @builtins.property
    def action_added(self) -> action_addedActionGroupInterfaceCB:
        """
        the class closure for the [signal`Gio`.ActionGroup::action-added] signal
        """
    @builtins.property
    def action_enabled_changed(self) -> action_enabled_changedActionGroupInterfaceCB:
        """
        the class closure for the [signal`Gio`.ActionGroup::action-enabled-changed] signal
        """
    @builtins.property
    def action_removed(self) -> action_removedActionGroupInterfaceCB:
        """
        the class closure for the [signal`Gio`.ActionGroup::action-removed] signal
        """
    @builtins.property
    def action_state_changed(self) -> action_state_changedActionGroupInterfaceCB:
        """
        the class closure for the [signal`Gio`.ActionGroup::action-enabled-changed] signal
        """
    @builtins.property
    def activate_action(self) -> activate_actionActionGroupInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.activate_action]
        """
    @builtins.property
    def change_action_state(self) -> change_action_stateActionGroupInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.change_action_state]
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_action_enabled(self) -> get_action_enabledActionGroupInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.get_action_enabled]
        """
    @builtins.property
    def get_action_parameter_type(self) -> get_action_parameter_typeActionGroupInterfaceCB | None:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.get_action_parameter_type]
        """
    @builtins.property
    def get_action_state(self) -> get_action_stateActionGroupInterfaceCB | None:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.get_action_state]
        """
    @builtins.property
    def get_action_state_hint(self) -> get_action_state_hintActionGroupInterfaceCB | None:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.get_action_state_hint]
        """
    @builtins.property
    def get_action_state_type(self) -> get_action_state_typeActionGroupInterfaceCB | None:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.get_action_state_type]
        """
    @builtins.property
    def has_action(self) -> has_actionActionGroupInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.has_action]
        """
    @builtins.property
    def list_actions(self) -> list_actionsActionGroupInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.list_actions]
        """
    @builtins.property
    def query_action(self) -> query_actionActionGroupInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.ActionGroup.query_action]
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ActionInterface(GObject.GPointer):
    """
    The virtual function table for [type`Gio`.Action].
    """

    # gi Fields
    @builtins.property
    def activate(self) -> activateActionInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.Action.activate].  Note that [type`Gio`.Action] does not have an
               'activate' signal but that implementations of it may have one.
        """
    @builtins.property
    def change_state(self) -> change_stateActionInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.Action.change_state]
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_enabled(self) -> get_enabledActionInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.Action.get_enabled]
        """
    @builtins.property
    def get_name(self) -> get_nameActionInterfaceCB:
        """
        the virtual function pointer for [method`Gio`.Action.get_name]
        """
    @builtins.property
    def get_parameter_type(self) -> get_parameter_typeActionInterfaceCB | None:
        """
        the virtual function pointer for [method`Gio`.Action.get_parameter_type]
        """
    @builtins.property
    def get_state(self) -> get_stateActionInterfaceCB | None:
        """
        the virtual function pointer for [method`Gio`.Action.get_state]
        """
    @builtins.property
    def get_state_hint(self) -> get_state_hintActionInterfaceCB | None:
        """
        the virtual function pointer for [method`Gio`.Action.get_state_hint]
        """
    @builtins.property
    def get_state_type(self) -> get_state_typeActionInterfaceCB | None:
        """
        the virtual function pointer for [method`Gio`.Action.get_state_type]
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ActionMap(GObject.GInterface):
    """
    `GActionMap` is an interface for action containers.

    The `GActionMap` interface is implemented by [iface`Gio`.ActionGroup]
    implementations that operate by containing a number of named
    [iface`Gio`.Action] instances, such as [class`Gio`.SimpleActionGroup].

    One useful application of this interface is to map the
    names of actions from various action groups to unique,
    prefixed names (e.g. by prepending "app." or "win.").
    This is the motivation for the ‘Map’ part of the interface
    name.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_action(self, action: Action) -> None:
        """
            Adds an action to the `action_map`.

        If the action map already contains an action with the same name
        as `action` then the old action is dropped from the action map.

        The action map takes its own reference on `action`.
        """
    def add_action_entries(self, entries: list, n_entries: int, user_data: object | None = None) -> None:
        """
            A convenience function for creating multiple [class`Gio`.SimpleAction]
        instances and adding them to a [iface`Gio`.ActionMap].

        Each action is constructed as per one [struct`Gio`.ActionEntry].

        ```c
        static void
        activate_quit (GSimpleAction *simple,
                       GVariant      *parameter,
                       gpointer       user_data)
        {
          exit (0);
        }

        static void
        activate_print_string (GSimpleAction *simple,
                               GVariant      *parameter,
                               gpointer       user_data)
        {
          g_print ("%s\\n", g_variant_get_string (parameter, None));
        }

        static GActionGroup *
        create_action_group (void)
        {
          const GActionEntry entries[] = {
            { "quit",         activate_quit              },
            { "print-string", activate_print_string, "s" }
          };
          GSimpleActionGroup *group;

          group = g_simple_action_group_new ();
          g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), None);

          return G_ACTION_GROUP (group);
        }
        ```
        """
    def lookup_action(self, action_name: str) -> Action | None:
        """
            Looks up the action with the name `action_name` in `action_map`.

        If no such action exists, returns `None`.
        """
    def remove_action(self, action_name: str) -> None:
        """
            Removes the named action from the action map.

        If no action of this name is in the map then nothing happens.
        """
    def remove_action_entries(self, entries: list, n_entries: int) -> None:
        """
            Remove actions from a [iface`Gio`.ActionMap]. This is meant as the reverse of
        [method`Gio`.ActionMap.add_action_entries].


        ```c
        static const GActionEntry entries[] = {
            { "quit",         activate_quit              },
            { "print-string", activate_print_string, "s" }
        };

        void
        add_actions (GActionMap *map)
        {
          g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), None);
        }

        void
        remove_actions (GActionMap *map)
        {
          g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
        }
        ```
        """

class ActionMapInterface(GObject.GPointer):
    """
    The virtual function table for [iface`Gio`.ActionMap].
    """

    # gi Fields
    @builtins.property
    def add_action(self) -> add_actionActionMapInterfaceCB:
        """
          the virtual function pointer for
        [method`Gio`.ActionMap.add_action]
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def lookup_action(self) -> lookup_actionActionMapInterfaceCB | None:
        """
          the virtual function pointer for
        [method`Gio`.ActionMap.lookup_action]
        """
    @builtins.property
    def remove_action(self) -> remove_actionActionMapInterfaceCB:
        """
          the virtual function pointer for
        [method`Gio`.ActionMap.remove_action]
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AppInfo(GObject.GInterface):
    """
    Information about an installed application and methods to launch
    it (with file arguments).

    `GAppInfo` and `GAppLaunchContext` are used for describing and launching
    applications installed on the system.

    As of GLib 2.20, URIs will always be converted to POSIX paths
    (using [method`Gio`.File.get_path]) when using [method`Gio`.AppInfo.launch]
    even if the application requested an URI and not a POSIX path. For example
    for a desktop-file based application with the following Exec key:

    ```
    Exec=totem U
    ```

    and a single URI, `sftp://foo/file.avi`, then
    `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only work
    if a set of suitable GIO extensions (such as GVfs 2.26 compiled with FUSE
    support), is available and operational; if this is not the case, the URI
    will be passed unmodified to the application. Some URIs, such as `mailto:`,
    of course cannot be mapped to a POSIX path (in GVfs there’s no FUSE mount
    for it); such URIs will be passed unmodified to the application.

    Specifically for GVfs 2.26 and later, the POSIX URI will be mapped
    back to the GIO URI in the [iface`Gio`.File] constructors (since GVfs
    implements the GVfs extension point). As such, if the application
    needs to examine the URI, it needs to use [method`Gio`.File.get_uri]
    or similar on [iface`Gio`.File]. In other words, an application cannot
    assume that the URI passed to e.g. [func`Gio`.File.new_for_commandline_arg]
    is equal to the result of [method`Gio`.File.get_uri]. The following snippet
    illustrates this:

    ```c
    GFile *f;
    char *uri;

    file = g_file_new_for_commandline_arg (uri_from_commandline);

    uri = g_file_get_uri (file);
    strcmp (uri, uri_from_commandline) == 0;
    g_free (uri);

    if (g_file_has_uri_scheme (file, "cdda"))
      {
        // do something special with uri
      }
    g_object_unref (file);
    ```

    This code will work when both `cdda://sr0/Track 1.wav` and
    `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
    application. It should be noted that it’s generally not safe
    for applications to rely on the format of a particular URIs.
    Different launcher applications (e.g. file managers) may have
    different ideas of what a given URI means.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_supports_type(self, content_type: str) -> bool:
        """
            Adds a content type to the application information to indicate the
        application is capable of opening files with the given content type.
        """
    def can_delete(self) -> bool:
        """
            Obtains the information whether the [iface`Gio`.AppInfo] can be deleted.
        See [method`Gio`.AppInfo.delete].
        """
    def can_remove_supports_type(self) -> bool:
        """
        Checks if a supported content type can be removed from an application.
        """
    @staticmethod
    def create_from_commandline(commandline: str, application_name: str | None, flags: AppInfoCreateFlags) -> AppInfo:
        """
            Creates a new [iface`Gio`.AppInfo] from the given information.

        Note that for `commandline`, the quoting rules of the `Exec` key of the
        [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
        are applied. For example, if the `commandline` contains
        percent-encoded URIs, the percent-character must be doubled in order to prevent it from
        being swallowed by `Exec` key unquoting. See
        [the specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html)
        for exact quoting rules.
        """
    def delete(self) -> bool:
        """
            Tries to delete a [iface`Gio`.AppInfo].

        On some platforms, there may be a difference between user-defined
        [iface`Gio`.AppInfo]s which can be deleted, and system-wide ones which cannot.
        See [method`Gio`.AppInfo.can_delete].
        """
    def dup(self) -> AppInfo:
        """
        Creates a duplicate of a [iface`Gio`.AppInfo].
        """
    def equal(self, appinfo2: AppInfo) -> bool:
        """
            Checks if two [iface`Gio`.AppInfo]s are equal.

        Note that the check *may not* compare each individual field, and only does
        an identity check. In case detecting changes in the contents is needed,
        program code must additionally compare relevant fields.
        """
    @staticmethod
    def get_all() -> list:
        """
            Gets a list of all of the applications currently registered
        on this system.

        For desktop files, this includes applications that have
        [`NoDisplay=true`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-nodisplay)
        set or are excluded from display by means of
        [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-onlyshowin)
        or [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-notshowin).
        See [method`Gio`.AppInfo.should_show].

        The returned list does not include applications which have the
        [`Hidden` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-hidden)
        set.
        """
    @staticmethod
    def get_all_for_type(content_type: str) -> list:
        """
            Gets a list of all [iface`Gio`.AppInfo]s for a given content type,
        including the recommended and fallback [iface`Gio`.AppInfo]s. See
        [func`Gio`.AppInfo.get_recommended_for_type] and
        [func`Gio`.AppInfo.get_fallback_for_type].
        """
    def get_commandline(self) -> str | None:
        """
            Gets the commandline with which the application will be
        started.
        """
    @staticmethod
    def get_default_for_type(content_type: str, must_support_uris: bool) -> AppInfo | None:
        """
        Gets the default [iface`Gio`.AppInfo] for a given content type.
        """
    @staticmethod
    async def get_default_for_type_async(
        content_type: str,
        must_support_uris: bool,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously gets the default [iface`Gio`.AppInfo] for a given content
        type.
        """
    @staticmethod
    def get_default_for_type_finish(result: AsyncResult) -> AppInfo:
        """
            Finishes a default [iface`Gio`.AppInfo] lookup started by
        [func`Gio`.AppInfo.get_default_for_type_async].

        If no #[iface`Gio`.AppInfo] is found, then `error` will be set to
        [error`Gio`.IOErrorEnum.NOT_FOUND].
        """
    @staticmethod
    def get_default_for_uri_scheme(uri_scheme: str) -> AppInfo | None:
        """
            Gets the default application for handling URIs with the given URI scheme.

        A URI scheme is the initial part of the URI, up to but not including the `:`.
        For example, `http`, `ftp` or `sip`.
        """
    @staticmethod
    async def get_default_for_uri_scheme_async(
        uri_scheme: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously gets the default application for handling URIs with
        the given URI scheme. A URI scheme is the initial part
        of the URI, up to but not including the `:`, e.g. `http`,
        `ftp` or `sip`.
        """
    @staticmethod
    def get_default_for_uri_scheme_finish(result: AsyncResult) -> AppInfo:
        """
            Finishes a default [iface`Gio`.AppInfo] lookup started by
        [func`Gio`.AppInfo.get_default_for_uri_scheme_async].

        If no [iface`Gio`.AppInfo] is found, then `error` will be set to
        [error`Gio`.IOErrorEnum.NOT_FOUND].
        """
    def get_description(self) -> str | None:
        """
        Gets a human-readable description of an installed application.
        """
    def get_display_name(self) -> str:
        """
            Gets the display name of the application. The display name is often more
        descriptive to the user than the name itself.
        """
    def get_executable(self) -> str:
        """
            Gets the executable’s name for the installed application.

        This is intended to be used for debugging or labelling what program is going
        to be run. To launch the executable, use [method`Gio`.AppInfo.launch] and related
        functions, rather than spawning the return value from this function.
        """
    @staticmethod
    def get_fallback_for_type(content_type: str) -> list:
        """
            Gets a list of fallback [iface`Gio`.AppInfo]s for a given content type, i.e.
        those applications which claim to support the given content type by MIME
        type subclassing and not directly.
        """
    def get_icon(self) -> Icon | None:
        """
        Gets the icon for the application.
        """
    def get_id(self) -> str | None:
        """
            Gets the ID of an application. An id is a string that identifies the
        application. The exact format of the id is platform dependent. For instance,
        on Unix this is the desktop file id from the xdg menu specification.

        Note that the returned ID may be `None`, depending on how the `appinfo` has
        been constructed.
        """
    def get_name(self) -> str:
        """
        Gets the installed name of the application.
        """
    @staticmethod
    def get_recommended_for_type(content_type: str) -> list:
        """
            Gets a list of recommended [iface`Gio`.AppInfo]s for a given content type,
        i.e. those applications which claim to support the given content type
        exactly, and not by MIME type subclassing.

        Note that the first application of the list is the last used one, i.e.
        the last one for which [method`Gio`.AppInfo.set_as_last_used_for_type] has
        been called.
        """
    def get_supported_types(self) -> list:
        """
            Retrieves the list of content types that `app_info` claims to support.
        If this information is not provided by the environment, this function
        will return `None`.

        This function does not take in consideration associations added with
        [method`Gio`.AppInfo.add_supports_type], but only those exported directly by
        the application.
        """
    def launch(self, files: list | None = None, context: AppLaunchContext | None = None) -> bool:
        """
            Launches the application. Passes `files` to the launched application
        as arguments, using the optional `context` to get information
        about the details of the launcher (like what screen it is on).
        On error, `error` will be set accordingly.

        To launch the application without arguments pass a `None` `files` list.

        Note that even if the launch is successful the application launched
        can fail to start if it runs into problems during startup. There is
        no way to detect this.

        Some URIs can be changed when passed through a GFile (for instance
        unsupported URIs with strange formats like mailto:), so if you have
        a textual URI you want to pass in as argument, consider using
        [method`Gio`.AppInfo.launch_uris] instead.

        The launched application inherits the environment of the launching
        process, but it can be modified with [method`Gio`.AppLaunchContext.setenv]
        and [method`Gio`.AppLaunchContext.unsetenv].

        On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
        environment variable with the path of the launched desktop file and
        `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
        process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
        should it be inherited by further processes. The `DISPLAY`,
        `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
        variables are also set, based on information provided in `context`.
        """
    @staticmethod
    def launch_default_for_uri(uri: str, context: AppLaunchContext | None = None) -> bool:
        """
            Utility function that launches the default application registered to handle
        the specified uri. Synchronous I/O is done on the uri to detect the type of
        the file if required.

        The D-Bus–activated applications don’t have to be started if your application
        terminates too soon after this function. To prevent this, use
        [func`Gio`.AppInfo.launch_default_for_uri_async] instead.
        """
    @staticmethod
    async def launch_default_for_uri_async(
        uri: str,
        context: AppLaunchContext | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Async version of [func`Gio`.AppInfo.launch_default_for_uri].

        This version is useful if you are interested in receiving error information
        in the case where the application is sandboxed and the portal may present an
        application chooser dialog to the user.

        This is also useful if you want to be sure that the D-Bus–activated
        applications are really started before termination and if you are interested
        in receiving error information from their activation.
        """
    @staticmethod
    def launch_default_for_uri_finish(result: AsyncResult) -> bool:
        """
        Finishes an asynchronous launch-default-for-uri operation.
        """
    def launch_uris(self, uris: list | None = None, context: AppLaunchContext | None = None) -> bool:
        """
            Launches the application. This passes the `uris` to the launched application
        as arguments, using the optional `context` to get information
        about the details of the launcher (like what screen it is on).
        On error, `error` will be set accordingly. If the application only supports
        one URI per invocation as part of their command-line, multiple instances
        of the application will be spawned.

        To launch the application without arguments pass a `None` `uris` list.

        Note that even if the launch is successful the application launched
        can fail to start if it runs into problems during startup. There is
        no way to detect this.
        """
    async def launch_uris_async(
        self,
        uris: list | None = None,
        context: AppLaunchContext | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Async version of [method`Gio`.AppInfo.launch_uris].

        The `callback` is invoked immediately after the application launch, but it
        waits for activation in case of D-Bus–activated applications and also provides
        extended error information for sandboxed applications, see notes for
        [func`Gio`.AppInfo.launch_default_for_uri_async].
        """
    def launch_uris_finish(self, result: AsyncResult) -> bool:
        """
        Finishes a [method`Gio`.AppInfo.launch_uris_async] operation.
        """
    def remove_supports_type(self, content_type: str) -> bool:
        """
        Removes a supported type from an application, if possible.
        """
    @staticmethod
    def reset_type_associations(content_type: str) -> None:
        """
            Removes all changes to the type associations done by
        [method`Gio`.AppInfo.set_as_default_for_type],
        [method`Gio`.AppInfo.set_as_default_for_extension],
        [method`Gio`.AppInfo.add_supports_type] or
        [method`Gio`.AppInfo.remove_supports_type].
        """
    def set_as_default_for_extension(self, extension: str) -> bool:
        """
        Sets the application as the default handler for the given file extension.
        """
    def set_as_default_for_type(self, content_type: str) -> bool:
        """
        Sets the application as the default handler for a given type.
        """
    def set_as_last_used_for_type(self, content_type: str) -> bool:
        """
            Sets the application as the last used application for a given type. This
        will make the application appear as first in the list returned by
        [func`Gio`.AppInfo.get_recommended_for_type], regardless of the default
        application for that content type.
        """
    def should_show(self) -> bool:
        """
            Checks if the application info should be shown in menus that
        list available applications.
        """
    def supports_files(self) -> bool:
        """
        Checks if the application accepts files as arguments.
        """
    def supports_uris(self) -> bool:
        """
        Checks if the application supports reading files and directories from URIs.
        """

class AppInfoIface(GObject.GPointer):
    """
    Application Information interface, for operating system portability.
    """

    # gi Fields
    @builtins.property
    def add_supports_type(self) -> add_supports_typeAppInfoIfaceCB:
        """
          Adds to the [iface`Gio`.AppInfo] information about
        supported file types.
        """
    @builtins.property
    def can_delete(self) -> can_deleteAppInfoIfaceCB:
        """
        Checks if a [iface`Gio`.AppInfo] can be deleted. (Since 2.20)
        """
    @builtins.property
    def can_remove_supports_type(self) -> can_remove_supports_typeAppInfoIfaceCB:
        """
          Checks for support for removing supported file
        types from a [iface`Gio`.AppInfo].
        """
    @builtins.property
    def do_delete(self) -> do_deleteAppInfoIfaceCB:
        """
        Deletes a [iface`Gio`.AppInfo]. (Since 2.20)
        """
    @builtins.property
    def dup(self) -> dupAppInfoIfaceCB:
        """
        Copies a [iface`Gio`.AppInfo].
        """
    @builtins.property
    def equal(self) -> equalAppInfoIfaceCB:
        """
        Checks two [iface`Gio`.AppInfo]s for equality.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def get_commandline(self) -> get_commandlineAppInfoIfaceCB | None:
        """
          Gets the commandline for the [iface`Gio`.AppInfo].
        (Since 2.20)
        """
    @builtins.property
    def get_description(self) -> get_descriptionAppInfoIfaceCB | None:
        """
          Gets a short description for the application described by
        the [iface`Gio`.AppInfo].
        """
    @builtins.property
    def get_display_name(self) -> get_display_nameAppInfoIfaceCB:
        """
          Gets the display name for the [iface`Gio`.AppInfo].
        (Since 2.24)
        """
    @builtins.property
    def get_executable(self) -> get_executableAppInfoIfaceCB:
        """
        Gets the executable name for the [iface`Gio`.AppInfo].
        """
    @builtins.property
    def get_icon(self) -> get_iconAppInfoIfaceCB | None:
        """
        Gets the [iface`Gio`.Icon] for the [iface`Gio`.AppInfo].
        """
    @builtins.property
    def get_id(self) -> get_idAppInfoIfaceCB | None:
        """
        Gets a string identifier for a [iface`Gio`.AppInfo].
        """
    @builtins.property
    def get_name(self) -> get_nameAppInfoIfaceCB:
        """
        Gets the name of the application for a [iface`Gio`.AppInfo].
        """
    @builtins.property
    def get_supported_types(self) -> get_supported_typesAppInfoIfaceCB:
        """
          Retrieves the list of content types that `app_info`
        claims to support.
        """
    @builtins.property
    def launch(self) -> launchAppInfoIfaceCB:
        """
        Launches an application specified by the [iface`Gio`.AppInfo].
        """
    @builtins.property
    def launch_uris(self) -> launch_urisAppInfoIfaceCB:
        """
        Launches an application with a list of URIs.
        """
    @builtins.property
    def launch_uris_async(self) -> launch_uris_asyncAppInfoIfaceCB:
        """
          Asynchronously launches an application with a list of
        URIs. (Since: 2.60)
        """
    @builtins.property
    def launch_uris_finish(self) -> launch_uris_finishAppInfoIfaceCB:
        """
          Finishes an operation started with `launch_uris_async`.
        (Since: 2.60)
        """
    @builtins.property
    def remove_supports_type(self) -> remove_supports_typeAppInfoIfaceCB:
        """
          Removes a supported application type from a
        [iface`Gio`.AppInfo].
        """
    @builtins.property
    def set_as_default_for_extension(self) -> set_as_default_for_extensionAppInfoIfaceCB:
        """
          Sets an application as default for a given
        file extension.
        """
    @builtins.property
    def set_as_default_for_type(self) -> set_as_default_for_typeAppInfoIfaceCB:
        """
          Sets an application as default for a given content
        type.
        """
    @builtins.property
    def set_as_last_used_for_type(self) -> set_as_last_used_for_typeAppInfoIfaceCB:
        """
          Sets the application as the last used. See
        [method`Gio`.AppInfo.set_as_last_used_for_type].
        """
    @builtins.property
    def should_show(self) -> should_showAppInfoIfaceCB:
        """
          Returns whether an application should be shown (e.g. when
        getting a list of installed applications).
        [FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
        """
    @builtins.property
    def supports_files(self) -> supports_filesAppInfoIfaceCB:
        """
          Indicates whether the application specified accepts
        filename arguments.
        """
    @builtins.property
    def supports_uris(self) -> supports_urisAppInfoIfaceCB:
        """
          Indicates whether the application specified supports
        launching URIs.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AppInfoMonitor(GObject.Object):
    """
    `GAppInfoMonitor` monitors application information for changes.

    `GAppInfoMonitor` is a very simple object used for monitoring the app
    info database for changes (newly installed or removed applications).

    Call [func`Gio`.AppInfoMonitor.get] to get a `GAppInfoMonitor` and connect
    to the [signal`Gio`.AppInfoMonitor::changed] signal. The signal will be emitted once when
    the app info database changes, and will not be emitted again until after the
    next call to [func`Gio`.AppInfo.get_all] or another `g_app_info_*()` function.
    This is because monitoring the app info database for changes is expensive.

    The following functions will re-arm the [signal`Gio`.AppInfoMonitor::changed]
    signal so it can be emitted again:

     - [func`Gio`.AppInfo.get_all]
     - [func`Gio`.AppInfo.get_all_for_type]
     - [func`Gio`.AppInfo.get_default_for_type]
     - [func`Gio`.AppInfo.get_fallback_for_type]
     - [func`Gio`.AppInfo.get_recommended_for_type]
     - [``g_desktop_app_info_get_implementations``](../gio-unix/type_func.DesktopAppInfo.get_implementation.html)
     - [``g_desktop_app_info_new``](../gio-unix/ctor.DesktopAppInfo.new.html)
     - [``g_desktop_app_info_new_from_filename``](../gio-unix/ctor.DesktopAppInfo.new_from_filename.html)
     - [``g_desktop_app_info_new_from_keyfile``](../gio-unix/ctor.DesktopAppInfo.new_from_keyfile.html)
     - [``g_desktop_app_info_search``](../gio-unix/type_func.DesktopAppInfo.search.html)

    The latter functions are available if using
    [`GDesktopAppInfo`](../gio-unix/class.DesktopAppInfo.html) from
    `gio-unix-2.0.pc` (GIR namespace `GioUnix-2.0`).

    In the usual case, applications should try to make note of the change
    (doing things like invalidating caches) but not act on it. In
    particular, applications should avoid making calls to `GAppInfo` APIs
    in response to the change signal, deferring these until the time that
    the updated data is actually required. The exception to this case is when
    application information is actually being displayed on the screen
    (for example, during a search or when the list of all applications is shown).
    The reason for this is that changes to the list of installed applications
    often come in groups (like during system updates) and rescanning the list
    on every change is pointless and expensive.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get() -> AppInfoMonitor:
        """
            Gets the GAppInfoMonitor for the current thread-default main
        context.

        The GAppInfoMonitor will emit a “changed” signal in the
        thread-default main context whenever the list of installed
        applications (as reported by `g_app_info_get_all`) may have changed.

        The GAppInfoMonitor::changed signal will only be emitted once until
        `g_app_info_get_all` (or another `g_app_info_*()` function) is called. Doing
        so will re-arm the signal ready to notify about the next change.

        You must only call `g_object_unref` on the return value from under
        the same main context as you created it.
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            Signal emitted when the app info database changes, when applications are
        installed or removed.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AppLaunchContext(GObject.Object):
    """
    Integrating the launch with the launching application. This is used to
    handle for instance startup notification and launching the new application
    on the same screen as the launching window.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> AppLaunchContextPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_display(self, info: AppInfo, files: list) -> str | None:
        """
            Gets the display string for the `context`. This is used to ensure new
        applications are started on the same display as the launching
        application, by setting the `DISPLAY` environment variable.
        """
    def get_environment(self) -> list:
        """
            Gets the complete environment variable list to be passed to
        the child process when `context` is used to launch an application.
        This is a `None`-terminated array of strings, where each string has
        the form `KEY=VALUE`.
        """
    def get_startup_notify_id(self, info: AppInfo | None = None, files: list | None = None) -> str | None:
        """
            Initiates startup notification for the application and returns the
        `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
        if supported.

        The returned token may be referred to equivalently as an ‘activation token’
        (using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
        The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).

        Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
        and startup notification IDs are defined in the
        [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).

        Support for the XDG Activation Protocol was added in GLib 2.76.
        Since GLib 2.82 `info` and `files` can be `None`. If that’s not supported by the backend,
        the returned token will be `None`.
        """
    def launch_failed(self, startup_notify_id: str) -> None:
        """
            Called when an application has failed to launch, so that it can cancel
        the application startup notification started in
        [method`Gio`.AppLaunchContext.get_startup_notify_id].
        """
    @classmethod
    def new(cls) -> AppLaunchContext:
        """
            Creates a new application launch context. This is not normally used,
        instead you instantiate a subclass of this, such as
        [`GdkAppLaunchContext`](https://docs.gtk.org/gdk4/class.AppLaunchContext.html).
        """
    def setenv(self, variable: str, value: str) -> None:
        """
            Arranges for `variable` to be set to `value` in the child’s environment when
        `context` is used to launch an application.
        """
    def unsetenv(self, variable: str) -> None:
        """
            Arranges for `variable` to be unset in the child’s environment when `context`
        is used to launch an application.
        """

    # python methods (overrides?)
    def do_get_display(
        self,
        info: AppInfo,
        files: list,
    ) -> str | None:
        """
        get_display(self, info:Gio.AppInfo, files:list) -> str or None
        """
    def do_get_startup_notify_id(
        self,
        info: AppInfo | None = None,
        files: list | None = None,
    ) -> str | None:
        """
        get_startup_notify_id(self, info:Gio.AppInfo=None, files:list=None) -> str or None
        """
    def do_launch_failed(
        self,
        startup_notify_id: str,
    ) -> None:
        """
        launch_failed(self, startup_notify_id:str)
        """
    def do_launch_started(
        self,
        info: AppInfo,
        platform_data: GLib.Variant,
    ) -> None:
        """
        launch_started(self, info:Gio.AppInfo, platform_data:GLib.Variant)
        """
    def do_launched(
        self,
        info: AppInfo,
        platform_data: GLib.Variant,
    ) -> None:
        """
        launched(self, info:Gio.AppInfo, platform_data:GLib.Variant)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["launch-failed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int:
        """
            The [signal`Gio`.AppLaunchContext::launch-failed] signal is emitted when a
        [iface`Gio`.AppInfo] launch fails. The startup notification id is provided,
        so that the launcher can cancel the startup notification.

        Because a launch operation may involve spawning multiple instances of the
        target application, you should expect this signal to be emitted multiple
        times, one for each spawned instance.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["launch-started"],
        handler: typing.Callable[[typing_extensions.Self, AppInfo, GLib.Variant | None], None],
        *args: typing.Any,
    ) -> int:
        """
            The [signal`Gio`.AppLaunchContext::launch-started] signal is emitted when a
        [iface`Gio`.AppInfo] is about to be launched. If non-null the
        `platform_data` is an GVariant dictionary mapping strings to variants
        (ie `a{sv}`), which contains additional, platform-specific data about this
        launch. On UNIX, at least the `startup-notification-id` keys will be
        present.

        The value of the `startup-notification-id` key (type `s`) is a startup
        notification ID corresponding to the format from the [startup-notification
        specification](https://specifications.freedesktop.org/startup-notification-spec/startup-notification-0.1.txt).
        It allows tracking the progress of the launchee through startup.

        It is guaranteed that this signal is followed by either a
        [signal`Gio`.AppLaunchContext::launched] or
        [signal`Gio`.AppLaunchContext::launch-failed] signal.

        Because a launch operation may involve spawning multiple instances of the
        target application, you should expect this signal to be emitted multiple
        times, one for each spawned instance.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["launched"],
        handler: typing.Callable[[typing_extensions.Self, AppInfo, GLib.Variant], None],
        *args: typing.Any,
    ) -> int:
        """
            The [signal`Gio`.AppLaunchContext::launched] signal is emitted when a
        [iface`Gio`.AppInfo] is successfully launched.

        Because a launch operation may involve spawning multiple instances of the
        target application, you should expect this signal to be emitted multiple
        times, one time for each spawned instance.

        The `platform_data` is an GVariant dictionary mapping
        strings to variants (ie `a{sv}`), which contains additional,
        platform-specific data about this launch. On UNIX, at least the
        `pid` and `startup-notification-id` keys will be present.

        Since 2.72 the `pid` may be 0 if the process id wasn’t known (for
        example if the process was launched via D-Bus). The `pid` may not be
        set at all in subsequent releases.

        On Windows, `pid` is guaranteed to be valid only for the duration of the
        [signal`Gio`.AppLaunchContext::launched] signal emission; after the signal
        is emitted, GLib will call [func`GLib`.spawn_close_pid]. If you need to
        keep the [alias`GLib`.Pid] after the signal has been emitted, then you can
        duplicate `pid` using ``DuplicateHandle``.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class AppLaunchContextClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def get_display(self) -> get_displayAppLaunchContextClassCB | None: ...
    @builtins.property
    def get_startup_notify_id(self) -> get_startup_notify_idAppLaunchContextClassCB | None: ...
    @builtins.property
    def launch_failed(self) -> launch_failedAppLaunchContextClassCB: ...
    @builtins.property
    def launch_started(self) -> launch_startedAppLaunchContextClassCB: ...
    @builtins.property
    def launched(self) -> launchedAppLaunchContextClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AppLaunchContextPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Application(GObject.Object):
    """
    `GApplication` is the core class for application support.

    A `GApplication` is the foundation of an application. It wraps some
    low-level platform-specific services and is intended to act as the
    foundation for higher-level application classes such as
    `GtkApplication` or `MxApplication`. In general, you should not use
    this class outside of a higher level framework.

    `GApplication` provides convenient life-cycle management by maintaining
    a "use count" for the primary application instance. The use count can
    be changed using [method`Gio`.Application.hold] and
    [method`Gio`.Application.release]. If it drops to zero, the application
    exits. Higher-level classes such as `GtkApplication` employ the use count
    to ensure that the application stays alive as long as it has any opened
    windows.

    Another feature that `GApplication` (optionally) provides is process
    uniqueness. Applications can make use of this functionality by
    providing a unique application ID. If given, only one application
    with this ID can be running at a time per session. The session
    concept is platform-dependent, but corresponds roughly to a graphical
    desktop login. When your application is launched again, its
    arguments are passed through platform communication to the already
    running program. The already running instance of the program is
    called the "primary instance"; for non-unique applications this is
    always the current instance. On Linux, the D-Bus session bus
    is used for communication.

    The use of `GApplication` differs from some other commonly-used
    uniqueness libraries (such as libunique) in important ways. The
    application is not expected to manually register itself and check
    if it is the primary instance. Instead, the `main` function of a
    `GApplication` should do very little more than instantiating the
    application instance, possibly connecting signal handlers, then
    calling [method`Gio`.Application.run]. All checks for uniqueness are done
    internally. If the application is the primary instance then the
    startup signal is emitted and the mainloop runs. If the application
    is not the primary instance then a signal is sent to the primary
    instance and [method`Gio`.Application.run] promptly returns. See the code
    examples below.

    If used, the expected form of an application identifier is the
    same as that of a
    [D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
    Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
    `org._7_zip.Archiver`.
    For details on valid application identifiers, see [func`Gio`.Application.id_is_valid].

    On Linux, the application identifier is claimed as a well-known bus name
    on the user's session bus. This means that the uniqueness of your
    application is scoped to the current session. It also means that your
    application may provide additional services (through registration of other
    object paths) at that bus name. The registration of these object paths
    should be done with the shared GDBus session bus. Note that due to the
    internal architecture of GDBus, method calls can be dispatched at any time
    (even if a main loop is not running). For this reason, you must ensure that
    any object paths that you wish to register are registered before GApplication
    attempts to acquire the bus name of your application (which happens in
    [method`Gio`.Application.register]). Unfortunately, this means that you cannot
    use [property`Gio`.Application:is-remote] to decide if you want to register
    object paths.

    `GApplication` also implements the [iface`Gio`.ActionGroup] and [iface`Gio`.ActionMap]
    interfaces and lets you easily export actions by adding them with
    [method`Gio`.ActionMap.add_action]. When invoking an action by calling
    [method`Gio`.ActionGroup.activate_action] on the application, it is always
    invoked in the primary instance. The actions are also exported on
    the session bus, and GIO provides the [class`Gio`.DBusActionGroup] wrapper to
    conveniently access them remotely. GIO provides a [class`Gio`.DBusMenuModel] wrapper
    for remote access to exported [class`Gio`.MenuModel]s.

    Note: Due to the fact that actions are exported on the session bus,
    using `maybe` parameters is not supported, since D-Bus does not support
    `maybe` types.

    There is a number of different entry points into a `GApplication`:

    - via 'Activate' (i.e. just starting the application)

    - via 'Open' (i.e. opening some files)

    - by handling a command-line

    - via activating an action

    The [signal`Gio`.Application::startup] signal lets you handle the application
    initialization for all of these in a single place.

    Regardless of which of these entry points is used to start the
    application, `GApplication` passes some ‘platform data’ from the
    launching instance to the primary instance, in the form of a
    [struct`GLib`.Variant] dictionary mapping strings to variants. To use platform
    data, override the [vfunc`Gio`.Application.before_emit] or
    [vfunc`Gio`.Application.after_emit] virtual functions
    in your `GApplication` subclass. When dealing with
    [class`Gio`.ApplicationCommandLine] objects, the platform data is
    directly available via [method`Gio`.ApplicationCommandLine.get_cwd],
    [method`Gio`.ApplicationCommandLine.get_environ] and
    [method`Gio`.ApplicationCommandLine.get_platform_data].

    As the name indicates, the platform data may vary depending on the
    operating system, but it always includes the current directory (key
    `cwd`), and optionally the environment (ie the set of environment
    variables and their values) of the calling process (key `environ`).
    The environment is only added to the platform data if the
    `G_APPLICATION_SEND_ENVIRONMENT` flag is set. `GApplication` subclasses
    can add their own platform data by overriding the
    [vfunc`Gio`.Application.add_platform_data] virtual function. For instance,
    `GtkApplication` adds startup notification data in this way.

    To parse commandline arguments you may handle the
    [signal`Gio`.Application::command-line] signal or override the
    [vfunc`Gio`.Application.local_command_line] virtual function, to parse them in
    either the primary instance or the local instance, respectively.

    For an example of opening files with a `GApplication`, see
    [gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).

    For an example of using actions with `GApplication`, see
    [gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).

    For an example of using extra D-Bus hooks with `GApplication`, see
    [gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
    """

    class Props(GObject.Object.Props):
        action_group: ActionGroup | None  # [action-group]: changed because contained invalid characters
        """
        The group of actions that the application exports.
        """
        application_id: str  # [application-id]: changed because contained invalid characters
        """
        The unique identifier for the application.
        """
        flags: ApplicationFlags
        """
        Flags specifying the behaviour of the application.
        """
        inactivity_timeout: int  # [inactivity-timeout]: changed because contained invalid characters
        """
        Time (in milliseconds) to stay alive after becoming idle.
        """
        is_busy: bool  # [is-busy]: changed because contained invalid characters
        """
        Whether the application is currently marked as busy through
        `g_application_mark_busy` or `g_application_bind_busy_property`.
        """
        is_registered: bool  # [is-registered]: changed because contained invalid characters
        """
        Whether [method`Gio`.Application.register] has been called.
        """
        is_remote: bool  # [is-remote]: changed because contained invalid characters
        """
        Whether this application instance is remote.
        """
        resource_base_path: str  # [resource-base-path]: changed because contained invalid characters
        """
        The base resource path for the application.
        """
        version: str
        """
        The human-readable version number of the application.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> ApplicationPrivate | None: ...

    # gi Methods
    def activate(self) -> None:
        """
            Activates the application.

        In essence, this results in the GApplication::activate signal being
        emitted in the primary instance.

        The application must be registered before calling this function.
        """
    def add_main_option(
        self,
        long_name: str,
        short_name: int,
        flags: GLib.OptionFlags,
        arg: GLib.OptionArg,
        description: str,
        arg_description: str | None = None,
    ) -> None:
        """
            Add an option to be handled by `application`.

        Calling this function is the equivalent of calling
        `g_application_add_main_option_entries` with a single GOptionEntry
        that has its arg_data member set to None.

        The parsed arguments will be packed into a GVariantDict which
        is passed to GApplication::handle-local-options. If
        G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
        be sent to the primary instance. See
        `g_application_add_main_option_entries` for more details.

        See GOptionEntry for more documentation of the arguments.
        """
    def add_main_option_entries(self, entries: list) -> None:
        """
            Adds main option entries to be handled by `application`.

        This function is comparable to `g_option_context_add_main_entries`.

        After the commandline arguments are parsed, the
        GApplication::handle-local-options signal will be emitted.  At this
        point, the application can inspect the values pointed to by `arg_data`
        in the given GOptionEntrys.

        Unlike GOptionContext, GApplication supports giving a None
        `arg_data` for a non-callback GOptionEntry.  This results in the
        argument in question being packed into a GVariantDict which is also
        passed to GApplication::handle-local-options, where it can be
        inspected and modified.  If G_APPLICATION_HANDLES_COMMAND_LINE is
        set, then the resulting dictionary is sent to the primary instance,
        where `g_application_command_line_get_options_dict` will return it.
        As it has been passed outside the process at this point, the types of all
        values in the options dict must be checked before being used.
        This "packing" is done according to the type of the argument --
        booleans for normal flags, strings for strings, bytestrings for
        filenames, etc.  The packing only occurs if the flag is given (ie: we
        do not pack a "false" GVariant in the case that a flag is missing).

        In general, it is recommended that all commandline arguments are
        parsed locally.  The options dictionary should then be used to
        transmit the result of the parsing to the primary instance, where
        `g_variant_dict_lookup` can be used.  For local options, it is
        possible to either use `arg_data` in the usual way, or to consult (and
        potentially remove) the option from the options dictionary.

        This function is new in GLib 2.40.  Before then, the only real choice
        was to send all of the commandline arguments (options and all) to the
        primary instance for handling.  GApplication ignored them completely
        on the local side.  Calling this function "opts in" to the new
        behaviour, and in particular, means that unrecognized options will be
        treated as errors.  Unrecognized options have never been ignored when
        G_APPLICATION_HANDLES_COMMAND_LINE is unset.

        If GApplication::handle-local-options needs to see the list of
        filenames, then the use of G_OPTION_REMAINING is recommended.  If
        `arg_data` is None then G_OPTION_REMAINING can be used as a key into
        the options dictionary.  If you do use G_OPTION_REMAINING then you
        need to handle these arguments for yourself because once they are
        consumed, they will no longer be visible to the default handling
        (which treats them as filenames to be opened).

        It is important to use the proper GVariant format when retrieving
        the options with `g_variant_dict_lookup`:
        - for G_OPTION_ARG_NONE, use `b`
        - for G_OPTION_ARG_STRING, use `&s`
        - for G_OPTION_ARG_INT, use `i`
        - for G_OPTION_ARG_INT64, use `x`
        - for G_OPTION_ARG_DOUBLE, use `d`
        - for G_OPTION_ARG_FILENAME, use `^&ay`
        - for G_OPTION_ARG_STRING_ARRAY, use `^a&s`
        - for G_OPTION_ARG_FILENAME_ARRAY, use `^a&ay`
        """
    def add_option_group(self, group: GLib.OptionGroup) -> None:
        """
            Adds a GOptionGroup to the commandline handling of `application`.

        This function is comparable to `g_option_context_add_group`.

        Unlike `g_application_add_main_option_entries`, this function does
        not deal with None `arg_data` and never transmits options to the
        primary instance.

        The reason for that is because, by the time the options arrive at the
        primary instance, it is typically too late to do anything with them.
        Taking the GTK option group as an example: GTK will already have been
        initialised by the time the GApplication::command-line handler runs.
        In the case that this is not the first-running instance of the
        application, the existing instance may already have been running for
        a very long time.

        This means that the options from GOptionGroup are only really usable
        in the case that the instance of the application being run is the
        first instance.  Passing options like `--display=` or `--gdk-debug=`
        on future runs will have no effect on the existing primary instance.

        Calling this function will cause the options in the supplied option
        group to be parsed, but it does not cause you to be "opted in" to the
        new functionality whereby unrecognized options are rejected even if
        G_APPLICATION_HANDLES_COMMAND_LINE was given.
        """
    def bind_busy_property(self, object: GObject.Object, property: str) -> None:
        """
            Marks `application` as busy (see `g_application_mark_busy`) while
        `property` on `object` is True.

        The binding holds a reference to `application` while it is active, but
        not to `object`. Instead, the binding is destroyed when `object` is
        finalized.
        """
    @builtins.property
    def get_application_id(self) -> str | None:
        """
        Gets the unique identifier for `application`.
        """
    def get_dbus_connection(self) -> DBusConnection | None:
        """
            Gets the GDBusConnection being used by the application, or None.

        If GApplication is using its D-Bus backend then this function will
        return the GDBusConnection being used for uniqueness and
        communication with the desktop environment and other instances of the
        application.

        If GApplication is not using D-Bus then this function will return
        None.  This includes the situation where the D-Bus backend would
        normally be in use but we were unable to connect to the bus.

        This function must not be called before the application has been
        registered.  See `g_application_get_is_registered`.
        """
    def get_dbus_object_path(self) -> str | None:
        """
            Gets the D-Bus object path being used by the application, or None.

        If GApplication is using its D-Bus backend then this function will
        return the D-Bus object path that GApplication is using.  If the
        application is the primary instance then there is an object published
        at this path.  If the application is not the primary instance then
        the result of this function is undefined.

        If GApplication is not using D-Bus then this function will return
        None.  This includes the situation where the D-Bus backend would
        normally be in use but we were unable to connect to the bus.

        This function must not be called before the application has been
        registered.  See `g_application_get_is_registered`.
        """
    @staticmethod
    def get_default() -> Application | None:
        """
            Returns the default GApplication instance for this process.

        Normally there is only one GApplication per process and it becomes
        the default when it is created.  You can exercise more control over
        this by using `g_application_set_default`.

        If there is no default application then None is returned.
        """
    @builtins.property
    def get_flags(self) -> ApplicationFlags:
        """
            Gets the flags for `application`.

        See GApplicationFlags.
        """
    @builtins.property
    def get_inactivity_timeout(self) -> int:
        """
            Gets the current inactivity timeout for the application.

        This is the amount of time (in milliseconds) after the last call to
        `g_application_release` before the application stops running.
        """
    @builtins.property
    def get_is_busy(self) -> bool:
        """
            Gets the application's current busy state, as set through
        `g_application_mark_busy` or `g_application_bind_busy_property`.
        """
    @builtins.property
    def get_is_registered(self) -> bool:
        """
            Checks if `application` is registered.

        An application is registered if `g_application_register` has been
        successfully called.
        """
    @builtins.property
    def get_is_remote(self) -> bool:
        """
            Checks if `application` is remote.

        If `application` is remote then it means that another instance of
        application already exists (the 'primary' instance).  Calls to
        perform actions on `application` will result in the actions being
        performed by the primary instance.

        The value of this property cannot be accessed before
        `g_application_register` has been called.  See
        `g_application_get_is_registered`.
        """
    @builtins.property
    def get_resource_base_path(self) -> str | None:
        """
            Gets the resource base path of `application`.

        See `g_application_set_resource_base_path` for more information.
        """
    @builtins.property
    def get_version(self) -> str | None:
        """
        Gets the version of `application`.
        """
    def hold(self) -> None:
        """
            Increases the use count of `application`.

        Use this function to indicate that the application has a reason to
        continue to run.  For example, `g_application_hold` is called by GTK
        when a toplevel window is on the screen.

        To cancel the hold, call `g_application_release`.
        """
    @staticmethod
    def id_is_valid(application_id: str) -> bool:
        """
            Checks if `application_id` is a valid application identifier.

        A valid ID is required for calls to `g_application_new` and
        `g_application_set_application_id`.

        Application identifiers follow the same format as
        [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
        For convenience, the restrictions on application identifiers are
        reproduced here:

        - Application identifiers are composed of 1 or more elements separated by a
          period (`.`) character. All elements must contain at least one character.

        - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
          with `-` discouraged in new application identifiers. Each element must not
          begin with a digit.

        - Application identifiers must contain at least one `.` (period) character
          (and thus at least two elements).

        - Application identifiers must not begin with a `.` (period) character.

        - Application identifiers must not exceed 255 characters.

        Note that the hyphen (`-`) character is allowed in application identifiers,
        but is problematic or not allowed in various specifications and APIs that
        refer to D-Bus, such as
        [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
        the
        [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
        and the convention that an application's "main" interface and object path
        resemble its application identifier and bus name. To avoid situations that
        require special-case handling, it is recommended that new application
        identifiers consistently replace hyphens with underscores.

        Like D-Bus interface names, application identifiers should start with the
        reversed DNS domain name of the author of the interface (in lower-case), and
        it is conventional for the rest of the application identifier to consist of
        words run together, with initial capital letters.

        As with D-Bus interface names, if the author's DNS domain name contains
        hyphen/minus characters they should be replaced by underscores, and if it
        contains leading digits they should be escaped by prepending an underscore.
        For example, if the owner of 7-zip.org used an application identifier for an
        archiving application, it might be named `org._7_zip.Archiver`.
        """
    def mark_busy(self) -> None:
        """
            Increases the busy count of `application`.

        Use this function to indicate that the application is busy, for instance
        while a long running operation is pending.

        The busy state will be exposed to other processes, so a session shell will
        use that information to indicate the state to the user (e.g. with a
        spinner).

        To cancel the busy indication, use `g_application_unmark_busy`.

        The application must be registered before calling this function.
        """
    @classmethod
    def new(cls, application_id: str | None, flags: ApplicationFlags) -> Application:
        """
            Creates a new GApplication instance.

        If non-None, the application id must be valid.  See
        `g_application_id_is_valid`.

        If no application ID is given then some features of GApplication
        (most notably application uniqueness) will be disabled.
        """
    def open(self, files: list, n_files: int, hint: str) -> None:
        """
            Opens the given files.

        In essence, this results in the GApplication::open signal being emitted
        in the primary instance.

        `n_files` must be greater than zero.

        `hint` is simply passed through to the ::open signal.  It is
        intended to be used by applications that have multiple modes for
        opening files (eg: "view" vs "edit", etc).  Unless you have a need
        for this functionality, you should use "".

        The application must be registered before calling this function
        and it must have the G_APPLICATION_HANDLES_OPEN flag set.
        """
    def quit(self) -> None:
        """
            Immediately quits the application.

        Upon return to the mainloop, `g_application_run` will return,
        calling only the 'shutdown' function before doing so.

        The hold count is ignored.
        Take care if your code has called `g_application_hold` on the application and
        is therefore still expecting it to exist.
        (Note that you may have called `g_application_hold` indirectly, for example
        through `gtk_application_add_window`.)

        The result of calling `g_application_run` again after it returns is
        unspecified.
        """
    def register(self, cancellable: Cancellable | None = None) -> bool:
        """
            Attempts registration of the application.

        This is the point at which the application discovers if it is the
        primary instance or merely acting as a remote for an already-existing
        primary instance.  This is implemented by attempting to acquire the
        application identifier as a unique bus name on the session bus using
        GDBus.

        If there is no application ID or if G_APPLICATION_NON_UNIQUE was
        given, then this process will always become the primary instance.

        Due to the internal architecture of GDBus, method calls can be
        dispatched at any time (even if a main loop is not running).  For
        this reason, you must ensure that any object paths that you wish to
        register are registered before calling this function.

        If the application has already been registered then True is
        returned with no work performed.

        The GApplication::startup signal is emitted if registration succeeds
        and `application` is the primary instance (including the non-unique
        case).

        In the event of an error (such as `cancellable` being cancelled, or a
        failure to connect to the session bus), False is returned and `error`
        is set appropriately.

        Note: the return value of this function is not an indicator that this
        instance is or is not the primary instance of the application.  See
        `g_application_get_is_remote` for that.
        """
    def release(self) -> None:
        """
            Decrease the use count of `application`.

        When the use count reaches zero, the application will stop running.

        Never call this function except to cancel the effect of a previous
        call to `g_application_hold`.
        """
    def run(self, argc: int, argv: list | None = None) -> int:
        """
            Runs the application.

        This function is intended to be run from `main` and its return value
        is intended to be returned by `main`. Although you are expected to pass
        the `argc`, `argv` parameters from `main` to this function, it is possible
        to pass None if `argv` is not available or commandline handling is not
        required.  Note that on Windows, `argc` and `argv` are ignored, and
        `g_win32_get_command_line` is called internally (for proper support
        of Unicode commandline arguments).

        GApplication will attempt to parse the commandline arguments.  You
        can add commandline flags to the list of recognised options by way of
        `g_application_add_main_option_entries`.  After this, the
        GApplication::handle-local-options signal is emitted, from which the
        application can inspect the values of its GOptionEntrys.

        GApplication::handle-local-options is a good place to handle options
        such as `--version`, where an immediate reply from the local process is
        desired (instead of communicating with an already-running instance).
        A GApplication::handle-local-options handler can stop further processing
        by returning a non-negative value, which then becomes the exit status of
        the process.

        What happens next depends on the flags: if
        G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
        commandline arguments are sent to the primary instance, where a
        GApplication::command-line signal is emitted.  Otherwise, the
        remaining commandline arguments are assumed to be a list of files.
        If there are no files listed, the application is activated via the
        GApplication::activate signal.  If there are one or more files, and
        G_APPLICATION_HANDLES_OPEN was specified then the files are opened
        via the GApplication::open signal.

        If you are interested in doing more complicated local handling of the
        commandline then you should implement your own GApplication subclass
        and override `local_command_line`. In this case, you most likely want
        to return True from your `local_command_line` implementation to
        suppress the default handling. See
        [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
        for an example.

        If, after the above is done, the use count of the application is zero
        then the exit status is returned immediately.  If the use count is
        non-zero then the default main context is iterated until the use count
        falls to zero, at which point 0 is returned.

        If the G_APPLICATION_IS_SERVICE flag is set, then the service will
        run for as much as 10 seconds with a use count of zero while waiting
        for the message that caused the activation to arrive.  After that,
        if the use count falls to zero the application will exit immediately,
        except in the case that `g_application_set_inactivity_timeout` is in
        use.

        This function sets the prgname (`g_set_prgname`), if not already set,
        to the basename of argv[0].

        Much like `g_main_loop_run`, this function will acquire the main context
        for the duration that the application is running.

        Since 2.40, applications that are not explicitly flagged as services
        or launchers (ie: neither G_APPLICATION_IS_SERVICE or
        G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
        default handler for local_command_line) if "--gapplication-service"
        was given in the command line.  If this flag is present then normal
        commandline processing is interrupted and the
        G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
        solution whereby running an application directly from the commandline
        will invoke it in the normal way (which can be useful for debugging)
        while still allowing applications to be D-Bus activated in service
        mode.  The D-Bus service file should invoke the executable with
        "--gapplication-service" as the sole commandline argument.  This
        approach is suitable for use by most graphical applications but
        should not be used from applications like editors that need precise
        control over when processes invoked via the commandline will exit and
        what their exit status will be.
        """
    def send_notification(self, id: str | None, notification: Notification) -> None:
        """
            Sends a notification on behalf of `application` to the desktop shell.
        There is no guarantee that the notification is displayed immediately,
        or even at all.

        Notifications may persist after the application exits. It will be
        D-Bus-activated when the notification or one of its actions is
        activated.

        Modifying `notification` after this call has no effect. However, the
        object can be reused for a later call to this function.

        `id` may be any string that uniquely identifies the event for the
        application. It does not need to be in any special format. For
        example, "new-message" might be appropriate for a notification about
        new messages.

        If a previous notification was sent with the same `id`, it will be
        replaced with `notification` and shown again as if it was a new
        notification. This works even for notifications sent from a previous
        execution of the application, as long as `id` is the same string.

        `id` may be `None`, but it is impossible to replace or withdraw
        notifications without an id.

        If `notification` is no longer relevant, it can be withdrawn with
        [method`Gio`.Application.withdraw_notification].

        It is an error to call this function if `application` has no
        application ID.
        """
    @deprecated("deprecated")
    def set_action_group(self, action_group: ActionGroup | None = None) -> None:
        """
            This used to be how actions were associated with a GApplication.
        Now there is GActionMap for that.
        """
    def set_application_id(self, application_id: str | None = None) -> None:
        """
            Sets the unique identifier for `application`.

        The application id can only be modified if `application` has not yet
        been registered.

        If non-None, the application id must be valid.  See
        `g_application_id_is_valid`.
        """
    def set_default(self) -> None:
        """
            Sets or unsets the default application for the process, as returned
        by `g_application_get_default`.

        This function does not take its own reference on `application`.  If
        `application` is destroyed then the default application will revert
        back to None.
        """
    def set_flags(self, flags: ApplicationFlags) -> None:
        """
            Sets the flags for `application`.

        The flags can only be modified if `application` has not yet been
        registered.

        See GApplicationFlags.
        """
    def set_inactivity_timeout(self, inactivity_timeout: int) -> None:
        """
            Sets the current inactivity timeout for the application.

        This is the amount of time (in milliseconds) after the last call to
        `g_application_release` before the application stops running.

        This call has no side effects of its own.  The value set here is only
        used for next time `g_application_release` drops the use count to
        zero.  Any timeouts currently in progress are not impacted.
        """
    def set_option_context_description(self, description: str | None = None) -> None:
        """
            Adds a description to the `application` option context.

        See `g_option_context_set_description` for more information.
        """
    def set_option_context_parameter_string(self, parameter_string: str | None = None) -> None:
        """
            Sets the parameter string to be used by the commandline handling of `application`.

        This function registers the argument to be passed to `g_option_context_new`
        when the internal GOptionContext of `application` is created.

        See `g_option_context_new` for more information about `parameter_string`.
        """
    def set_option_context_summary(self, summary: str | None = None) -> None:
        """
            Adds a summary to the `application` option context.

        See `g_option_context_set_summary` for more information.
        """
    def set_resource_base_path(self, resource_path: str | None = None) -> None:
        """
            Sets (or unsets) the base resource path of `application`.

        The path is used to automatically load various
        [application resources][struct`Gio`.Resource] such as menu layouts and
        action descriptions. The various types of resources will be found at
        fixed names relative to the given base path.

        By default, the resource base path is determined from the application
        ID by prefixing '/' and replacing each '.' with '/'.  This is done at
        the time that the GApplication object is constructed.  Changes to
        the application ID after that point will not have an impact on the
        resource base path.

        As an example, if the application has an ID of "org.example.app" then
        the default resource base path will be "/org/example/app".  If this
        is a GtkApplication (and you have not manually changed the path)
        then Gtk will then search for the menus of the application at
        "/org/example/app/gtk/menus.ui".

        See GResource for more information about adding resources to your
        application.

        You can disable automatic resource loading functionality by setting
        the path to None.

        Changing the resource base path once the application is running is
        not recommended.  The point at which the resource path is consulted
        for forming paths for various purposes is unspecified.  When writing
        a sub-class of GApplication you should either set the
        GApplication:resource-base-path property at construction time, or call
        this function during the instance initialization. Alternatively, you
        can call this function in the GApplicationClass.startup virtual function,
        before chaining up to the parent implementation.
        """
    def set_version(self, version: str) -> None:
        """
            Sets the version number of `application`. This will be used to implement
        a `--version` command line argument

        The application version can only be modified if `application` has not yet
        been registered.
        """
    def unbind_busy_property(self, object: GObject.Object, property: str) -> None:
        """
            Destroys a binding between `property` and the busy state of
        `application` that was previously created with
        `g_application_bind_busy_property`.
        """
    def unmark_busy(self) -> None:
        """
            Decreases the busy count of `application`.

        When the busy count reaches zero, the new state will be propagated
        to other processes.

        This function must only be called to cancel the effect of a previous
        call to `g_application_mark_busy`.
        """
    def withdraw_notification(self, id: str) -> None:
        """
            Withdraws a notification that was sent with
        `g_application_send_notification`.

        This call does nothing if a notification with `id` doesn't exist or
        the notification was never sent.

        This function works even for notifications sent in previous
        executions of this application, as long `id` is the same as it was for
        the sent notification.

        Note that notifications are dismissed when the user clicks on one
        of the buttons in a notification or triggers its default action, so
        there is no need to explicitly withdraw the notification in that case.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
    def create_asyncio_task(
        self,
        coro: typing.Any,
    ) -> typing.Any:
        """
        Safely create an asyncio task. The application will not quit until the
        task completes. For potentially longer running tasks, you should add
        cancellation logic to abort a task when it is not needed anymore (e.g.
        cancelling it from the Gtk.Window.do_unmap event).

        Note that python will only log a raised exception if the Task is
        destroyed without the result having been collected. However, this does
        also not happen when the task is cancelled. As such, be careful to not
        cancel tasks that are already finished.

        You can deal with this by either only storing a weak reference to the
        Task, by explicitly collecting the result, or by only cancelling it if
        it is not done already.
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["activate"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            The ::activate signal is emitted on the primary instance when an
        activation occurs. See `g_application_activate`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["command-line"],
        handler: typing.Callable[[typing_extensions.Self, ApplicationCommandLine], int],
        *args: typing.Any,
    ) -> int:
        """
            The ::command-line signal is emitted on the primary instance when
        a commandline is not handled locally. See `g_application_run` and
        the GApplicationCommandLine documentation for more information.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["handle-local-options"],
        handler: typing.Callable[[typing_extensions.Self, GLib.VariantDict], int],
        *args: typing.Any,
    ) -> int:
        """
            The ::handle-local-options signal is emitted on the local instance
        after the parsing of the commandline options has occurred.

        You can add options to be recognised during commandline option
        parsing using `g_application_add_main_option_entries` and
        `g_application_add_option_group`.

        Signal handlers can inspect `options` (along with values pointed to
        from the `arg_data` of an installed GOptionEntrys) in order to
        decide to perform certain actions, including direct local handling
        (which may be useful for options like --version).

        In the event that the application is marked
        G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will
        send the `options` dictionary to the primary instance where it can be
        read with `g_application_command_line_get_options_dict`.  The signal
        handler can modify the dictionary before returning, and the
        modified dictionary will be sent.

        In the event that G_APPLICATION_HANDLES_COMMAND_LINE is not set,
        "normal processing" will treat the remaining uncollected command
        line arguments as filenames or URIs.  If there are no arguments,
        the application is activated by `g_application_activate`.  One or
        more arguments results in a call to `g_application_open`.

        If you want to handle the local commandline arguments for yourself
        by converting them to calls to `g_application_open` or
        `g_action_group_activate_action` then you must be sure to register
        the application first.  You should probably not call
        `g_application_activate` for yourself, however: just return -1 and
        allow the default handler to do it for you.  This will ensure that
        the `--gapplication-service` switch works properly (i.e. no activation
        in that case).

        Note that this signal is emitted from the default implementation of
        `local_command_line`.  If you override that function and don't
        chain up then this signal will never be emitted.

        You can override `local_command_line` if you need more powerful
        capabilities than what is provided here, but this should not
        normally be required.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["name-lost"], handler: typing.Callable[..., bool], *args: typing.Any
    ) -> int:
        """
            The ::name-lost signal is emitted only on the registered primary instance
        when a new instance has taken over. This can only happen if the application
        is using the G_APPLICATION_ALLOW_REPLACEMENT flag.

        The default handler for this signal calls `g_application_quit`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["open"],
        handler: typing.Callable[[typing_extensions.Self, list, int, str], None],
        *args: typing.Any,
    ) -> int:
        """
            The ::open signal is emitted on the primary instance when there are
        files to open. See `g_application_open` for more information.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["shutdown"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            The ::shutdown signal is emitted only on the registered primary instance
        immediately after the main loop terminates.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["startup"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            The ::startup signal is emitted on the primary instance immediately
        after registration. See `g_application_register`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::action_group"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::application_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::inactivity_timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_busy"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_registered"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_remote"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::resource_base_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::version"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ApplicationClass(GObject.GPointer):
    """
    Virtual function table for GApplication.
    """

    # gi Fields
    @builtins.property
    def activate(self) -> activateApplicationClassCB:
        """
        invoked on the primary instance when an activation occurs
        """
    @builtins.property
    def add_platform_data(self) -> add_platform_dataApplicationClassCB:
        """
        invoked (locally) to add 'platform data' to be sent to
        the primary instance when activating, opening or invoking actions
        """
    @builtins.property
    def after_emit(self) -> after_emitApplicationClassCB:
        """
        invoked on the primary instance after 'activate', 'open',
        'command-line' or any action invocation, gets the 'platform data' from
        the calling instance
        """
    @builtins.property
    def before_emit(self) -> before_emitApplicationClassCB:
        """
        invoked on the primary instance before 'activate', 'open',
        'command-line' or any action invocation, gets the 'platform data' from
        the calling instance
        """
    @builtins.property
    def command_line(self) -> command_lineApplicationClassCB:
        """
          invoked on the primary instance when a command-line is
        not handled locally
        """
    @builtins.property
    def dbus_register(self) -> dbus_registerApplicationClassCB:
        """
        invoked locally during registration, if the application is
        using its D-Bus backend. You can use this to export extra objects on the
        bus, that need to exist before the application tries to own the bus name.
        The function is passed the GDBusConnection to to session bus, and the
        object path that GApplication will use to export its D-Bus API.
        If this function returns True, registration will proceed; otherwise
        registration will abort. Since: 2.34
        """
    @builtins.property
    def dbus_unregister(self) -> dbus_unregisterApplicationClassCB:
        """
        invoked locally during unregistration, if the application
        is using its D-Bus backend. Use this to undo anything done by
        the `dbus_register` vfunc. Since: 2.34
        """
    @builtins.property
    def handle_local_options(self) -> handle_local_optionsApplicationClassCB:
        """
           invoked locally after the parsing of the commandline
        options has occurred. Since: 2.40
        """
    @builtins.property
    def local_command_line(self) -> local_command_lineApplicationClassCB:
        """
        invoked (locally). The virtual function has the chance
        to inspect (and possibly replace) command line arguments. See
        `g_application_run` for more information. Also see the
        GApplication::handle-local-options signal, which is a simpler
        alternative to handling some commandline options locally
        """
    @builtins.property
    def name_lost(self) -> name_lostApplicationClassCB:
        """
        invoked when another instance is taking over the name. Since: 2.60
        """
    @builtins.property
    def open(self) -> openApplicationClassCB:
        """
        invoked on the primary instance when there are files to open
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def quit_mainloop(self) -> quit_mainloopApplicationClassCB:
        """
        Used to be invoked on the primary instance when the use
        count of the application drops to zero (and after any inactivity
        timeout, if requested). Not used anymore since 2.32
        """
    @builtins.property
    def run_mainloop(self) -> run_mainloopApplicationClassCB:
        """
        Used to be invoked on the primary instance from
        `g_application_run` if the use-count is non-zero. Since 2.32,
        GApplication is iterating the main context directly and is not
        using `run_mainloop` anymore
        """
    @builtins.property
    def shutdown(self) -> shutdownApplicationClassCB:
        """
        invoked only on the registered primary instance immediately
         after the main loop terminates
        """
    @builtins.property
    def startup(self) -> startupApplicationClassCB:
        """
        invoked on the primary instance immediately after registration
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ApplicationCommandLine(GObject.Object):
    """
    `GApplicationCommandLine` represents a command-line invocation of
    an application.

    It is created by [class`Gio`.Application] and emitted
    in the [signal`Gio`.Application::command-line] signal and virtual function.

    The class contains the list of arguments that the program was invoked
    with. It is also possible to query if the commandline invocation was
    local (ie: the current process is running in direct response to the
    invocation) or remote (ie: some other process forwarded the
    commandline to this process).

    The `GApplicationCommandLine` object can provide the `argc` and `argv`
    parameters for use with the [struct`GLib`.OptionContext] command-line parsing API,
    with the [method`Gio`.ApplicationCommandLine.get_arguments] function. See
    [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
    for an example.

    The exit status of the originally-invoked process may be set and
    messages can be printed to stdout or stderr of that process.

    For remote invocation, the originally-invoked process exits when
    [method`Gio`.ApplicationCommandLine.done] method is called. This method is
    also automatically called when the object is disposed.

    The main use for `GApplicationCommandLine` (and the
    [signal`Gio`.Application::command-line] signal) is 'Emacs server' like use cases:
    You can set the `EDITOR` environment variable to have e.g. git use
    your favourite editor to edit commit messages, and if you already
    have an instance of the editor running, the editing will happen
    in the running instance, instead of opening a new one. An important
    aspect of this use case is that the process that gets started by git
    does not return until the editing is done.

    Normally, the commandline is completely handled in the
    [signal`Gio`.Application::command-line] handler. The launching instance exits
    once the signal handler in the primary instance has returned, and
    the return value of the signal handler becomes the exit status
    of the launching instance.

    ```c
    static int
    command_line (GApplication            *application,
                  GApplicationCommandLine *cmdline)
    {
      gchar **argv;
      gint argc;
      gint i;

      argv = g_application_command_line_get_arguments (cmdline, &argc);

      g_application_command_line_print (cmdline,
                                        "This text is written back\\n"
                                        "to stdout of the caller\\n");

      for (i = 0; i < argc; i++)
        g_print ("argument %d: %s\\n", i, argv[i]);

      g_strfreev (argv);

      return 0;
    }
    ```

    The complete example can be found here:
    [gapplication-example-cmdline.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)

    In more complicated cases, the handling of the commandline can be
    split between the launcher and the primary instance.

    ```c
    static gboolean
     test_local_cmdline (GApplication   *application,
                         gchar        ***arguments,
                         gint           *exit_status)
    {
      gint i, j;
      gchar **argv;

      argv = *arguments;

      if (argv[0] == None)
        {
          *exit_status = 0;
          return False;
        }

      i = 1;
      while (argv[i])
        {
          if (g_str_has_prefix (argv[i], "--local-"))
            {
              g_print ("handling argument %s locally\\n", argv[i]);
              g_free (argv[i]);
              for (j = i; argv[j]; j++)
                argv[j] = argv[j + 1];
            }
          else
            {
              g_print ("not handling argument %s locally\\n", argv[i]);
              i++;
            }
        }

      *exit_status = 0;

      return False;
    }

    static void
    test_application_class_init (TestApplicationClass *class)
    {
      G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;

      ...
    }
    ```

    In this example of split commandline handling, options that start
    with `--local-` are handled locally, all other options are passed
    to the [signal`Gio`.Application::command-line] handler which runs in the primary
    instance.

    The complete example can be found here:
    [gapplication-example-cmdline2.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)

    If handling the commandline requires a lot of work, it may be better to defer it.

    ```c
    static gboolean
    my_cmdline_handler (gpointer data)
    {
      GApplicationCommandLine *cmdline = data;

      // do the heavy lifting in an idle

      g_application_command_line_set_exit_status (cmdline, 0);
      g_object_unref (cmdline); // this releases the application

      return G_SOURCE_REMOVE;
    }

    static int
    command_line (GApplication            *application,
                  GApplicationCommandLine *cmdline)
    {
      // keep the application running until we are done with this commandline
      g_application_hold (application);

      g_object_set_data_full (G_OBJECT (cmdline),
                              "application", application,
                              (GDestroyNotify)g_application_release);

      g_object_ref (cmdline);
      g_idle_add (my_cmdline_handler, cmdline);

      return 0;
    }
    ```

    In this example the commandline is not completely handled before
    the [signal`Gio`.Application::command-line] handler returns. Instead, we keep
    a reference to the `GApplicationCommandLine` object and handle it
    later (in this example, in an idle). Note that it is necessary to
    hold the application until you are done with the commandline.

    The complete example can be found here:
    [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
    """

    class Props(GObject.Object.Props):
        arguments: GLib.Variant | None
        """
        The commandline that caused this [signal`Gio`.Application::command-line]
        signal emission.
        """
        is_remote: bool  # [is-remote]: changed because contained invalid characters
        """
        Whether this is a remote commandline.
        """
        options: GLib.Variant | None
        """
        The options sent along with the commandline.
        """
        platform_data: GLib.Variant | None  # [platform-data]: changed because contained invalid characters
        """
        Platform-specific data for the commandline.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> ApplicationCommandLinePrivate | None: ...

    # gi Methods
    def __init__(
        self,
        arguments: GLib.Variant | None = ...,
        options: GLib.Variant | None = ...,
        platform_data: GLib.Variant | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def create_file_for_arg(self, arg: str) -> File:
        """
            Creates a GFile corresponding to a filename that was given as part
        of the invocation of `cmdline`.

        This differs from `g_file_new_for_commandline_arg` in that it
        resolves relative pathnames using the current working directory of
        the invoking process rather than the local process.
        """
    def done(self) -> None:
        """
            Signals that command line processing is completed.

        For remote invocation, it causes the invoking process to terminate.

        For local invocation, it does nothing.

        This method should be called in the [signal`Gio`.Application::command-line]
        handler, after the exit status is set and all messages are printed.

        After this call, `g_application_command_line_set_exit_status` has no effect.
        Subsequent calls to this method are no-ops.

        This method is automatically called when the GApplicationCommandLine
        object is disposed — so you can omit the call in non-garbage collected
        languages.
        """
    def get_arguments(self) -> tuple[list, int]:
        """
            Gets the list of arguments that was passed on the command line.

        The strings in the array may contain non-UTF-8 data on UNIX (such as
        filenames or arguments given in the system locale) but are always in
        UTF-8 on Windows.

        If you wish to use the return value with GOptionContext, you must
        use `g_option_context_parse_strv`.

        The return value is None-terminated and should be freed using
        `g_strfreev`.
        """
    def get_cwd(self) -> str | None:
        """
            Gets the working directory of the command line invocation.
        The string may contain non-utf8 data.

        It is possible that the remote application did not send a working
        directory, so this may be None.

        The return value should not be modified or freed and is valid for as
        long as `cmdline` exists.
        """
    def get_environ(self) -> list:
        """
            Gets the contents of the 'environ' variable of the command line
        invocation, as would be returned by `g_get_environ`, ie as a
        None-terminated list of strings in the form 'NAME=VALUE'.
        The strings may contain non-utf8 data.

        The remote application usually does not send an environment.  Use
        G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
        set it is possible that the environment is still not available (due
        to invocation messages from other applications).

        The return value should not be modified or freed and is valid for as
        long as `cmdline` exists.

        See `g_application_command_line_getenv` if you are only interested
        in the value of a single environment variable.
        """
    def get_exit_status(self) -> int:
        """
            Gets the exit status of `cmdline`.  See
        `g_application_command_line_set_exit_status` for more information.
        """
    @builtins.property
    def get_is_remote(self) -> bool:
        """
        Determines if `cmdline` represents a remote invocation.
        """
    def get_options_dict(self) -> GLib.VariantDict:
        """
            Gets the options that were passed to `g_application_command_line`.

        If you did not override `local_command_line` then these are the same
        options that were parsed according to the GOptionEntrys added to the
        application with `g_application_add_main_option_entries` and possibly
        modified from your GApplication::handle-local-options handler.

        If no options were sent then an empty dictionary is returned so that
        you don't need to check for None.

        The data has been passed via an untrusted external process, so the types of
        all values must be checked before being used.
        """
    def get_platform_data(self) -> GLib.Variant | None:
        """
            Gets the platform data associated with the invocation of `cmdline`.

        This is a GVariant dictionary containing information about the
        context in which the invocation occurred.  It typically contains
        information like the current working directory and the startup
        notification ID.

        It comes from an untrusted external process and hence the types of all
        values must be validated before being used.

        For local invocation, it will be None.
        """
    def get_stdin(self) -> InputStream | None:
        """
            Gets the stdin of the invoking process.

        The GInputStream can be used to read data passed to the standard
        input of the invoking process.
        This doesn't work on all platforms.  Presently, it is only available
        on UNIX when using a D-Bus daemon capable of passing file descriptors.
        If stdin is not available then None will be returned.  In the
        future, support may be expanded to other platforms.

        You must only call this function once per commandline invocation.
        """
    def getenv(self, name: str) -> str | None:
        """
            Gets the value of a particular environment variable of the command
        line invocation, as would be returned by `g_getenv`.  The strings may
        contain non-utf8 data.

        The remote application usually does not send an environment.  Use
        G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
        set it is possible that the environment is still not available (due
        to invocation messages from other applications).

        The return value should not be modified or freed and is valid for as
        long as `cmdline` exists.
        """
    def print_literal(self, message: str) -> None:
        """
            Prints a message using the stdout print handler in the invoking process.

        Unlike `g_application_command_line_print`, `message` is not a ``printf``-style
        format string. Use this function if `message` contains text you don't have
        control over, that could include ``printf`` escape sequences.
        """
    def printerr_literal(self, message: str) -> None:
        """
            Prints a message using the stderr print handler in the invoking process.

        Unlike `g_application_command_line_printerr`, `message` is not
        a ``printf``-style format string. Use this function if `message` contains text
        you don't have control over, that could include ``printf`` escape sequences.
        """
    def set_exit_status(self, exit_status: int) -> None:
        """
            Sets the exit status that will be used when the invoking process
        exits.

        The return value of the GApplication::command-line signal is
        passed to this function when the handler returns.  This is the usual
        way of setting the exit status.

        In the event that you want the remote invocation to continue running
        and want to decide on the exit status in the future, you can use this
        call.  For the case of a remote invocation, the remote process will
        typically exit when the last reference is dropped on `cmdline`.  The
        exit status of the remote process will be equal to the last value
        that was set with this function.

        In the case that the commandline invocation is local, the situation
        is slightly more complicated.  If the commandline invocation results
        in the mainloop running (ie: because the use-count of the application
        increased to a non-zero value) then the application is considered to
        have been 'successful' in a certain sense, and the exit status is
        always zero.  If the application use count is zero, though, the exit
        status of the local GApplicationCommandLine is used.

        This method is a no-op if `g_application_command_line_done` has
        been called.
        """

    # python methods (overrides?)
    def do_done(
        self,
    ) -> None:
        """
        done(self)
        """
    def do_get_stdin(
        self,
    ) -> InputStream | None:
        """
        get_stdin(self) -> Gio.InputStream or None
        """
    def do_print_literal(
        self,
        message: str,
    ) -> None:
        """
        print_literal(self, message:str)
        """
    def do_printerr_literal(
        self,
        message: str,
    ) -> None:
        """
        printerr_literal(self, message:str)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::arguments"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_remote"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::options"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::platform_data"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ApplicationCommandLineClass(GObject.GPointer):
    """
    The GApplicationCommandLineClass-struct
    contains private data only.
    """

    # gi Fields
    @builtins.property
    def done(self) -> doneApplicationCommandLineClassCB: ...
    @builtins.property
    def get_stdin(self) -> get_stdinApplicationCommandLineClassCB | None: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def print_literal(self) -> print_literalApplicationCommandLineClassCB: ...
    @builtins.property
    def printerr_literal(self) -> printerr_literalApplicationCommandLineClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ApplicationCommandLinePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ApplicationPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AsyncInitable(GObject.GInterface):
    """
    `GAsyncInitable` is an interface for asynchronously initializable objects.

    This is the asynchronous version of [iface`Gio`.Initable]; it behaves the same
    in all ways except that initialization is asynchronous. For more details
    see the descriptions on `GInitable`.

    A class may implement both the `GInitable` and `GAsyncInitable` interfaces.

    Users of objects implementing this are not intended to use the interface
    method directly; instead it will be used automatically in various ways.
    For C applications you generally just call [func`Gio`.AsyncInitable.new_async]
    directly, or indirectly via a `foo_thing_new_async` wrapper. This will call
    [method`Gio`.AsyncInitable.init_async] under the covers, calling back with `None`
    and a set `GError` on failure.

    A typical implementation might look something like this:

    ```c
    enum {
       NOT_INITIALIZED,
       INITIALIZING,
       INITIALIZED
    };

    static void
    _foo_ready_cb (Foo *self)
    {
      GList *l;

      self->priv->state = INITIALIZED;

      for (l = self->priv->init_results; l != None; l = l->next)
        {
          GTask *task = l->data;

          if (self->priv->success)
            g_task_return_boolean (task, True);
          else
            g_task_return_new_error (task, ...);
          g_object_unref (task);
        }

      g_list_free (self->priv->init_results);
      self->priv->init_results = None;
    }

    static void
    foo_init_async (GAsyncInitable       *initable,
                    int                   io_priority,
                    GCancellable         *cancellable,
                    GAsyncReadyCallback   callback,
                    gpointer              user_data)
    {
      Foo *self = FOO (initable);
      GTask *task;

      task = g_task_new (initable, cancellable, callback, user_data);
      g_task_set_name (task, G_STRFUNC);

      switch (self->priv->state)
        {
          case NOT_INITIALIZED:
            _foo_get_ready (self);
            self->priv->init_results = g_list_append (self->priv->init_results,
                                                      task);
            self->priv->state = INITIALIZING;
            break;
          case INITIALIZING:
            self->priv->init_results = g_list_append (self->priv->init_results,
                                                      task);
            break;
          case INITIALIZED:
            if (!self->priv->success)
              g_task_return_new_error (task, ...);
            else
              g_task_return_boolean (task, True);
            g_object_unref (task);
            break;
        }
    }

    static gboolean
    foo_init_finish (GAsyncInitable       *initable,
                     GAsyncResult         *result,
                     GError              **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, initable), False);

      return g_task_propagate_boolean (G_TASK (result), error);
    }

    static void
    foo_async_initable_iface_init (gpointer g_iface,
                                   gpointer data)
    {
      GAsyncInitableIface *iface = g_iface;

      iface->init_async = foo_init_async;
      iface->init_finish = foo_init_finish;
    }
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    async def init_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Starts asynchronous initialization of the object implementing the
        interface. This must be done before any real use of the object after
        initial construction. If the object also implements GInitable you can
        optionally call `g_initable_init` instead.

        This method is intended for language bindings. If writing in C,
        `g_async_initable_new_async` should typically be used instead.

        When the initialization is finished, `callback` will be called. You can
        then call `g_async_initable_init_finish` to get the result of the
        initialization.

        Implementations may also support cancellation. If `cancellable` is not
        None, then initialization can be cancelled by triggering the cancellable
        object from another thread. If the operation was cancelled, the error
        G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not None, and
        the object doesn't support cancellable initialization, the error
        G_IO_ERROR_NOT_SUPPORTED will be returned.

        As with GInitable, if the object is not initialized, or initialization
        returns with an error, then all operations on the object except
        `g_object_ref` and `g_object_unref` are considered to be invalid, and
        have undefined behaviour. They will often fail with `g_critical` or
        `g_warning`, but this must not be relied on.

        Callers should not assume that a class which implements GAsyncInitable can
        be initialized multiple times; for more information, see `g_initable_init`.
        If a class explicitly supports being initialized multiple times,
        implementation requires yielding all subsequent calls to `init_async` on the
        results of the first call.

        For classes that also support the GInitable interface, the default
        implementation of this method will run the `g_initable_init` function
        in a thread, so if you want to support asynchronous initialization via
        threads, just implement the GAsyncInitable interface without overriding
        any interface methods.
        """
    def init_finish(self, res: AsyncResult) -> bool:
        """
            Finishes asynchronous initialization and returns the result.
        See `g_async_initable_init_async`.
        """
    def new_finish(self, res: AsyncResult) -> GObject.Object:
        """
            Finishes the async construction for the various g_async_initable_new
        calls, returning the created object or None on error.
        """
    @deprecated("deprecated")
    @staticmethod
    def newv_async(
        object_type: GObject.GType,
        n_parameters: int,
        parameters: GObject.Parameter,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Helper function for constructing GAsyncInitable object. This is
        similar to `g_object_newv` but also initializes the object asynchronously.

        When the initialization is finished, `callback` will be called. You can
        then call `g_async_initable_new_finish` to get the new object and check
        for any errors.
        """

class AsyncInitableIface(GObject.GPointer):
    """
    Provides an interface for asynchronous initializing object such that
    initialization may fail.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def init_async(self) -> init_asyncAsyncInitableIfaceCB:
        """
        Starts initialization of the object.
        """
    @builtins.property
    def init_finish(self) -> init_finishAsyncInitableIfaceCB:
        """
        Finishes initialization of the object.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class AsyncResult(GObject.GInterface):
    """
    `GAsyncResult` provides a base class for implementing asynchronous function results.

    Asynchronous operations are broken up into two separate operations
    which are chained together by a `GAsyncReadyCallback`. To begin
    an asynchronous operation, provide a `GAsyncReadyCallback` to the
    asynchronous function. This callback will be triggered when the
    operation has completed, and must be run in a later iteration of
    the thread-default main context (see
    [method`GLib`.MainContext.push_thread_default]) from where the operation was
    initiated. It will be passed a `GAsyncResult` instance filled with the
    details of the operation's success or failure, the object the asynchronous
    function was started for and any error codes returned. The asynchronous
    callback function is then expected to call the corresponding ``_finish``
    function, passing the object the function was called for, the
    `GAsyncResult` instance, and (optionally) an `error` to grab any
    error conditions that may have occurred.

    The ``_finish`` function for an operation takes the generic result
    (of type `GAsyncResult`) and returns the specific result that the
    operation in question yields (e.g. a [class`Gio`.FileEnumerator] for a
    "enumerate children" operation). If the result or error status of the
    operation is not needed, there is no need to call the ``_finish``
    function; GIO will take care of cleaning up the result and error
    information after the `GAsyncReadyCallback` returns. You can pass
    `None` for the `GAsyncReadyCallback` if you don't need to take any
    action at all after the operation completes. Applications may also
    take a reference to the `GAsyncResult` and call ``_finish`` later;
    however, the ``_finish`` function may be called at most once.

    Example of a typical asynchronous operation flow:

    ```c
    void _theoretical_frobnitz_async (Theoretical         *t,
                                      GCancellable        *c,
                                      GAsyncReadyCallback  cb,
                                      gpointer             u);

    gboolean _theoretical_frobnitz_finish (Theoretical   *t,
                                           GAsyncResult  *res,
                                           GError       **e);

    static void
    frobnitz_result_func (GObject      *source_object,
                     GAsyncResult *res,
                     gpointer      user_data)
    {
      gboolean success = False;

      success = _theoretical_frobnitz_finish (source_object, res, None);

      if (success)
        g_printf ("Hurray!\\n");
      else
        g_printf ("Uh oh!\\n");

      ...

    }

    int main (int argc, void *argv[])
    {
       ...

       _theoretical_frobnitz_async (theoretical_data,
                                    None,
                                    frobnitz_result_func,
                                    None);

       ...
    }
    ```

    The callback for an asynchronous operation is called only once, and is
    always called, even in the case of a cancelled operation. On cancellation
    the result is a `G_IO_ERROR_CANCELLED` error.

    ## I/O Priority

    Many I/O-related asynchronous operations have a priority parameter,
    which is used in certain cases to determine the order in which
    operations are executed. They are not used to determine system-wide
    I/O scheduling. Priorities are integers, with lower numbers indicating
    higher priority. It is recommended to choose priorities between
    `G_PRIORITY_LOW` and `G_PRIORITY_HIGH`, with `G_PRIORITY_DEFAULT`
    as a default.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_source_object(self) -> GObject.Object | None:
        """
        Gets the source object from a [iface`Gio`.AsyncResult].
        """
    def get_user_data(self) -> object | None:
        """
        Gets the user data from a [iface`Gio`.AsyncResult].
        """
    def is_tagged(self, source_tag: object | None = None) -> bool:
        """
            Checks if `res` has the given `source_tag` (generally a function
        pointer indicating the function `res` was created by).
        """
    def legacy_propagate_error(self) -> bool:
        """
            If `res` is a [class`Gio`.SimpleAsyncResult], this is equivalent to
        [method`Gio`.SimpleAsyncResult.propagate_error]. Otherwise it returns
        `False`.

        This can be used for legacy error handling in async `*`_finish``
        wrapper functions that traditionally handled [class`Gio`.SimpleAsyncResult]
        error returns themselves rather than calling into the virtual method.
        This should not be used in new code; [iface`Gio`.AsyncResult] errors that are
        set by virtual methods should also be extracted by virtual methods,
        to enable subclasses to chain up correctly.
        """

class AsyncResultIface(GObject.GPointer):
    """
    Interface definition for [iface`Gio`.AsyncResult].
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def get_source_object(self) -> get_source_objectAsyncResultIfaceCB | None:
        """
        Gets the source object that issued the asynchronous operation.
        """
    @builtins.property
    def get_user_data(self) -> get_user_dataAsyncResultIfaceCB | None:
        """
        Gets the user data passed to the callback.
        """
    @builtins.property
    def is_tagged(self) -> is_taggedAsyncResultIfaceCB:
        """
        Checks if a result is tagged with a particular source.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BufferedInputStream(FilterInputStream):
    """
    Buffered input stream implements [class`Gio`.FilterInputStream] and provides
    for buffered reads.

    By default, `GBufferedInputStream`'s buffer size is set at 4 kilobytes.

    To create a buffered input stream, use [ctor`Gio`.BufferedInputStream.new],
    or [ctor`Gio`.BufferedInputStream.new_sized] to specify the buffer's size at
    construction.

    To get the size of a buffer within a buffered input stream, use
    [method`Gio`.BufferedInputStream.get_buffer_size]. To change the size of a
    buffered input stream's buffer, use [method`Gio`.BufferedInputStream.set_buffer_size].
    Note that the buffer's size cannot be reduced below the size of the data within the buffer.
    """

    class Props(FilterInputStream.Props):
        buffer_size: int  # [buffer-size]: changed because contained invalid characters
        """
        The size of the backend buffer, in bytes.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> FilterInputStream | None: ...
    @builtins.property
    def priv(self) -> BufferedInputStreamPrivate | None: ...

    # gi Methods
    def __init__(self, buffer_size: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def fill(self, count: int, cancellable: Cancellable | None = None) -> int:
        """
            Tries to read `count` bytes from the stream into the buffer.
        Will block during this read.

        If `count` is zero, returns zero and does nothing. A value of `count`
        larger than `G_MAXSSIZE` will cause a
        [error`Gio`.IOErrorEnum.INVALID_ARGUMENT] error.

        On success, the number of bytes read into the buffer is returned.
        It is not an error if this is not the same as the requested size, as it
        can happen e.g. near the end of a file. Zero is returned on end of file
        (or if `count` is zero),  but never otherwise.

        If `count` is -1 then the attempted read size is equal to the number of
        bytes that are required to fill the buffer.

        If `cancellable` is not `None`, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error [error`Gio`.IOErrorEnum.CANCELLED] will be returned.
        If an operation was partially finished when the operation was cancelled the
        partial result will be returned, without an error.

        On error `-1` is returned and `error` is set accordingly.

        For the asynchronous, non-blocking, version of this function, see
        [method`Gio`.BufferedInputStream.fill_async].
        """
    async def fill_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Reads data into `stream`'s buffer asynchronously, up to `count` size.
        `io_priority` can be used to prioritize reads. For the synchronous
        version of this function, see [method`Gio`.BufferedInputStream.fill].

        If `count` is `-1` then the attempted read size is equal to the number
        of bytes that are required to fill the buffer.
        """
    def fill_finish(self, result: AsyncResult) -> int:
        """
        Finishes an asynchronous read.
        """
    def get_available(self) -> int:
        """
        Gets the size of the available data within the stream.
        """
    @builtins.property
    def get_buffer_size(self) -> int:
        """
        Gets the size of the input buffer.
        """
    @classmethod
    def new(cls, base_stream: InputStream) -> BufferedInputStream:
        """
            Creates a new [class`Gio`.InputStream] from the given `base_stream`, with
        a buffer set to the default size (4 kilobytes).
        """
    @classmethod
    def new_sized(cls, base_stream: InputStream, size: int) -> BufferedInputStream:
        """
            Creates a new [class`Gio`.BufferedInputStream] from the given `base_stream`,
        with a buffer set to `size`.
        """
    def peek(self, buffer: list, offset: int, count: int) -> int:
        """
            Peeks in the buffer, copying data of size `count` into `buffer`,
        offset `offset` bytes.
        """
    def peek_buffer(self) -> tuple[list, int]:
        """
            Returns the buffer with the currently available bytes. The returned
        buffer must not be modified and will become invalid when reading from
        the stream or filling the buffer.
        """
    def read_byte(self, cancellable: Cancellable | None = None) -> int:
        """
            Tries to read a single byte from the stream or the buffer. Will block
        during this read.

        On success, the byte read from the stream is returned. On end of stream
        `-1` is returned but it's not an exceptional error and `error` is not set.

        If `cancellable` is not `None`, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error [error`Gio`.IOErrorEnum.CANCELLED] will be returned.
        If an operation was partially finished when the operation was cancelled the
        partial result will be returned, without an error.

        On error `-1` is returned and `error` is set accordingly.
        """
    def set_buffer_size(self, size: int) -> None:
        """
            Sets the size of the internal buffer of `stream` to `size`, or to the
        size of the contents of the buffer. The buffer can never be resized
        smaller than its current contents.
        """

    # python methods (overrides?)
    def do_fill(
        self,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        fill(self, count:int, cancellable:Gio.Cancellable=None) -> int
        """
    def do_fill_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        fill_async(self, count:int, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_fill_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        fill_finish(self, result:Gio.AsyncResult) -> int
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BufferedInputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def fill(self) -> fillBufferedInputStreamClassCB: ...
    @builtins.property
    def fill_async(self) -> fill_asyncBufferedInputStreamClassCB: ...
    @builtins.property
    def fill_finish(self) -> fill_finishBufferedInputStreamClassCB: ...
    @builtins.property
    def parent_class(self) -> FilterInputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BufferedInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BufferedOutputStream(FilterOutputStream):
    """
    Buffered output stream implements [class`Gio`.FilterOutputStream] and provides
    for buffered writes.

    By default, `GBufferedOutputStream`'s buffer size is set at 4 kilobytes.

    To create a buffered output stream, use [ctor`Gio`.BufferedOutputStream.new],
    or [ctor`Gio`.BufferedOutputStream.new_sized] to specify the buffer's size
    at construction.

    To get the size of a buffer within a buffered input stream, use
    [method`Gio`.BufferedOutputStream.get_buffer_size]. To change the size of a
    buffered output stream's buffer, use [method`Gio`.BufferedOutputStream.set_buffer_size].
    Note that the buffer's size cannot be reduced below the size of the data within the buffer.
    """

    class Props(FilterOutputStream.Props):
        auto_grow: bool  # [auto-grow]: changed because contained invalid characters
        """
        Whether the buffer should automatically grow.
        """
        buffer_size: int  # [buffer-size]: changed because contained invalid characters
        """
        The size of the backend buffer, in bytes.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> FilterOutputStream | None: ...
    @builtins.property
    def priv(self) -> BufferedOutputStreamPrivate | None: ...

    # gi Methods
    def __init__(self, auto_grow: bool = ..., buffer_size: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_auto_grow(self) -> bool:
        """
        Checks if the buffer automatically grows as data is added.
        """
    @builtins.property
    def get_buffer_size(self) -> int:
        """
        Gets the size of the buffer in the `stream`.
        """
    @classmethod
    def new(cls, base_stream: OutputStream) -> BufferedOutputStream:
        """
        Creates a new buffered output stream for a base stream.
        """
    @classmethod
    def new_sized(cls, base_stream: OutputStream, size: int) -> BufferedOutputStream:
        """
        Creates a new buffered output stream with a given buffer size.
        """
    def set_auto_grow(self, auto_grow: bool) -> None:
        """
            Sets whether or not the `stream`'s buffer should automatically grow.
        If `auto_grow` is true, then each write will just make the buffer
        larger, and you must manually flush the buffer to actually write out
        the data to the underlying stream.
        """
    def set_buffer_size(self, size: int) -> None:
        """
        Sets the size of the internal buffer to `size`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::auto_grow"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::buffer_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class BufferedOutputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> FilterOutputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BufferedOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class BytesIcon(GObject.Object):
    """
    `GBytesIcon` specifies an image held in memory in a common format (usually
    PNG) to be used as icon.
    """

    class Props(GObject.Object.Props):
        bytes: GLib.Bytes | None
        """
        The bytes containing the icon.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, bytes: GLib.Bytes | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_bytes(self) -> GLib.Bytes:
        """
        Gets the GBytes associated with the given `icon`.
        """
    @classmethod
    def new(cls, bytes: GLib.Bytes) -> BytesIcon:
        """
            Creates a new icon for a bytes.

        This cannot fail, but loading and interpreting the bytes may fail later on
        (for example, if `g_loadable_icon_load` is called) if the image is invalid.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Cancellable(GObject.Object):
    """
    `GCancellable` allows operations to be cancelled.

    `GCancellable` is a thread-safe operation cancellation stack used
    throughout GIO to allow for cancellation of synchronous and
    asynchronous operations.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> CancellablePrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def cancel(self) -> None:
        """
            Will set `cancellable` to cancelled, and will emit the
        GCancellable::cancelled signal. (However, see the warning about
        race conditions in the documentation for that signal if you are
        planning to connect to it.)

        This function is thread-safe. In other words, you can safely call
        it from a thread other than the one running the operation that was
        passed the `cancellable`.

        If `cancellable` is None, this function returns immediately for convenience.

        The convention within GIO is that cancelling an asynchronous
        operation causes it to complete asynchronously. That is, if you
        cancel the operation from the same thread in which it is running,
        then the operation's GAsyncReadyCallback will not be invoked until
        the application returns to the main loop.

        It is safe (although useless, since it will be a no-op) to call
        this function from a [signal`Gio`.Cancellable::cancelled] signal handler.
        """
    def connect(self, callback: GObject.Callback, *data: object | None) -> int:
        """
            Convenience function to connect to the GCancellable::cancelled
        signal. Also handles the race condition that may happen
        if the cancellable is cancelled right before connecting.

        `callback` is called exactly once each time `cancellable` is cancelled,
        either directly at the time of the connect if `cancellable` is already
        cancelled, or when `cancellable` is cancelled in some thread.
        In case the cancellable is reset via [method`Gio`.Cancellable.reset]
        then the callback can be called again if the `cancellable` is cancelled and
        if it had not been previously cancelled at the time
        [method`Gio`.Cancellable.connect] was called (e.g. if the connection actually
        took place, returning a non-zero value).

        `data_destroy_func` will be called when the handler is
        disconnected, or immediately if the cancellable is already
        cancelled.

        See GCancellable::cancelled for details on how to use this.

        Since GLib 2.40, the lock protecting `cancellable` is not held when
        `callback` is invoked. This lifts a restriction in place for
        earlier GLib versions which now makes it easier to write cleanup
        code that unconditionally invokes e.g. [method`Gio`.Cancellable.cancel].
        Note that since 2.82 GLib still holds a lock during the callback but it’s
        designed in a way that most of the [class`Gio`.Cancellable] methods can be
        called, including [method`Gio`.Cancellable.cancel] or
        [method`GObject`.Object.unref].

        There are still some methods that will deadlock (by design) when
        called from the [signal`Gio`.Cancellable::cancelled] callbacks:
         - [method`Gio`.Cancellable.connect]
         - [method`Gio`.Cancellable.disconnect]
         - [method`Gio`.Cancellable.reset]
         - [method`Gio`.Cancellable.make_pollfd]
         - [method`Gio`.Cancellable.release_fd]

        [note from gi-stub-gen] Cancellable has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    def disconnect(self, handler_id: int) -> None:
        """
            Disconnects a handler from a cancellable instance similar to
        `g_signal_handler_disconnect`.  Additionally, in the event that a
        signal handler is currently running, this call will block until the
        handler has finished.  Calling this function from a
        GCancellable::cancelled signal handler will therefore result in a
        deadlock.

        This avoids a race condition where a thread cancels at the
        same time as the cancellable operation is finished and the
        signal handler is removed. See GCancellable::cancelled for
        details on how to use this.

        If `cancellable` is None or `handler_id` is `0` this function does
        nothing.
        """
    @staticmethod
    def get_current() -> Cancellable | None:
        """
        Gets the top cancellable from the stack.
        """
    def get_fd(self) -> int:
        """
            Gets the file descriptor for a cancellable job. This can be used to
        implement cancellable operations on Unix systems. The returned fd will
        turn readable when `cancellable` is cancelled.

        You are not supposed to read from the fd yourself, just check for
        readable status. Reading to unset the readable status is done
        with `g_cancellable_reset`.

        After a successful return from this function, you should use
        `g_cancellable_release_fd` to free up resources allocated for
        the returned file descriptor.

        See also `g_cancellable_make_pollfd`.
        """
    def is_cancelled(self) -> bool:
        """
        Checks if a cancellable job has been cancelled.
        """
    def make_pollfd(self, pollfd: GLib.PollFD) -> bool:
        """
            Creates a GPollFD corresponding to `cancellable`; this can be passed
        to `g_poll` and used to poll for cancellation. This is useful both
        for unix systems without a native poll and for portability to
        windows.

        When this function returns True, you should use
        `g_cancellable_release_fd` to free up resources allocated for the
        `pollfd`. After a False return, do not call `g_cancellable_release_fd`.

        If this function returns False, either no `cancellable` was given or
        resource limits prevent this function from allocating the necessary
        structures for polling. (On Linux, you will likely have reached
        the maximum number of file descriptors.) The suggested way to handle
        these cases is to ignore the `cancellable`.

        You are not supposed to read from the fd yourself, just check for
        readable status. Reading to unset the readable status is done
        with `g_cancellable_reset`.

        Note that in the event that a [signal`Gio`.Cancellable::cancelled] signal handler is
        currently running, this call will block until the handler has finished.
        Calling this function from a signal handler will therefore result in a
        deadlock.
        """
    @classmethod
    def new(cls) -> Cancellable:
        """
            Creates a new GCancellable object.

        Applications that want to start one or more operations
        that should be cancellable should create a GCancellable
        and pass it to the operations.

        One GCancellable can be used in multiple consecutive
        operations or in multiple concurrent operations.
        """
    def pop_current(self) -> None:
        """
            Pops `cancellable` off the cancellable stack (verifying that `cancellable`
        is on the top of the stack).
        """
    def push_current(self) -> None:
        """
            Pushes `cancellable` onto the cancellable stack. The current
        cancellable can then be received using `g_cancellable_get_current`.

        This is useful when implementing cancellable operations in
        code that does not allow you to pass down the cancellable object.

        This is typically called automatically by e.g. GFile operations,
        so you rarely have to call this yourself.
        """
    def release_fd(self) -> None:
        """
            Releases a resources previously allocated by `g_cancellable_get_fd`
        or `g_cancellable_make_pollfd`.

        For compatibility reasons with older releases, calling this function
        is not strictly required, the resources will be automatically freed
        when the `cancellable` is finalized. However, the `cancellable` will
        block scarce file descriptors until it is finalized if this function
        is not called. This can cause the application to run out of file
        descriptors when many GCancellables are used at the same time.

        Note that in the event that a [signal`Gio`.Cancellable::cancelled] signal handler is
        currently running, this call will block until the handler has finished.
        Calling this function from a signal handler will therefore result in a
        deadlock.
        """
    def reset(self) -> None:
        """
            Resets `cancellable` to its uncancelled state.

        If cancellable is currently in use by any cancellable operation
        then the behavior of this function is undefined.

        Note that it is generally not a good idea to reuse an existing
        cancellable for more operations after it has been cancelled once,
        as this function might tempt you to do. The recommended practice
        is to drop the reference to a cancellable after cancelling it,
        and let it die with the outstanding async operations. You should
        create a fresh cancellable for further async operations.

        In the event that a [signal`Gio`.Cancellable::cancelled] signal handler is currently
        running, this call will block until the handler has finished.
        Calling this function from a signal handler will therefore result in a
        deadlock.
        """
    def set_error_if_cancelled(self) -> bool:
        """
            If the `cancellable` is cancelled, sets the error to notify
        that the operation was cancelled.
        """
    def source_new(self) -> GLib.Source:
        """
            Creates a source that triggers if `cancellable` is cancelled and
        calls its callback of type GCancellableSourceFunc. This is
        primarily useful for attaching to another (non-cancellable) source
        with `g_source_add_child_source` to add cancellability to it.

        For convenience, you can call this with a None GCancellable,
        in which case the source will never trigger.

        The new GSource will hold a reference to the GCancellable.
        """

    # python methods (overrides?)
    def do_cancelled(
        self,
    ) -> None:
        """
        cancelled(self)
        """

class CancellableClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def cancelled(self) -> cancelledCancellableClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CancellablePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class CharsetConverter(GObject.Object):
    """
    `GCharsetConverter` is an implementation of [iface`Gio`.Converter] based on
    [struct`GLib`.IConv].
    """

    class Props(GObject.Object.Props):
        from_charset: str  # [from-charset]: changed because contained invalid characters
        """
        The character encoding to convert from.
        """
        to_charset: str  # [to-charset]: changed because contained invalid characters
        """
        The character encoding to convert to.
        """
        use_fallback: bool  # [use-fallback]: changed because contained invalid characters
        """
        Use fallback (of form `<hexval>`) for invalid bytes.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, from_charset: str = ..., to_charset: str = ..., use_fallback: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_num_fallbacks(self) -> int:
        """
        Gets the number of fallbacks that `converter` has applied so far.
        """
    @builtins.property
    def get_use_fallback(self) -> bool:
        """
        Gets the GCharsetConverter:use-fallback property.
        """
    @classmethod
    def new(cls, to_charset: str, from_charset: str) -> CharsetConverter:
        """
        Creates a new GCharsetConverter.
        """
    def set_use_fallback(self, use_fallback: bool) -> None:
        """
        Sets the GCharsetConverter:use-fallback property.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::from_charset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::to_charset"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_fallback"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class CharsetConverterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Converter(GObject.GInterface):
    """
    `GConverter` is an interface for streaming conversions.

    `GConverter` is implemented by objects that convert
    binary data in various ways. The conversion can be
    stateful and may fail at any place.

    Some example conversions are: character set conversion,
    compression, decompression and regular expression
    replace.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def convert(
        self, inbuf: list, inbuf_size: int, outbuf: list, outbuf_size: int, flags: ConverterFlags
    ) -> tuple[ConverterResult, int, int]:
        """
            This is the main operation used when converting data. It is to be called
        multiple times in a loop, and each time it will do some work, i.e.
        producing some output (in `outbuf`) or consuming some input (from `inbuf`) or
        both. If its not possible to do any work an error is returned.

        Note that a single call may not consume all input (or any input at all).
        Also a call may produce output even if given no input, due to state stored
        in the converter producing output.

        If any data was either produced or consumed, and then an error happens, then
        only the successful conversion is reported and the error is returned on the
        next call.

        A full conversion loop involves calling this method repeatedly, each time
        giving it new input and space output space. When there is no more input
        data after the data in `inbuf`, the flag G_CONVERTER_INPUT_AT_END must be set.
        The loop will be (unless some error happens) returning G_CONVERTER_CONVERTED
        each time until all data is consumed and all output is produced, then
        G_CONVERTER_FINISHED is returned instead. Note, that G_CONVERTER_FINISHED
        may be returned even if G_CONVERTER_INPUT_AT_END is not set, for instance
        in a decompression converter where the end of data is detectable from the
        data (and there might even be other data after the end of the compressed data).

        When some data has successfully been converted `bytes_read` and is set to
        the number of bytes read from `inbuf`, and `bytes_written` is set to indicate
        how many bytes was written to `outbuf`. If there are more data to output
        or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified) then
        G_CONVERTER_CONVERTED is returned, and if no more data is to be output
        then G_CONVERTER_FINISHED is returned.

        On error G_CONVERTER_ERROR is returned and `error` is set accordingly.
        Some errors need special handling:

        G_IO_ERROR_NO_SPACE is returned if there is not enough space
        to write the resulting converted data, the application should
        call the function again with a larger `outbuf` to continue.

        G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
        input to fully determine what the conversion should produce,
        and the G_CONVERTER_INPUT_AT_END flag is not set. This happens for
        example with an incomplete multibyte sequence when converting text,
        or when a regexp matches up to the end of the input (and may match
        further input). It may also happen when `inbuf_size` is zero and
        there is no more data to produce.

        When this happens the application should read more input and then
        call the function again. If further input shows that there is no
        more data call the function again with the same data but with
        the G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
        to finish as e.g. in the regexp match case (or, to fail again with
        G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
        input is actually partial).

        After `g_converter_convert` has returned G_CONVERTER_FINISHED the
        converter object is in an invalid state where its not allowed
        to call `g_converter_convert` anymore. At this time you can only
        free the object or call `g_converter_reset` to reset it to the
        initial state.

        If the flag G_CONVERTER_FLUSH is set then conversion is modified
        to try to write out all internal state to the output. The application
        has to call the function multiple times with the flag set, and when
        the available input has been consumed and all internal state has
        been produced then G_CONVERTER_FLUSHED (or G_CONVERTER_FINISHED if
        really at the end) is returned instead of G_CONVERTER_CONVERTED.
        This is somewhat similar to what happens at the end of the input stream,
        but done in the middle of the data.

        This has different meanings for different conversions. For instance
        in a compression converter it would mean that we flush all the
        compression state into output such that if you uncompress the
        compressed data you get back all the input data. Doing this may
        make the final file larger due to padding though. Another example
        is a regexp conversion, where if you at the end of the flushed data
        have a match, but there is also a potential longer match. In the
        non-flushed case we would ask for more input, but when flushing we
        treat this as the end of input and do the match.

        Flushing is not always possible (like if a charset converter flushes
        at a partial multibyte sequence). Converters are supposed to try
        to produce as much output as possible and then return an error
        (typically G_IO_ERROR_PARTIAL_INPUT).
        """
    def convert_bytes(self, bytes: GLib.Bytes) -> GLib.Bytes:
        """
        Applies `converter` to the data in `bytes`.
        """
    def reset(self) -> None:
        """
            Resets all internal state in the converter, making it behave
        as if it was just created. If the converter has any internal
        state that would produce output then that output is lost.
        """

class ConverterIface(GObject.GPointer):
    """
    Provides an interface for converting data from one type
    to another type. The conversion can be stateful
    and may fail at any place.
    """

    # gi Fields
    @builtins.property
    def convert(self) -> convertConverterIfaceCB:
        """
        Converts data.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def reset(self) -> resetConverterIfaceCB:
        """
        Reverts the internal state of the converter to its initial state.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConverterInputStream(FilterInputStream):
    """
    Converter input stream implements [class`Gio`.InputStream] and allows
    conversion of data of various types during reading.

    As of GLib 2.34, `GConverterInputStream` implements
    [iface`Gio`.PollableInputStream].
    """

    class Props(FilterInputStream.Props):
        converter: Converter | None
        """
        The converter object.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> FilterInputStream | None: ...
    @builtins.property
    def priv(self) -> ConverterInputStreamPrivate | None: ...

    # gi Methods
    def __init__(self, converter: Converter | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_converter(self) -> Converter:
        """
        Gets the GConverter that is used by `converter_stream`.
        """
    @classmethod
    def new(cls, base_stream: InputStream, converter: Converter) -> ConverterInputStream:
        """
        Creates a new converter input stream for the `base_stream`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::converter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ConverterInputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> FilterInputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConverterInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConverterOutputStream(FilterOutputStream):
    """
    Converter output stream implements [class`Gio`.OutputStream] and allows
    conversion of data of various types during reading.

    As of GLib 2.34, `GConverterOutputStream` implements
    [iface`Gio`.PollableOutputStream].
    """

    class Props(FilterOutputStream.Props):
        converter: Converter | None
        """
        The converter object.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> FilterOutputStream | None: ...
    @builtins.property
    def priv(self) -> ConverterOutputStreamPrivate | None: ...

    # gi Methods
    def __init__(self, converter: Converter | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_converter(self) -> Converter:
        """
        Gets the GConverter that is used by `converter_stream`.
        """
    @classmethod
    def new(cls, base_stream: OutputStream, converter: Converter) -> ConverterOutputStream:
        """
        Creates a new converter output stream for the `base_stream`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::converter"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ConverterOutputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> FilterOutputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ConverterOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Credentials(GObject.Object):
    """
    The `GCredentials` type is a reference-counted wrapper for native
    credentials.

    The information in `GCredentials` is typically used for identifying,
    authenticating and authorizing other processes.

    Some operating systems supports looking up the credentials of the remote
    peer of a communication endpoint - see e.g. [method`Gio`.Socket.get_credentials].

    Some operating systems supports securely sending and receiving
    credentials over a Unix Domain Socket, see [class`Gio`.UnixCredentialsMessage],
    [method`Gio`.UnixConnection.send_credentials] and
    [method`Gio`.UnixConnection.receive_credentials] for details.

    On Linux, the native credential type is a `struct ucred` - see the
    [`unix(7)` man page](man:unix(7)) for details. This corresponds to
    `G_CREDENTIALS_TYPE_LINUX_UCRED`.

    On Apple operating systems (including iOS, tvOS, and macOS), the native credential
    type is a `struct xucred`. This corresponds to `G_CREDENTIALS_TYPE_APPLE_XUCRED`.

    On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is a
    `struct cmsgcred`. This corresponds to `G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED`.

    On NetBSD, the native credential type is a `struct unpcbid`.
    This corresponds to `G_CREDENTIALS_TYPE_NETBSD_UNPCBID`.

    On OpenBSD, the native credential type is a `struct sockpeercred`.
    This corresponds to `G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED`.

    On Solaris (including OpenSolaris and its derivatives), the native credential type
    is a `ucred_t`. This corresponds to `G_CREDENTIALS_TYPE_SOLARIS_UCRED`.

    Since GLib 2.72, on Windows, the native credentials may contain the PID of a
    process. This corresponds to `G_CREDENTIALS_TYPE_WIN32_PID`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_unix_pid(self) -> int:
        """
            Tries to get the UNIX process identifier from `credentials`. This
        method is only available on UNIX platforms.

        This operation can fail if GCredentials is not supported on the
        OS or if the native credentials type does not contain information
        about the UNIX process ID.
        """
    def get_unix_user(self) -> int:
        """
            Tries to get the UNIX user identifier from `credentials`. This
        method is only available on UNIX platforms.

        This operation can fail if GCredentials is not supported on the
        OS or if the native credentials type does not contain information
        about the UNIX user.
        """
    def is_same_user(self, other_credentials: Credentials) -> bool:
        """
            Checks if `credentials` and `other_credentials` is the same user.

        This operation can fail if GCredentials is not supported on the
        the OS.
        """
    @classmethod
    def new(cls) -> Credentials:
        """
            Creates a new GCredentials object with credentials matching the
        the current process.
        """
    def set_native(self, native_type: CredentialsType, native: object) -> None:
        """
            Copies the native credentials of type `native_type` from `native`
        into `credentials`.

        It is a programming error (which will cause a warning to be
        logged) to use this method if there is no GCredentials support for
        the OS or if `native_type` isn't supported by the OS.
        """
    def set_unix_user(self, uid: int) -> bool:
        """
            Tries to set the UNIX user identifier on `credentials`. This method
        is only available on UNIX platforms.

        This operation can fail if GCredentials is not supported on the
        OS or if the native credentials type does not contain information
        about the UNIX user. It can also fail if the OS does not allow the
        use of "spoofed" credentials.
        """
    def to_string(self) -> str:
        """
            Creates a human-readable textual representation of `credentials`
        that can be used in logging and debug messages. The format of the
        returned string may change in future GLib release.
        """

class CredentialsClass(GObject.GPointer):
    """
    Class structure for GCredentials.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusActionGroup(GObject.Object):
    """
    `GDBusActionGroup` is an implementation of the [iface`Gio`.ActionGroup]
    interface.

    `GDBusActionGroup` can be used as a proxy for an action group
    that is exported over D-Bus with [method`Gio`.DBusConnection.export_action_group].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get(connection: DBusConnection, bus_name: str | None, object_path: str) -> DBusActionGroup:
        """
            Obtains a GDBusActionGroup for the action group which is exported at
        the given `bus_name` and `object_path`.

        The thread default main context is taken at the time of this call.
        All signals on the menu model (and any linked models) are reported
        with respect to this context.  All calls on the returned menu model
        (and linked models) must also originate from this same context, with
        the thread default main context unchanged.

        This call is non-blocking.  The returned action group may or may not
        already be filled in.  The correct thing to do is connect the signals
        for the action group to monitor for changes and then to call
        `g_action_group_list_actions` to get the initial list.
        """

class DBusAnnotationInfo(GObject.GBoxed):
    """
    Information about an annotation.
    """

    # gi Fields
    annotations: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusAnnotationInfo structures or None if there are no annotations.

    """
    key: str = ...
    """
    The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".

    """
    ref_count: int = ...
    """
    The reference count or -1 if statically allocated.

    """
    value: str = ...
    """
    The value of the annotation.

    """

    # gi Methods
    @staticmethod
    def lookup(annotations: list | None, name: str) -> str | None:
        """
            Looks up the value of an annotation.

        The cost of this function is O(n) in number of annotations.
        """
    def ref(self) -> DBusAnnotationInfo:
        """
            If `info` is statically allocated does nothing. Otherwise increases
        the reference count.
        """
    def unref(self) -> None:
        """
            If `info` is statically allocated, does nothing. Otherwise decreases
        the reference count of `info`. When its reference count drops to 0,
        the memory used is freed.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class DBusArgInfo(GObject.GBoxed):
    """
    Information about an argument for a method or a signal.
    """

    # gi Fields
    annotations: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusAnnotationInfo structures or None if there are no annotations.

    """
    name: str = ...
    """
    Name of the argument, e.g. `unix_user_id`.

    """
    ref_count: int = ...
    """
    The reference count or -1 if statically allocated.

    """
    signature: str = ...
    """
    D-Bus signature of the argument (a single complete type).

    """

    # gi Methods
    def ref(self) -> DBusArgInfo:
        """
            If `info` is statically allocated does nothing. Otherwise increases
        the reference count.
        """
    def unref(self) -> None:
        """
            If `info` is statically allocated, does nothing. Otherwise decreases
        the reference count of `info`. When its reference count drops to 0,
        the memory used is freed.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class DBusAuthObserver(GObject.Object):
    """
    `GDBusAuthObserver` provides a mechanism for participating
    in how a [class`Gio`.DBusServer] (or a [class`Gio`.DBusConnection])
    authenticates remote peers.

    Simply instantiate a `GDBusAuthObserver` and connect to the
    signals you are interested in. Note that new signals may be added
    in the future.

    ## Controlling Authentication Mechanisms

    By default, a `GDBusServer` or server-side `GDBusConnection` will allow
    any authentication mechanism to be used. If you only want to allow D-Bus
    connections with the `EXTERNAL` mechanism, which makes use of credentials
    passing and is the recommended mechanism for modern Unix platforms such
    as Linux and the BSD family, you would use a signal handler like this:

    ```c
    static gboolean
    on_allow_mechanism (GDBusAuthObserver *observer,
                        const gchar       *mechanism,
                        gpointer           user_data)
    {
      if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
        {
          return True;
        }

      return False;
    }
    ```

    ## Controlling Authorization

    By default, a `GDBusServer` or server-side `GDBusConnection` will accept
    connections from any successfully authenticated user (but not from
    anonymous connections using the `ANONYMOUS` mechanism). If you only
    want to allow D-Bus connections from processes owned by the same uid
    as the server, since GLib 2.68, you should use the
    `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag. It’s equivalent
    to the following signal handler:

    ```c
    static gboolean
    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
                                     GIOStream         *stream,
                                     GCredentials      *credentials,
                                     gpointer           user_data)
    {
      gboolean authorized;

      authorized = False;
      if (credentials != None)
        {
          GCredentials *own_credentials;
          own_credentials = g_credentials_new ();
          if (g_credentials_is_same_user (credentials, own_credentials, None))
            authorized = True;
          g_object_unref (own_credentials);
        }

      return authorized;
    }
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def allow_mechanism(self, mechanism: str) -> bool:
        """
        Emits the GDBusAuthObserver::allow-mechanism signal on `observer`.
        """
    def authorize_authenticated_peer(self, stream: IOStream, credentials: Credentials | None = None) -> bool:
        """
        Emits the GDBusAuthObserver::authorize-authenticated-peer signal on `observer`.
        """
    @classmethod
    def new(cls) -> DBusAuthObserver:
        """
        Creates a new GDBusAuthObserver object.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["allow-mechanism"],
        handler: typing.Callable[[typing_extensions.Self, str], bool],
        *args: typing.Any,
    ) -> int:
        """
        Emitted to check if `mechanism` is allowed to be used.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["authorize-authenticated-peer"],
        handler: typing.Callable[[typing_extensions.Self, IOStream, Credentials | None], bool],
        *args: typing.Any,
    ) -> int:
        """
            Emitted to check if a peer that is successfully authenticated
        is authorized.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusConnection(GObject.Object):
    """
    The `GDBusConnection` type is used for D-Bus connections to remote
    peers such as a message buses.

    It is a low-level API that offers a lot of flexibility. For instance,
    it lets you establish a connection over any transport that can by represented
    as a [class`Gio`.IOStream].

    This class is rarely used directly in D-Bus clients. If you are writing
    a D-Bus client, it is often easier to use the [func`Gio`.bus_own_name],
    [func`Gio`.bus_watch_name] or [func`Gio`.DBusProxy.new_for_bus] APIs.

    As an exception to the usual GLib rule that a particular object must not
    be used by two threads at the same time, `GDBusConnection`s methods may be
    called from any thread. This is so that [func`Gio`.bus_get] and
    [func`Gio`.bus_get_sync] can safely return the same `GDBusConnection` when
    called from any thread.

    Most of the ways to obtain a `GDBusConnection` automatically initialize it
    (i.e. connect to D-Bus): for instance, [func`Gio`.DBusConnection.new] and
    [func`Gio`.bus_get], and the synchronous versions of those methods, give you
    an initialized connection. Language bindings for GIO should use
    [func`Gio`.Initable.new] or [func`Gio`.AsyncInitable.new_async], which also
    initialize the connection.

    If you construct an uninitialized `GDBusConnection`, such as via
    [ctor`GObject`.Object.new], you must initialize it via [method`Gio`.Initable.init] or
    [method`Gio`.AsyncInitable.init_async] before using its methods or properties.
    Calling methods or accessing properties on a `GDBusConnection` that has not
    completed initialization successfully is considered to be invalid, and leads
    to undefined behaviour. In particular, if initialization fails with a
    `GError`, the only valid thing you can do with that `GDBusConnection` is to
    free it with [method`GObject`.Object.unref].

    ## An example D-Bus server

    Here is an example for a D-Bus server:
    [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)

    ## An example for exporting a subtree

    Here is an example for exporting a subtree:
    [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)

    ## An example for file descriptor passing

    Here is an example for passing UNIX file descriptors:
    [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)

    ## An example for exporting a GObject

    Here is an example for exporting a GObject:
    [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
    """

    class Props(GObject.Object.Props):
        address: str
        """
        A D-Bus address specifying potential endpoints that can be used
        when establishing the connection.
        """
        authentication_observer: (
            DBusAuthObserver | None
        )  # [authentication-observer]: changed because contained invalid characters
        """
        A GDBusAuthObserver object to assist in the authentication process or None.
        """
        capabilities: DBusCapabilityFlags
        """
        Flags from the GDBusCapabilityFlags enumeration
        representing connection features negotiated with the other peer.
        """
        closed: bool
        """
        A boolean specifying whether the connection has been closed.
        """
        exit_on_close: bool  # [exit-on-close]: changed because contained invalid characters
        """
        A boolean specifying whether the process will be terminated (by
        calling `raise(SIGTERM)`) if the connection is closed by the
        remote peer.

        Note that GDBusConnection objects returned by `g_bus_get_finish`
        and `g_bus_get_sync` will (usually) have this property set to True.
        """
        flags: DBusConnectionFlags
        """
        Flags from the GDBusConnectionFlags enumeration.
        """
        guid: str
        """
        The GUID of the peer performing the role of server when
        authenticating.

        If you are constructing a GDBusConnection and pass
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
        GDBusConnection:flags property then you **must** also set this
        property to a valid guid.

        If you are constructing a GDBusConnection and pass
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
        GDBusConnection:flags property you will be able to read the GUID
        of the other peer here after the connection has been successfully
        initialized.

        Note that the
        [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
        uses the term ‘UUID’ to refer to this, whereas GLib consistently uses the
        term ‘GUID’ for historical reasons.

        Despite its name, the format of GDBusConnection:guid does not follow
        [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
        GUID format.
        """
        stream: IOStream | None
        """
        The underlying GIOStream used for I/O.

        If this is passed on construction and is a GSocketConnection,
        then the corresponding GSocket will be put into non-blocking mode.

        While the GDBusConnection is active, it will interact with this
        stream from a worker thread, so it is not safe to interact with
        the stream directly.
        """
        unique_name: str  # [unique-name]: changed because contained invalid characters
        """
        The unique name as assigned by the message bus or None if the
        connection is not open or not a message bus connection.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        address: str = ...,
        authentication_observer: DBusAuthObserver | None = ...,
        exit_on_close: bool = ...,
        flags: DBusConnectionFlags = ...,
        guid: str = ...,
        stream: IOStream | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_filter(
        self, filter_function: DBusMessageFilterFunction | typing.Callable[..., DBusMessage], *user_data: object | None
    ) -> int:
        """
            Adds a message filter. Filters are handlers that are run on all
        incoming and outgoing messages, prior to standard dispatch. Filters
        are run in the order that they were added.  The same handler can be
        added as a filter more than once, in which case it will be run more
        than once.  Filters added during a filter callback won't be run on
        the message being processed. Filter functions are allowed to modify
        and even drop messages.

        Note that filters are run in a dedicated message handling thread so
        they can't block and, generally, can't do anything but signal a
        worker thread. Also note that filters are rarely needed - use API
        such as `g_dbus_connection_send_message_with_reply`,
        `g_dbus_connection_signal_subscribe` or `g_dbus_connection_call` instead.

        If a filter consumes an incoming message the message is not
        dispatched anywhere else - not even the standard dispatch machinery
        (that API such as `g_dbus_connection_signal_subscribe` and
        `g_dbus_connection_send_message_with_reply` relies on) will see the
        message. Similarly, if a filter consumes an outgoing message, the
        message will not be sent to the other peer.

        If `user_data_free_func` is non-None, it will be called (in the
        thread-default main context of the thread you are calling this
        method from) at some point after `user_data` is no longer
        needed. (It is not guaranteed to be called synchronously when the
        filter is removed, and may be called after `connection` has been
        destroyed.)
        """
    async def call(
        self,
        bus_name: str | None,
        object_path: str,
        interface_name: str,
        method_name: str,
        parameters: GLib.Variant | None,
        reply_type: GLib.VariantType | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously invokes the `method_name` method on the
        `interface_name` D-Bus interface on the remote object at
        `object_path` owned by `bus_name`.

        If `connection` is closed then the operation will fail with
        G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
        fail with G_IO_ERROR_CANCELLED. If `parameters` contains a value
        not compatible with the D-Bus protocol, the operation fails with
        G_IO_ERROR_INVALID_ARGUMENT.

        If `reply_type` is non-None then the reply will be checked for having this type and an
        error will be raised if it does not match.  Said another way, if you give a `reply_type`
        then any non-None return value will be of this type. Unless it’s
        G_VARIANT_TYPE_UNIT, the `reply_type` will be a tuple containing one or more
        values.

        If the `parameters` GVariant is floating, it is consumed. This allows
        convenient 'inline' use of `g_variant_new`, e.g.:
        |[<!-- language="C" -->
         g_dbus_connection_call (connection,
                                 "org.freedesktop.StringThings",
                                 "/org/freedesktop/StringThings",
                                 "org.freedesktop.StringThings",
                                 "TwoStrings",
                                 g_variant_new ("(ss)",
                                                "Thing One",
                                                "Thing Two"),
                                 None,
                                 G_DBUS_CALL_FLAGS_NONE,
                                 -1,
                                 None,
                                 (GAsyncReadyCallback) two_strings_done,
                                 None);
        ]|

        This is an asynchronous method. When the operation is finished,
        `callback` will be invoked in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from. You can then call
        `g_dbus_connection_call_finish` to get the result of the operation.
        See `g_dbus_connection_call_sync` for the synchronous version of this
        function.

        If `callback` is None then the D-Bus method call message will be sent with
        the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
        """
    def call_finish(self, res: AsyncResult) -> GLib.Variant:
        """
        Finishes an operation started with `g_dbus_connection_call`.
        """
    def call_sync(
        self,
        bus_name: str | None,
        object_path: str,
        interface_name: str,
        method_name: str,
        parameters: GLib.Variant | None,
        reply_type: GLib.VariantType | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
    ) -> GLib.Variant:
        """
            Synchronously invokes the `method_name` method on the
        `interface_name` D-Bus interface on the remote object at
        `object_path` owned by `bus_name`.

        If `connection` is closed then the operation will fail with
        G_IO_ERROR_CLOSED. If `cancellable` is canceled, the
        operation will fail with G_IO_ERROR_CANCELLED. If `parameters`
        contains a value not compatible with the D-Bus protocol, the operation
        fails with G_IO_ERROR_INVALID_ARGUMENT.

        If `reply_type` is non-None then the reply will be checked for having
        this type and an error will be raised if it does not match.  Said
        another way, if you give a `reply_type` then any non-None return
        value will be of this type.

        If the `parameters` GVariant is floating, it is consumed.
        This allows convenient 'inline' use of `g_variant_new`, e.g.:
        |[<!-- language="C" -->
         g_dbus_connection_call_sync (connection,
                                      "org.freedesktop.StringThings",
                                      "/org/freedesktop/StringThings",
                                      "org.freedesktop.StringThings",
                                      "TwoStrings",
                                      g_variant_new ("(ss)",
                                                     "Thing One",
                                                     "Thing Two"),
                                      None,
                                      G_DBUS_CALL_FLAGS_NONE,
                                      -1,
                                      None,
                                      &error);
        ]|

        The calling thread is blocked until a reply is received. See
        `g_dbus_connection_call` for the asynchronous version of
        this method.
        """
    async def call_with_unix_fd_list(
        self,
        bus_name: str | None,
        object_path: str,
        interface_name: str,
        method_name: str,
        parameters: GLib.Variant | None,
        reply_type: GLib.VariantType | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        fd_list: UnixFDList | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Like `g_dbus_connection_call` but also takes a GUnixFDList object.

        The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE
        values in the body of the message. For example, if a message contains
        two file descriptors, `fd_list` would have length 2, and
        `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
        somewhere in the body of the message (not necessarily in that order!)
        to represent the file descriptors at indexes 0 and 1 respectively.

        When designing D-Bus APIs that are intended to be interoperable,
        please note that non-GDBus implementations of D-Bus can usually only
        access file descriptors if they are referenced in this way by a
        value of type G_VARIANT_TYPE_HANDLE in the body of the message.

        This method is only available on UNIX.
        """
    def call_with_unix_fd_list_finish(self, res: AsyncResult) -> tuple[GLib.Variant, UnixFDList | None]:
        """
            Finishes an operation started with `g_dbus_connection_call_with_unix_fd_list`.

        The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE
        values in the body of the message. For example,
        if `g_variant_get_handle` returns 5, that is intended to be a reference
        to the file descriptor that can be accessed by
        `g_unix_fd_list_get (*out_fd_list, 5, ...)`.

        When designing D-Bus APIs that are intended to be interoperable,
        please note that non-GDBus implementations of D-Bus can usually only
        access file descriptors if they are referenced in this way by a
        value of type G_VARIANT_TYPE_HANDLE in the body of the message.
        """
    def call_with_unix_fd_list_sync(
        self,
        bus_name: str | None,
        object_path: str,
        interface_name: str,
        method_name: str,
        parameters: GLib.Variant | None,
        reply_type: GLib.VariantType | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        fd_list: UnixFDList | None = None,
        cancellable: Cancellable | None = None,
    ) -> tuple[GLib.Variant, UnixFDList | None]:
        """
            Like `g_dbus_connection_call_sync` but also takes and returns GUnixFDList objects.
        See `g_dbus_connection_call_with_unix_fd_list` and
        `g_dbus_connection_call_with_unix_fd_list_finish` for more details.

        This method is only available on UNIX.
        """
    async def close(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Closes `connection`. Note that this never causes the process to
        exit (this might only happen if the other end of a shared message
        bus connection disconnects, see GDBusConnection:exit-on-close).

        Once the connection is closed, operations such as sending a message
        will return with the error G_IO_ERROR_CLOSED. Closing a connection
        will not automatically flush the connection so queued messages may
        be lost. Use `g_dbus_connection_flush` if you need such guarantees.

        If `connection` is already closed, this method fails with
        G_IO_ERROR_CLOSED.

        When `connection` has been closed, the GDBusConnection::closed
        signal is emitted in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        of the thread that `connection` was constructed in.

        This is an asynchronous method. When the operation is finished,
        `callback` will be invoked in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from. You can
        then call `g_dbus_connection_close_finish` to get the result of the
        operation. See `g_dbus_connection_close_sync` for the synchronous
        version.
        """
    def close_finish(self, res: AsyncResult) -> bool:
        """
        Finishes an operation started with `g_dbus_connection_close`.
        """
    def close_sync(self, cancellable: Cancellable | None = None) -> bool:
        """
            Synchronously closes `connection`. The calling thread is blocked
        until this is done. See `g_dbus_connection_close` for the
        asynchronous version of this method and more details about what it
        does.
        """
    def emit_signal(
        self,
        destination_bus_name: str | None,
        object_path: str,
        interface_name: str,
        signal_name: str,
        parameters: GLib.Variant | None = None,
    ) -> bool:
        """
            Emits a signal.

        If the parameters GVariant is floating, it is consumed.

        This can only fail if `parameters` is not compatible with the D-Bus protocol
        (G_IO_ERROR_INVALID_ARGUMENT), or if `connection` has been closed
        (G_IO_ERROR_CLOSED).
        """
    def export_action_group(self, object_path: str, action_group: ActionGroup) -> int:
        """
            Exports `action_group` on `connection` at `object_path`.

        The implemented D-Bus API should be considered private.  It is
        subject to change in the future.

        A given object path can only have one action group exported on it.
        If this constraint is violated, the export will fail and 0 will be
        returned (with `error` set accordingly).

        You can unexport the action group using
        [method`Gio`.DBusConnection.unexport_action_group] with the return value of
        this function.

        The thread default main context is taken at the time of this call.
        All incoming action activations and state change requests are
        reported from this context.  Any changes on the action group that
        cause it to emit signals must also come from this same context.
        Since incoming action activations and state change requests are
        rather likely to cause changes on the action group, this effectively
        limits a given action group to being exported from only one main
        context.
        """
    def export_menu_model(self, object_path: str, menu: MenuModel) -> int:
        """
            Exports `menu` on `connection` at `object_path`.

        The implemented D-Bus API should be considered private.
        It is subject to change in the future.

        An object path can only have one menu model exported on it. If this
        constraint is violated, the export will fail and 0 will be
        returned (with `error` set accordingly).

        Exporting menus with sections containing more than
        G_MENU_EXPORTER_MAX_SECTION_SIZE items is not supported and results in
        undefined behavior.

        You can unexport the menu model using
        `g_dbus_connection_unexport_menu_model` with the return value of
        this function.
        """
    async def flush(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously flushes `connection`, that is, writes all queued
        outgoing messages to the transport and then flushes the transport
        (using `g_output_stream_flush_async`). This is useful in programs
        that want to emit a D-Bus signal and then exit immediately. Without
        flushing the connection, there is no guarantee that the message has
        been sent to the networking buffers in the OS kernel.

        This is an asynchronous method. When the operation is finished,
        `callback` will be invoked in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from. You can
        then call `g_dbus_connection_flush_finish` to get the result of the
        operation. See `g_dbus_connection_flush_sync` for the synchronous
        version.
        """
    def flush_finish(self, res: AsyncResult) -> bool:
        """
        Finishes an operation started with `g_dbus_connection_flush`.
        """
    def flush_sync(self, cancellable: Cancellable | None = None) -> bool:
        """
            Synchronously flushes `connection`. The calling thread is blocked
        until this is done. See `g_dbus_connection_flush` for the
        asynchronous version of this method and more details about what it
        does.
        """
    @builtins.property
    def get_capabilities(self) -> DBusCapabilityFlags:
        """
        Gets the capabilities negotiated with the remote peer
        """
    @builtins.property
    def get_exit_on_close(self) -> bool:
        """
            Gets whether the process is terminated when `connection` is
        closed by the remote peer. See
        GDBusConnection:exit-on-close for more details.
        """
    @builtins.property
    def get_flags(self) -> DBusConnectionFlags:
        """
        Gets the flags used to construct this connection
        """
    @builtins.property
    def get_guid(self) -> str:
        """
            The GUID of the peer performing the role of server when
        authenticating. See GDBusConnection:guid for more details.
        """
    def get_last_serial(self) -> int:
        """
            Retrieves the last serial number assigned to a GDBusMessage on
        the current thread. This includes messages sent via both low-level
        API such as `g_dbus_connection_send_message` as well as
        high-level API such as `g_dbus_connection_emit_signal`,
        `g_dbus_connection_call` or `g_dbus_proxy_call`.
        """
    def get_peer_credentials(self) -> Credentials | None:
        """
            Gets the credentials of the authenticated peer. This will always
        return None unless `connection` acted as a server
        (e.g. G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
        when set up and the client passed credentials as part of the
        authentication process.

        In a message bus setup, the message bus is always the server and
        each application is a client. So this method will always return
        None for message bus clients.
        """
    @builtins.property
    def get_stream(self) -> IOStream:
        """
            Gets the underlying stream used for IO.

        While the GDBusConnection is active, it will interact with this
        stream from a worker thread, so it is not safe to interact with
        the stream directly.
        """
    @builtins.property
    def get_unique_name(self) -> str | None:
        """
            Gets the unique name of `connection` as assigned by the message
        bus. This can also be used to figure out if `connection` is a
        message bus connection.
        """
    @builtins.property
    def is_closed(self) -> bool:
        """
        Gets whether `connection` is closed.
        """
    @staticmethod
    async def new(
        stream: IOStream,
        guid: str | None,
        flags: DBusConnectionFlags,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
        with the end represented by `stream`.

        If `stream` is a GSocketConnection, then the corresponding GSocket
        will be put into non-blocking mode.

        The D-Bus connection will interact with `stream` from a worker thread.
        As a result, the caller should not interact with `stream` after this
        method has been called, except by calling `g_object_unref` on it.

        If `observer` is not None it may be used to control the
        authentication process.

        When the operation is finished, `callback` will be invoked. You can
        then call `g_dbus_connection_new_finish` to get the result of the
        operation.

        This is an asynchronous failable constructor. See
        `g_dbus_connection_new_sync` for the synchronous
        version.
        """
    @classmethod
    def new_finish(cls, res: AsyncResult) -> DBusConnection:
        """
        Finishes an operation started with `g_dbus_connection_new`.
        """
    @staticmethod
    async def new_for_address(
        address: str,
        flags: DBusConnectionFlags,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously connects and sets up a D-Bus client connection for
        exchanging D-Bus messages with an endpoint specified by `address`
        which must be in the
        [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

        This constructor can only be used to initiate client-side
        connections - use `g_dbus_connection_new` if you need to act as the
        server. In particular, `flags` cannot contain the
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.

        When the operation is finished, `callback` will be invoked. You can
        then call `g_dbus_connection_new_for_address_finish` to get the result of
        the operation.

        If `observer` is not None it may be used to control the
        authentication process.

        This is an asynchronous failable constructor. See
        `g_dbus_connection_new_for_address_sync` for the synchronous
        version.
        """
    @classmethod
    def new_for_address_finish(cls, res: AsyncResult) -> DBusConnection:
        """
        Finishes an operation started with `g_dbus_connection_new_for_address`.
        """
    @classmethod
    def new_for_address_sync(
        cls,
        address: str,
        flags: DBusConnectionFlags,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
    ) -> DBusConnection:
        """
            Synchronously connects and sets up a D-Bus client connection for
        exchanging D-Bus messages with an endpoint specified by `address`
        which must be in the
        [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

        This constructor can only be used to initiate client-side
        connections - use `g_dbus_connection_new_sync` if you need to act
        as the server. In particular, `flags` cannot contain the
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.

        This is a synchronous failable constructor. See
        `g_dbus_connection_new_for_address` for the asynchronous version.

        If `observer` is not None it may be used to control the
        authentication process.
        """
    @classmethod
    def new_sync(
        cls,
        stream: IOStream,
        guid: str | None,
        flags: DBusConnectionFlags,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
    ) -> DBusConnection:
        """
            Synchronously sets up a D-Bus connection for exchanging D-Bus messages
        with the end represented by `stream`.

        If `stream` is a GSocketConnection, then the corresponding GSocket
        will be put into non-blocking mode.

        The D-Bus connection will interact with `stream` from a worker thread.
        As a result, the caller should not interact with `stream` after this
        method has been called, except by calling `g_object_unref` on it.

        If `observer` is not None it may be used to control the
        authentication process.

        This is a synchronous failable constructor. See
        `g_dbus_connection_new` for the asynchronous version.
        """
    @deprecated("deprecated")
    def register_object(
        self,
        object_path: str,
        interface_info: DBusInterfaceInfo,
        method_call_closure: GObject.Closure | None = None,
        get_property_closure: GObject.Closure | None = None,
        set_property_closure: GObject.Closure | None = None,
    ) -> int:
        """
            Registers callbacks for exported objects at `object_path` with the
        D-Bus interface that is described in `interface_info`.

        Calls to functions in `vtable` (and `user_data_free_func`) will happen
        in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from.

        Note that all GVariant values passed to functions in `vtable` will match
        the signature given in `interface_info` - if a remote caller passes
        incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`
        is returned to the remote caller.

        Additionally, if the remote caller attempts to invoke methods or
        access properties not mentioned in `interface_info` the
        `org.freedesktop.DBus.Error.UnknownMethod` resp.
        `org.freedesktop.DBus.Error.InvalidArgs` errors
        are returned to the caller.

        It is considered a programming error if the
        GDBusInterfaceGetPropertyFunc function in `vtable` returns a
        GVariant of incorrect type.

        If an existing callback is already registered at `object_path` and
        `interface_name`, then `error` is set to G_IO_ERROR_EXISTS.

        GDBus automatically implements the standard D-Bus interfaces
        org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
        and org.freedesktop.Peer, so you don't have to implement those for the
        objects you export. You can implement org.freedesktop.DBus.Properties
        yourself, e.g. to handle getting and setting of properties asynchronously.

        Note that the reference count on `interface_info` will be
        incremented by 1 (unless allocated statically, e.g. if the
        reference count is -1, see `g_dbus_interface_info_ref`) for as long
        as the object is exported. Also note that `vtable` will be copied.

        See this [server][class`Gio`.DBusConnection#an-example-d-bus-server]
        for an example of how to use this method.
        """
    def register_object_with_closures2(
        self,
        object_path: str,
        interface_info: DBusInterfaceInfo,
        method_call_closure: GObject.Closure | None = None,
        get_property_closure: GObject.Closure | None = None,
        set_property_closure: GObject.Closure | None = None,
    ) -> int:
        """
            Version of [method`Gio`.DBusConnection.register_object] using closures instead
        of a [type`Gio`.DBusInterfaceVTable] for easier binding in other languages.

        In contrast to [method`Gio`.DBusConnection.register_object] and
        [method`Gio`.DBusConnection.register_object_with_closures], the reference
        counting semantics of the function wrapped by `method_call_closure` are *not*
        the same as those of [callback`Gio`.DBusInterfaceMethodCallFunc]. Ownership of
        a reference to the [class`Gio`.DBusMethodInvocation] is *not* transferred to
        the function. Bindings must ensure that they add a reference to the
        [class`Gio`.DBusMethodInvocation] before calling any
        `g_dbus_method_invocation_return_*()` methods on it. This should be automatic
        as a result of the introspection annotations on those methods.
        """
    def register_subtree(
        self,
        object_path: str,
        vtable: DBusSubtreeVTable,
        flags: DBusSubtreeFlags,
        user_data: object | None,
        user_data_free_func: GLib.DestroyNotify,
    ) -> int:
        """
            Registers a whole subtree of dynamic objects.

        The `enumerate` and `introspection` functions in `vtable` are used to
        convey, to remote callers, what nodes exist in the subtree rooted
        by `object_path`.

        When handling remote calls into any node in the subtree, first the
        `enumerate` function is used to check if the node exists. If the node exists
        or the G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
        the `introspection` function is used to check if the node supports the
        requested method. If so, the `dispatch` function is used to determine
        where to dispatch the call. The collected GDBusInterfaceVTable and
        #gpointer will be used to call into the interface vtable for processing
        the request.

        All calls into user-provided code will be invoked in the thread-default
        main context (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from.

        If an existing subtree is already registered at `object_path` or
        then `error` is set to G_IO_ERROR_EXISTS.

        Note that it is valid to register regular objects (using
        `g_dbus_connection_register_object`) in a subtree registered with
        `g_dbus_connection_register_subtree` - if so, the subtree handler
        is tried as the last resort. One way to think about a subtree
        handler is to consider it a fallback handler for object paths not
        registered via `g_dbus_connection_register_object` or other bindings.

        Note that `vtable` will be copied so you cannot change it after
        registration.

        See this [server][class`Gio`.DBusConnection#an-example-for-exporting-a-subtree]
        for an example of how to use this method.
        """
    def remove_filter(self, filter_id: int) -> None:
        """
            Removes a filter.

        Note that since filters run in a different thread, there is a race
        condition where it is possible that the filter will be running even
        after calling `g_dbus_connection_remove_filter`, so you cannot just
        free data that the filter might be using. Instead, you should pass
        a GDestroyNotify to `g_dbus_connection_add_filter`, which will be
        called when it is guaranteed that the data is no longer needed.
        """
    def send_message(self, message: DBusMessage, flags: DBusSendMessageFlags) -> tuple[bool, int]:
        """
            Asynchronously sends `message` to the peer represented by `connection`.

        Unless `flags` contain the
        G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
        will be assigned by `connection` and set on `message` via
        `g_dbus_message_set_serial`. If `out_serial` is not None, then the
        serial number used will be written to this location prior to
        submitting the message to the underlying transport. While it has a `volatile`
        qualifier, this is a historical artifact and the argument passed to it should
        not be `volatile`.

        If `connection` is closed then the operation will fail with
        G_IO_ERROR_CLOSED. If `message` is not well-formed,
        the operation fails with G_IO_ERROR_INVALID_ARGUMENT.

        See this [server][class`Gio`.DBusConnection#an-example-d-bus-server]
        and [client][class`Gio`.DBusConnection#an-example-for-file-descriptor-passing]
        for an example of how to use this low-level API to send and receive
        UNIX file descriptors.

        Note that `message` must be unlocked, unless `flags` contain the
        G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
        """
    async def send_message_with_reply(
        self,
        message: DBusMessage,
        flags: DBusSendMessageFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> int:
        """
            Asynchronously sends `message` to the peer represented by `connection`.

        Unless `flags` contain the
        G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
        will be assigned by `connection` and set on `message` via
        `g_dbus_message_set_serial`. If `out_serial` is not None, then the
        serial number used will be written to this location prior to
        submitting the message to the underlying transport. While it has a `volatile`
        qualifier, this is a historical artifact and the argument passed to it should
        not be `volatile`.

        If `connection` is closed then the operation will fail with
        G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
        fail with G_IO_ERROR_CANCELLED. If `message` is not well-formed,
        the operation fails with G_IO_ERROR_INVALID_ARGUMENT.

        This is an asynchronous method. When the operation is finished, `callback`
        will be invoked in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from. You can then call
        `g_dbus_connection_send_message_with_reply_finish` to get the result of the operation.
        See `g_dbus_connection_send_message_with_reply_sync` for the synchronous version.

        Note that `message` must be unlocked, unless `flags` contain the
        G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.

        See this [server][class`Gio`.DBusConnection#an-example-d-bus-server]
        and [client][class`Gio`.DBusConnection#an-example-for-file-descriptor-passing]
        for an example of how to use this low-level API to send and receive
        UNIX file descriptors.
        """
    def send_message_with_reply_finish(self, res: AsyncResult) -> DBusMessage:
        """
            Finishes an operation started with `g_dbus_connection_send_message_with_reply`.

        Note that `error` is only set if a local in-process error
        occurred. That is to say that the returned GDBusMessage object may
        be of type G_DBUS_MESSAGE_TYPE_ERROR. Use
        `g_dbus_message_to_gerror` to transcode this to a GError.

        See this [server][class`Gio`.DBusConnection#an-example-d-bus-server]
        and [client][class`Gio`.DBusConnection#an-example-for-file-descriptor-passing]
        for an example of how to use this low-level API to send and receive
        UNIX file descriptors.
        """
    def send_message_with_reply_sync(
        self,
        message: DBusMessage,
        flags: DBusSendMessageFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
    ) -> tuple[DBusMessage, int]:
        """
            Synchronously sends `message` to the peer represented by `connection`
        and blocks the calling thread until a reply is received or the
        timeout is reached. See `g_dbus_connection_send_message_with_reply`
        for the asynchronous version of this method.

        Unless `flags` contain the
        G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
        will be assigned by `connection` and set on `message` via
        `g_dbus_message_set_serial`. If `out_serial` is not None, then the
        serial number used will be written to this location prior to
        submitting the message to the underlying transport. While it has a `volatile`
        qualifier, this is a historical artifact and the argument passed to it should
        not be `volatile`.

        If `connection` is closed then the operation will fail with
        G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
        fail with G_IO_ERROR_CANCELLED. If `message` is not well-formed,
        the operation fails with G_IO_ERROR_INVALID_ARGUMENT.

        Note that `error` is only set if a local in-process error
        occurred. That is to say that the returned GDBusMessage object may
        be of type G_DBUS_MESSAGE_TYPE_ERROR. Use
        `g_dbus_message_to_gerror` to transcode this to a GError.

        See this [server][class`Gio`.DBusConnection#an-example-d-bus-server]
        and [client][class`Gio`.DBusConnection#an-example-for-file-descriptor-passing]
        for an example of how to use this low-level API to send and receive
        UNIX file descriptors.

        Note that `message` must be unlocked, unless `flags` contain the
        G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
        """
    def set_exit_on_close(self, exit_on_close: bool) -> None:
        """
            Sets whether the process should be terminated when `connection` is
        closed by the remote peer. See GDBusConnection:exit-on-close for
        more details.

        Note that this function should be used with care. Most modern UNIX
        desktops tie the notion of a user session with the session bus, and expect
        all of a user's applications to quit when their bus connection goes away.
        If you are setting `exit_on_close` to False for the shared session
        bus connection, you should make sure that your application exits
        when the user session ends.
        """
    def signal_subscribe(
        self,
        sender: str | None,
        interface_name: str | None,
        member: str | None,
        object_path: str | None,
        arg0: str | None,
        flags: DBusSignalFlags,
        callback: DBusSignalCallback,
        *user_data: object | None,
    ) -> int:
        """
            Subscribes to signals on `connection` and invokes `callback` whenever
        the signal is received. Note that `callback` will be invoked in the
        thread-default main context (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from.

        If `connection` is not a message bus connection, `sender` must be
        None.

        If `sender` is a well-known name note that `callback` is invoked with
        the unique name for the owner of `sender`, not the well-known name
        as one would expect. This is because the message bus rewrites the
        name. As such, to avoid certain race conditions, users should be
        tracking the name owner of the well-known name and use that when
        processing the received signal.

        If one of G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
        G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, `arg0` is
        interpreted as part of a namespace or path.  The first argument
        of a signal is matched against that part as specified by D-Bus.

        If `user_data_free_func` is non-None, it will be called (in the
        thread-default main context of the thread you are calling this
        method from) at some point after `user_data` is no longer
        needed. (It is not guaranteed to be called synchronously when the
        signal is unsubscribed from, and may be called after `connection`
        has been destroyed.)

        As `callback` is potentially invoked in a different thread from where it’s
        emitted, it’s possible for this to happen after
        `g_dbus_connection_signal_unsubscribe` has been called in another thread.
        Due to this, `user_data` should have a strong reference which is freed with
        `user_data_free_func`, rather than pointing to data whose lifecycle is tied
        to the signal subscription. For example, if a GObject is used to store the
        subscription ID from `g_dbus_connection_signal_subscribe`, a strong reference
        to that GObject must be passed to `user_data`, and `g_object_unref` passed to
        `user_data_free_func`. You are responsible for breaking the resulting
        reference count cycle by explicitly unsubscribing from the signal when
        dropping the last external reference to the GObject. Alternatively, a weak
        reference may be used.

        It is guaranteed that if you unsubscribe from a signal using
        `g_dbus_connection_signal_unsubscribe` from the same thread which made the
        corresponding `g_dbus_connection_signal_subscribe` call, `callback` will not
        be invoked after `g_dbus_connection_signal_unsubscribe` returns.

        The returned subscription identifier is an opaque value which is guaranteed
        to never be zero.

        This function can never fail.
        """
    def signal_unsubscribe(self, subscription_id: int) -> None:
        """
            Unsubscribes from signals.

        Note that there may still be D-Bus traffic to process (relating to this
        signal subscription) in the current thread-default GMainContext after this
        function has returned. You should continue to iterate the GMainContext
        until the GDestroyNotify function passed to
        `g_dbus_connection_signal_subscribe` is called, in order to avoid memory
        leaks through callbacks queued on the GMainContext after it’s stopped being
        iterated.
        Alternatively, any idle source with a priority lower than G_PRIORITY_DEFAULT
        that was scheduled after unsubscription, also indicates that all resources
        of this subscription are released.
        """
    def start_message_processing(self) -> None:
        """
            If `connection` was created with
        G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
        starts processing messages. Does nothing on if `connection` wasn't
        created with this flag or if the method has already been called.
        """
    def unexport_action_group(self, export_id: int) -> None:
        """
            Reverses the effect of a previous call to
        [method`Gio`.DBusConnection.export_action_group].

        It is an error to call this function with an ID that wasn’t returned from
        [method`Gio`.DBusConnection.export_action_group] or to call it with the same
        ID more than once.
        """
    def unexport_menu_model(self, export_id: int) -> None:
        """
            Reverses the effect of a previous call to
        `g_dbus_connection_export_menu_model`.

        It is an error to call this function with an ID that wasn't returned
        from `g_dbus_connection_export_menu_model` or to call it with the
        same ID more than once.
        """
    def unregister_object(self, registration_id: int) -> bool:
        """
        Unregisters an object.
        """
    def unregister_subtree(self, registration_id: int) -> bool:
        """
        Unregisters a subtree.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["closed"],
        handler: typing.Callable[[typing_extensions.Self, bool, GLib.Error | None], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when the connection is closed.

        The cause of this event can be

        - If `g_dbus_connection_close` is called. In this case
          `remote_peer_vanished` is set to False and `error` is None.

        - If the remote peer closes the connection. In this case
          `remote_peer_vanished` is set to True and `error` is set.

        - If the remote peer sends invalid or malformed data. In this
          case `remote_peer_vanished` is set to False and `error` is set.

        Upon receiving this signal, you should give up your reference to
        `connection`. You are guaranteed that this signal is emitted only
        once.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::authentication_observer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::capabilities"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::closed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::exit_on_close"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::guid"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::unique_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusErrorEntry(GObject.GPointer):
    """
    Struct used in `g_dbus_error_register_error_domain`.
    """

    # gi Fields
    dbus_error_name: str = ...
    """
    The D-Bus error name to associate with `error_code`.

    """
    error_code: int = ...
    """
    An error code.

    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusInterface(GObject.GInterface):
    """
    Base type for D-Bus interfaces.

    The `GDBusInterface` type is the base type for D-Bus interfaces both
    on the service side (see [class`Gio`.DBusInterfaceSkeleton]) and client side
    (see [class`Gio`.DBusProxy]).
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_info(self) -> DBusInterfaceInfo:
        """
            Gets D-Bus introspection information for the D-Bus interface
        implemented by `interface_`.
        """
    def get_object(self) -> DBusObject | None:
        """
            Gets the GDBusObject that `interface_` belongs to, if any.

        It is not safe to use the returned object if `interface_` or
        the returned object is being used from other threads. See
        `g_dbus_interface_dup_object` for a thread-safe alternative.
        """
    def set_object(self, object: DBusObject | None = None) -> None:
        """
            Sets the GDBusObject for `interface_` to `object`.

        Note that `interface_` will hold a weak reference to `object`.
        """

class DBusInterfaceIface(GObject.GPointer):
    """
    Base type for D-Bus interfaces.
    """

    # gi Fields
    @builtins.property
    def dup_object(self) -> dup_objectDBusInterfaceIfaceCB | None:
        """
        Gets a reference to the enclosing GDBusObject. See `g_dbus_interface_dup_object`. Added in 2.32.
        """
    @builtins.property
    def get_info(self) -> get_infoDBusInterfaceIfaceCB:
        """
        Returns a GDBusInterfaceInfo. See `g_dbus_interface_get_info`.
        """
    @builtins.property
    def get_object(self) -> get_objectDBusInterfaceIfaceCB | None:
        """
        Gets the enclosing GDBusObject. See `g_dbus_interface_get_object`.
        """
    @builtins.property
    def parent_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def set_object(self) -> set_objectDBusInterfaceIfaceCB:
        """
        Sets the enclosing GDBusObject. See `g_dbus_interface_set_object`.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusInterfaceInfo(GObject.GBoxed):
    """
    Information about a D-Bus interface.
    """

    # gi Fields
    annotations: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusAnnotationInfo structures or None if there are no annotations.

    """
    methods: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusMethodInfo structures or None if there are no methods.

    """
    name: str = ...
    """
    The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".

    """
    properties: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusPropertyInfo structures or None if there are no properties.

    """
    ref_count: int = ...
    """
    The reference count or -1 if statically allocated.

    """
    signals: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusSignalInfo structures or None if there are no signals.

    """

    # gi Methods
    def cache_build(self) -> None:
        """
            Builds a lookup-cache to speed up
        `g_dbus_interface_info_lookup_method`,
        `g_dbus_interface_info_lookup_signal` and
        `g_dbus_interface_info_lookup_property`.

        If this has already been called with `info`, the existing cache is
        used and its use count is increased.

        Note that `info` cannot be modified until
        `g_dbus_interface_info_cache_release` is called.
        """
    def cache_release(self) -> None:
        """
            Decrements the usage count for the cache for `info` built by
        `g_dbus_interface_info_cache_build` (if any) and frees the
        resources used by the cache if the usage count drops to zero.
        """
    def generate_xml(self, indent: int, string_builder: GLib.String) -> None:
        """
            Appends an XML representation of `info` (and its children) to `string_builder`.

        This function is typically used for generating introspection XML
        documents at run-time for handling the
        `org.freedesktop.DBus.Introspectable.Introspect`
        method.
        """
    def lookup_method(self, name: str) -> DBusMethodInfo | None:
        """
            Looks up information about a method.

        The cost of this function is O(n) in number of methods unless
        `g_dbus_interface_info_cache_build` has been used on `info`.
        """
    def lookup_property(self, name: str) -> DBusPropertyInfo | None:
        """
            Looks up information about a property.

        The cost of this function is O(n) in number of properties unless
        `g_dbus_interface_info_cache_build` has been used on `info`.
        """
    def lookup_signal(self, name: str) -> DBusSignalInfo | None:
        """
            Looks up information about a signal.

        The cost of this function is O(n) in number of signals unless
        `g_dbus_interface_info_cache_build` has been used on `info`.
        """
    def ref(self) -> DBusInterfaceInfo:
        """
            If `info` is statically allocated does nothing. Otherwise increases
        the reference count.
        """
    def unref(self) -> None:
        """
            If `info` is statically allocated, does nothing. Otherwise decreases
        the reference count of `info`. When its reference count drops to 0,
        the memory used is freed.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class DBusInterfaceSkeleton(GObject.Object):
    """
    Abstract base class for D-Bus interfaces on the service side.
    """

    class Props(GObject.Object.Props):
        g_flags: DBusInterfaceSkeletonFlags  # [g-flags]: changed because contained invalid characters
        """
        Flags from the GDBusInterfaceSkeletonFlags enumeration.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> DBusInterfaceSkeletonPrivate | None: ...

    # gi Methods
    def __init__(self, g_flags: DBusInterfaceSkeletonFlags = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def export(self, connection: DBusConnection, object_path: str) -> bool:
        """
            Exports `interface_` at `object_path` on `connection`.

        This can be called multiple times to export the same `interface_`
        onto multiple connections however the `object_path` provided must be
        the same for all connections.

        Use `g_dbus_interface_skeleton_unexport` to unexport the object.
        """
    def flush(self) -> None:
        """
            If `interface_` has outstanding changes, request for these changes to be
        emitted immediately.

        For example, an exported D-Bus interface may queue up property
        changes and emit the
        `org.freedesktop.DBus.Properties.PropertiesChanged`
        signal later (e.g. in an idle handler). This technique is useful
        for collapsing multiple property changes into one.
        """
    def get_connection(self) -> DBusConnection | None:
        """
        Gets the first connection that `interface_` is exported on, if any.
        """
    def get_connections(self) -> list:
        """
        Gets a list of the connections that `interface_` is exported on.
        """
    def get_flags(self) -> DBusInterfaceSkeletonFlags:
        """
            Gets the GDBusInterfaceSkeletonFlags that describes what the behavior
        of `interface_`
        """
    def get_info(self) -> DBusInterfaceInfo:
        """
            Gets D-Bus introspection information for the D-Bus interface
        implemented by `interface_`.
        """
    def get_object_path(self) -> str | None:
        """
        Gets the object path that `interface_` is exported on, if any.
        """
    def get_properties(self) -> GLib.Variant:
        """
        Gets all D-Bus properties for `interface_`.
        """
    def get_vtable(self) -> DBusInterfaceVTable:
        """
            Gets the interface vtable for the D-Bus interface implemented by
        `interface_`. The returned function pointers should expect `interface_`
        itself to be passed as `user_data`.
        """
    def has_connection(self, connection: DBusConnection) -> bool:
        """
        Checks if `interface_` is exported on `connection`.
        """
    def set_flags(self, flags: DBusInterfaceSkeletonFlags) -> None:
        """
        Sets flags describing what the behavior of `skeleton` should be.
        """
    def unexport(self) -> None:
        """
            Stops exporting `interface_` on all connections it is exported on.

        To unexport `interface_` from only a single connection, use
        `g_dbus_interface_skeleton_unexport_from_connection`
        """
    def unexport_from_connection(self, connection: DBusConnection) -> None:
        """
            Stops exporting `interface_` on `connection`.

        To stop exporting on all connections the interface is exported on,
        use `g_dbus_interface_skeleton_unexport`.
        """

    # python methods (overrides?)
    def do_flush(
        self,
    ) -> None:
        """
        flush(self)
        """
    def do_g_authorize_method(
        self,
        invocation: DBusMethodInvocation,
    ) -> bool:
        """
        g_authorize_method(self, invocation:Gio.DBusMethodInvocation) -> bool
        """
    def do_get_info(
        self,
    ) -> DBusInterfaceInfo:
        """
        get_info(self) -> Gio.DBusInterfaceInfo
        """
    def do_get_properties(
        self,
    ) -> GLib.Variant:
        """
        get_properties(self) -> GLib.Variant
        """
    def do_get_vtable(
        self,
    ) -> DBusInterfaceVTable:
        """
        get_vtable(self) -> Gio.DBusInterfaceVTable
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["g-authorize-method"],
        handler: typing.Callable[[typing_extensions.Self, DBusMethodInvocation], bool],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when a method is invoked by a remote caller and used to
        determine if the method call is authorized.

        Note that this signal is emitted in a thread dedicated to
        handling the method call so handlers are allowed to perform
        blocking IO. This means that it is appropriate to call e.g.
        [`polkit_authority_check_authorization_sync`](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html#polkit-authority-check-authorization-sync)
        with the
        [POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.htmlPOLKIT-CHECK-AUTHORIZATION-FLAGS-ALLOW-USER-INTERACTION:CAPS)
        flag set.

        If False is returned then no further handlers are run and the
        signal handler must take a reference to `invocation` and finish
        handling the call (e.g. return an error via
        `g_dbus_method_invocation_return_error`).

        Otherwise, if True is returned, signal emission continues. If no
        handlers return False, then the method is dispatched. If
        `interface` has an enclosing GDBusObjectSkeleton, then the
        GDBusObjectSkeleton::authorize-method signal handlers run before
        the handlers for this signal.

        The default class handler just returns True.

        Please note that the common case is optimized: if no signals
        handlers are connected and the default class handler isn't
        overridden (for both `interface` and the enclosing
        GDBusObjectSkeleton, if any) and GDBusInterfaceSkeleton:g-flags does
        not have the
        G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD
        flags set, no dedicated thread is ever used and the call will be
        handled in the same thread as the object that `interface` belongs
        to was exported in.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusInterfaceSkeletonClass(GObject.GPointer):
    """
    Class structure for GDBusInterfaceSkeleton.
    """

    # gi Fields
    @builtins.property
    def flush(self) -> flushDBusInterfaceSkeletonClassCB:
        """
        Emits outstanding changes, if any. See `g_dbus_interface_skeleton_flush`.
        """
    @builtins.property
    def g_authorize_method(self) -> g_authorize_methodDBusInterfaceSkeletonClassCB:
        """
        Signal class handler for the GDBusInterfaceSkeleton::g-authorize-method signal.
        """
    @builtins.property
    def get_info(self) -> get_infoDBusInterfaceSkeletonClassCB:
        """
        Returns a GDBusInterfaceInfo. See `g_dbus_interface_skeleton_get_info` for details.
        """
    @builtins.property
    def get_properties(self) -> get_propertiesDBusInterfaceSkeletonClassCB:
        """
        Returns a GVariant with all properties. See `g_dbus_interface_skeleton_get_properties`.
        """
    @builtins.property
    def get_vtable(self) -> get_vtableDBusInterfaceSkeletonClassCB:
        """
        Returns a GDBusInterfaceVTable. See `g_dbus_interface_skeleton_get_vtable` for details.
        """
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None:
        """
        The parent class.
        """
    @builtins.property
    def signal_padding(self) -> list | None: ...
    @builtins.property
    def vfunc_padding(self) -> list | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusInterfaceSkeletonPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusInterfaceVTable(GObject.GPointer):
    """
    Virtual table for handling properties and method calls for a D-Bus
    interface.

    Since 2.38, if you want to handle getting/setting D-Bus properties
    asynchronously, give None as your `get_property` or `set_property`
    function. The D-Bus call will be directed to your `method_call` function,
    with the provided `interface_name` set to "org.freedesktop.DBus.Properties".

    Ownership of the GDBusMethodInvocation object passed to the
    `method_call` function is transferred to your handler; you must
    call one of the methods of GDBusMethodInvocation to return a reply
    (possibly empty), or an error. These functions also take ownership
    of the passed-in invocation object, so unless the invocation
    object has otherwise been referenced, it will be then be freed.
    Calling one of these functions may be done within your
    `method_call` implementation but it also can be done at a later
    point to handle the method asynchronously.

    The usual checks on the validity of the calls is performed. For
    `Get` calls, an error is automatically returned if the property does
    not exist or the permissions do not allow access. The same checks are
    performed for `Set` calls, and the provided value is also checked for
    being the correct type.

    For both `Get` and `Set` calls, the GDBusMethodInvocation
    passed to the `method_call` handler can be queried with
    `g_dbus_method_invocation_get_property_info` to get a pointer
    to the GDBusPropertyInfo of the property.

    If you have readable properties specified in your interface info,
    you must ensure that you either provide a non-None `get_property`()
    function or provide implementations of both the `Get` and `GetAll`
    methods on org.freedesktop.DBus.Properties interface in your `method_call`
    function. Note that the required return type of the `Get` call is
    `(v)`, not the type of the property. `GetAll` expects a return value
    of type `a{sv}`.

    If you have writable properties specified in your interface info,
    you must ensure that you either provide a non-None `set_property`()
    function or provide an implementation of the `Set` call. If implementing
    the call, you must return the value of type G_VARIANT_TYPE_UNIT.
    """

    # gi Fields
    get_property: DBusInterfaceGetPropertyFuncDBusInterfaceVTableCB = ...
    """
    Function for getting a property.

    """
    method_call: DBusInterfaceMethodCallFuncDBusInterfaceVTableCB = ...
    """
    Function for handling incoming method calls.

    """
    @builtins.property
    def padding(self) -> list | None: ...
    set_property: DBusInterfaceSetPropertyFuncDBusInterfaceVTableCB = ...
    """
    Function for setting a property.

    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusMenuModel(MenuModel):
    """
    `GDBusMenuModel` is an implementation of [class`Gio`.MenuModel] that can be
    used as a proxy for a menu model that is exported over D-Bus with
    [method`Gio`.DBusConnection.export_menu_model].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get(connection: DBusConnection, bus_name: str | None, object_path: str) -> DBusMenuModel:
        """
            Obtains a GDBusMenuModel for the menu model which is exported
        at the given `bus_name` and `object_path`.

        The thread default main context is taken at the time of this call.
        All signals on the menu model (and any linked models) are reported
        with respect to this context.  All calls on the returned menu model
        (and linked models) must also originate from this same context, with
        the thread default main context unchanged.
        """

class DBusMessage(GObject.Object):
    """
    A type for representing D-Bus messages that can be sent or received
    on a [class`Gio`.DBusConnection].
    """

    class Props(GObject.Object.Props):
        locked: bool

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def bytes_needed(blob: list, blob_len: int) -> int:
        """
            Utility function to calculate how many bytes are needed to
        completely deserialize the D-Bus message stored at `blob`.
        """
    def copy(self) -> DBusMessage:
        """
            Copies `message`. The copy is a deep copy and the returned
        GDBusMessage is completely identical except that it is guaranteed
        to not be locked.

        This operation can fail if e.g. `message` contains file descriptors
        and the per-process or system-wide open files limit is reached.
        """
    def get_arg0(self) -> str | None:
        """
            Convenience to get the first item in the body of `message`.

        See [method`Gio`.DBusMessage.get_arg0_path] for returning object-path-typed
        arg0 values.
        """
    def get_arg0_path(self) -> str | None:
        """
            Convenience to get the first item in the body of `message`.

        See [method`Gio`.DBusMessage.get_arg0] for returning string-typed arg0 values.
        """
    def get_body(self) -> GLib.Variant | None:
        """
        Gets the body of a message.
        """
    def get_byte_order(self) -> DBusMessageByteOrder:
        """
        Gets the byte order of `message`.
        """
    def get_destination(self) -> str | None:
        """
        Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
        """
    def get_error_name(self) -> str | None:
        """
        Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
        """
    def get_flags(self) -> DBusMessageFlags:
        """
        Gets the flags for `message`.
        """
    def get_header(self, header_field: DBusMessageHeaderField) -> GLib.Variant | None:
        """
            Gets a header field on `message`.

        The caller is responsible for checking the type of the returned GVariant
        matches what is expected.
        """
    def get_header_fields(self) -> list:
        """
        Gets an array of all header fields on `message` that are set.
        """
    def get_interface(self) -> str | None:
        """
        Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
        """
    @builtins.property
    def get_locked(self) -> bool:
        """
            Checks whether `message` is locked. To monitor changes to this
        value, conncet to the GObject::notify signal to listen for changes
        on the GDBusMessage:locked property.
        """
    def get_member(self) -> str | None:
        """
        Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
        """
    def get_message_type(self) -> DBusMessageType:
        """
        Gets the type of `message`.
        """
    def get_num_unix_fds(self) -> int:
        """
        Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
        """
    def get_path(self) -> str | None:
        """
        Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
        """
    def get_reply_serial(self) -> int:
        """
        Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
        """
    def get_sender(self) -> str | None:
        """
        Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
        """
    def get_serial(self) -> int:
        """
        Gets the serial for `message`.
        """
    def get_signature(self) -> str:
        """
            Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.

        This will always be non-None, but may be an empty string.
        """
    def get_unix_fd_list(self) -> UnixFDList | None:
        """
            Gets the UNIX file descriptors associated with `message`, if any.

        This method is only available on UNIX.

        The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE
        values in the body of the message. For example,
        if `g_variant_get_handle` returns 5, that is intended to be a reference
        to the file descriptor that can be accessed by
        `g_unix_fd_list_get (list, 5, ...)`.
        """
    def lock(self) -> None:
        """
        If `message` is locked, does nothing. Otherwise locks the message.
        """
    @classmethod
    def new(cls) -> DBusMessage:
        """
        Creates a new empty GDBusMessage.
        """
    @classmethod
    def new_from_blob(cls, blob: list, blob_len: int, capabilities: DBusCapabilityFlags) -> DBusMessage:
        """
            Creates a new GDBusMessage from the data stored at `blob`. The byte
        order that the message was in can be retrieved using
        `g_dbus_message_get_byte_order`.

        If the `blob` cannot be parsed, contains invalid fields, or contains invalid
        headers, G_IO_ERROR_INVALID_ARGUMENT will be returned.
        """
    @classmethod
    def new_method_call(cls, name: str | None, path: str, interface_: str | None, method: str) -> DBusMessage:
        """
        Creates a new GDBusMessage for a method call.
        """
    def new_method_error_literal(self, error_name: str, error_message: str) -> DBusMessage:
        """
        Creates a new GDBusMessage that is an error reply to `method_call_message`.
        """
    def new_method_reply(self) -> DBusMessage:
        """
        Creates a new GDBusMessage that is a reply to `method_call_message`.
        """
    @classmethod
    def new_signal(cls, path: str, interface_: str, signal: str) -> DBusMessage:
        """
        Creates a new GDBusMessage for a signal emission.
        """
    def print_(self, indent: int) -> str: ...
    def set_body(self, body: GLib.Variant) -> None:
        """
            Sets the body `message`. As a side-effect the
        G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the
        type string of `body` (or cleared if `body` is None).

        If `body` is floating, `message` assumes ownership of `body`.
        """
    def set_byte_order(self, byte_order: DBusMessageByteOrder) -> None:
        """
        Sets the byte order of `message`.
        """
    def set_destination(self, value: str | None = None) -> None:
        """
        Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
        """
    def set_error_name(self, value: str) -> None:
        """
        Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
        """
    def set_flags(self, flags: DBusMessageFlags) -> None:
        """
        Sets the flags to set on `message`.
        """
    def set_header(self, header_field: DBusMessageHeaderField, value: GLib.Variant | None = None) -> None:
        """
            Sets a header field on `message`.

        If `value` is floating, `message` assumes ownership of `value`.
        """
    def set_interface(self, value: str | None = None) -> None:
        """
        Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
        """
    def set_member(self, value: str | None = None) -> None:
        """
        Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
        """
    def set_message_type(self, type: DBusMessageType) -> None:
        """
        Sets `message` to be of `type`.
        """
    def set_num_unix_fds(self, value: int) -> None:
        """
        Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
        """
    def set_path(self, value: str | None = None) -> None:
        """
        Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
        """
    def set_reply_serial(self, value: int) -> None:
        """
        Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
        """
    def set_sender(self, value: str | None = None) -> None:
        """
        Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
        """
    def set_serial(self, serial: int) -> None:
        """
            Sets the serial for `message`.

        The [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-messages)
        does not allow the `serial` to be zero.
        """
    def set_signature(self, value: str | None = None) -> None:
        """
        Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
        """
    def set_unix_fd_list(self, fd_list: UnixFDList | None = None) -> None:
        """
            Sets the UNIX file descriptors associated with `message`. As a
        side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header
        field is set to the number of fds in `fd_list` (or cleared if
        `fd_list` is None).

        This method is only available on UNIX.

        When designing D-Bus APIs that are intended to be interoperable,
        please note that non-GDBus implementations of D-Bus can usually only
        access file descriptors if they are referenced by a value of type
        G_VARIANT_TYPE_HANDLE in the body of the message.
        """
    def to_blob(self, capabilities: DBusCapabilityFlags) -> tuple[list, int]:
        """
            Serializes `message` to a blob. The byte order returned by
        `g_dbus_message_get_byte_order` will be used.
        """
    def to_gerror(self) -> bool:
        """
            If `message` is not of type G_DBUS_MESSAGE_TYPE_ERROR does
        nothing and returns False.

        Otherwise this method encodes the error in `message` as a GError
        using `g_dbus_error_set_dbus_error` using the information in the
        G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of `message` as
        well as the first string item in `message`'s body.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::locked"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusMethodInfo(GObject.GBoxed):
    """
    Information about a method on a D-Bus interface.
    """

    # gi Fields
    annotations: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusAnnotationInfo structures or None if there are no annotations.

    """
    in_args: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusArgInfo structures or None if there are no in arguments.

    """
    name: str = ...
    """
    The name of the D-Bus method, e.g. `RequestName`.

    """
    out_args: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusArgInfo structures or None if there are no out arguments.

    """
    ref_count: int = ...
    """
    The reference count or -1 if statically allocated.

    """

    # gi Methods
    def ref(self) -> DBusMethodInfo:
        """
            If `info` is statically allocated does nothing. Otherwise increases
        the reference count.
        """
    def unref(self) -> None:
        """
            If `info` is statically allocated, does nothing. Otherwise decreases
        the reference count of `info`. When its reference count drops to 0,
        the memory used is freed.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class DBusMethodInvocation(GObject.Object):
    """
    Instances of the `GDBusMethodInvocation` class are used when
    handling D-Bus method calls. It provides a way to asynchronously
    return results and errors.

    The normal way to obtain a `GDBusMethodInvocation` object is to receive
    it as an argument to the ``handle_method_call`` function in a
    [type`Gio`.DBusInterfaceVTable] that was passed to
    [method`Gio`.DBusConnection.register_object].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_connection(self) -> DBusConnection:
        """
        Gets the GDBusConnection the method was invoked on.
        """
    def get_interface_name(self) -> str | None:
        """
            Gets the name of the D-Bus interface the method was invoked on.

        This can be `None` if it was not specified by the sender. See
        [callback`Gio`.DBusInterfaceMethodCallFunc] or the
        [D-Bus Specification](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-types-method)
        for details on when this can happen and how it should be handled.

        If this method call is a property Get, Set or GetAll call that has
        been redirected to the method call handler then
        "org.freedesktop.DBus.Properties" will be returned.  See
        GDBusInterfaceVTable for more information.
        """
    def get_message(self) -> DBusMessage:
        """
            Gets the GDBusMessage for the method invocation. This is useful if
        you need to use low-level protocol features, such as UNIX file
        descriptor passing, that cannot be properly expressed in the
        GVariant API.

        See this [server][class`Gio`.DBusConnection#an-example-d-bus-server]
        and [client][class`Gio`.DBusConnection#an-example-for-file-descriptor-passing]
        for an example of how to use this low-level API to send and receive
        UNIX file descriptors.
        """
    def get_method_info(self) -> DBusMethodInfo | None:
        """
            Gets information about the method call, if any.

        If this method invocation is a property Get, Set or GetAll call that
        has been redirected to the method call handler then None will be
        returned.  See `g_dbus_method_invocation_get_property_info` and
        GDBusInterfaceVTable for more information.
        """
    def get_method_name(self) -> str:
        """
        Gets the name of the method that was invoked.
        """
    def get_object_path(self) -> str:
        """
        Gets the object path the method was invoked on.
        """
    def get_parameters(self) -> GLib.Variant:
        """
            Gets the parameters of the method invocation. If there are no input
        parameters then this will return a GVariant with 0 children rather than None.
        """
    def get_property_info(self) -> DBusPropertyInfo | None:
        """
            Gets information about the property that this method call is for, if
        any.

        This will only be set in the case of an invocation in response to a
        property Get or Set call that has been directed to the method call
        handler for an object on account of its `property_get` or
        `property_set` vtable pointers being unset.

        See GDBusInterfaceVTable for more information.

        If the call was GetAll, None will be returned.
        """
    def get_sender(self) -> str | None:
        """
            Gets the bus name that invoked the method.

        This can return None if not specified by the caller, e.g. on peer-to-peer
        connections.
        """
    def return_dbus_error(self, error_name: str, error_message: str) -> None:
        """
            Finishes handling a D-Bus method call by returning an error.

        This method will take ownership of `invocation`. See
        GDBusInterfaceVTable for more information about the ownership of
        `invocation`.
        """
    def return_error_literal(self, domain: int, code: int, message: str) -> None:
        """
            Like `g_dbus_method_invocation_return_error` but without `printf`-style formatting.

        This method will take ownership of `invocation`. See
        GDBusInterfaceVTable for more information about the ownership of
        `invocation`.
        """
    def return_gerror(self, error: GLib.Error) -> None:
        """
            Like `g_dbus_method_invocation_return_error` but takes a GError
        instead of the error domain, error code and message.

        This method will take ownership of `invocation`. See
        GDBusInterfaceVTable for more information about the ownership of
        `invocation`.
        """
    def return_value(self, parameters: GLib.Variant | None = None) -> None:
        """
            Finishes handling a D-Bus method call by returning `parameters`.
        If the `parameters` GVariant is floating, it is consumed.

        It is an error if `parameters` is not of the right format: it must be a tuple
        containing the out-parameters of the D-Bus method. Even if the method has a
        single out-parameter, it must be contained in a tuple. If the method has no
        out-parameters, `parameters` may be None or an empty tuple.

        |[<!-- language="C" -->
        GDBusMethodInvocation *invocation = some_invocation;
        g_autofree gchar *result_string = None;
        g_autoptr (GError) error = None;

        result_string = calculate_result (&error);

        if (error != None)
          g_dbus_method_invocation_return_gerror (invocation, error);
        else
          g_dbus_method_invocation_return_value (invocation,
                                                 g_variant_new ("(s)", result_string));

        // Do not free `invocation` here; returning a value does that
        ]|

        This method will take ownership of `invocation`. See
        GDBusInterfaceVTable for more information about the ownership of
        `invocation`.

        Since 2.48, if the method call requested for a reply not to be sent
        then this call will sink `parameters` and free `invocation`, but
        otherwise do nothing (as per the recommendations of the D-Bus
        specification).
        """
    def return_value_with_unix_fd_list(
        self, parameters: GLib.Variant | None = None, fd_list: UnixFDList | None = None
    ) -> None:
        """
            Like `g_dbus_method_invocation_return_value` but also takes a GUnixFDList.

        This method is only available on UNIX.

        This method will take ownership of `invocation`. See
        GDBusInterfaceVTable for more information about the ownership of
        `invocation`.
        """

class DBusNodeInfo(GObject.GBoxed):
    """
    Information about nodes in a remote object hierarchy.
    """

    # gi Fields
    annotations: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusAnnotationInfo structures or None if there are no annotations.

    """
    interfaces: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusInterfaceInfo structures or None if there are no interfaces.

    """
    nodes: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusNodeInfo structures or None if there are no nodes.

    """
    path: str = ...
    """
    The path of the node or None if omitted. Note that this may be a relative path. See the D-Bus specification for more details.

    """
    ref_count: int = ...
    """
    The reference count or -1 if statically allocated.

    """

    # gi Methods
    def generate_xml(self, indent: int, string_builder: GLib.String) -> None:
        """
            Appends an XML representation of `info` (and its children) to `string_builder`.

        This function is typically used for generating introspection XML documents at run-time for
        handling the `org.freedesktop.DBus.Introspectable.Introspect`  method.
        """
    def lookup_interface(self, name: str) -> DBusInterfaceInfo | None:
        """
            Looks up information about an interface.

        The cost of this function is O(n) in number of interfaces.
        """
    @classmethod
    def new_for_xml(cls, xml_data: str) -> DBusNodeInfo:
        """
            Parses `xml_data` and returns a GDBusNodeInfo representing the data.

        The introspection XML must contain exactly one top-level
        `<node>` element.

        Note that this routine is using a
        [GMarkup](../glib/markup.html)-based
        parser that only accepts a subset of valid XML documents.
        """
    def ref(self) -> DBusNodeInfo:
        """
            If `info` is statically allocated does nothing. Otherwise increases
        the reference count.
        """
    def unref(self) -> None:
        """
            If `info` is statically allocated, does nothing. Otherwise decreases
        the reference count of `info`. When its reference count drops to 0,
        the memory used is freed.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class DBusObject(GObject.GInterface):
    """
    The `GDBusObject` type is the base type for D-Bus objects on both
    the service side (see [class`Gio`.DBusObjectSkeleton]) and the client side
    (see [class`Gio`.DBusObjectProxy]). It is essentially just a container of
    interfaces.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_interface(self, interface_name: str) -> DBusInterface | None:
        """
            Gets the D-Bus interface with name `interface_name` associated with
        `object`, if any.
        """
    def get_interfaces(self) -> list:
        """
        Gets the D-Bus interfaces associated with `object`.
        """
    def get_object_path(self) -> str:
        """
        Gets the object path for `object`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-added"],
        handler: typing.Callable[[typing_extensions.Self, DBusInterface], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when `interface` is added to `object`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-removed"],
        handler: typing.Callable[[typing_extensions.Self, DBusInterface], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when `interface` is removed from `object`.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusObjectIface(GObject.GPointer):
    """
    Base object type for D-Bus objects.
    """

    # gi Fields
    @builtins.property
    def get_interface(self) -> get_interfaceDBusObjectIfaceCB | None:
        """
        Returns an interface by name. See `g_dbus_object_get_interface`.
        """
    @builtins.property
    def get_interfaces(self) -> get_interfacesDBusObjectIfaceCB:
        """
        Returns all interfaces. See `g_dbus_object_get_interfaces`.
        """
    @builtins.property
    def get_object_path(self) -> get_object_pathDBusObjectIfaceCB:
        """
        Returns the object path. See `g_dbus_object_get_object_path`.
        """
    @builtins.property
    def interface_added(self) -> interface_addedDBusObjectIfaceCB:
        """
        Signal handler for the GDBusObject::interface-added signal.
        """
    @builtins.property
    def interface_removed(self) -> interface_removedDBusObjectIfaceCB:
        """
        Signal handler for the GDBusObject::interface-removed signal.
        """
    @builtins.property
    def parent_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusObjectManager(GObject.GInterface):
    """
    The `GDBusObjectManager` type is the base type for service- and
    client-side implementations of the standardized
    [`org.freedesktop.DBus.ObjectManager`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
    interface.

    See [class`Gio`.DBusObjectManagerClient] for the client-side implementation
    and [class`Gio`.DBusObjectManagerServer] for the service-side implementation.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_interface(self, object_path: str, interface_name: str) -> DBusInterface | None:
        """
            Gets the interface proxy for `interface_name` at `object_path`, if
        any.
        """
    def get_object(self, object_path: str) -> DBusObject | None:
        """
        Gets the GDBusObject at `object_path`, if any.
        """
    def get_object_path(self) -> str:
        """
        Gets the object path that `manager` is for.
        """
    def get_objects(self) -> list:
        """
        Gets all GDBusObject objects known to `manager`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-added"],
        handler: typing.Callable[[typing_extensions.Self, DBusObject, DBusInterface], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when `interface` is added to `object`.

        This signal exists purely as a convenience to avoid having to
        connect signals to all objects managed by `manager`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-removed"],
        handler: typing.Callable[[typing_extensions.Self, DBusObject, DBusInterface], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when `interface` has been removed from `object`.

        This signal exists purely as a convenience to avoid having to
        connect signals to all objects managed by `manager`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["object-added"],
        handler: typing.Callable[[typing_extensions.Self, DBusObject], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when `object` is added to `manager`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["object-removed"],
        handler: typing.Callable[[typing_extensions.Self, DBusObject], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when `object` is removed from `manager`.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusObjectManagerClient(GObject.Object):
    """
    `GDBusObjectManagerClient` is used to create, monitor and delete object
    proxies for remote objects exported by a [class`Gio`.DBusObjectManagerServer]
    (or any code implementing the
    [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
    interface).

    Once an instance of this type has been created, you can connect to
    the [signal`Gio`.DBusObjectManager::object-added] and
    [signal`Gio`.DBusObjectManager::object-removed signals] and inspect the
    [class`Gio`.DBusObjectProxy] objects returned by
    [method`Gio`.DBusObjectManager.get_objects].

    If the name for a `GDBusObjectManagerClient` is not owned by anyone at
    object construction time, the default behavior is to request the
    message bus to launch an owner for the name. This behavior can be
    disabled using the `G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START`
    flag. It’s also worth noting that this only works if the name of
    interest is activatable in the first place. E.g. in some cases it
    is not possible to launch an owner for the requested name. In this
    case, `GDBusObjectManagerClient` object construction still succeeds but
    there will be no object proxies
    (e.g. [method`Gio`.DBusObjectManager.get_objects] returns the empty list) and
    the [property`Gio`.DBusObjectManagerClient:name-owner] property is `None`.

    The owner of the requested name can come and go (for example
    consider a system service being restarted) – `GDBusObjectManagerClient`
    handles this case too; simply connect to the [signal`GObject`.Object::notify]
    signal to watch for changes on the
    [property`Gio`.DBusObjectManagerClient:name-owner] property. When the name
    owner vanishes, the behavior is that
    [property`Gio`.DBusObjectManagerClient:name-owner] is set to `None` (this
    includes emission of the [signal`GObject`.Object::notify] signal) and then
    [signal`Gio`.DBusObjectManager::object-removed] signals are synthesized
    for all currently existing object proxies. Since
    [property`Gio`.DBusObjectManagerClient:name-owner] is `None` when this
    happens, you can use this information to disambiguate a synthesized signal
    from a genuine signal caused by object removal on the remote
    [iface`Gio`.DBusObjectManager]. Similarly, when a new name owner appears,
    [signal`Gio`.DBusObjectManager::object-added] signals are synthesized
    while [property`Gio`.DBusObjectManagerClient:name-owner] is still `None`. Only
    when all object proxies have been added, the
    [property`Gio`.DBusObjectManagerClient:name-owner] is set to the new name
    owner (this includes emission of the [signal`GObject`.Object::notify] signal).
    Furthermore, you are guaranteed that
    [property`Gio`.DBusObjectManagerClient:name-owner] will alternate between a
    name owner (e.g. `:1.42`) and `None` even in the case where
    the name of interest is atomically replaced

    Ultimately, `GDBusObjectManagerClient` is used to obtain
    [class`Gio`.DBusProxy] instances. All signals (including the
    `org.freedesktop.DBus.Properties::PropertiesChanged` signal)
    delivered to [class`Gio`.DBusProxy] instances are guaranteed to originate
    from the name owner. This guarantee along with the behavior
    described above, means that certain race conditions including the
    “half the proxy is from the old owner and the other half is from
    the new owner” problem cannot happen.

    To avoid having the application connect to signals on the returned
    [class`Gio`.DBusObjectProxy] and [class`Gio`.DBusProxy] objects, the
    [signal`Gio`.DBusObject::interface-added],
    [signal`Gio`.DBusObject::interface-removed],
    [signal`Gio`.DBusProxy::g-properties-changed] and
    [signal`Gio`.DBusProxy::g-signal] signals
    are also emitted on the `GDBusObjectManagerClient` instance managing these
    objects. The signals emitted are
    [signal`Gio`.DBusObjectManager::interface-added],
    [signal`Gio`.DBusObjectManager::interface-removed],
    [signal`Gio`.DBusObjectManagerClient::interface-proxy-properties-changed] and
    [signal`Gio`.DBusObjectManagerClient::interface-proxy-signal].

    Note that all callbacks and signals are emitted in the
    thread-default main context (see
    [method`GLib`.MainContext.push_thread_default]) that the
    `GDBusObjectManagerClient` object was constructed in. Additionally, the
    [class`Gio`.DBusObjectProxy] and [class`Gio`.DBusProxy] objects
    originating from the `GDBusObjectManagerClient` object will be created in
    the same context and, consequently, will deliver signals in the
    same main loop.
    """

    class Props(GObject.Object.Props):
        bus_type: BusType  # [bus-type]: changed because contained invalid characters
        """
        If this property is not G_BUS_TYPE_NONE, then
        GDBusObjectManagerClient:connection must be None and will be set to the
        GDBusConnection obtained by calling `g_bus_get` with the value
        of this property.
        """
        connection: DBusConnection | None
        """
        The GDBusConnection to use.
        """
        flags: DBusObjectManagerClientFlags
        """
        Flags from the GDBusObjectManagerClientFlags enumeration.
        """
        get_proxy_type_destroy_notify: (
            object | None
        )  # [get-proxy-type-destroy-notify]: changed because contained invalid characters
        """
        A GDestroyNotify for the #gpointer user_data in GDBusObjectManagerClient:get-proxy-type-user-data.
        """
        get_proxy_type_func: object | None  # [get-proxy-type-func]: changed because contained invalid characters
        """
        The GDBusProxyTypeFunc to use when determining what GType to
        use for interface proxies or None.
        """
        get_proxy_type_user_data: (
            object | None
        )  # [get-proxy-type-user-data]: changed because contained invalid characters
        """
        The #gpointer user_data to pass to GDBusObjectManagerClient:get-proxy-type-func.
        """
        name: str
        """
        The well-known name or unique name that the manager is for.
        """
        name_owner: str  # [name-owner]: changed because contained invalid characters
        """
        The unique name that owns GDBusObjectManagerClient:name or None if
        no-one is currently owning the name. Connect to the
        GObject::notify signal to track changes to this property.
        """
        object_path: str  # [object-path]: changed because contained invalid characters
        """
        The object path the manager is for.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> DBusObjectManagerClientPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        bus_type: BusType = ...,
        connection: DBusConnection | None = ...,
        flags: DBusObjectManagerClientFlags = ...,
        get_proxy_type_destroy_notify: object | None = ...,
        get_proxy_type_func: object | None = ...,
        get_proxy_type_user_data: object | None = ...,
        name: str = ...,
        object_path: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_connection(self) -> DBusConnection:
        """
        Gets the GDBusConnection used by `manager`.
        """
    @builtins.property
    def get_flags(self) -> DBusObjectManagerClientFlags:
        """
        Gets the flags that `manager` was constructed with.
        """
    @builtins.property
    def get_name(self) -> str:
        """
            Gets the name that `manager` is for, or None if not a message bus
        connection.
        """
    @builtins.property
    def get_name_owner(self) -> str | None:
        """
            The unique name that owns the name that `manager` is for or None if
        no-one currently owns that name. You can connect to the
        GObject::notify signal to track changes to the
        GDBusObjectManagerClient:name-owner property.
        """
    @staticmethod
    async def new(
        connection: DBusConnection,
        flags: DBusObjectManagerClientFlags,
        name: str,
        object_path: str,
        get_proxy_type_func: DBusProxyTypeFunc | None | typing.Callable[..., GObject.GType] = None,
        get_proxy_type_user_data: object | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously creates a new GDBusObjectManagerClient object.

        This is an asynchronous failable constructor. When the result is
        ready, `callback` will be invoked in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from. You can then call
        `g_dbus_object_manager_client_new_finish` to get the result. See
        `g_dbus_object_manager_client_new_sync` for the synchronous version.
        """
    @classmethod
    def new_finish(cls, res: AsyncResult) -> DBusObjectManagerClient:
        """
        Finishes an operation started with `g_dbus_object_manager_client_new`.
        """
    @staticmethod
    async def new_for_bus(
        bus_type: BusType,
        flags: DBusObjectManagerClientFlags,
        name: str,
        object_path: str,
        get_proxy_type_func: DBusProxyTypeFunc | None | typing.Callable[..., GObject.GType] = None,
        get_proxy_type_user_data: object | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Like `g_dbus_object_manager_client_new` but takes a GBusType instead of a
        GDBusConnection.

        This is an asynchronous failable constructor. When the result is
        ready, `callback` will be invoked in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from. You can
        then call `g_dbus_object_manager_client_new_for_bus_finish` to get the result. See
        `g_dbus_object_manager_client_new_for_bus_sync` for the synchronous version.
        """
    @classmethod
    def new_for_bus_finish(cls, res: AsyncResult) -> DBusObjectManagerClient:
        """
        Finishes an operation started with `g_dbus_object_manager_client_new_for_bus`.
        """
    @classmethod
    def new_for_bus_sync(
        cls,
        bus_type: BusType,
        flags: DBusObjectManagerClientFlags,
        name: str,
        object_path: str,
        get_proxy_type_func: DBusProxyTypeFunc | None | typing.Callable[..., GObject.GType] = None,
        *get_proxy_type_user_data: object | None,
        cancellable: Cancellable | None = None,
    ) -> DBusObjectManagerClient:
        """
            Like `g_dbus_object_manager_client_new_sync` but takes a GBusType instead
        of a GDBusConnection.

        This is a synchronous failable constructor - the calling thread is
        blocked until a reply is received. See `g_dbus_object_manager_client_new_for_bus`
        for the asynchronous version.
        """
    @classmethod
    def new_sync(
        cls,
        connection: DBusConnection,
        flags: DBusObjectManagerClientFlags,
        name: str | None,
        object_path: str,
        get_proxy_type_func: DBusProxyTypeFunc | None | typing.Callable[..., GObject.GType] = None,
        *get_proxy_type_user_data: object | None,
        cancellable: Cancellable | None = None,
    ) -> DBusObjectManagerClient:
        """
            Creates a new GDBusObjectManagerClient object.

        This is a synchronous failable constructor - the calling thread is
        blocked until a reply is received. See `g_dbus_object_manager_client_new`
        for the asynchronous version.
        """

    # python methods (overrides?)
    def do_interface_proxy_properties_changed(
        self,
        object_proxy: DBusObjectProxy,
        interface_proxy: DBusProxy,
        changed_properties: GLib.Variant,
        invalidated_properties: str,
    ) -> None:
        """
        interface_proxy_properties_changed(self, object_proxy:Gio.DBusObjectProxy, interface_proxy:Gio.DBusProxy, changed_properties:GLib.Variant, invalidated_properties:str)
        """
    def do_interface_proxy_signal(
        self,
        object_proxy: DBusObjectProxy,
        interface_proxy: DBusProxy,
        sender_name: str,
        signal_name: str,
        parameters: GLib.Variant,
    ) -> None:
        """
        interface_proxy_signal(self, object_proxy:Gio.DBusObjectProxy, interface_proxy:Gio.DBusProxy, sender_name:str, signal_name:str, parameters:GLib.Variant)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-proxy-properties-changed"],
        handler: typing.Callable[[typing_extensions.Self, DBusObjectProxy, DBusProxy, GLib.Variant, list], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when one or more D-Bus properties on proxy changes. The
        local cache has already been updated when this signal fires. Note
        that both `changed_properties` and `invalidated_properties` are
        guaranteed to never be None (either may be empty though).

        This signal exists purely as a convenience to avoid having to
        connect signals to all interface proxies managed by `manager`.

        This signal is emitted in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        that `manager` was constructed in.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["interface-proxy-signal"],
        handler: typing.Callable[[typing_extensions.Self, DBusObjectProxy, DBusProxy, str, str, GLib.Variant], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when a D-Bus signal is received on `interface_proxy`.

        This signal exists purely as a convenience to avoid having to
        connect signals to all interface proxies managed by `manager`.

        This signal is emitted in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        that `manager` was constructed in.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::bus_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::get_proxy_type_destroy_notify"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::get_proxy_type_func"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::get_proxy_type_user_data"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name_owner"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusObjectManagerClientClass(GObject.GPointer):
    """
    Class structure for GDBusObjectManagerClient.
    """

    # gi Fields
    @builtins.property
    def interface_proxy_properties_changed(self) -> interface_proxy_properties_changedDBusObjectManagerClientClassCB:
        """
        Signal class handler for the GDBusObjectManagerClient::interface-proxy-properties-changed signal.
        """
    @builtins.property
    def interface_proxy_signal(self) -> interface_proxy_signalDBusObjectManagerClientClassCB:
        """
        Signal class handler for the GDBusObjectManagerClient::interface-proxy-signal signal.
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None:
        """
        The parent class.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusObjectManagerClientPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusObjectManagerIface(GObject.GPointer):
    """
    Base type for D-Bus object managers.
    """

    # gi Fields
    @builtins.property
    def get_interface(self) -> get_interfaceDBusObjectManagerIfaceCB | None:
        """
        Virtual function for `g_dbus_object_manager_get_interface`.
        """
    @builtins.property
    def get_object(self) -> get_objectDBusObjectManagerIfaceCB | None:
        """
        Virtual function for `g_dbus_object_manager_get_object`.
        """
    @builtins.property
    def get_object_path(self) -> get_object_pathDBusObjectManagerIfaceCB:
        """
        Virtual function for `g_dbus_object_manager_get_object_path`.
        """
    @builtins.property
    def get_objects(self) -> get_objectsDBusObjectManagerIfaceCB:
        """
        Virtual function for `g_dbus_object_manager_get_objects`.
        """
    @builtins.property
    def interface_added(self) -> interface_addedDBusObjectManagerIfaceCB:
        """
        Signal handler for the GDBusObjectManager::interface-added signal.
        """
    @builtins.property
    def interface_removed(self) -> interface_removedDBusObjectManagerIfaceCB:
        """
        Signal handler for the GDBusObjectManager::interface-removed signal.
        """
    @builtins.property
    def object_added(self) -> object_addedDBusObjectManagerIfaceCB:
        """
        Signal handler for the GDBusObjectManager::object-added signal.
        """
    @builtins.property
    def object_removed(self) -> object_removedDBusObjectManagerIfaceCB:
        """
        Signal handler for the GDBusObjectManager::object-removed signal.
        """
    @builtins.property
    def parent_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusObjectManagerServer(GObject.Object):
    """
    `GDBusObjectManagerServer` is used to export [iface`Gio`.DBusObject] instances
    using the standardized
    [`org.freedesktop.DBus.ObjectManager`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
    interface. For example, remote D-Bus clients can get all objects
    and properties in a single call. Additionally, any change in the
    object hierarchy is broadcast using signals. This means that D-Bus
    clients can keep caches up to date by only listening to D-Bus
    signals.

    The recommended path to export an object manager at is the path form of the
    well-known name of a D-Bus service, or below. For example, if a D-Bus service
    is available at the well-known name `net.example.ExampleService1`, the object
    manager should typically be exported at `/net/example/ExampleService1`, or
    below (to allow for multiple object managers in a service).

    It is supported, but not recommended, to export an object manager at the root
    path, `/`.

    See [class`Gio`.DBusObjectManagerClient] for the client-side code that is
    intended to be used with `GDBusObjectManagerServer` or any D-Bus
    object implementing the `org.freedesktop.DBus.ObjectManager` interface.
    """

    class Props(GObject.Object.Props):
        connection: DBusConnection | None
        """
        The GDBusConnection to export objects on.
        """
        object_path: str  # [object-path]: changed because contained invalid characters
        """
        The object path to register the manager object at.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> DBusObjectManagerServerPrivate | None: ...

    # gi Methods
    def __init__(self, connection: DBusConnection | None = ..., object_path: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def export(self, object: DBusObjectSkeleton) -> None:
        """
            Exports `object` on `manager`.

        If there is already a GDBusObject exported at the object path,
        then the old object is removed.

        The object path for `object` must be in the hierarchy rooted by the
        object path for `manager`.

        Note that `manager` will take a reference on `object` for as long as
        it is exported.
        """
    def export_uniquely(self, object: DBusObjectSkeleton) -> None:
        """
            Like `g_dbus_object_manager_server_export` but appends a string of
        the form _N (with N being a natural number) to `object`'s object path
        if an object with the given path already exists. As such, the
        GDBusObjectProxy:g-object-path property of `object` may be modified.
        """
    @builtins.property
    def get_connection(self) -> DBusConnection | None:
        """
        Gets the GDBusConnection used by `manager`.
        """
    def is_exported(self, object: DBusObjectSkeleton) -> bool:
        """
        Returns whether `object` is currently exported on `manager`.
        """
    @classmethod
    def new(cls, object_path: str) -> DBusObjectManagerServer:
        """
            Creates a new GDBusObjectManagerServer object.

        The returned server isn't yet exported on any connection. To do so,
        use `g_dbus_object_manager_server_set_connection`. Normally you
        want to export all of your objects before doing so to avoid
        [InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
        signals being emitted.
        """
    def set_connection(self, connection: DBusConnection | None = None) -> None:
        """
            Exports all objects managed by `manager` on `connection`. If
        `connection` is None, stops exporting objects.
        """
    def unexport(self, object_path: str) -> bool:
        """
            If `manager` has an object at `path`, removes the object. Otherwise
        does nothing.

        Note that `object_path` must be in the hierarchy rooted by the
        object path for `manager`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusObjectManagerServerClass(GObject.GPointer):
    """
    Class structure for GDBusObjectManagerServer.
    """

    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None:
        """
        The parent class.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusObjectManagerServerPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusObjectProxy(GObject.Object):
    """
    A `GDBusObjectProxy` is an object used to represent a remote object
    with one or more D-Bus interfaces. Normally, you don’t instantiate
    a `GDBusObjectProxy` yourself — typically [class`Gio`.DBusObjectManagerClient]
    is used to obtain it.
    """

    class Props(GObject.Object.Props):
        g_connection: DBusConnection | None  # [g-connection]: changed because contained invalid characters
        """
        The connection of the proxy.
        """
        g_object_path: str  # [g-object-path]: changed because contained invalid characters
        """
        The object path of the proxy.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> DBusObjectProxyPrivate | None: ...

    # gi Methods
    def __init__(self, g_connection: DBusConnection | None = ..., g_object_path: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_connection(self) -> DBusConnection:
        """
        Gets the connection that `proxy` is for.
        """
    @classmethod
    def new(cls, connection: DBusConnection, object_path: str) -> DBusObjectProxy:
        """
            Creates a new GDBusObjectProxy for the given connection and
        object path.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusObjectProxyClass(GObject.GPointer):
    """
    Class structure for GDBusObjectProxy.
    """

    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None:
        """
        The parent class.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusObjectProxyPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusObjectSkeleton(GObject.Object):
    """
    A `GDBusObjectSkeleton` instance is essentially a group of D-Bus
    interfaces. The set of exported interfaces on the object may be
    dynamic and change at runtime.

    This type is intended to be used with [iface`Gio`.DBusObjectManager].
    """

    class Props(GObject.Object.Props):
        g_object_path: str  # [g-object-path]: changed because contained invalid characters
        """
        The object path where the object is exported.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> DBusObjectSkeletonPrivate | None: ...

    # gi Methods
    def __init__(self, g_object_path: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_interface(self, interface_: DBusInterfaceSkeleton) -> None:
        """
            Adds `interface_` to `object`.

        If `object` already contains a GDBusInterfaceSkeleton with the same
        interface name, it is removed before `interface_` is added.

        Note that `object` takes its own reference on `interface_` and holds
        it until removed.
        """
    def flush(self) -> None:
        """
            This method simply calls `g_dbus_interface_skeleton_flush` on all
        interfaces belonging to `object`. See that method for when flushing
        is useful.
        """
    @classmethod
    def new(cls, object_path: str) -> DBusObjectSkeleton:
        """
        Creates a new GDBusObjectSkeleton.
        """
    def remove_interface(self, interface_: DBusInterfaceSkeleton) -> None:
        """
        Removes `interface_` from `object`.
        """
    def remove_interface_by_name(self, interface_name: str) -> None:
        """
            Removes the GDBusInterface with `interface_name` from `object`.

        If no D-Bus interface of the given interface exists, this function
        does nothing.
        """
    def set_object_path(self, object_path: str) -> None:
        """
        Sets the object path for `object`.
        """

    # python methods (overrides?)
    def do_authorize_method(
        self,
        interface_: DBusInterfaceSkeleton,
        invocation: DBusMethodInvocation,
    ) -> bool:
        """
        authorize_method(self, interface_:Gio.DBusInterfaceSkeleton, invocation:Gio.DBusMethodInvocation) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["authorize-method"],
        handler: typing.Callable[[typing_extensions.Self, DBusInterfaceSkeleton, DBusMethodInvocation], bool],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when a method is invoked by a remote caller and used to
        determine if the method call is authorized.

        This signal is like GDBusInterfaceSkeleton's
        GDBusInterfaceSkeleton::g-authorize-method signal,
        except that it is for the enclosing object.

        The default class handler just returns True.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusObjectSkeletonClass(GObject.GPointer):
    """
    Class structure for GDBusObjectSkeleton.
    """

    # gi Fields
    @builtins.property
    def authorize_method(self) -> authorize_methodDBusObjectSkeletonClassCB:
        """
        Signal class handler for the GDBusObjectSkeleton::authorize-method signal.
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None:
        """
        The parent class.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusObjectSkeletonPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusPropertyInfo(GObject.GBoxed):
    """
    Information about a D-Bus property on a D-Bus interface.
    """

    # gi Fields
    annotations: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusAnnotationInfo structures or None if there are no annotations.

    """
    flags: DBusPropertyInfoFlags = ...
    """
    Access control flags for the property.

    """
    name: str = ...
    """
    The name of the D-Bus property, e.g. "SupportedFilesystems".

    """
    ref_count: int = ...
    """
    The reference count or -1 if statically allocated.

    """
    signature: str = ...
    """
    The D-Bus signature of the property (a single complete type).

    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def ref(self) -> DBusPropertyInfo:
        """
            If `info` is statically allocated does nothing. Otherwise increases
        the reference count.
        """
    def unref(self) -> None:
        """
            If `info` is statically allocated, does nothing. Otherwise decreases
        the reference count of `info`. When its reference count drops to 0,
        the memory used is freed.
        """

class DBusProxy(GObject.Object):
    """
    `GDBusProxy` is a base class used for proxies to access a D-Bus
    interface on a remote object. A `GDBusProxy` can be constructed for
    both well-known and unique names.

    By default, `GDBusProxy` will cache all properties (and listen to
    changes) of the remote object, and proxy all signals that get
    emitted. This behaviour can be changed by passing suitable
    [flags`Gio`.DBusProxyFlags] when the proxy is created. If the proxy is for a
    well-known name, the property cache is flushed when the name owner
    vanishes and reloaded when a name owner appears.

    The unique name owner of the proxy’s name is tracked and can be read from
    [property`Gio`.DBusProxy:g-name-owner]. Connect to the
    [signal`GObject`.Object::notify] signal to get notified of changes.
    Additionally, only signals and property changes emitted from the current name
    owner are considered and calls are always sent to the current name owner.
    This avoids a number of race conditions when the name is lost by one owner
    and claimed by another. However, if no name owner currently exists,
    then calls will be sent to the well-known name which may result in
    the message bus launching an owner (unless
    `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` is set).

    If the proxy is for a stateless D-Bus service, where the name owner may
    be started and stopped between calls, the
    [property`Gio`.DBusProxy:g-name-owner] tracking of `GDBusProxy` will cause the
    proxy to drop signal and property changes from the service after it has
    restarted for the first time. When interacting with a stateless D-Bus
    service, do not use `GDBusProxy` — use direct D-Bus method calls and signal
    connections.

    The generic [signal`Gio`.DBusProxy::g-properties-changed] and
    [signal`Gio`.DBusProxy::g-signal] signals are not very convenient to work
    with. Therefore, the recommended way of working with proxies is to subclass
    `GDBusProxy`, and have more natural properties and signals in your derived
    class. This [example](migrating-gdbus.html#using-gdbus-codegen) shows how
    this can easily be done using the [`gdbus-codegen`](gdbus-codegen.html) tool.

    A `GDBusProxy` instance can be used from multiple threads but note
    that all signals (e.g. [signal`Gio`.DBusProxy::g-signal],
    [signal`Gio`.DBusProxy::g-properties-changed] and
    [signal`GObject`.Object::notify]) are emitted in the thread-default main
    context (see [method`GLib`.MainContext.push_thread_default]) of the thread
    where the instance was constructed.


    ## A watch proxy example
    An example using a proxy for a well-known name can be found in
    [`gdbus-example-watch-proxy.c`](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c).
    """

    class Props(GObject.Object.Props):
        g_bus_type: BusType  # [g-bus-type]: changed because contained invalid characters
        """
        If this property is not G_BUS_TYPE_NONE, then
        GDBusProxy:g-connection must be None and will be set to the
        GDBusConnection obtained by calling `g_bus_get` with the value
        of this property.
        """
        g_connection: DBusConnection | None  # [g-connection]: changed because contained invalid characters
        """
        The GDBusConnection the proxy is for.
        """
        g_default_timeout: int  # [g-default-timeout]: changed because contained invalid characters
        """
        The timeout to use if -1 (specifying default timeout) is passed
        as `timeout_msec` in the `g_dbus_proxy_call` and
        `g_dbus_proxy_call_sync` functions.

        This allows applications to set a proxy-wide timeout for all
        remote method invocations on the proxy. If this property is -1,
        the default timeout (typically 25 seconds) is used. If set to
        G_MAXINT, then no timeout is used.
        """
        g_flags: DBusProxyFlags  # [g-flags]: changed because contained invalid characters
        """
        Flags from the GDBusProxyFlags enumeration.
        """
        g_interface_info: DBusInterfaceInfo | None  # [g-interface-info]: changed because contained invalid characters
        """
        Ensure that interactions with this proxy conform to the given
        interface. This is mainly to ensure that malformed data received
        from the other peer is ignored. The given GDBusInterfaceInfo is
        said to be the "expected interface".

        The checks performed are:
        - When completing a method call, if the type signature of
          the reply message isn't what's expected, the reply is
          discarded and the GError is set to G_IO_ERROR_INVALID_ARGUMENT.

        - Received signals that have a type signature mismatch are dropped and
          a warning is logged via `g_warning`.

        - Properties received via the initial ``GetAll`` call or via the
          `::PropertiesChanged` signal (on the
          [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
          interface) or set using `g_dbus_proxy_set_cached_property`
          with a type signature mismatch are ignored and a warning is
          logged via `g_warning`.

        Note that these checks are never done on methods, signals and
        properties that are not referenced in the given
        GDBusInterfaceInfo, since extending a D-Bus interface on the
        service-side is not considered an ABI break.
        """
        g_interface_name: str  # [g-interface-name]: changed because contained invalid characters
        """
        The D-Bus interface name the proxy is for.
        """
        g_name: str  # [g-name]: changed because contained invalid characters
        """
        The well-known or unique name that the proxy is for.
        """
        g_name_owner: str  # [g-name-owner]: changed because contained invalid characters
        """
        The unique name that owns GDBusProxy:g-name or None if no-one
        currently owns that name. You may connect to GObject::notify signal to
        track changes to this property.
        """
        g_object_path: str  # [g-object-path]: changed because contained invalid characters
        """
        The object path the proxy is for.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> DBusProxyPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        g_bus_type: BusType = ...,
        g_connection: DBusConnection | None = ...,
        g_default_timeout: int = ...,
        g_flags: DBusProxyFlags = ...,
        g_interface_info: DBusInterfaceInfo | None = ...,
        g_interface_name: str = ...,
        g_name: str = ...,
        g_object_path: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    async def call(
        self,
        method_name: str,
        parameters: GLib.Variant | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously invokes the `method_name` method on `proxy`.

        If `method_name` contains any dots, then `name` is split into interface and
        method name parts. This allows using `proxy` for invoking methods on
        other interfaces.

        If the GDBusConnection associated with `proxy` is closed then
        the operation will fail with G_IO_ERROR_CLOSED. If
        `cancellable` is canceled, the operation will fail with
        G_IO_ERROR_CANCELLED. If `parameters` contains a value not
        compatible with the D-Bus protocol, the operation fails with
        G_IO_ERROR_INVALID_ARGUMENT.

        If the `parameters` GVariant is floating, it is consumed. This allows
        convenient 'inline' use of `g_variant_new`, e.g.:
        |[<!-- language="C" -->
         g_dbus_proxy_call (proxy,
                            "TwoStrings",
                            g_variant_new ("(ss)",
                                           "Thing One",
                                           "Thing Two"),
                            G_DBUS_CALL_FLAGS_NONE,
                            -1,
                            None,
                            (GAsyncReadyCallback) two_strings_done,
                            &data);
        ]|

        If `proxy` has an expected interface (see
        GDBusProxy:g-interface-info) and `method_name` is referenced by it,
        then the return value is checked against the return type.

        This is an asynchronous method. When the operation is finished,
        `callback` will be invoked in the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        of the thread you are calling this method from.
        You can then call `g_dbus_proxy_call_finish` to get the result of
        the operation. See `g_dbus_proxy_call_sync` for the synchronous
        version of this method.

        If `callback` is None then the D-Bus method call message will be sent with
        the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
        """
    def call_finish(self, res: AsyncResult) -> GLib.Variant:
        """
        Finishes an operation started with `g_dbus_proxy_call`.
        """
    def call_sync(
        self,
        method_name: str,
        parameters: GLib.Variant | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        cancellable: Cancellable | None = None,
    ) -> GLib.Variant:
        """
            Synchronously invokes the `method_name` method on `proxy`.

        If `method_name` contains any dots, then `name` is split into interface and
        method name parts. This allows using `proxy` for invoking methods on
        other interfaces.

        If the GDBusConnection associated with `proxy` is disconnected then
        the operation will fail with G_IO_ERROR_CLOSED. If
        `cancellable` is canceled, the operation will fail with
        G_IO_ERROR_CANCELLED. If `parameters` contains a value not
        compatible with the D-Bus protocol, the operation fails with
        G_IO_ERROR_INVALID_ARGUMENT.

        If the `parameters` GVariant is floating, it is consumed. This allows
        convenient 'inline' use of `g_variant_new`, e.g.:
        |[<!-- language="C" -->
         g_dbus_proxy_call_sync (proxy,
                                 "TwoStrings",
                                 g_variant_new ("(ss)",
                                                "Thing One",
                                                "Thing Two"),
                                 G_DBUS_CALL_FLAGS_NONE,
                                 -1,
                                 None,
                                 &error);
        ]|

        The calling thread is blocked until a reply is received. See
        `g_dbus_proxy_call` for the asynchronous version of this
        method.

        If `proxy` has an expected interface (see
        GDBusProxy:g-interface-info) and `method_name` is referenced by it,
        then the return value is checked against the return type.
        """
    async def call_with_unix_fd_list(
        self,
        method_name: str,
        parameters: GLib.Variant | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        fd_list: UnixFDList | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Like `g_dbus_proxy_call` but also takes a GUnixFDList object.

        This method is only available on UNIX.
        """
    def call_with_unix_fd_list_finish(self, res: AsyncResult) -> tuple[GLib.Variant, UnixFDList | None]:
        """
        Finishes an operation started with `g_dbus_proxy_call_with_unix_fd_list`.
        """
    def call_with_unix_fd_list_sync(
        self,
        method_name: str,
        parameters: GLib.Variant | None,
        flags: DBusCallFlags,
        timeout_msec: int,
        fd_list: UnixFDList | None = None,
        cancellable: Cancellable | None = None,
    ) -> tuple[GLib.Variant, UnixFDList | None]:
        """
            Like `g_dbus_proxy_call_sync` but also takes and returns GUnixFDList objects.

        This method is only available on UNIX.
        """
    def get_cached_property(self, property_name: str) -> GLib.Variant | None:
        """
            Looks up the value for a property from the cache. This call does no
        blocking IO.

        If `proxy` has an expected interface (see
        GDBusProxy:g-interface-info) and `property_name` is referenced by
        it, then `value` is checked against the type of the property.
        """
    def get_cached_property_names(self) -> list | None:
        """
        Gets the names of all cached properties on `proxy`.
        """
    def get_connection(self) -> DBusConnection:
        """
        Gets the connection `proxy` is for.
        """
    def get_default_timeout(self) -> int:
        """
            Gets the timeout to use if -1 (specifying default timeout) is
        passed as `timeout_msec` in the `g_dbus_proxy_call` and
        `g_dbus_proxy_call_sync` functions.

        See the GDBusProxy:g-default-timeout property for more details.
        """
    def get_flags(self) -> DBusProxyFlags:
        """
        Gets the flags that `proxy` was constructed with.
        """
    def get_interface_info(self) -> DBusInterfaceInfo | None:
        """
            Returns the GDBusInterfaceInfo, if any, specifying the interface
        that `proxy` conforms to. See the GDBusProxy:g-interface-info
        property for more details.
        """
    def get_interface_name(self) -> str:
        """
        Gets the D-Bus interface name `proxy` is for.
        """
    def get_name(self) -> str | None:
        """
            Gets the name that `proxy` was constructed for.

        When connected to a message bus, this will usually be non-None.
        However, it may be None for a proxy that communicates using a peer-to-peer
        pattern.
        """
    def get_name_owner(self) -> str | None:
        """
            The unique name that owns the name that `proxy` is for or None if
        no-one currently owns that name. You may connect to the
        GObject::notify signal to track changes to the
        GDBusProxy:g-name-owner property.
        """
    def get_object_path(self) -> str:
        """
        Gets the object path `proxy` is for.
        """
    @staticmethod
    async def new(
        connection: DBusConnection,
        flags: DBusProxyFlags,
        info: DBusInterfaceInfo | None,
        name: str | None,
        object_path: str,
        interface_name: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Creates a proxy for accessing `interface_name` on the remote object
        at `object_path` owned by `name` at `connection` and asynchronously
        loads D-Bus properties unless the
        G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
        the GDBusProxy::g-properties-changed signal to get notified about
        property changes.

        If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
        match rules for signals. Connect to the GDBusProxy::g-signal signal
        to handle signals from the remote object.

        If both G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
        G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
        guaranteed to complete immediately without blocking.

        If `name` is a well-known name and the
        G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
        flags aren't set and no name owner currently exists, the message bus
        will be requested to launch a name owner for the name.

        This is a failable asynchronous constructor - when the proxy is
        ready, `callback` will be invoked and you can use
        `g_dbus_proxy_new_finish` to get the result.

        See `g_dbus_proxy_new_sync` and for a synchronous version of this constructor.

        GDBusProxy is used in this [example][class`Gio`.DBusProxy#a-watch-proxy-example].
        """
    @classmethod
    def new_finish(cls, res: AsyncResult) -> DBusProxy:
        """
        Finishes creating a GDBusProxy.
        """
    @staticmethod
    async def new_for_bus(
        bus_type: BusType,
        flags: DBusProxyFlags,
        info: DBusInterfaceInfo | None,
        name: str,
        object_path: str,
        interface_name: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Like `g_dbus_proxy_new` but takes a GBusType instead of a GDBusConnection.

        GDBusProxy is used in this [example][class`Gio`.DBusProxy#a-watch-proxy-example].
        """
    @classmethod
    def new_for_bus_finish(cls, res: AsyncResult) -> DBusProxy:
        """
        Finishes creating a GDBusProxy.
        """
    @classmethod
    def new_for_bus_sync(
        cls,
        bus_type: BusType,
        flags: DBusProxyFlags,
        info: DBusInterfaceInfo | None,
        name: str,
        object_path: str,
        interface_name: str,
        cancellable: Cancellable | None = None,
    ) -> DBusProxy:
        """
            Like `g_dbus_proxy_new_sync` but takes a GBusType instead of a GDBusConnection.

        GDBusProxy is used in this [example][class`Gio`.DBusProxy#a-watch-proxy-example].
        """
    @classmethod
    def new_sync(
        cls,
        connection: DBusConnection,
        flags: DBusProxyFlags,
        info: DBusInterfaceInfo | None,
        name: str | None,
        object_path: str,
        interface_name: str,
        cancellable: Cancellable | None = None,
    ) -> DBusProxy:
        """
            Creates a proxy for accessing `interface_name` on the remote object
        at `object_path` owned by `name` at `connection` and synchronously
        loads D-Bus properties unless the
        G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.

        If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
        match rules for signals. Connect to the GDBusProxy::g-signal signal
        to handle signals from the remote object.

        If both G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
        G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
        guaranteed to return immediately without blocking.

        If `name` is a well-known name and the
        G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
        flags aren't set and no name owner currently exists, the message bus
        will be requested to launch a name owner for the name.

        This is a synchronous failable constructor. See `g_dbus_proxy_new`
        and `g_dbus_proxy_new_finish` for the asynchronous version.

        GDBusProxy is used in this [example][class`Gio`.DBusProxy#a-watch-proxy-example].
        """
    def set_cached_property(self, property_name: str, value: GLib.Variant | None = None) -> None:
        """
            If `value` is not None, sets the cached value for the property with
        name `property_name` to the value in `value`.

        If `value` is None, then the cached value is removed from the
        property cache.

        If `proxy` has an expected interface (see
        GDBusProxy:g-interface-info) and `property_name` is referenced by
        it, then `value` is checked against the type of the property.

        If the `value` GVariant is floating, it is consumed. This allows
        convenient 'inline' use of `g_variant_new`, e.g.
        |[<!-- language="C" -->
         g_dbus_proxy_set_cached_property (proxy,
                                           "SomeProperty",
                                           g_variant_new ("(si)",
                                                         "A String",
                                                         42));
        ]|

        Normally you will not need to use this method since `proxy`
        is tracking changes using the
        `org.freedesktop.DBus.Properties.PropertiesChanged`
        D-Bus signal. However, for performance reasons an object may
        decide to not use this signal for some properties and instead
        use a proprietary out-of-band mechanism to transmit changes.

        As a concrete example, consider an object with a property
        `ChatroomParticipants` which is an array of strings. Instead of
        transmitting the same (long) array every time the property changes,
        it is more efficient to only transmit the delta using e.g. signals
        `ChatroomParticipantJoined(String name)` and
        `ChatroomParticipantParted(String name)`.
        """
    def set_default_timeout(self, timeout_msec: int) -> None:
        """
            Sets the timeout to use if -1 (specifying default timeout) is
        passed as `timeout_msec` in the `g_dbus_proxy_call` and
        `g_dbus_proxy_call_sync` functions.

        See the GDBusProxy:g-default-timeout property for more details.
        """
    def set_interface_info(self, info: DBusInterfaceInfo | None = None) -> None:
        """
            Ensure that interactions with `proxy` conform to the given
        interface. See the GDBusProxy:g-interface-info property for more
        details.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["g-properties-changed"],
        handler: typing.Callable[[typing_extensions.Self, GLib.Variant, list], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when one or more D-Bus properties on `proxy` changes. The
        local cache has already been updated when this signal fires. Note
        that both `changed_properties` and `invalidated_properties` are
        guaranteed to never be None (either may be empty though).

        If the proxy has the flag
        G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES set, then
        `invalidated_properties` will always be empty.

        This signal corresponds to the
        `PropertiesChanged` D-Bus signal on the
        `org.freedesktop.DBus.Properties` interface.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["g-signal"],
        handler: typing.Callable[[typing_extensions.Self, str | None, str, GLib.Variant], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when a signal from the remote object and interface that `proxy` is for, has been received.

        Since 2.72 this signal supports detailed connections. You can connect to
        the detailed signal `g-signal::x` in order to receive callbacks only when
        signal `x` is received from the remote object.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_bus_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_default_timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_interface_info"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_interface_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_name_owner"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::g_object_path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusProxyClass(GObject.GPointer):
    """
    Class structure for GDBusProxy.
    """

    # gi Fields
    @builtins.property
    def g_properties_changed(self) -> g_properties_changedDBusProxyClassCB:
        """
        Signal class handler for the GDBusProxy::g-properties-changed signal.
        """
    @builtins.property
    def g_signal(self) -> g_signalDBusProxyClassCB:
        """
        Signal class handler for the GDBusProxy::g-signal signal.
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusProxyPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DBusServer(GObject.Object):
    """
    `GDBusServer` is a helper for listening to and accepting D-Bus
    connections. This can be used to create a new D-Bus server, allowing two
    peers to use the D-Bus protocol for their own specialized communication.
    A server instance provided in this way will not perform message routing or
    implement the
    [`org.freedesktop.DBus` interface](https://dbus.freedesktop.org/doc/dbus-specification.html#message-bus-messages).

    To just export an object on a well-known name on a message bus, such as the
    session or system bus, you should instead use [func`Gio`.bus_own_name].

    An example of peer-to-peer communication with GDBus can be found
    in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).

    Note that a minimal `GDBusServer` will accept connections from any
    peer. In many use-cases it will be necessary to add a
    [class`Gio`.DBusAuthObserver] that only accepts connections that have
    successfully authenticated as the same user that is running the
    `GDBusServer`. Since GLib 2.68 this can be achieved more simply by passing
    the `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag to the
    server.
    """

    class Props(GObject.Object.Props):
        active: bool
        """
        Whether the server is currently active.
        """
        address: str
        """
        The D-Bus address to listen on.
        """
        authentication_observer: (
            DBusAuthObserver | None
        )  # [authentication-observer]: changed because contained invalid characters
        """
        A GDBusAuthObserver object to assist in the authentication process or None.
        """
        client_address: str  # [client-address]: changed because contained invalid characters
        """
        The D-Bus address that clients can use.
        """
        flags: DBusServerFlags
        """
        Flags from the GDBusServerFlags enumeration.
        """
        guid: str
        """
        The GUID of the server.

        See GDBusConnection:guid for more details.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        address: str = ...,
        authentication_observer: DBusAuthObserver | None = ...,
        flags: DBusServerFlags = ...,
        guid: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_client_address(self) -> str:
        """
            Gets a
        [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
        string that can be used by clients to connect to `server`.

        This is valid and non-empty if initializing the GDBusServer succeeded.
        """
    @builtins.property
    def get_flags(self) -> DBusServerFlags:
        """
        Gets the flags for `server`.
        """
    @builtins.property
    def get_guid(self) -> str:
        """
        Gets the GUID for `server`, as provided to `g_dbus_server_new_sync`.
        """
    @builtins.property
    def is_active(self) -> bool:
        """
        Gets whether `server` is active.
        """
    @classmethod
    def new_sync(
        cls,
        address: str,
        flags: DBusServerFlags,
        guid: str,
        observer: DBusAuthObserver | None = None,
        cancellable: Cancellable | None = None,
    ) -> DBusServer:
        """
            Creates a new D-Bus server that listens on the first address in
        `address` that works.

        Once constructed, you can use `g_dbus_server_get_client_address` to
        get a D-Bus address string that clients can use to connect.

        To have control over the available authentication mechanisms and
        the users that are authorized to connect, it is strongly recommended
        to provide a non-None GDBusAuthObserver.

        Connect to the GDBusServer::new-connection signal to handle
        incoming connections.

        The returned GDBusServer isn't active - you have to start it with
        `g_dbus_server_start`.

        GDBusServer is used in this [example](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).

        This is a synchronous failable constructor. There is currently no
        asynchronous version.
        """
    def start(self) -> None:
        """
        Starts `server`.
        """
    def stop(self) -> None:
        """
        Stops `server`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["new-connection"],
        handler: typing.Callable[[typing_extensions.Self, DBusConnection], bool],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when a new authenticated connection has been made. Use
        `g_dbus_connection_get_peer_credentials` to figure out what
        identity (if any), was authenticated.

        If you want to accept the connection, take a reference to the
        `connection` object and return True. When you are done with the
        connection call `g_dbus_connection_close` and give up your
        reference. Note that the other peer may disconnect at any time -
        a typical thing to do when accepting a connection is to listen to
        the GDBusConnection::closed signal.

        If GDBusServer:flags contains G_DBUS_SERVER_FLAGS_RUN_IN_THREAD
        then the signal is emitted in a new thread dedicated to the
        connection. Otherwise the signal is emitted in the thread-default
        main context (see [method`GLib`.MainContext.push_thread_default])
        of the thread that `server` was constructed in.

        You are guaranteed that signal handlers for this signal runs
        before incoming messages on `connection` are processed. This means
        that it's suitable to call `g_dbus_connection_register_object` or
        similar from the signal handler.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::authentication_observer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::client_address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::guid"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DBusSignalInfo(GObject.GBoxed):
    """
    Information about a signal on a D-Bus interface.
    """

    # gi Fields
    annotations: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusAnnotationInfo structures or None if there are no annotations.

    """
    args: list | None = ...
    """
    A pointer to a None-terminated array of pointers to GDBusArgInfo structures or None if there are no arguments.

    """
    name: str = ...
    """
    The name of the D-Bus signal, e.g. "NameOwnerChanged".

    """
    ref_count: int = ...
    """
    The reference count or -1 if statically allocated.

    """

    # gi Methods
    def ref(self) -> DBusSignalInfo:
        """
            If `info` is statically allocated does nothing. Otherwise increases
        the reference count.
        """
    def unref(self) -> None:
        """
            If `info` is statically allocated, does nothing. Otherwise decreases
        the reference count of `info`. When its reference count drops to 0,
        the memory used is freed.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class DBusSubtreeVTable(GObject.GPointer):
    """
    Virtual table for handling subtrees registered with `g_dbus_connection_register_subtree`.
    """

    # gi Fields
    dispatch: DBusSubtreeDispatchFuncDBusSubtreeVTableCB | None = ...
    """
    Function for dispatching a remote call on a child node.

    """
    enumerate: DBusSubtreeEnumerateFuncDBusSubtreeVTableCB = ...
    """
    Function for enumerating child nodes.

    """
    introspect: DBusSubtreeIntrospectFuncDBusSubtreeVTableCB | None = ...
    """
    Function for introspecting a child node.

    """
    @builtins.property
    def padding(self) -> list | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DataInputStream(BufferedInputStream):
    """
    Data input stream implements [class`Gio`.InputStream] and includes functions
    for reading structured data directly from a binary input stream.
    """

    class Props(BufferedInputStream.Props):
        byte_order: DataStreamByteOrder  # [byte-order]: changed because contained invalid characters
        """
        The :byte-order property determines the byte ordering that
        is used when reading multi-byte entities (such as integers)
        from the stream.
        """
        newline_type: DataStreamNewlineType  # [newline-type]: changed because contained invalid characters
        """
        The :newline-type property determines what is considered
        as a line ending when reading complete lines from the stream.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> BufferedInputStream | None: ...
    @builtins.property
    def priv(self) -> DataInputStreamPrivate | None: ...

    # gi Methods
    def __init__(self, byte_order: DataStreamByteOrder = ..., newline_type: DataStreamNewlineType = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_byte_order(self) -> DataStreamByteOrder:
        """
        Gets the byte order for the data input stream.
        """
    @builtins.property
    def get_newline_type(self) -> DataStreamNewlineType:
        """
        Gets the current newline type for the `stream`.
        """
    @classmethod
    def new(cls, base_stream: InputStream) -> DataInputStream:
        """
        Creates a new data input stream for the `base_stream`.
        """
    def read_byte(self, cancellable: Cancellable | None = None) -> int:
        """
        Reads an unsigned 8-bit/1-byte value from `stream`.
        """
    def read_int16(self, cancellable: Cancellable | None = None) -> int:
        """
            Reads a 16-bit/2-byte value from `stream`.

        In order to get the correct byte order for this read operation,
        see `g_data_input_stream_get_byte_order` and `g_data_input_stream_set_byte_order`.
        """
    def read_int32(self, cancellable: Cancellable | None = None) -> int:
        """
            Reads a signed 32-bit/4-byte value from `stream`.

        In order to get the correct byte order for this read operation,
        see `g_data_input_stream_get_byte_order` and `g_data_input_stream_set_byte_order`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def read_int64(self, cancellable: Cancellable | None = None) -> int:
        """
            Reads a 64-bit/8-byte value from `stream`.

        In order to get the correct byte order for this read operation,
        see `g_data_input_stream_get_byte_order` and `g_data_input_stream_set_byte_order`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def read_line(self, cancellable: Cancellable | None = None) -> tuple[list | None, int]:
        """
            Reads a line from the data input stream.  Note that no encoding
        checks or conversion is performed; the input is not guaranteed to
        be UTF-8, and may in fact have embedded NUL characters.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def read_line_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            The asynchronous version of `g_data_input_stream_read_line`.  It is
        an error to have two outstanding calls to this function.

        When the operation is finished, `callback` will be called. You
        can then call `g_data_input_stream_read_line_finish` to get
        the result of the operation.
        """
    def read_line_finish(self, result: AsyncResult) -> tuple[list | None, int]:
        """
            Finish an asynchronous call started by
        `g_data_input_stream_read_line_async`.  Note the warning about
        string encoding in `g_data_input_stream_read_line` applies here as
        well.
        """
    def read_line_finish_utf8(self, result: AsyncResult) -> tuple[str | None, int]:
        """
            Finish an asynchronous call started by
        `g_data_input_stream_read_line_async`.
        """
    def read_line_utf8(self, cancellable: Cancellable | None = None) -> tuple[str | None, int]:
        """
            Reads a UTF-8 encoded line from the data input stream.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def read_uint16(self, cancellable: Cancellable | None = None) -> int:
        """
            Reads an unsigned 16-bit/2-byte value from `stream`.

        In order to get the correct byte order for this read operation,
        see `g_data_input_stream_get_byte_order` and `g_data_input_stream_set_byte_order`.
        """
    def read_uint32(self, cancellable: Cancellable | None = None) -> int:
        """
            Reads an unsigned 32-bit/4-byte value from `stream`.

        In order to get the correct byte order for this read operation,
        see `g_data_input_stream_get_byte_order` and `g_data_input_stream_set_byte_order`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def read_uint64(self, cancellable: Cancellable | None = None) -> int:
        """
            Reads an unsigned 64-bit/8-byte value from `stream`.

        In order to get the correct byte order for this read operation,
        see `g_data_input_stream_get_byte_order`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    @deprecated("deprecated")
    def read_until(self, stop_chars: str, cancellable: Cancellable | None = None) -> tuple[str, int]:
        """
            Reads a string from the data input stream, up to the first
        occurrence of any of the stop characters.

        Note that, in contrast to `g_data_input_stream_read_until_async`,
        this function consumes the stop character that it finds.

        Don't use this function in new code.  Its functionality is
        inconsistent with `g_data_input_stream_read_until_async`.  Both
        functions will be marked as deprecated in a future release.  Use
        `g_data_input_stream_read_upto` instead, but note that that function
        does not consume the stop character.
        """
    @deprecated("deprecated")
    async def read_until_async(
        self,
        stop_chars: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            The asynchronous version of `g_data_input_stream_read_until`.
        It is an error to have two outstanding calls to this function.

        Note that, in contrast to `g_data_input_stream_read_until`,
        this function does not consume the stop character that it finds.  You
        must read it for yourself.

        When the operation is finished, `callback` will be called. You
        can then call `g_data_input_stream_read_until_finish` to get
        the result of the operation.

        Don't use this function in new code.  Its functionality is
        inconsistent with `g_data_input_stream_read_until`.  Both functions
        will be marked as deprecated in a future release.  Use
        `g_data_input_stream_read_upto_async` instead.
        """
    @deprecated("deprecated")
    def read_until_finish(self, result: AsyncResult) -> tuple[str, int]:
        """
            Finish an asynchronous call started by
        `g_data_input_stream_read_until_async`.
        """
    def read_upto(
        self, stop_chars: str, stop_chars_len: int, cancellable: Cancellable | None = None
    ) -> tuple[str, int]:
        """
            Reads a string from the data input stream, up to the first
        occurrence of any of the stop characters.

        In contrast to `g_data_input_stream_read_until`, this function
        does not consume the stop character. You have to use
        `g_data_input_stream_read_byte` to get it before calling
        `g_data_input_stream_read_upto` again.

        Note that `stop_chars` may contain '\\0' if `stop_chars_len` is
        specified.

        The returned string will always be nul-terminated on success.
        """
    async def read_upto_async(
        self,
        stop_chars: str,
        stop_chars_len: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            The asynchronous version of `g_data_input_stream_read_upto`.
        It is an error to have two outstanding calls to this function.

        In contrast to `g_data_input_stream_read_until`, this function
        does not consume the stop character. You have to use
        `g_data_input_stream_read_byte` to get it before calling
        `g_data_input_stream_read_upto` again.

        Note that `stop_chars` may contain '\\0' if `stop_chars_len` is
        specified.

        When the operation is finished, `callback` will be called. You
        can then call `g_data_input_stream_read_upto_finish` to get
        the result of the operation.
        """
    def read_upto_finish(self, result: AsyncResult) -> tuple[str, int]:
        """
            Finish an asynchronous call started by
        `g_data_input_stream_read_upto_async`.

        Note that this function does not consume the stop character. You
        have to use `g_data_input_stream_read_byte` to get it before calling
        `g_data_input_stream_read_upto_async` again.

        The returned string will always be nul-terminated on success.
        """
    def set_byte_order(self, order: DataStreamByteOrder) -> None:
        """
            This function sets the byte order for the given `stream`. All subsequent
        reads from the `stream` will be read in the given `order`.
        """
    def set_newline_type(self, type: DataStreamNewlineType) -> None:
        """
            Sets the newline type for the `stream`.

        Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
        chunk ends in "CR" we must read an additional byte to know if this is "CR" or
        "CR LF", and this might block if there is no more data available.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::byte_order"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::newline_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DataInputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> BufferedInputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DataInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DataOutputStream(FilterOutputStream):
    """
    Data output stream implements [class`Gio`.OutputStream] and includes functions
    for writing data directly to an output stream.
    """

    class Props(FilterOutputStream.Props):
        byte_order: DataStreamByteOrder  # [byte-order]: changed because contained invalid characters
        """
        Determines the byte ordering that is used when writing
        multi-byte entities (such as integers) to the stream.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> FilterOutputStream | None: ...
    @builtins.property
    def priv(self) -> DataOutputStreamPrivate | None: ...

    # gi Methods
    def __init__(self, byte_order: DataStreamByteOrder = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_byte_order(self) -> DataStreamByteOrder:
        """
        Gets the byte order for the stream.
        """
    @classmethod
    def new(cls, base_stream: OutputStream) -> DataOutputStream:
        """
        Creates a new data output stream for `base_stream`.
        """
    def put_byte(self, data: int, cancellable: Cancellable | None = None) -> bool:
        """
        Puts a byte into the output stream.
        """
    def put_int16(self, data: int, cancellable: Cancellable | None = None) -> bool:
        """
        Puts a signed 16-bit integer into the output stream.
        """
    def put_int32(self, data: int, cancellable: Cancellable | None = None) -> bool:
        """
        Puts a signed 32-bit integer into the output stream.
        """
    def put_int64(self, data: int, cancellable: Cancellable | None = None) -> bool:
        """
        Puts a signed 64-bit integer into the stream.
        """
    def put_string(self, str: str, cancellable: Cancellable | None = None) -> bool:
        """
        Puts a string into the output stream.
        """
    def put_uint16(self, data: int, cancellable: Cancellable | None = None) -> bool:
        """
        Puts an unsigned 16-bit integer into the output stream.
        """
    def put_uint32(self, data: int, cancellable: Cancellable | None = None) -> bool:
        """
        Puts an unsigned 32-bit integer into the stream.
        """
    def put_uint64(self, data: int, cancellable: Cancellable | None = None) -> bool:
        """
        Puts an unsigned 64-bit integer into the stream.
        """
    def set_byte_order(self, order: DataStreamByteOrder) -> None:
        """
        Sets the byte order of the data output stream to `order`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::byte_order"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DataOutputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> FilterOutputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DataOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DatagramBased(GObject.GInterface):
    """
    Interface for socket-like objects with datagram semantics.

    A `GDatagramBased` is a networking interface for representing datagram-based
    communications. It is a more or less direct mapping of the core parts of the
    BSD socket API in a portable GObject interface. It is implemented by
    [class`Gio`.Socket], which wraps the UNIX socket API on UNIX and winsock2 on Windows.

    `GDatagramBased` is entirely platform independent, and is intended to be used
    alongside higher-level networking APIs such as [class`Gio`.IOStream].

    It uses vectored scatter/gather I/O by default, allowing for many messages
    to be sent or received in a single call. Where possible, implementations of
    the interface should take advantage of vectored I/O to minimise processing
    or system calls. For example, `GSocket` uses ``recvmmsg`` and ``sendmmsg``
    where possible. Callers should take advantage of scatter/gather I/O (the use of
    multiple buffers per message) to avoid unnecessary copying of data to
    assemble or disassemble a message.

    Each `GDatagramBased` operation has a timeout parameter which may be negative
    for blocking behaviour, zero for non-blocking behaviour, or positive for
    timeout behaviour. A blocking operation blocks until finished or there is an
    error. A non-blocking operation will return immediately with a
    `G_IO_ERROR_WOULD_BLOCK` error if it cannot make progress. A timeout operation
    will block until the operation is complete or the timeout expires; if the
    timeout expires it will return what progress it made, or
    `G_IO_ERROR_TIMED_OUT` if no progress was made. To know when a call would
    successfully run you can call [method`Gio`.DatagramBased.condition_check] or
    [method`Gio`.DatagramBased.condition_wait]. You can also use
    [method`Gio`.DatagramBased.create_source] and attach it to a [struct`GLib`.MainContext]
    to get callbacks when I/O is possible.

    When running a non-blocking operation applications should always be able to
    handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other function
    said that I/O was possible. This can easily happen in case of a race
    condition in the application, but it can also happen for other reasons. For
    instance, on Windows a socket is always seen as writable until a write
    returns `G_IO_ERROR_WOULD_BLOCK`.

    As with `GSocket`, `GDatagramBased`s can be either connection oriented (for
    example, SCTP) or connectionless (for example, UDP). `GDatagramBased`s must be
    datagram-based, not stream-based. The interface does not cover connection
    establishment — use methods on the underlying type to establish a connection
    before sending and receiving data through the `GDatagramBased` API. For
    connectionless socket types the target/source address is specified or
    received in each I/O operation.

    Like most other APIs in GLib, `GDatagramBased` is not inherently thread safe.
    To use a `GDatagramBased` concurrently from multiple threads, you must
    implement your own locking.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def condition_check(self, condition: GLib.IOCondition) -> GLib.IOCondition:
        """
            Checks on the readiness of `datagram_based` to perform operations. The
        operations specified in `condition` are checked for and masked against the
        currently-satisfied conditions on `datagram_based`. The result is returned.

        G_IO_IN will be set in the return value if data is available to read with
        `g_datagram_based_receive_messages`, or if the connection is closed remotely
        (EOS); and if the datagram_based has not been closed locally using some
        implementation-specific method (such as `g_socket_close` or
        `g_socket_shutdown` with `shutdown_read` set, if it’s a GSocket).

        If the connection is shut down or closed (by calling `g_socket_close` or
        `g_socket_shutdown` with `shutdown_read` set, if it’s a GSocket, for
        example), all calls to this function will return G_IO_ERROR_CLOSED.

        G_IO_OUT will be set if it is expected that at least one byte can be sent
        using `g_datagram_based_send_messages` without blocking. It will not be set
        if the datagram_based has been closed locally.

        G_IO_HUP will be set if the connection has been closed locally.

        G_IO_ERR will be set if there was an asynchronous error in transmitting data
        previously enqueued using `g_datagram_based_send_messages`.

        Note that on Windows, it is possible for an operation to return
        G_IO_ERROR_WOULD_BLOCK even immediately after
        `g_datagram_based_condition_check` has claimed that the GDatagramBased is
        ready for writing. Rather than calling `g_datagram_based_condition_check` and
        then writing to the GDatagramBased if it succeeds, it is generally better to
        simply try writing right away, and try again later if the initial attempt
        returns G_IO_ERROR_WOULD_BLOCK.

        It is meaningless to specify G_IO_ERR or G_IO_HUP in `condition`; these
        conditions will always be set in the output if they are true. Apart from
        these flags, the output is guaranteed to be masked by `condition`.

        This call never blocks.
        """
    def condition_wait(self, condition: GLib.IOCondition, timeout: int, cancellable: Cancellable | None = None) -> bool:
        """
            Waits for up to `timeout` microseconds for condition to become true on
        `datagram_based`. If the condition is met, True is returned.

        If `cancellable` is cancelled before the condition is met, or if `timeout` is
        reached before the condition is met, then False is returned and `error` is
        set appropriately (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
        """
    def create_source(self, condition: GLib.IOCondition, cancellable: Cancellable | None = None) -> GLib.Source:
        """
            Creates a GSource that can be attached to a GMainContext to monitor for
        the availability of the specified `condition` on the GDatagramBased. The
        GSource keeps a reference to the `datagram_based`.

        The callback on the source is of the GDatagramBasedSourceFunc type.

        It is meaningless to specify G_IO_ERR or G_IO_HUP in `condition`; these
        conditions will always be reported in the callback if they are true.

        If non-None, `cancellable` can be used to cancel the source, which will
        cause the source to trigger, reporting the current condition (which is
        likely 0 unless cancellation happened at the same time as a condition
        change). You can check for this in the callback using
        `g_cancellable_is_cancelled`.
        """
    def receive_messages(
        self, messages: list, num_messages: int, flags: int, timeout: int, cancellable: Cancellable | None = None
    ) -> int:
        """
            Receive one or more data messages from `datagram_based` in one go.

        `messages` must point to an array of GInputMessage structs and
        `num_messages` must be the length of this array. Each GInputMessage
        contains a pointer to an array of GInputVector structs describing the
        buffers that the data received in each message will be written to.

        `flags` modify how all messages are received. The commonly available
        arguments for this are available in the GSocketMsgFlags enum, but the
        values there are the same as the system values, and the flags
        are passed in as-is, so you can pass in system-specific flags too. These
        flags affect the overall receive operation. Flags affecting individual
        messages are returned in GInputMessage.flags.

        The other members of GInputMessage are treated as described in its
        documentation.

        If `timeout` is negative the call will block until `num_messages` have been
        received, the connection is closed remotely (EOS), `cancellable` is cancelled,
        or an error occurs.

        If `timeout` is 0 the call will return up to `num_messages` without blocking,
        or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
        to be received.

        If `timeout` is positive the call will block on the same conditions as if
        `timeout` were negative. If the timeout is reached
        before any messages are received, G_IO_ERROR_TIMED_OUT is returned,
        otherwise it will return the number of messages received before timing out.
        (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
        `recvmmsg`.)

        To be notified when messages are available, wait for the G_IO_IN condition.
        Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
        `g_datagram_based_receive_messages` even if you were previously notified of a
        G_IO_IN condition.

        If the remote peer closes the connection, any messages queued in the
        underlying receive buffer will be returned, and subsequent calls to
        `g_datagram_based_receive_messages` will return 0 (with no error set).

        If the connection is shut down or closed (by calling `g_socket_close` or
        `g_socket_shutdown` with `shutdown_read` set, if it’s a GSocket, for
        example), all calls to this function will return G_IO_ERROR_CLOSED.

        On error -1 is returned and `error` is set accordingly. An error will only
        be returned if zero messages could be received; otherwise the number of
        messages successfully received before the error will be returned. If
        `cancellable` is cancelled, G_IO_ERROR_CANCELLED is returned as with any
        other error.
        """
    def send_messages(
        self, messages: list, num_messages: int, flags: int, timeout: int, cancellable: Cancellable | None = None
    ) -> int:
        """
            Send one or more data messages from `datagram_based` in one go.

        `messages` must point to an array of GOutputMessage structs and
        `num_messages` must be the length of this array. Each GOutputMessage
        contains an address to send the data to, and a pointer to an array of
        GOutputVector structs to describe the buffers that the data to be sent
        for each message will be gathered from.

        `flags` modify how the message is sent. The commonly available arguments
        for this are available in the GSocketMsgFlags enum, but the
        values there are the same as the system values, and the flags
        are passed in as-is, so you can pass in system-specific flags too.

        The other members of GOutputMessage are treated as described in its
        documentation.

        If `timeout` is negative the call will block until `num_messages` have been
        sent, `cancellable` is cancelled, or an error occurs.

        If `timeout` is 0 the call will send up to `num_messages` without blocking,
        or will return G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.

        If `timeout` is positive the call will block on the same conditions as if
        `timeout` were negative. If the timeout is reached before any messages are
        sent, G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
        of messages sent before timing out.

        To be notified when messages can be sent, wait for the G_IO_OUT condition.
        Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
        `g_datagram_based_send_messages` even if you were previously notified of a
        G_IO_OUT condition. (On Windows in particular, this is very common due to
        the way the underlying APIs work.)

        If the connection is shut down or closed (by calling `g_socket_close` or
        `g_socket_shutdown` with `shutdown_write` set, if it’s a GSocket, for
        example), all calls to this function will return G_IO_ERROR_CLOSED.

        On error -1 is returned and `error` is set accordingly. An error will only
        be returned if zero messages could be sent; otherwise the number of messages
        successfully sent before the error will be returned. If `cancellable` is
        cancelled, G_IO_ERROR_CANCELLED is returned as with any other error.
        """

class DatagramBasedInterface(GObject.GPointer):
    """
    Provides an interface for socket-like objects which have datagram semantics,
    following the Berkeley sockets API. The interface methods are thin wrappers
    around the corresponding virtual methods, and no pre-processing of inputs is
    implemented — so implementations of this API must handle all functionality
    documented in the interface methods.
    """

    # gi Fields
    @builtins.property
    def condition_check(self) -> condition_checkDatagramBasedInterfaceCB:
        """
        Virtual method for `g_datagram_based_condition_check`.
        """
    @builtins.property
    def condition_wait(self) -> condition_waitDatagramBasedInterfaceCB:
        """
          Virtual method for
        `g_datagram_based_condition_wait`.
        """
    @builtins.property
    def create_source(self) -> create_sourceDatagramBasedInterfaceCB:
        """
        Virtual method for `g_datagram_based_create_source`.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def receive_messages(self) -> receive_messagesDatagramBasedInterfaceCB:
        """
        Virtual method for `g_datagram_based_receive_messages`.
        """
    @builtins.property
    def send_messages(self) -> send_messagesDatagramBasedInterfaceCB:
        """
        Virtual method for `g_datagram_based_send_messages`.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DebugController(GObject.GInterface):
    """
    `GDebugController` is an interface to expose control of debugging features and
    debug output.

    It is implemented on Linux using [class`Gio`.DebugControllerDBus], which
    exposes a D-Bus interface to allow authenticated peers to control debug
    features in this process.

    Whether debug output is enabled is exposed as
    [property`Gio`.DebugController:debug-enabled]. This controls
    [func`GLib`.log_set_debug_enabled] by default. Application code may
    connect to the [signal`GObject`.Object::notify] signal for it
    to control other parts of its debug infrastructure as necessary.

    If your application or service is using the default GLib log writer function,
    creating one of the built-in implementations of `GDebugController` should be
    all that’s needed to dynamically enable or disable debug output.
    """

    class Props(GObject.GInterface.Props):
        debug_enabled: bool  # [debug-enabled]: changed because contained invalid characters
        """
        True if debug output should be exposed (for example by forwarding it to
        the journal), False otherwise.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, debug_enabled: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_debug_enabled(self) -> bool:
        """
        Get the value of GDebugController:debug-enabled.
        """
    def set_debug_enabled(self, debug_enabled: bool) -> None:
        """
        Set the value of GDebugController:debug-enabled.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::debug_enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DebugControllerDBus(GObject.Object):
    """
    `GDebugControllerDBus` is an implementation of [iface`Gio`.DebugController]
    which exposes debug settings as a D-Bus object.

    It is a [iface`Gio`.Initable] object, and will register an object at
    `/org/gtk/Debugging` on the bus given as
    [property`Gio`.DebugControllerDBus:connection] once it’s initialized. The
    object will be unregistered when the last reference to the
    `GDebugControllerDBus` is dropped.

    This D-Bus object can be used by remote processes to enable or disable debug
    output in this process. Remote processes calling
    `org.gtk.Debugging.`SetDebugEnabled`` will affect the value of
    [property`Gio`.DebugController:debug-enabled] and, by default,
    [func`GLib`.log_get_debug_enabled].

    By default, no processes are allowed to call ``SetDebugEnabled`` unless a
    [signal`Gio`.DebugControllerDBus::authorize] signal handler is installed. This
    is because the process may be privileged, or might expose sensitive
    information in its debug output. You may want to restrict the ability to
    enable debug output to privileged users or processes.

    One option is to install a D-Bus security policy which restricts access to
    ``SetDebugEnabled``, installing something like the following in
    `$datadir/dbus-1/system.d/`:

    ```xml
    <?xml version="1.0"?> <!--*-nxml-*-->
    <!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
         "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
    <busconfig>
      <policy user="root">
        <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
      </policy>
      <policy context="default">
        <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
      </policy>
    </busconfig>
    ```

    This will prevent the ``SetDebugEnabled`` method from being called by all
    except root. It will not prevent the `DebugEnabled` property from being read,
    as it’s accessed through the `org.freedesktop.DBus.Properties` interface.

    Another option is to use polkit to allow or deny requests on a case-by-case
    basis, allowing for the possibility of dynamic authorisation. To do this,
    connect to the [signal`Gio`.DebugControllerDBus::authorize] signal and query
    polkit in it:

    ```c
      g_autoptr(GError) child_error = None;
      g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, None, None);
      gulong debug_controller_authorize_id = 0;

      // Set up the debug controller.
      debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, None, &child_error));
      if (debug_controller == None)
        {
          g_error ("Could not register debug controller on bus: %s",
                   child_error->message);
        }

      debug_controller_authorize_id = g_signal_connect (debug_controller,
                                                        "authorize",
                                                        G_CALLBACK (debug_controller_authorize_cb),
                                                        self);

      static gboolean
      debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
                                     GDBusMethodInvocation *invocation,
                                     gpointer               user_data)
      {
        g_autoptr(PolkitAuthority) authority = None;
        g_autoptr(PolkitSubject) subject = None;
        g_autoptr(PolkitAuthorizationResult) auth_result = None;
        g_autoptr(GError) local_error = None;
        GDBusMessage *message;
        GDBusMessageFlags message_flags;
        PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;

        message = g_dbus_method_invocation_get_message (invocation);
        message_flags = g_dbus_message_get_flags (message);

        authority = polkit_authority_get_sync (None, &local_error);
        if (authority == None)
          {
            g_warning ("Failed to get polkit authority: %s", local_error->message);
            return False;
          }

        if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
          flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;

        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));

        auth_result = polkit_authority_check_authorization_sync (authority,
                                                                 subject,
                                                                 "com.example.MyService.set-debug-enabled",
                                                                 None,
                                                                 flags,
                                                                 None,
                                                                 &local_error);
        if (auth_result == None)
          {
            g_warning ("Failed to get check polkit authorization: %s", local_error->message);
            return False;
          }

        return polkit_authorization_result_get_is_authorized (auth_result);
      }
    ```
    """

    class Props(GObject.Object.Props):
        connection: DBusConnection | None
        """
        The D-Bus connection to expose the debugging interface on.

        Typically this will be the same connection (to the system or session bus)
        which the rest of the application or service’s D-Bus objects are registered
        on.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...

    # gi Methods
    def __init__(self, connection: DBusConnection | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, connection: DBusConnection, cancellable: Cancellable | None = None) -> DebugControllerDBus | None:
        """
            Create a new GDebugControllerDBus and synchronously initialize it.

        Initializing the object will export the debug object on `connection`. The
        object will remain registered until the last reference to the
        GDebugControllerDBus is dropped.

        Initialization may fail if registering the object on `connection` fails.
        """
    def stop(self) -> None:
        """
            Stop the debug controller, unregistering its object from the bus.

        Any pending method calls to the object will complete successfully, but new
        ones will return an error. This method will block until all pending
        GDebugControllerDBus::authorize signals have been handled. This is expected
        to not take long, as it will just be waiting for threads to join. If any
        GDebugControllerDBus::authorize signal handlers are still executing in other
        threads, this will block until after they have returned.

        This method will be called automatically when the final reference to the
        GDebugControllerDBus is dropped. You may want to call it explicitly to know
        when the controller has been fully removed from the bus, or to break
        reference count cycles.

        Calling this method from within a GDebugControllerDBus::authorize signal
        handler will cause a deadlock and must not be done.
        """

    # python methods (overrides?)
    def do_authorize(
        self,
        invocation: DBusMethodInvocation,
    ) -> bool:
        """
        authorize(self, invocation:Gio.DBusMethodInvocation) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["authorize"],
        handler: typing.Callable[[typing_extensions.Self, DBusMethodInvocation], bool],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when a D-Bus peer is trying to change the debug settings and used
        to determine if that is authorized.

        This signal is emitted in a dedicated worker thread, so handlers are
        allowed to perform blocking I/O. This means that, for example, it is
        appropriate to call ``polkit_authority_check_authorization_sync`` to check
        authorization using polkit.

        If False is returned then no further handlers are run and the request to
        change the debug settings is rejected.

        Otherwise, if True is returned, signal emission continues. If no handlers
        return False, then the debug settings are allowed to be changed.

        Signal handlers must not modify `invocation`, or cause it to return a value.

        The default class handler just returns True.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connection"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DebugControllerDBusClass(GObject.GPointer):
    """
    The virtual function table for GDebugControllerDBus.
    """

    # gi Fields
    @builtins.property
    def authorize(self) -> authorizeDebugControllerDBusClassCB:
        """
        Default handler for the GDebugControllerDBus::authorize signal.
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None:
        """
        The parent class.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DebugControllerInterface(GObject.GPointer):
    """
    The virtual function table for GDebugController.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DesktopAppInfo(GObject.Object):
    """
    `GDesktopAppInfo` is an implementation of [iface`Gio`.AppInfo] based on
    desktop files.

    Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific
    GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
    file or the `GioUnix-2.0` GIR namespace when using it.
    """

    class Props(GObject.Object.Props):
        filename: str
        """
        The origin filename of this [class`Gio`.DesktopAppInfo]
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, filename: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_action_name(self, action_name: str) -> str:
        """
            Gets the user-visible display name of the
        [‘additional application actions’](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s11.html)
        specified by `action_name`.

        This corresponds to the `Name` key within the keyfile group for the
        action.
        """
    def get_boolean(self, key: str) -> bool:
        """
            Looks up a boolean value in the keyfile backing `info`.

        The `key` is looked up in the `Desktop Entry` group.
        """
    def get_categories(self) -> str | None:
        """
        Gets the categories from the desktop file.
        """
    @builtins.property
    def get_filename(self) -> str | None:
        """
            When `info` was created from a known filename, return it.  In some
        situations such as a [class`Gio`.DesktopAppInfo] returned from
        [ctor`Gio`.DesktopAppInfo.new_from_keyfile], this function will return `None`.
        """
    def get_generic_name(self) -> str | None:
        """
        Gets the generic name from the desktop file.
        """
    @staticmethod
    def get_implementations(interface: str) -> list:
        """
            Gets all applications that implement `interface`.

        An application implements an interface if that interface is listed in
        the `Implements` line of the desktop file of the application.
        """
    def get_is_hidden(self) -> bool:
        """
            A desktop file is hidden if the
        [`Hidden` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-hidden)
        in it is set to `True`.
        """
    def get_keywords(self) -> list:
        """
        Gets the keywords from the desktop file.
        """
    def get_locale_string(self, key: str) -> str | None:
        """
            Looks up a localized string value in the keyfile backing `info`
        translated to the current locale.

        The `key` is looked up in the `Desktop Entry` group.
        """
    def get_nodisplay(self) -> bool:
        """
            Gets the value of the
        [`NoDisplay` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-nodisplay)
         which helps determine if the application info should be shown in menus. See
        `G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY` and [method`Gio`.AppInfo.should_show].
        """
    def get_show_in(self, desktop_env: str | None = None) -> bool:
        """
            Checks if the application info should be shown in menus that list available
        applications for a specific name of the desktop, based on the
        [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-onlyshowin)
        and [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-notshowin)
        keys.

        `desktop_env` should typically be given as `None`, in which case the
        `XDG_CURRENT_DESKTOP` environment variable is consulted.  If you want
        to override the default mechanism then you may specify `desktop_env`,
        but this is not recommended.

        Note that [method`Gio`.AppInfo.should_show] for `info` will include this check
        (with `None` for `desktop_env`) as well as additional checks.
        """
    def get_startup_wm_class(self) -> str | None:
        """
            Retrieves the `StartupWMClass` field from `info`. This represents the
        `WM_CLASS` property of the main window of the application, if launched
        through `info`.
        """
    def get_string(self, key: str) -> str | None:
        """
            Looks up a string value in the keyfile backing `info`.

        The `key` is looked up in the `Desktop Entry` group.
        """
    def get_string_list(self, key: str) -> tuple[list, int]:
        """
            Looks up a string list value in the keyfile backing `info`.

        The `key` is looked up in the `Desktop Entry` group.
        """
    def has_key(self, key: str) -> bool:
        """
            Returns whether `key` exists in the `Desktop Entry` group
        of the keyfile backing `info`.
        """
    def launch_action(self, action_name: str, launch_context: AppLaunchContext | None = None) -> None:
        """
            Activates the named application action.

        You may only call this function on action names that were
        returned from [method`Gio`.DesktopAppInfo.list_actions].

        Note that if the main entry of the desktop file indicates that the
        application supports startup notification, and `launch_context` is
        non-`None`, then startup notification will be used when activating the
        action (and as such, invocation of the action on the receiving side
        must signal the end of startup notification when it is completed).
        This is the expected behaviour of applications declaring additional
        actions, as per the
        [desktop file specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s11.html).

        As with [method`Gio`.AppInfo.launch] there is no way to detect failures that
        occur while using this function.
        """
    def launch_uris_as_manager(
        self,
        uris: list,
        launch_context: AppLaunchContext | None,
        spawn_flags: GLib.SpawnFlags,
        user_setup: GLib.SpawnChildSetupFunc | None = None,
        user_setup_data: object | None = None,
        pid_callback: DesktopAppLaunchCallback | None = None,
        *pid_callback_data: object | None,
    ) -> bool:
        """
            This function performs the equivalent of [method`Gio`.AppInfo.launch_uris],
        but is intended primarily for operating system components that
        launch applications.  Ordinary applications should use
        [method`Gio`.AppInfo.launch_uris].

        If the application is launched via GSpawn, then `spawn_flags`, `user_setup`
        and `user_setup_data` are used for the call to [func`GLib`.spawn_async].
        Additionally, `pid_callback` (with `pid_callback_data`) will be called to
        inform about the PID of the created process. See
        [func`GLib`.spawn_async_with_pipes] for information on certain parameter
        conditions that can enable an optimized [``posix_spawn``](man:posix_spawn(3))
        code path to be used.

        If application launching occurs via some other mechanism (for example, D-Bus
        activation) then `spawn_flags`, `user_setup`, `user_setup_data`,
        `pid_callback` and `pid_callback_data` are ignored.
        """
    def launch_uris_as_manager_with_fds(
        self,
        uris: list,
        launch_context: AppLaunchContext | None,
        spawn_flags: GLib.SpawnFlags,
        user_setup: GLib.SpawnChildSetupFunc | None,
        user_setup_data: object | None,
        pid_callback: DesktopAppLaunchCallback | None,
        *pid_callback_data: object | None,
        stdin_fd: int,
        stdout_fd: int,
        stderr_fd: int,
    ) -> bool:
        """
            Equivalent to [method`Gio`.DesktopAppInfo.launch_uris_as_manager] but allows
        you to pass in file descriptors for the stdin, stdout and stderr streams
        of the launched process.

        If application launching occurs via some non-spawn mechanism (e.g. D-Bus
        activation) then `stdin_fd`, `stdout_fd` and `stderr_fd` are ignored.
        """
    def list_actions(self) -> list:
        """
            Returns the list of
        [‘additional application actions’](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s11.html)
        supported on the desktop file, as per the desktop file specification.

        As per the specification, this is the list of actions that are
        explicitly listed in the `Actions` key of the `Desktop Entry` group.
        """
    @classmethod
    def new(cls, desktop_id: str) -> DesktopAppInfo | None:
        """
            Creates a new [class`Gio`.DesktopAppInfo] based on a desktop file ID.

        A desktop file ID is the basename of the desktop file, including the
        `.desktop` extension. GIO is looking for a desktop file with this name
        in the `applications` subdirectories of the XDG
        data directories (i.e. the directories specified in the `XDG_DATA_HOME`
        and `XDG_DATA_DIRS` environment variables). GIO also supports the
        prefix-to-subdirectory mapping that is described in the
        [Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
        (i.e. a desktop ID of `kde-foo.desktop` will match
        `/usr/share/applications/kde/foo.desktop`).
        """
    @classmethod
    def new_from_filename(cls, filename: str) -> DesktopAppInfo | None:
        """
        Creates a new [class`Gio`.DesktopAppInfo].
        """
    @classmethod
    def new_from_keyfile(cls, key_file: GLib.KeyFile) -> DesktopAppInfo | None:
        """
        Creates a new [class`Gio`.DesktopAppInfo].
        """
    @staticmethod
    def search(search_string: str) -> list:
        """
            Searches desktop files for ones that match `search_string`.

        The return value is an array of strvs.  Each strv contains a list of
        applications that matched `search_string` with an equal score.  The
        outer list is sorted by score so that the first strv contains the
        best-matching applications, and so on.
        The algorithm for determining matches is undefined and may change at
        any time.

        None of the search results are subjected to the normal validation
        checks performed by [ctor`Gio`.DesktopAppInfo.new] (for example, checking that
        the executable referenced by a result exists), and so it is possible for
        [ctor`Gio`.DesktopAppInfo.new] to return `None` when passed an app ID returned
        by this function. It is expected that calling code will do this when
        subsequently creating a [class`Gio`.DesktopAppInfo] for each result.
        """
    @deprecated("deprecated")
    @staticmethod
    def set_desktop_env(desktop_env: str) -> None:
        """
            Sets the name of the desktop that the application is running in.

        This is used by [method`Gio`.AppInfo.should_show] and
        [method`Gio`.DesktopAppInfo.get_show_in] to evaluate the
        [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-onlyshowin)
        and [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-notshowin)
        keys.

        Should be called only once; subsequent calls are ignored.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::filename"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DesktopAppInfoClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DesktopAppInfoLookup(GObject.GInterface):
    """
    GDesktopAppInfoLookup is an opaque data structure and can only be accessed
    using the following functions.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def get_default_for_uri_scheme(self, uri_scheme: str) -> AppInfo | None:
        """
            Gets the default application for launching applications
        using this URI scheme for a particular [iface`Gio`.DesktopAppInfoLookup]
        implementation.

        The [iface`Gio`.DesktopAppInfoLookup] interface and this function is used
        to implement [func`Gio`.AppInfo.get_default_for_uri_scheme] backends
        in a GIO module. There is no reason for applications to use it
        directly. Applications should use
        [func`Gio`.AppInfo.get_default_for_uri_scheme].
        """

class DesktopAppInfoLookupIface(GObject.GPointer):
    """
    Interface that is used by backends to associate default
    handlers with URI schemes.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...
    @builtins.property
    def get_default_for_uri_scheme(self) -> get_default_for_uri_schemeDesktopAppInfoLookupIfaceCB | None:
        """
           Virtual method for
        `g_desktop_app_info_lookup_get_default_for_uri_scheme`.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Drive(GObject.GInterface):
    """
    `GDrive` represents a piece of hardware connected to the machine.
    It’s generally only created for removable hardware or hardware with
    removable media. For example, an optical disc drive, or a USB flash drive.

    `GDrive` is a container class for [iface`Gio`.Volume] objects that stem from
    the same piece of media. As such, `GDrive` abstracts a drive with
    (or without) removable media and provides operations for querying
    whether media is available, determining whether media change is
    automatically detected and ejecting the media.

    If the `GDrive` reports that media isn’t automatically detected, one
    can poll for media; typically one should not do this periodically
    as a poll for media operation is potentially expensive and may
    spin up the drive creating noise.

    `GDrive` supports starting and stopping drives with authentication
    support for the former. This can be used to support a diverse set
    of use cases including connecting/disconnecting iSCSI devices,
    powering down external disk enclosures and starting/stopping
    multi-disk devices such as RAID devices. Note that the actual
    semantics and side-effects of starting/stopping a `GDrive` may vary
    according to implementation. To choose the correct verbs in e.g. a
    file manager, use [method`Gio`.Drive.get_start_stop_type].

    For [porting from GnomeVFS](migrating-gnome-vfs.html) note that there is no
    equivalent of `GDrive` in that API.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_eject(self) -> bool:
        """
        Checks if a drive can be ejected.
        """
    def can_poll_for_media(self) -> bool:
        """
        Checks if a drive can be polled for media changes.
        """
    def can_start(self) -> bool:
        """
        Checks if a drive can be started.
        """
    def can_start_degraded(self) -> bool:
        """
        Checks if a drive can be started degraded.
        """
    def can_stop(self) -> bool:
        """
        Checks if a drive can be stopped.
        """
    @deprecated("deprecated")
    async def eject(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously ejects a drive.

        When the operation is finished, `callback` will be called.
        You can then call `g_drive_eject_finish` to obtain the
        result of the operation.
        """
    @deprecated("deprecated")
    def eject_finish(self, result: AsyncResult) -> bool:
        """
        Finishes ejecting a drive.
        """
    async def eject_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Ejects a drive. This is an asynchronous operation, and is
        finished by calling `g_drive_eject_with_operation_finish` with the `drive`
        and GAsyncResult data returned in the `callback`.
        """
    def eject_with_operation_finish(self, result: AsyncResult) -> bool:
        """
            Finishes ejecting a drive. If any errors occurred during the operation,
        `error` will be set to contain the errors and False will be returned.
        """
    def enumerate_identifiers(self) -> list:
        """
            Gets the kinds of identifiers that `drive` has.
        Use `g_drive_get_identifier` to obtain the identifiers
        themselves.
        """
    def get_icon(self) -> Icon:
        """
        Gets the icon for `drive`.
        """
    def get_identifier(self, kind: str) -> str | None:
        """
            Gets the identifier of the given kind for `drive`. The only
        identifier currently available is
        G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
        """
    def get_name(self) -> str:
        """
        Gets the name of `drive`.
        """
    def get_sort_key(self) -> str | None:
        """
        Gets the sort key for `drive`, if any.
        """
    def get_start_stop_type(self) -> DriveStartStopType:
        """
        Gets a hint about how a drive can be started/stopped.
        """
    def get_symbolic_icon(self) -> Icon:
        """
        Gets the icon for `drive`.
        """
    def get_volumes(self) -> list:
        """
            Get a list of mountable volumes for `drive`.

        The returned list should be freed with `g_list_free`, after
        its elements have been unreffed with `g_object_unref`.
        """
    def has_media(self) -> bool:
        """
            Checks if the `drive` has media. Note that the OS may not be polling
        the drive for media changes; see `g_drive_is_media_check_automatic`
        for more details.
        """
    def has_volumes(self) -> bool:
        """
        Check if `drive` has any mountable volumes.
        """
    def is_media_check_automatic(self) -> bool:
        """
        Checks if `drive` is capable of automatically detecting media changes.
        """
    def is_media_removable(self) -> bool:
        """
        Checks if the `drive` supports removable media.
        """
    def is_removable(self) -> bool:
        """
            Checks if the GDrive and/or its media is considered removable by the user.
        See `g_drive_is_media_removable`.
        """
    async def poll_for_media(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously polls `drive` to see if media has been inserted or removed.

        When the operation is finished, `callback` will be called.
        You can then call `g_drive_poll_for_media_finish` to obtain the
        result of the operation.
        """
    def poll_for_media_finish(self, result: AsyncResult) -> bool:
        """
        Finishes an operation started with `g_drive_poll_for_media` on a drive.
        """
    async def start(
        self,
        flags: DriveStartFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously starts a drive.

        When the operation is finished, `callback` will be called.
        You can then call `g_drive_start_finish` to obtain the
        result of the operation.
        """
    def start_finish(self, result: AsyncResult) -> bool:
        """
        Finishes starting a drive.
        """
    async def stop(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously stops a drive.

        When the operation is finished, `callback` will be called.
        You can then call `g_drive_stop_finish` to obtain the
        result of the operation.
        """
    def stop_finish(self, result: AsyncResult) -> bool:
        """
        Finishes stopping a drive.
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
        Emitted when the drive's state has changed.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["disconnected"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            This signal is emitted when the GDrive have been
        disconnected. If the recipient is holding references to the
        object they should release them so the object can be
        finalized.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["eject-button"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            Emitted when the physical eject button (if any) of a drive has
        been pressed.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["stop-button"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            Emitted when the physical stop button (if any) of a drive has
        been pressed.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DriveIface(GObject.GPointer):
    """
    Interface for creating GDrive implementations.
    """

    # gi Fields
    @builtins.property
    def can_eject(self) -> can_ejectDriveIfaceCB:
        """
        Returns True if the GDrive can eject media.
        """
    @builtins.property
    def can_poll_for_media(self) -> can_poll_for_mediaDriveIfaceCB:
        """
        Returns True if the GDrive is capable of manually polling for media change.
        """
    @builtins.property
    def can_start(self) -> can_startDriveIfaceCB:
        """
        Returns True if a GDrive can be started. Since 2.22.
        """
    @builtins.property
    def can_start_degraded(self) -> can_start_degradedDriveIfaceCB:
        """
        Returns True if a GDrive can be started degraded. Since 2.22.
        """
    @builtins.property
    def can_stop(self) -> can_stopDriveIfaceCB:
        """
        Returns True if a GDrive can be stopped. Since 2.22.
        """
    @builtins.property
    def changed(self) -> changedDriveIfaceCB:
        """
        Signal emitted when the drive is changed.
        """
    @builtins.property
    def disconnected(self) -> disconnectedDriveIfaceCB:
        """
        The removed signal that is emitted when the GDrive have been disconnected. If the recipient is holding references to the object they should release them so the object can be finalized.
        """
    @builtins.property
    def eject(self) -> ejectDriveIfaceCB:
        """
        Ejects a GDrive.
        """
    @builtins.property
    def eject_button(self) -> eject_buttonDriveIfaceCB:
        """
        Signal emitted when the physical eject button (if any) of a drive have been pressed.
        """
    @builtins.property
    def eject_finish(self) -> eject_finishDriveIfaceCB:
        """
        Finishes an eject operation.
        """
    @builtins.property
    def eject_with_operation(self) -> eject_with_operationDriveIfaceCB:
        """
        Starts ejecting a GDrive using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def eject_with_operation_finish(self) -> eject_with_operation_finishDriveIfaceCB:
        """
        Finishes an eject operation using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def enumerate_identifiers(self) -> enumerate_identifiersDriveIfaceCB:
        """
         Returns an array strings listing the kinds
        of identifiers which the GDrive has.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def get_icon(self) -> get_iconDriveIfaceCB:
        """
        Returns a GIcon for the given GDrive.
        """
    @builtins.property
    def get_identifier(self) -> get_identifierDriveIfaceCB | None:
        """
         Returns the identifier of the given kind, or None if
        the GDrive doesn't have one.
        """
    @builtins.property
    def get_name(self) -> get_nameDriveIfaceCB:
        """
        Returns the name for the given GDrive.
        """
    @builtins.property
    def get_sort_key(self) -> get_sort_keyDriveIfaceCB | None:
        """
        Gets a key used for sorting GDrive instances or None if no such key exists. Since 2.32.
        """
    @builtins.property
    def get_start_stop_type(self) -> get_start_stop_typeDriveIfaceCB:
        """
        Gets a GDriveStartStopType with details about starting/stopping the drive. Since 2.22.
        """
    @builtins.property
    def get_symbolic_icon(self) -> get_symbolic_iconDriveIfaceCB:
        """
        Returns a symbolic GIcon for the given GDrive. Since 2.34.
        """
    @builtins.property
    def get_volumes(self) -> get_volumesDriveIfaceCB:
        """
        Returns a list GList of GVolume for the GDrive.
        """
    @builtins.property
    def has_media(self) -> has_mediaDriveIfaceCB:
        """
        Returns True if the GDrive has media inserted.
        """
    @builtins.property
    def has_volumes(self) -> has_volumesDriveIfaceCB:
        """
        Returns True if the GDrive has mountable volumes.
        """
    @builtins.property
    def is_media_check_automatic(self) -> is_media_check_automaticDriveIfaceCB:
        """
        Returns True if the GDrive is capable of automatically detecting media changes.
        """
    @builtins.property
    def is_media_removable(self) -> is_media_removableDriveIfaceCB:
        """
        Returns True if the GDrive supports removal and insertion of media.
        """
    @builtins.property
    def is_removable(self) -> is_removableDriveIfaceCB:
        """
        Returns True if the GDrive and/or its media is considered removable by the user. Since 2.50.
        """
    @builtins.property
    def poll_for_media(self) -> poll_for_mediaDriveIfaceCB:
        """
        Poll for media insertion/removal on a GDrive.
        """
    @builtins.property
    def poll_for_media_finish(self) -> poll_for_media_finishDriveIfaceCB:
        """
        Finishes a media poll operation.
        """
    @builtins.property
    def start(self) -> startDriveIfaceCB:
        """
        Starts a GDrive. Since 2.22.
        """
    @builtins.property
    def start_finish(self) -> start_finishDriveIfaceCB:
        """
        Finishes a start operation. Since 2.22.
        """
    @builtins.property
    def stop(self) -> stopDriveIfaceCB:
        """
        Stops a GDrive. Since 2.22.
        """
    @builtins.property
    def stop_button(self) -> stop_buttonDriveIfaceCB:
        """
        Signal emitted when the physical stop button (if any) of a drive have been pressed. Since 2.22.
        """
    @builtins.property
    def stop_finish(self) -> stop_finishDriveIfaceCB:
        """
        Finishes a stop operation. Since 2.22.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DtlsClientConnection(GObject.GInterface):
    """
    `GDtlsClientConnection` is the client-side subclass of
    [iface`Gio`.DtlsConnection], representing a client-side DTLS connection.
    """

    class Props(GObject.GInterface.Props):
        accepted_cas: list | None  # [accepted-cas]: changed because contained invalid characters
        """
        A list of the distinguished names of the Certificate Authorities
        that the server will accept client certificates signed by. If the
        server requests a client certificate during the handshake, then
        this property will be set after the handshake completes.

        Each item in the list is a GByteArray which contains the complete
        subject DN of the certificate authority.
        """
        server_identity: SocketConnectable | None  # [server-identity]: changed because contained invalid characters
        """
        A GSocketConnectable describing the identity of the server that
        is expected on the other end of the connection.

        If the G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
        GDtlsClientConnection:validation-flags, this object will be used
        to determine the expected identify of the remote end of the
        connection; if GDtlsClientConnection:server-identity is not set,
        or does not match the identity presented by the server, then the
        G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.

        In addition to its use in verifying the server certificate,
        this is also used to give a hint to the server about what
        certificate we expect, which is useful for servers that serve
        virtual hosts.
        """
        validation_flags: TlsCertificateFlags  # [validation-flags]: changed because contained invalid characters
        """
        What steps to perform when validating a certificate received from
        a server. Server certificates that fail to validate in any of the
        ways indicated here will be rejected unless the application
        overrides the default via GDtlsConnection::accept-certificate.

        GLib guarantees that if certificate verification fails, at least one
        flag will be set, but it does not guarantee that all possible flags
        will be set. Accordingly, you may not safely decide to ignore any
        particular type of error. For example, it would be incorrect to mask
        G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
        because this could potentially be the only error flag set even if
        other problems exist with the certificate. Therefore, there is no
        safe way to use this property. This is not a horrible problem,
        though, because you should not be attempting to ignore validation
        errors anyway. If you really must ignore TLS certificate errors,
        connect to GDtlsConnection::accept-certificate.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, server_identity: SocketConnectable | None = ..., validation_flags: TlsCertificateFlags = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_accepted_cas(self) -> list:
        """
            Gets the list of distinguished names of the Certificate Authorities
        that the server will accept certificates from. This will be set
        during the TLS handshake if the server requests a certificate.
        Otherwise, it will be None.

        Each item in the list is a GByteArray which contains the complete
        subject DN of the certificate authority.
        """
    @builtins.property
    def get_server_identity(self) -> SocketConnectable:
        """
        Gets `conn`'s expected server identity
        """
    @deprecated("deprecated")
    @builtins.property
    def get_validation_flags(self) -> TlsCertificateFlags:
        """
            Gets `conn`'s validation flags

        This function does not work as originally designed and is impossible
        to use correctly. See GDtlsClientConnection:validation-flags for more
        information.
        """
    @staticmethod
    def new(base_socket: DatagramBased, server_identity: SocketConnectable | None = None) -> DtlsClientConnection:
        """
            Creates a new GDtlsClientConnection wrapping `base_socket` which is
        assumed to communicate with the server identified by `server_identity`.
        """
    def set_server_identity(self, identity: SocketConnectable) -> None:
        """
            Sets `conn`'s expected server identity, which is used both to tell
        servers on virtual hosts which certificate to present, and also
        to let `conn` know what name to look for in the certificate when
        performing G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
        """
    @deprecated("deprecated")
    def set_validation_flags(self, flags: TlsCertificateFlags) -> None:
        """
            Sets `conn`'s validation flags, to override the default set of
        checks performed when validating a server certificate. By default,
        G_TLS_CERTIFICATE_VALIDATE_ALL is used.

        This function does not work as originally designed and is impossible
        to use correctly. See GDtlsClientConnection:validation-flags for more
        information.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accepted_cas"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::server_identity"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::validation_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DtlsClientConnectionInterface(GObject.GPointer):
    """
    vtable for a GDtlsClientConnection implementation.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DtlsConnection(GObject.GInterface):
    """
    `GDtlsConnection` is the base DTLS connection class type, which wraps
    a [iface`Gio`.DatagramBased] and provides DTLS encryption on top of it. Its
    subclasses, [iface`Gio`.DtlsClientConnection] and
    [iface`Gio`.DtlsServerConnection], implement client-side and server-side DTLS,
    respectively.

    For TLS support, see [class`Gio`.TlsConnection].

    As DTLS is datagram based, `GDtlsConnection` implements
    [iface`Gio`.DatagramBased], presenting a datagram-socket-like API for the
    encrypted connection. This operates over a base datagram connection, which is
    also a `GDatagramBased` ([property`Gio`.DtlsConnection:base-socket]).

    To close a DTLS connection, use [method`Gio`.DtlsConnection.close].

    Neither [iface`Gio`.DtlsServerConnection] or [iface`Gio`.DtlsClientConnection]
    set the peer address on their base [iface`Gio`.DatagramBased] if it is a
    [class`Gio`.Socket] — it is up to the caller to do that if they wish. If they
    do not, and [method`Gio`.Socket.close] is called on the base socket, the
    `GDtlsConnection` will not raise a `G_IO_ERROR_NOT_CONNECTED` error on
    further I/O.
    """

    class Props(GObject.GInterface.Props):
        advertised_protocols: list | None  # [advertised-protocols]: changed because contained invalid characters
        """
        The list of application-layer protocols that the connection
        advertises that it is willing to speak. See
        `g_dtls_connection_set_advertised_protocols`.
        """
        base_socket: DatagramBased | None  # [base-socket]: changed because contained invalid characters
        """
        The GDatagramBased that the connection wraps. Note that this may be any
        implementation of GDatagramBased, not just a GSocket.
        """
        certificate: TlsCertificate | None
        """
        The connection's certificate; see
        `g_dtls_connection_set_certificate`.
        """
        ciphersuite_name: str  # [ciphersuite-name]: changed because contained invalid characters
        """
        The name of the DTLS ciphersuite in use. See `g_dtls_connection_get_ciphersuite_name`.
        """
        database: TlsDatabase | None
        """
        The certificate database to use when verifying this TLS connection.
        If no certificate database is set, then the default database will be
        used. See `g_tls_backend_get_default_database`.

        When using a non-default database, GDtlsConnection must fall back to using
        the GTlsDatabase to perform certificate verification using
        `g_tls_database_verify_chain`, which means certificate verification will
        not be able to make use of TLS session context. This may be less secure.
        For example, if you create your own GTlsDatabase that just wraps the
        default GTlsDatabase, you might expect that you have not changed anything,
        but this is not true because you may have altered the behavior of
        GDtlsConnection by causing it to use `g_tls_database_verify_chain`. See the
        documentation of `g_tls_database_verify_chain` for more details on specific
        security checks that may not be performed. Accordingly, setting a
        non-default database is discouraged except for specialty applications with
        unusual security requirements.
        """
        interaction: TlsInteraction | None
        """
        A GTlsInteraction object to be used when the connection or certificate
        database need to interact with the user. This will be used to prompt the
        user for passwords where necessary.
        """
        negotiated_protocol: str  # [negotiated-protocol]: changed because contained invalid characters
        """
        The application-layer protocol negotiated during the TLS
        handshake. See `g_dtls_connection_get_negotiated_protocol`.
        """
        peer_certificate: TlsCertificate | None  # [peer-certificate]: changed because contained invalid characters
        """
        The connection's peer's certificate, after the TLS handshake has
        completed or failed. Note in particular that this is not yet set
        during the emission of GDtlsConnection::accept-certificate.

        (You can watch for a GObject::notify signal on this property to
        detect when a handshake has occurred.)
        """
        peer_certificate_errors: (
            TlsCertificateFlags  # [peer-certificate-errors]: changed because contained invalid characters
        )
        """
        The errors noticed while verifying
        GDtlsConnection:peer-certificate. Normally this should be 0, but
        it may not be if GDtlsClientConnection:validation-flags is not
        G_TLS_CERTIFICATE_VALIDATE_ALL, or if
        GDtlsConnection::accept-certificate overrode the default
        behavior.

        GLib guarantees that if certificate verification fails, at least
        one error will be set, but it does not guarantee that all possible
        errors will be set. Accordingly, you may not safely decide to
        ignore any particular type of error. For example, it would be
        incorrect to mask G_TLS_CERTIFICATE_EXPIRED if you want to allow
        expired certificates, because this could potentially be the only
        error flag set even if other problems exist with the certificate.
        """
        protocol_version: TlsProtocolVersion  # [protocol-version]: changed because contained invalid characters
        """
        The DTLS protocol version in use. See `g_dtls_connection_get_protocol_version`.
        """
        rehandshake_mode: TlsRehandshakeMode  # [rehandshake-mode]: changed because contained invalid characters
        """
        The rehandshaking mode. See
        `g_dtls_connection_set_rehandshake_mode`.
        """
        require_close_notify: bool  # [require-close-notify]: changed because contained invalid characters
        """
        Whether or not proper TLS close notification is required.
        See `g_dtls_connection_set_require_close_notify`.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        advertised_protocols: list | None = ...,
        base_socket: DatagramBased | None = ...,
        certificate: TlsCertificate | None = ...,
        database: TlsDatabase | None = ...,
        interaction: TlsInteraction | None = ...,
        rehandshake_mode: TlsRehandshakeMode = ...,
        require_close_notify: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def close(self, cancellable: Cancellable | None = None) -> bool:
        """
            Close the DTLS connection. This is equivalent to calling
        `g_dtls_connection_shutdown` to shut down both sides of the connection.

        Closing a GDtlsConnection waits for all buffered but untransmitted data to
        be sent before it completes. It then sends a `close_notify` DTLS alert to the
        peer and may wait for a `close_notify` to be received from the peer. It does
        not close the underlying GDtlsConnection:base-socket; that must be closed
        separately.

        Once `conn` is closed, all other operations will return G_IO_ERROR_CLOSED.
        Closing a GDtlsConnection multiple times will not return an error.

        GDtlsConnections will be automatically closed when the last reference is
        dropped, but you might want to call this function to make sure resources are
        released as early as possible.

        If `cancellable` is cancelled, the GDtlsConnection may be left
        partially-closed and any pending untransmitted data may be lost. Call
        `g_dtls_connection_close` again to complete closing the GDtlsConnection.
        """
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously close the DTLS connection. See `g_dtls_connection_close` for
        more information.
        """
    def close_finish(self, result: AsyncResult) -> bool:
        """
            Finish an asynchronous TLS close operation. See `g_dtls_connection_close`
        for more information.
        """
    def emit_accept_certificate(self, peer_cert: TlsCertificate, errors: TlsCertificateFlags) -> bool:
        """
            Used by GDtlsConnection implementations to emit the
        GDtlsConnection::accept-certificate signal.
        """
    @builtins.property
    def get_certificate(self) -> TlsCertificate | None:
        """
            Gets `conn`'s certificate, as set by
        `g_dtls_connection_set_certificate`.
        """
    def get_channel_binding_data(self, type: TlsChannelBindingType) -> tuple[bool, list]:
        """
            Query the TLS backend for TLS channel binding data of `type` for `conn`.

        This call retrieves TLS channel binding data as specified in RFC
        [5056](https://tools.ietf.org/html/rfc5056), RFC
        [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
        binding data is returned in `data`.  The `data` is resized by the callee
        using GByteArray buffer management and will be freed when the `data`
        is destroyed by `g_byte_array_unref`. If `data` is None, it will only
        check whether TLS backend is able to fetch the data (e.g. whether `type`
        is supported by the TLS backend). It does not guarantee that the data
        will be available though.  That could happen if TLS connection does not
        support `type` or the binding data is not available yet due to additional
        negotiation or input required.
        """
    @builtins.property
    def get_ciphersuite_name(self) -> str | None:
        """
            Returns the name of the current DTLS ciphersuite, or None if the
        connection has not handshaked or has been closed. Beware that the TLS
        backend may use any of multiple different naming conventions, because
        OpenSSL and GnuTLS have their own ciphersuite naming conventions that
        are different from each other and different from the standard, IANA-
        registered ciphersuite names. The ciphersuite name is intended to be
        displayed to the user for informative purposes only, and parsing it
        is not recommended.
        """
    @builtins.property
    def get_database(self) -> TlsDatabase | None:
        """
            Gets the certificate database that `conn` uses to verify
        peer certificates. See `g_dtls_connection_set_database`.
        """
    @builtins.property
    def get_interaction(self) -> TlsInteraction | None:
        """
            Get the object that will be used to interact with the user. It will be used
        for things like prompting the user for passwords. If None is returned, then
        no user interaction will occur for this connection.
        """
    @builtins.property
    def get_negotiated_protocol(self) -> str | None:
        """
            Gets the name of the application-layer protocol negotiated during
        the handshake.

        If the peer did not use the ALPN extension, or did not advertise a
        protocol that matched one of `conn`'s protocols, or the TLS backend
        does not support ALPN, then this will be None. See
        `g_dtls_connection_set_advertised_protocols`.
        """
    @builtins.property
    def get_peer_certificate(self) -> TlsCertificate | None:
        """
            Gets `conn`'s peer's certificate after the handshake has completed
        or failed. (It is not set during the emission of
        GDtlsConnection::accept-certificate.)
        """
    @builtins.property
    def get_peer_certificate_errors(self) -> TlsCertificateFlags:
        """
            Gets the errors associated with validating `conn`'s peer's
        certificate, after the handshake has completed or failed. (It is
        not set during the emission of GDtlsConnection::accept-certificate.)
        """
    @builtins.property
    def get_protocol_version(self) -> TlsProtocolVersion:
        """
            Returns the current DTLS protocol version, which may be
        G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
        has been closed, or if the TLS backend has implemented a protocol version
        that is not a recognized GTlsProtocolVersion.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_rehandshake_mode(self) -> TlsRehandshakeMode:
        """
            Gets `conn` rehandshaking mode. See
        `g_dtls_connection_set_rehandshake_mode` for details.
        """
    @builtins.property
    def get_require_close_notify(self) -> bool:
        """
            Tests whether or not `conn` expects a proper TLS close notification
        when the connection is closed. See
        `g_dtls_connection_set_require_close_notify` for details.
        """
    def handshake(self, cancellable: Cancellable | None = None) -> bool:
        """
            Attempts a TLS handshake on `conn`.

        On the client side, it is never necessary to call this method;
        although the connection needs to perform a handshake after
        connecting, GDtlsConnection will handle this for you automatically
        when you try to send or receive data on the connection. You can call
        `g_dtls_connection_handshake` manually if you want to know whether
        the initial handshake succeeded or failed (as opposed to just
        immediately trying to use `conn` to read or write, in which case,
        if it fails, it may not be possible to tell if it failed before
        or after completing the handshake), but beware that servers may reject
        client authentication after the handshake has completed, so a
        successful handshake does not indicate the connection will be usable.

        Likewise, on the server side, although a handshake is necessary at
        the beginning of the communication, you do not need to call this
        function explicitly unless you want clearer error reporting.

        Previously, calling `g_dtls_connection_handshake` after the initial
        handshake would trigger a rehandshake; however, this usage was
        deprecated in GLib 2.60 because rehandshaking was removed from the
        TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
        the initial handshake will no longer do anything.

        GDtlsConnection::accept_certificate may be emitted during the
        handshake.
        """
    async def handshake_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously performs a TLS handshake on `conn`. See
        `g_dtls_connection_handshake` for more information.
        """
    def handshake_finish(self, result: AsyncResult) -> bool:
        """
            Finish an asynchronous TLS handshake operation. See
        `g_dtls_connection_handshake` for more information.
        """
    def set_advertised_protocols(self, protocols: list | None = None) -> None:
        """
            Sets the list of application-layer protocols to advertise that the
        caller is willing to speak on this connection. The
        Application-Layer Protocol Negotiation (ALPN) extension will be
        used to negotiate a compatible protocol with the peer; use
        `g_dtls_connection_get_negotiated_protocol` to find the negotiated
        protocol after the handshake.  Specifying None for the the value
        of `protocols` will disable ALPN negotiation.

        See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
        for a list of registered protocol IDs.
        """
    def set_certificate(self, certificate: TlsCertificate) -> None:
        """
            This sets the certificate that `conn` will present to its peer
        during the TLS handshake. For a GDtlsServerConnection, it is
        mandatory to set this, and that will normally be done at construct
        time.

        For a GDtlsClientConnection, this is optional. If a handshake fails
        with G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
        requires a certificate, and if you try connecting again, you should
        call this method first. You can call
        `g_dtls_client_connection_get_accepted_cas` on the failed connection
        to get a list of Certificate Authorities that the server will
        accept certificates from.

        (It is also possible that a server will allow the connection with
        or without a certificate; in that case, if you don't provide a
        certificate, you can tell that the server requested one by the fact
        that `g_dtls_client_connection_get_accepted_cas` will return
        non-None.)
        """
    def set_database(self, database: TlsDatabase | None = None) -> None:
        """
            Sets the certificate database that is used to verify peer certificates.
        This is set to the default database by default. See
        `g_tls_backend_get_default_database`. If set to None, then
        peer certificate validation will always set the
        G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
        GDtlsConnection::accept-certificate will always be emitted on
        client-side connections, unless that bit is not set in
        GDtlsClientConnection:validation-flags).

        There are nonintuitive security implications when using a non-default
        database. See GDtlsConnection:database for details.
        """
    def set_interaction(self, interaction: TlsInteraction | None = None) -> None:
        """
            Set the object that will be used to interact with the user. It will be used
        for things like prompting the user for passwords.

        The `interaction` argument will normally be a derived subclass of
        GTlsInteraction. None can also be provided if no user interaction
        should occur for this connection.
        """
    @deprecated("deprecated")
    def set_rehandshake_mode(self, mode: TlsRehandshakeMode) -> None:
        """
            Since GLib 2.64, changing the rehandshake mode is no longer supported
        and will have no effect. With TLS 1.3, rehandshaking has been removed from
        the TLS protocol, replaced by separate post-handshake authentication and
        rekey operations.
        """
    def set_require_close_notify(self, require_close_notify: bool) -> None:
        """
            Sets whether or not `conn` expects a proper TLS close notification
        before the connection is closed. If this is True (the default),
        then `conn` will expect to receive a TLS close notification from its
        peer before the connection is closed, and will return a
        G_TLS_ERROR_EOF error if the connection is closed without proper
        notification (since this may indicate a network error, or
        man-in-the-middle attack).

        In some protocols, the application will know whether or not the
        connection was closed cleanly based on application-level data
        (because the application-level data includes a length field, or is
        somehow self-delimiting); in this case, the close notify is
        redundant and may be omitted. You
        can use `g_dtls_connection_set_require_close_notify` to tell `conn`
        to allow an "unannounced" connection close, in which case the close
        will show up as a 0-length read, as in a non-TLS
        GDatagramBased, and it is up to the application to check that
        the data has been fully received.

        Note that this only affects the behavior when the peer closes the
        connection; when the application calls `g_dtls_connection_close_async` on
        `conn` itself, this will send a close notification regardless of the
        setting of this property. If you explicitly want to do an unclean
        close, you can close `conn`'s GDtlsConnection:base-socket rather
        than closing `conn` itself.
        """
    def shutdown(self, shutdown_read: bool, shutdown_write: bool, cancellable: Cancellable | None = None) -> bool:
        """
            Shut down part or all of a DTLS connection.

        If `shutdown_read` is True then the receiving side of the connection is shut
        down, and further reading is disallowed. Subsequent calls to
        `g_datagram_based_receive_messages` will return G_IO_ERROR_CLOSED.

        If `shutdown_write` is True then the sending side of the connection is shut
        down, and further writing is disallowed. Subsequent calls to
        `g_datagram_based_send_messages` will return G_IO_ERROR_CLOSED.

        It is allowed for both `shutdown_read` and `shutdown_write` to be True — this
        is equivalent to calling `g_dtls_connection_close`.

        If `cancellable` is cancelled, the GDtlsConnection may be left
        partially-closed and any pending untransmitted data may be lost. Call
        `g_dtls_connection_shutdown` again to complete closing the GDtlsConnection.
        """
    async def shutdown_async(
        self,
        shutdown_read: bool,
        shutdown_write: bool,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously shut down part or all of the DTLS connection. See
        `g_dtls_connection_shutdown` for more information.
        """
    def shutdown_finish(self, result: AsyncResult) -> bool:
        """
            Finish an asynchronous TLS shutdown operation. See
        `g_dtls_connection_shutdown` for more information.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["accept-certificate"],
        handler: typing.Callable[[typing_extensions.Self, TlsCertificate, TlsCertificateFlags], bool],
        *args: typing.Any,
    ) -> int:
        """
            Emitted during the TLS handshake after the peer certificate has
        been received. You can examine `peer_cert`'s certification path by
        calling `g_tls_certificate_get_issuer` on it.

        For a client-side connection, `peer_cert` is the server's
        certificate, and the signal will only be emitted if the
        certificate was not acceptable according to `conn`'s
        GDtlsClientConnection:validation_flags. If you would like the
        certificate to be accepted despite `errors`, return True from the
        signal handler. Otherwise, if no handler accepts the certificate,
        the handshake will fail with G_TLS_ERROR_BAD_CERTIFICATE.

        GLib guarantees that if certificate verification fails, this signal
        will be emitted with at least one error will be set in `errors`, but
        it does not guarantee that all possible errors will be set.
        Accordingly, you may not safely decide to ignore any particular
        type of error. For example, it would be incorrect to ignore
        G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
        certificates, because this could potentially be the only error flag
        set even if other problems exist with the certificate.

        For a server-side connection, `peer_cert` is the certificate
        presented by the client, if this was requested via the server's
        GDtlsServerConnection:authentication_mode. On the server side,
        the signal is always emitted when the client presents a
        certificate, and the certificate will only be accepted if a
        handler returns True.

        Note that if this signal is emitted as part of asynchronous I/O
        in the main thread, then you should not attempt to interact with
        the user before returning from the signal handler. If you want to
        let the user decide whether or not to accept the certificate, you
        would have to return False from the signal handler on the first
        attempt, and then after the connection attempt returns a
        G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user, and
        if the user decides to accept the certificate, remember that fact,
        create a new connection, and return True from the signal handler
        the next time.

        If you are doing I/O in another thread, you do not
        need to worry about this, and can simply block in the signal
        handler until the UI thread returns an answer.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::advertised_protocols"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_socket"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ciphersuite_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::database"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::interaction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::negotiated_protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::peer_certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::peer_certificate_errors"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::protocol_version"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rehandshake_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::require_close_notify"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DtlsConnectionInterface(GObject.GPointer):
    """
    Virtual method table for a GDtlsConnection implementation.
    """

    # gi Fields
    @builtins.property
    def accept_certificate(self) -> accept_certificateDtlsConnectionInterfaceCB:
        """
        Check whether to accept a certificate.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def get_binding_data(self) -> get_binding_dataDtlsConnectionInterfaceCB:
        """
        Retrieve TLS channel binding data (Since: 2.66)
        """
    @builtins.property
    def get_negotiated_protocol(self) -> get_negotiated_protocolDtlsConnectionInterfaceCB | None:
        """
        Get ALPN-negotiated protocol (Since: 2.60)
        """
    @builtins.property
    def handshake(self) -> handshakeDtlsConnectionInterfaceCB:
        """
        Perform a handshake operation.
        """
    @builtins.property
    def handshake_async(self) -> handshake_asyncDtlsConnectionInterfaceCB:
        """
        Start an asynchronous handshake operation.
        """
    @builtins.property
    def handshake_finish(self) -> handshake_finishDtlsConnectionInterfaceCB:
        """
        Finish an asynchronous handshake operation.
        """
    @builtins.property
    def set_advertised_protocols(self) -> set_advertised_protocolsDtlsConnectionInterfaceCB:
        """
        Set APLN protocol list (Since: 2.60)
        """
    @builtins.property
    def shutdown(self) -> shutdownDtlsConnectionInterfaceCB:
        """
        Shut down one or both directions of the connection.
        """
    @builtins.property
    def shutdown_async(self) -> shutdown_asyncDtlsConnectionInterfaceCB:
        """
        Start an asynchronous shutdown operation.
        """
    @builtins.property
    def shutdown_finish(self) -> shutdown_finishDtlsConnectionInterfaceCB:
        """
        Finish an asynchronous shutdown operation.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class DtlsServerConnection(GObject.GInterface):
    """
    `GDtlsServerConnection` is the server-side subclass of
    [iface`Gio`.DtlsConnection], representing a server-side DTLS connection.
    """

    class Props(GObject.GInterface.Props):
        authentication_mode: (
            TlsAuthenticationMode  # [authentication-mode]: changed because contained invalid characters
        )
        """
        The GTlsAuthenticationMode for the server. This can be changed
        before calling `g_dtls_connection_handshake` if you want to
        rehandshake with a different mode from the initial handshake.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, authentication_mode: TlsAuthenticationMode = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def new(base_socket: DatagramBased, certificate: TlsCertificate | None = None) -> DtlsServerConnection:
        """
        Creates a new GDtlsServerConnection wrapping `base_socket`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::authentication_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class DtlsServerConnectionInterface(GObject.GPointer):
    """
    vtable for a GDtlsServerConnection implementation.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Emblem(GObject.Object):
    """
    `GEmblem` is an implementation of [iface`Gio`.Icon] that supports
    having an emblem, which is an icon with additional properties.
    It can than be added to a [class`Gio`.EmblemedIcon].

    Currently, only metainformation about the emblem's origin is
    supported. More may be added in the future.
    """

    class Props(GObject.Object.Props):
        icon: GObject.Object | None
        """
        The actual icon of the emblem.
        """
        origin: EmblemOrigin
        """
        The origin the emblem is derived from.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, icon: GObject.Object | None = ..., origin: EmblemOrigin = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_icon(self) -> Icon:
        """
        Gives back the icon from `emblem`.
        """
    @builtins.property
    def get_origin(self) -> EmblemOrigin:
        """
        Gets the origin of the emblem.
        """
    @classmethod
    def new(cls, icon: Icon) -> Emblem:
        """
        Creates a new emblem for `icon`.
        """
    @classmethod
    def new_with_origin(cls, icon: Icon, origin: EmblemOrigin) -> Emblem:
        """
        Creates a new emblem for `icon`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::icon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::origin"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EmblemClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EmblemedIcon(GObject.Object):
    """
    `GEmblemedIcon` is an implementation of [iface`Gio`.Icon] that supports
    adding an emblem to an icon. Adding multiple emblems to an
    icon is ensured via [method`Gio`.EmblemedIcon.add_emblem].

    Note that `GEmblemedIcon` allows no control over the position
    of the emblems. See also [class`Gio`.Emblem] for more information.
    """

    class Props(GObject.Object.Props):
        gicon: Icon | None
        """
        The [iface`Gio`.Icon] to attach emblems to.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> EmblemedIconPrivate | None: ...

    # gi Methods
    def __init__(self, gicon: Icon | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_emblem(self, emblem: Emblem) -> None:
        """
        Adds `emblem` to the GList of GEmblems.
        """
    def clear_emblems(self) -> None:
        """
        Removes all the emblems from `icon`.
        """
    def get_emblems(self) -> list:
        """
        Gets the list of emblems for the `icon`.
        """
    def get_icon(self) -> Icon:
        """
        Gets the main icon for `emblemed`.
        """
    @classmethod
    def new(cls, icon: Icon, emblem: Emblem | None = None) -> EmblemedIcon:
        """
        Creates a new emblemed icon for `icon` with the emblem `emblem`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::gicon"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class EmblemedIconClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class EmblemedIconPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class File(GObject.GInterface):
    """
    `GFile` is a high level abstraction for manipulating files on a
    virtual file system. `GFile`s are lightweight, immutable objects
    that do no I/O upon creation. It is necessary to understand that
    `GFile` objects do not represent files, merely an identifier for a
    file. All file content I/O is implemented as streaming operations
    (see [class`Gio`.InputStream] and [class`Gio`.OutputStream]).

    To construct a `GFile`, you can use:

    - [func`Gio`.File.new_for_path] if you have a path.
    - [func`Gio`.File.new_for_uri] if you have a URI.
    - [func`Gio`.File.new_for_commandline_arg] or
      [func`Gio`.File.new_for_commandline_arg_and_cwd] for a command line
      argument.
    - [func`Gio`.File.new_tmp] to create a temporary file from a template.
    - [func`Gio`.File.new_tmp_async] to asynchronously create a temporary file.
    - [func`Gio`.File.new_tmp_dir_async] to asynchronously create a temporary
      directory.
    - [func`Gio`.File.parse_name] from a UTF-8 string gotten from
      [method`Gio`.File.get_parse_name].
    - [func`Gio`.File.new_build_filename] or [func`Gio`.File.new_build_filenamev]
      to create a file from path elements.

    One way to think of a `GFile` is as an abstraction of a pathname. For
    normal files the system pathname is what is stored internally, but as
    `GFile`s are extensible it could also be something else that corresponds
    to a pathname in a userspace implementation of a filesystem.

    `GFile`s make up hierarchies of directories and files that correspond to
    the files on a filesystem. You can move through the file system with
    `GFile` using [method`Gio`.File.get_parent] to get an identifier for the
    parent directory, [method`Gio`.File.get_child] to get a child within a
    directory, and [method`Gio`.File.resolve_relative_path] to resolve a relative
    path between two `GFile`s. There can be multiple hierarchies, so you may not
    end up at the same root if you repeatedly call [method`Gio`.File.get_parent]
    on two different files.

    All `GFile`s have a basename (get with [method`Gio`.File.get_basename]). These
    names are byte strings that are used to identify the file on the filesystem
    (relative to its parent directory) and there is no guarantees that they
    have any particular charset encoding or even make any sense at all. If
    you want to use filenames in a user interface you should use the display
    name that you can get by requesting the
    `G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME` attribute with
    [method`Gio`.File.query_info]. This is guaranteed to be in UTF-8 and can be
    used in a user interface. But always store the real basename or the `GFile`
    to use to actually access the file, because there is no way to go from a
    display name to the actual name.

    Using `GFile` as an identifier has the same weaknesses as using a path
    in that there may be multiple aliases for the same file. For instance,
    hard or soft links may cause two different `GFile`s to refer to the same
    file. Other possible causes for aliases are: case insensitive filesystems,
    short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
    check if two `GFile`s point to the same file you can query for the
    `G_FILE_ATTRIBUTE_ID_FILE` attribute. Note that `GFile` does some trivial
    canonicalization of pathnames passed in, so that trivial differences in
    the path string used at creation (duplicated slashes, slash at end of
    path, `.` or `..` path segments, etc) does not create different `GFile`s.

    Many `GFile` operations have both synchronous and asynchronous versions
    to suit your application. Asynchronous versions of synchronous functions
    simply have ``_async`` appended to their function names. The asynchronous
    I/O functions call a [callback`Gio`.AsyncReadyCallback] which is then used to
    finalize the operation, producing a [iface`Gio`.AsyncResult] which is then
    passed to the function’s matching ``_finish`` operation.

    It is highly recommended to use asynchronous calls when running within a
    shared main loop, such as in the main thread of an application. This avoids
    I/O operations blocking other sources on the main loop from being dispatched.
    Synchronous I/O operations should be performed from worker threads. See the
    [introduction to asynchronous programming section](overview.html#asynchronous-programming)
    for more.

    Some `GFile` operations almost always take a noticeable amount of time, and
    so do not have synchronous analogs. Notable cases include:

    - [method`Gio`.File.mount_mountable] to mount a mountable file.
    - [method`Gio`.File.unmount_mountable_with_operation] to unmount a mountable
      file.
    - [method`Gio`.File.eject_mountable_with_operation] to eject a mountable file.

    ## Entity Tags

    One notable feature of `GFile`s are entity tags, or ‘etags’ for
    short. Entity tags are somewhat like a more abstract version of the
    traditional mtime, and can be used to quickly determine if the file
    has been modified from the version on the file system. See the
    HTTP 1.1
    [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
    for HTTP `ETag` headers, which are a very similar concept.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append_to(self, flags: FileCreateFlags, cancellable: Cancellable | None = None) -> FileOutputStream:
        """
            Gets an output stream for appending data to the file.
        If the file doesn't already exist it is created.

        By default files created are generally readable by everyone,
        but if you pass G_FILE_CREATE_PRIVATE in `flags` the file
        will be made readable only to the current user, to the level that
        is supported on the target filesystem.

        If `cancellable` is not None, then the operation can be cancelled
        by triggering the cancellable object from another thread. If the
        operation was cancelled, the error G_IO_ERROR_CANCELLED will be
        returned.

        Some file systems don't allow all file names, and may return an
        G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
        G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
        possible too, and depend on what kind of filesystem the file is on.
        """
    async def append_to_async(
        self,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously opens `file` for appending.

        For more details, see `g_file_append_to` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_append_to_finish` to get the result
        of the operation.
        """
    def append_to_finish(self, res: AsyncResult) -> FileOutputStream:
        """
            Finishes an asynchronous file append operation started with
        `g_file_append_to_async`.
        """
    def build_attribute_list_for_copy(self, flags: FileCopyFlags, cancellable: Cancellable | None = None) -> str:
        """
            Prepares the file attribute query string for copying to `file`.

        This function prepares an attribute query string to be
        passed to `g_file_query_info` to get a list of attributes
        normally copied with the file (see `g_file_copy_attributes`
        for the detailed description). This function is used by the
        implementation of `g_file_copy_attributes` and is useful
        when one needs to query and set the attributes in two
        stages (e.g., for recursive move of a directory).
        """
    def copy(
        self,
        destination: File,
        flags: FileCopyFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        *progress_callback_data: object | None,
    ) -> bool:
        """
            Copies the file `source` to the location specified by `destination`.
        Can not handle recursive copies of directories.

        If the flag G_FILE_COPY_OVERWRITE is specified an already
        existing `destination` file is overwritten.

        If the flag G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
        will be copied as symlinks, otherwise the target of the
        `source` symlink will be copied.

        If the flag G_FILE_COPY_ALL_METADATA is specified then all the metadata
        that is possible to copy is copied, not just the default subset (which,
        for instance, does not include the owner, see GFileInfo).

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        If `progress_callback` is not None, then the operation can be monitored
        by setting this to a GFileProgressCallback function.
        `progress_callback_data` will be passed to this function. It is guaranteed
        that this callback will be called after all data has been transferred with
        the total number of bytes copied during the operation.

        If the `source` file does not exist, then the G_IO_ERROR_NOT_FOUND error
        is returned, independent on the status of the `destination`.

        If G_FILE_COPY_OVERWRITE is not specified and the target exists, then
        the error G_IO_ERROR_EXISTS is returned.

        If trying to overwrite a file over a directory, the G_IO_ERROR_IS_DIRECTORY
        error is returned. If trying to overwrite a directory with a directory the
        G_IO_ERROR_WOULD_MERGE error is returned.

        If the source is a directory and the target does not exist, or
        G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
        G_IO_ERROR_WOULD_RECURSE error is returned.

        If you are interested in copying the GFile object itself (not the on-disk
        file), see `g_file_dup`.
        """
    async def copy_async(
        self,
        destination: File,
        flags: FileCopyFlags,
        io_priority: int,
        cancellable: Cancellable | None,
        progress_callback_closure: GObject.Closure | None,
        ready_callback_closure: GObject.Closure,
    ) -> None:
        """
            Copies the file `source` to the location specified by `destination`
        asynchronously. For details of the behaviour, see `g_file_copy`.

        If `progress_callback` is not None, then that function that will be called
        just like in `g_file_copy`. The callback will run in the default main context
        of the thread calling `g_file_copy_async` — the same context as `callback` is
        run in.

        When the operation is finished, `callback` will be called. You can then call
        `g_file_copy_finish` to get the result of the operation.
        """
    def copy_attributes(self, destination: File, flags: FileCopyFlags, cancellable: Cancellable | None = None) -> bool:
        """
            Copies the file attributes from `source` to `destination`.

        Normally only a subset of the file attributes are copied,
        those that are copies in a normal file copy operation
        (which for instance does not include e.g. owner). However
        if G_FILE_COPY_ALL_METADATA is specified in `flags`, then
        all the metadata that is possible to copy is copied. This
        is useful when implementing move by copy + delete source.
        """
    def copy_finish(self, res: AsyncResult) -> bool:
        """
        Finishes copying the file started with `g_file_copy_async`.
        """
    def create(self, flags: FileCreateFlags, cancellable: Cancellable | None = None) -> FileOutputStream:
        """
            Creates a new file and returns an output stream for writing to it.
        The file must not already exist.

        By default files created are generally readable by everyone,
        but if you pass G_FILE_CREATE_PRIVATE in `flags` the file
        will be made readable only to the current user, to the level
        that is supported on the target filesystem.

        If `cancellable` is not None, then the operation can be cancelled
        by triggering the cancellable object from another thread. If the
        operation was cancelled, the error G_IO_ERROR_CANCELLED will be
        returned.

        If a file or directory with this name already exists the
        G_IO_ERROR_EXISTS error will be returned. Some file systems don't
        allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME
        error, and if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will
        be returned. Other errors are possible too, and depend on what kind
        of filesystem the file is on.
        """
    async def create_async(
        self,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously creates a new file and returns an output stream
        for writing to it. The file must not already exist.

        For more details, see `g_file_create` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_create_finish` to get the result
        of the operation.
        """
    def create_finish(self, res: AsyncResult) -> FileOutputStream:
        """
            Finishes an asynchronous file create operation started with
        `g_file_create_async`.
        """
    def create_readwrite(self, flags: FileCreateFlags, cancellable: Cancellable | None = None) -> FileIOStream:
        """
            Creates a new file and returns a stream for reading and
        writing to it. The file must not already exist.

        By default files created are generally readable by everyone,
        but if you pass G_FILE_CREATE_PRIVATE in `flags` the file
        will be made readable only to the current user, to the level
        that is supported on the target filesystem.

        If `cancellable` is not None, then the operation can be cancelled
        by triggering the cancellable object from another thread. If the
        operation was cancelled, the error G_IO_ERROR_CANCELLED will be
        returned.

        If a file or directory with this name already exists, the
        G_IO_ERROR_EXISTS error will be returned. Some file systems don't
        allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME
        error, and if the name is too long, G_IO_ERROR_FILENAME_TOO_LONG
        will be returned. Other errors are possible too, and depend on what
        kind of filesystem the file is on.

        Note that in many non-local file cases read and write streams are
        not supported, so make sure you really need to do read and write
        streaming, rather than just opening for reading or writing.
        """
    async def create_readwrite_async(
        self,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously creates a new file and returns a stream
        for reading and writing to it. The file must not already exist.

        For more details, see `g_file_create_readwrite` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_create_readwrite_finish` to get
        the result of the operation.
        """
    def create_readwrite_finish(self, res: AsyncResult) -> FileIOStream:
        """
            Finishes an asynchronous file create operation started with
        `g_file_create_readwrite_async`.
        """
    def delete(self, cancellable: Cancellable | None = None) -> bool:
        """
            Deletes a file. If the `file` is a directory, it will only be
        deleted if it is empty. This has the same semantics as `g_unlink`.

        If `file` doesn’t exist, G_IO_ERROR_NOT_FOUND will be returned. This allows
        for deletion to be implemented avoiding
        [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
        |[
        g_autoptr(GError) local_error = None;
        if (!g_file_delete (my_file, my_cancellable, &local_error) &&
            !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
          {
            // deletion failed for some reason other than the file not existing:
            // so report the error
            g_warning ("Failed to delete %s: %s",
                       g_file_peek_path (my_file), local_error->message);
          }
        ]|

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def delete_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously delete a file. If the `file` is a directory, it will
        only be deleted if it is empty.  This has the same semantics as
        `g_unlink`.
        """
    def delete_finish(self, result: AsyncResult) -> bool:
        """
        Finishes deleting a file started with `g_file_delete_async`.
        """
    def dup(self) -> File:
        """
            Duplicates a GFile handle. This operation does not duplicate
        the actual file or directory represented by the GFile; see
        `g_file_copy` if attempting to copy a file.

        `g_file_dup` is useful when a second handle is needed to the same underlying
        file, for use in a separate thread (GFile is not thread-safe). For use
        within the same thread, use `g_object_ref` to increment the existing object’s
        reference count.

        This call does no blocking I/O.
        """
    @deprecated("deprecated")
    async def eject_mountable(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Starts an asynchronous eject on a mountable.
        When this operation has completed, `callback` will be called with
        `user_user` data, and the operation can be finalized with
        `g_file_eject_mountable_finish`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    @deprecated("deprecated")
    def eject_mountable_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an asynchronous eject operation started by
        `g_file_eject_mountable`.
        """
    async def eject_mountable_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Starts an asynchronous eject on a mountable.
        When this operation has completed, `callback` will be called with
        `user_user` data, and the operation can be finalized with
        `g_file_eject_mountable_with_operation_finish`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def eject_mountable_with_operation_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an asynchronous eject operation started by
        `g_file_eject_mountable_with_operation`.
        """
    def enumerate_children(
        self, attributes: str, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> FileEnumerator:
        """
            Gets the requested information about the files in a directory.
        The result is a GFileEnumerator object that will give out
        GFileInfo objects for all the files in the directory.

        The `attributes` value is a string that specifies the file
        attributes that should be gathered. It is not an error if
        it's not possible to read a particular requested attribute
        from a file - it just won't be set. `attributes` should
        be a comma-separated list of attributes or attribute wildcards.
        The wildcard "*" means all attributes, and a wildcard like
        "standard::*" means all attributes in the standard namespace.
        An example attribute query be "standard::*,owner::user".
        The standard attributes are available as defines, like
        G_FILE_ATTRIBUTE_STANDARD_NAME. G_FILE_ATTRIBUTE_STANDARD_NAME should
        always be specified if you plan to call `g_file_enumerator_get_child` or
        `g_file_enumerator_iterate` on the returned enumerator.

        If `cancellable` is not None, then the operation can be cancelled
        by triggering the cancellable object from another thread. If the
        operation was cancelled, the error G_IO_ERROR_CANCELLED will be
        returned.

        If the file does not exist, the G_IO_ERROR_NOT_FOUND error will
        be returned. If the file is not a directory, the G_IO_ERROR_NOT_DIRECTORY
        error will be returned. Other errors are possible too.
        """
    async def enumerate_children_async(
        self,
        attributes: str,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously gets the requested information about the files
        in a directory. The result is a GFileEnumerator object that will
        give out GFileInfo objects for all the files in the directory.

        For more details, see `g_file_enumerate_children` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called. You can
        then call `g_file_enumerate_children_finish` to get the result of
        the operation.
        """
    def enumerate_children_finish(self, res: AsyncResult) -> FileEnumerator:
        """
            Finishes an async enumerate children operation.
        See `g_file_enumerate_children_async`.
        """
    def equal(self, file2: File) -> bool:
        """
            Checks if the two given GFiles refer to the same file.

        Note that two GFiles that differ can still refer to the same
        file on the filesystem due to various forms of filename
        aliasing.

        This call does no blocking I/O.
        """
    def find_enclosing_mount(self, cancellable: Cancellable | None = None) -> Mount:
        """
            Gets a GMount for the GFile.

        GMount is returned only for user interesting locations, see
        GVolumeMonitor. If the GFileIface for `file` does not have a #mount,
        `error` will be set to G_IO_ERROR_NOT_FOUND and None #will be returned.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def find_enclosing_mount_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously gets the mount for the file.

        For more details, see `g_file_find_enclosing_mount` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_find_enclosing_mount_finish` to
        get the result of the operation.
        """
    def find_enclosing_mount_finish(self, res: AsyncResult) -> Mount:
        """
            Finishes an asynchronous find mount request.
        See `g_file_find_enclosing_mount_async`.
        """
    def get_basename(self) -> str | None:
        """
            Gets the base name (the last component of the path) for a given GFile.

        If called for the top level of a system (such as the filesystem root
        or a uri like sftp://host/) it will return a single directory separator
        (and on Windows, possibly a drive letter).

        The base name is a byte string (not UTF-8). It has no defined encoding
        or rules other than it may not contain zero bytes.  If you want to use
        filenames in a user interface you should use the display name that you
        can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
        attribute with `g_file_query_info`.

        This call does no blocking I/O.
        """
    def get_child(self, name: str) -> File:
        """
            Gets a child of `file` with basename equal to `name`.

        Note that the file with that specific name might not exist, but
        you can still have a GFile that points to it. You can use this
        for instance to create that file.

        This call does no blocking I/O.
        """
    def get_child_for_display_name(self, display_name: str) -> File:
        """
            Gets the child of `file` for a given `display_name` (i.e. a UTF-8
        version of the name). If this function fails, it returns None
        and `error` will be set. This is very useful when constructing a
        GFile for a new file and the user entered the filename in the
        user interface, for instance when you select a directory and
        type a filename in the file selector.

        This call does no blocking I/O.
        """
    def get_parent(self) -> File | None:
        """
            Gets the parent directory for the `file`.
        If the `file` represents the root directory of the
        file system, then None will be returned.

        This call does no blocking I/O.
        """
    def get_parse_name(self) -> str:
        """
            Gets the parse name of the `file`.
        A parse name is a UTF-8 string that describes the
        file such that one can get the GFile back using
        `g_file_parse_name`.

        This is generally used to show the GFile as a nice
        full-pathname kind of string in a user interface,
        like in a location entry.

        For local files with names that can safely be converted
        to UTF-8 the pathname is used, otherwise the IRI is used
        (a form of URI that allows UTF-8 characters unescaped).

        This call does no blocking I/O.
        """
    def get_path(self) -> str | None:
        """
            Gets the local pathname for GFile, if one exists. If non-None, this is
        guaranteed to be an absolute, canonical path. It might contain symlinks.

        This call does no blocking I/O.
        """
    def get_relative_path(self, descendant: File) -> str | None:
        """
            Gets the path for `descendant` relative to `parent`.

        This call does no blocking I/O.
        """
    def get_uri(self) -> str:
        """
            Gets the URI for the `file`.

        This call does no blocking I/O.
        """
    def get_uri_scheme(self) -> str | None:
        """
            Gets the URI scheme for a GFile.
        RFC 3986 decodes the scheme as:
        |[
        URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
        ]|
        Common schemes include "file", "http", "ftp", etc.

        The scheme can be different from the one used to construct the GFile,
        in that it might be replaced with one that is logically equivalent to the GFile.

        This call does no blocking I/O.
        """
    def has_parent(self, parent: File | None = None) -> bool:
        """
            Checks if `file` has a parent, and optionally, if it is `parent`.

        If `parent` is None then this function returns True if `file` has any
        parent at all.  If `parent` is non-None then True is only returned
        if `file` is an immediate child of `parent`.
        """
    def has_prefix(self, prefix: File) -> bool:
        """
            Checks whether `file` has the prefix specified by `prefix`.

        In other words, if the names of initial elements of `file`'s
        pathname match `prefix`. Only full pathname elements are matched,
        so a path like /foo is not considered a prefix of /foobar, only
        of /foo/bar.

        A GFile is not a prefix of itself. If you want to check for
        equality, use `g_file_equal`.

        This call does no I/O, as it works purely on names. As such it can
        sometimes return False even if `file` is inside a `prefix` (from a
        filesystem point of view), because the prefix of `file` is an alias
        of `prefix`.
        """
    def has_uri_scheme(self, uri_scheme: str) -> bool:
        """
            Checks to see if a GFile has a given URI scheme.

        This call does no blocking I/O.
        """
    def hash(self) -> int:
        """
            Creates a hash value for a GFile.

        This call does no blocking I/O.
        """
    def is_native(self) -> bool:
        """
            Checks to see if a file is native to the platform.

        A native file is one expressed in the platform-native filename format,
        e.g. "C:\\Windows" or "/usr/bin/". This does not mean the file is local,
        as it might be on a locally mounted remote filesystem.

        On some systems non-native files may be available using the native
        filesystem via a userspace filesystem (FUSE), in these cases this call
        will return False, but `g_file_get_path` will still return a native path.

        This call does no blocking I/O.
        """
    def load_bytes(self, cancellable: Cancellable | None = None) -> tuple[GLib.Bytes, str | None]:
        """
            Loads the contents of `file` and returns it as GBytes.

        If `file` is a resource:// based URI, the resulting bytes will reference the
        embedded resource instead of a copy. Otherwise, this is equivalent to calling
        `g_file_load_contents` and `g_bytes_new_take`.

        For resources, `etag_out` will be set to None.

        The data contained in the resulting GBytes is always zero-terminated, but
        this is not included in the GBytes length. The resulting GBytes should be
        freed with `g_bytes_unref` when no longer in use.
        """
    async def load_bytes_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously loads the contents of `file` as GBytes.

        If `file` is a resource:// based URI, the resulting bytes will reference the
        embedded resource instead of a copy. Otherwise, this is equivalent to calling
        `g_file_load_contents_async` and `g_bytes_new_take`.

        `callback` should call `g_file_load_bytes_finish` to get the result of this
        asynchronous operation.

        See `g_file_load_bytes` for more information.
        """
    def load_bytes_finish(self, result: AsyncResult) -> tuple[GLib.Bytes, str | None]:
        """
            Completes an asynchronous request to `g_file_load_bytes_async`.

        For resources, `etag_out` will be set to None.

        The data contained in the resulting GBytes is always zero-terminated, but
        this is not included in the GBytes length. The resulting GBytes should be
        freed with `g_bytes_unref` when no longer in use.

        See `g_file_load_bytes` for more information.
        """
    def load_contents(self, cancellable: Cancellable | None = None) -> tuple[bool, list, int, str | None]:
        """
            Loads the content of the file into memory. The data is always
        zero-terminated, but this is not included in the resultant `length`.
        The returned `contents` should be freed with `g_free` when no longer
        needed.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def load_contents_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Starts an asynchronous load of the `file`'s contents.

        For more details, see `g_file_load_contents` which is
        the synchronous version of this call.

        When the load operation has completed, `callback` will be called
        with `user` data. To finish the operation, call
        `g_file_load_contents_finish` with the GAsyncResult returned by
        the `callback`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def load_contents_finish(self, res: AsyncResult) -> tuple[bool, list, int, str | None]:
        """
            Finishes an asynchronous load of the `file`'s contents.
        The contents are placed in `contents`, and `length` is set to the
        size of the `contents` string. The `contents` should be freed with
        `g_free` when no longer needed. If `etag_out` is present, it will be
        set to the new entity tag for the `file`.
        """
    def load_partial_contents_finish(self, res: AsyncResult) -> tuple[bool, list, int, str | None]:
        """
            Finishes an asynchronous partial load operation that was started
        with `g_file_load_partial_contents_async`. The data is always
        zero-terminated, but this is not included in the resultant `length`.
        The returned `contents` should be freed with `g_free` when no longer
        needed.
        """
    def make_directory(self, cancellable: Cancellable | None = None) -> bool:
        """
            Creates a directory.

        Note that this will only create a child directory
        of the immediate parent directory of the path or URI given by the GFile.
        To recursively create directories, see `g_file_make_directory_with_parents`.

        This function will fail if the parent directory does not exist, setting
        `error` to G_IO_ERROR_NOT_FOUND. If the file system doesn't support
        creating directories, this function will fail, setting `error` to
        G_IO_ERROR_NOT_SUPPORTED. If the directory already exists,
        [error`Gio`.IOErrorEnum.EXISTS] will be returned.

        For a local GFile the newly created directory will have the default
        (current) ownership and permissions of the current process.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def make_directory_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
        Asynchronously creates a directory.
        """
    def make_directory_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an asynchronous directory creation, started with
        `g_file_make_directory_async`.
        """
    def make_directory_with_parents(self, cancellable: Cancellable | None = None) -> bool:
        """
            Creates a directory and any parent directories that may not
        exist similar to 'mkdir -p'. If the file system does not support
        creating directories, this function will fail, setting `error` to
        G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
        this function will fail setting `error` to G_IO_ERROR_EXISTS, unlike
        the similar `g_mkdir_with_parents`.

        For a local GFile the newly created directories will have the default
        (current) ownership and permissions of the current process.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def make_symbolic_link(self, symlink_value: str, cancellable: Cancellable | None = None) -> bool:
        """
            Creates a symbolic link named `file` which contains the string
        `symlink_value`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def make_symbolic_link_async(
        self,
        symlink_value: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously creates a symbolic link named `file` which contains the
        string `symlink_value`.
        """
    def make_symbolic_link_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an asynchronous symbolic link creation, started with
        `g_file_make_symbolic_link_async`.
        """
    def measure_disk_usage(
        self,
        flags: FileMeasureFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileMeasureProgressCallback | None = None,
        *progress_data: object | None,
    ) -> tuple[bool, int, int, int]:
        """
            Recursively measures the disk usage of `file`.

        This is essentially an analog of the 'du' command, but it also
        reports the number of directories and non-directory files encountered
        (including things like symbolic links).

        By default, errors are only reported against the toplevel file
        itself.  Errors found while recursing are silently ignored, unless
        G_FILE_MEASURE_REPORT_ANY_ERROR is given in `flags`.

        The returned size, `disk_usage`, is in bytes and should be formatted
        with `g_format_size` in order to get something reasonable for showing
        in a user interface.

        `progress_callback` and `progress_data` can be given to request
        periodic progress updates while scanning.  See the documentation for
        GFileMeasureProgressCallback for information about when and how the
        callback will be invoked.
        """
    def measure_disk_usage_finish(self, result: AsyncResult) -> tuple[bool, int, int, int]:
        """
            Collects the results from an earlier call to
        `g_file_measure_disk_usage_async`.  See `g_file_measure_disk_usage` for
        more information.
        """
    def monitor(self, flags: FileMonitorFlags, cancellable: Cancellable | None = None) -> FileMonitor:
        """
            Obtains a file or directory monitor for the given file,
        depending on the type of the file.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def monitor_directory(self, flags: FileMonitorFlags, cancellable: Cancellable | None = None) -> FileMonitor:
        """
            Obtains a directory monitor for the given file.
        This may fail if directory monitoring is not supported.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        It does not make sense for `flags` to contain
        G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
        directories.  It is not possible to monitor all the files in a
        directory for changes made via hard links; if you want to do this then
        you must register individual watches with `g_file_monitor`.
        """
    def monitor_file(self, flags: FileMonitorFlags, cancellable: Cancellable | None = None) -> FileMonitor:
        """
            Obtains a file monitor for the given file. If no file notification
        mechanism exists, then regular polling of the file is used.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        If `flags` contains G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
        will also attempt to report changes made to the file via another
        filename (ie, a hard link). Without this flag, you can only rely on
        changes made through the filename contained in `file` to be
        reported. Using this flag may result in an increase in resource
        usage, and may not have any effect depending on the GFileMonitor
        backend and/or filesystem type.
        """
    async def mount_enclosing_volume(
        self,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Starts a `mount_operation`, mounting the volume that contains
        the file `location`.

        When this operation has completed, `callback` will be called with
        `user_user` data, and the operation can be finalized with
        `g_file_mount_enclosing_volume_finish`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def mount_enclosing_volume_finish(self, result: AsyncResult) -> bool:
        """
        Finishes a mount operation started by `g_file_mount_enclosing_volume`.
        """
    async def mount_mountable(
        self,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Mounts a file of type G_FILE_TYPE_MOUNTABLE.
        Using `mount_operation`, you can request callbacks when, for instance,
        passwords are needed during authentication.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_mount_mountable_finish` to get
        the result of the operation.
        """
    def mount_mountable_finish(self, result: AsyncResult) -> File:
        """
            Finishes a mount operation. See `g_file_mount_mountable` for details.

        Finish an asynchronous mount operation that was started
        with `g_file_mount_mountable`.
        """
    def move(
        self,
        destination: File,
        flags: FileCopyFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        *progress_callback_data: object | None,
    ) -> bool:
        """
            Tries to move the file or directory `source` to the location specified
        by `destination`. If native move operations are supported then this is
        used, otherwise a copy + delete fallback is used. The native
        implementation may support moving directories (for instance on moves
        inside the same filesystem), but the fallback code does not.

        If the flag G_FILE_COPY_OVERWRITE is specified an already
        existing `destination` file is overwritten.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        If `progress_callback` is not None, then the operation can be monitored
        by setting this to a GFileProgressCallback function.
        `progress_callback_data` will be passed to this function. It is
        guaranteed that this callback will be called after all data has been
        transferred with the total number of bytes copied during the operation.

        If the `source` file does not exist, then the G_IO_ERROR_NOT_FOUND
        error is returned, independent on the status of the `destination`.

        If G_FILE_COPY_OVERWRITE is not specified and the target exists,
        then the error G_IO_ERROR_EXISTS is returned.

        If trying to overwrite a file over a directory, the G_IO_ERROR_IS_DIRECTORY
        error is returned. If trying to overwrite a directory with a directory the
        G_IO_ERROR_WOULD_MERGE error is returned.

        If the source is a directory and the target does not exist, or
        G_FILE_COPY_OVERWRITE is specified and the target is a file, then
        the G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
        move operation isn't available).
        """
    async def move_async(
        self,
        destination: File,
        flags: FileCopyFlags,
        io_priority: int,
        cancellable: Cancellable | None,
        progress_callback_closure: GObject.Closure | None,
        ready_callback_closure: GObject.Closure,
    ) -> None:
        """
            Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see `g_file_move`.

        If `progress_callback` is not None, then that function that will be called
        just like in `g_file_move`. The callback will run in the default main context
        of the thread calling `g_file_move_async` — the same context as `callback` is
        run in.

        When the operation is finished, `callback` will be called. You can then call
        `g_file_move_finish` to get the result of the operation.
        """
    def move_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an asynchronous file movement, started with
        `g_file_move_async`.
        """
    @staticmethod
    def new_build_filenamev(args: list) -> File:
        """
            Constructs a GFile from a vector of elements using the correct
        separator for filenames.

        Using this function is equivalent to calling `g_build_filenamev`,
        followed by `g_file_new_for_path` on the result.
        """
    @staticmethod
    def new_for_commandline_arg(arg: str) -> File:
        """
            Creates a GFile with the given argument from the command line.
        The value of `arg` can be either a URI, an absolute path or a
        relative path resolved relative to the current working directory.
        This operation never fails, but the returned object might not
        support any I/O operation if `arg` points to a malformed path.

        Note that on Windows, this function expects its argument to be in
        UTF-8 -- not the system code page.  This means that you
        should not use this function with string from argv as it is passed
        to `main`.  `g_win32_get_command_line` will return a UTF-8 version of
        the commandline.  GApplication also uses UTF-8 but
        `g_application_command_line_create_file_for_arg` may be more useful
        for you there.  It is also always possible to use this function with
        GOptionContext arguments of type G_OPTION_ARG_FILENAME.
        """
    @staticmethod
    def new_for_commandline_arg_and_cwd(arg: str, cwd: str) -> File:
        """
            Creates a GFile with the given argument from the command line.

        This function is similar to `g_file_new_for_commandline_arg` except
        that it allows for passing the current working directory as an
        argument instead of using the current working directory of the
        process.

        This is useful if the commandline argument was given in a context
        other than the invocation of the current process.

        See also `g_application_command_line_create_file_for_arg`.
        """
    @staticmethod
    def new_for_path(path: str) -> File:
        """
            Constructs a GFile for a given path. This operation never
        fails, but the returned object might not support any I/O
        operation if `path` is malformed.
        """
    @staticmethod
    def new_for_uri(uri: str) -> File:
        """
            Constructs a GFile for a given URI. This operation never
        fails, but the returned object might not support any I/O
        operation if `uri` is malformed or if the uri type is
        not supported.
        """
    @staticmethod
    def new_tmp(tmpl: str | None = None) -> tuple[File, FileIOStream]:
        """
            Opens a file in the preferred directory for temporary files (as
        returned by `g_get_tmp_dir`) and returns a GFile and
        GFileIOStream pointing to it.

        `tmpl` should be a string in the GLib file name encoding
        containing a sequence of six 'X' characters, and containing no
        directory components. If it is None, a default template is used.

        Unlike the other GFile constructors, this will return None if
        a temporary file could not be created.
        """
    @staticmethod
    async def new_tmp_async(
        tmpl: str | None,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously opens a file in the preferred directory for temporary files
         (as returned by `g_get_tmp_dir`) as `g_file_new_tmp`.

        `tmpl` should be a string in the GLib file name encoding
        containing a sequence of six 'X' characters, and containing no
        directory components. If it is None, a default template is used.
        """
    @staticmethod
    async def new_tmp_dir_async(
        tmpl: str | None,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously creates a directory in the preferred directory for
        temporary files (as returned by `g_get_tmp_dir`) as `g_dir_make_tmp`.

        `tmpl` should be a string in the GLib file name encoding
        containing a sequence of six 'X' characters, and containing no
        directory components. If it is None, a default template is used.
        """
    @staticmethod
    def new_tmp_dir_finish(result: AsyncResult) -> File:
        """
            Finishes a temporary directory creation started by
        `g_file_new_tmp_dir_async`.
        """
    @staticmethod
    def new_tmp_finish(result: AsyncResult) -> tuple[File, FileIOStream]:
        """
        Finishes a temporary file creation started by `g_file_new_tmp_async`.
        """
    def open_readwrite(self, cancellable: Cancellable | None = None) -> FileIOStream:
        """
            Opens an existing file for reading and writing. The result is
        a GFileIOStream that can be used to read and write the contents
        of the file.

        If `cancellable` is not None, then the operation can be cancelled
        by triggering the cancellable object from another thread. If the
        operation was cancelled, the error G_IO_ERROR_CANCELLED will be
        returned.

        If the file does not exist, the G_IO_ERROR_NOT_FOUND error will
        be returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY
        error will be returned. Other errors are possible too, and depend on
        what kind of filesystem the file is on. Note that in many non-local
        file cases read and write streams are not supported, so make sure you
        really need to do read and write streaming, rather than just opening
        for reading or writing.
        """
    async def open_readwrite_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously opens `file` for reading and writing.

        For more details, see `g_file_open_readwrite` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_open_readwrite_finish` to get
        the result of the operation.
        """
    def open_readwrite_finish(self, res: AsyncResult) -> FileIOStream:
        """
            Finishes an asynchronous file read operation started with
        `g_file_open_readwrite_async`.
        """
    @staticmethod
    def parse_name(parse_name: str) -> File:
        """
            Constructs a GFile with the given `parse_name` (i.e. something
        given by `g_file_get_parse_name`). This operation never fails,
        but the returned object might not support any I/O operation if
        the `parse_name` cannot be parsed.
        """
    def peek_path(self) -> str | None:
        """
            Exactly like `g_file_get_path`, but caches the result via
        `g_object_set_qdata_full`.  This is useful for example in C
        applications which mix `g_file_*` APIs with native ones.  It
        also avoids an extra duplicated string when possible, so will be
        generally more efficient.

        This call does no blocking I/O.
        """
    async def poll_mountable(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Polls a file of type G_FILE_TYPE_MOUNTABLE.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_mount_mountable_finish` to get
        the result of the operation.
        """
    def poll_mountable_finish(self, result: AsyncResult) -> bool:
        """
            Finishes a poll operation. See `g_file_poll_mountable` for details.

        Finish an asynchronous poll operation that was polled
        with `g_file_poll_mountable`.
        """
    def query_default_handler(self, cancellable: Cancellable | None = None) -> AppInfo:
        """
            Returns the GAppInfo that is registered as the default
        application to handle the file specified by `file`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def query_default_handler_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
        Async version of `g_file_query_default_handler`.
        """
    def query_default_handler_finish(self, result: AsyncResult) -> AppInfo:
        """
        Finishes a `g_file_query_default_handler_async` operation.
        """
    def query_exists(self, cancellable: Cancellable | None = None) -> bool:
        """
            Utility function to check if a particular file exists.

        The fallback implementation of this API is using [method`Gio`.File.query_info]
        and therefore may do blocking I/O. To asynchronously query the existence
        of a file, use [method`Gio`.File.query_info_async].

        Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
        and then execute something based on the outcome of that, because the
        file might have been created or removed in between the operations. The
        general approach to handling that is to not check, but just do the
        operation and handle the errors as they come.

        As an example of race-free checking, take the case of reading a file,
        and if it doesn't exist, creating it. There are two racy versions: read
        it, and on error create it; and: check if it exists, if not create it.
        These can both result in two processes creating the file (with perhaps
        a partially written file as the result). The correct approach is to
        always try to create the file with `g_file_create` which will either
        atomically create the file or fail with a G_IO_ERROR_EXISTS error.

        However, in many cases an existence check is useful in a user interface,
        for instance to make a menu item sensitive/insensitive, so that you don't
        have to fool users that something is possible and then just show an error
        dialog. If you do this, you should make sure to also handle the errors
        that can happen due to races when you execute the operation.
        """
    def query_file_type(self, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None) -> FileType:
        """
            Utility function to inspect the GFileType of a file. This is
        implemented using `g_file_query_info` and as such does blocking I/O.

        The primary use case of this method is to check if a file is
        a regular file, directory, or symlink.
        """
    def query_filesystem_info(self, attributes: str, cancellable: Cancellable | None = None) -> FileInfo:
        """
            Similar to `g_file_query_info`, but obtains information
        about the filesystem the `file` is on, rather than the file itself.
        For instance the amount of space available and the type of
        the filesystem.

        The `attributes` value is a string that specifies the attributes
        that should be gathered. It is not an error if it's not possible
        to read a particular requested attribute from a file - it just
        won't be set. `attributes` should be a comma-separated list of
        attributes or attribute wildcards. The wildcard "*" means all
        attributes, and a wildcard like "filesystem::*" means all attributes
        in the filesystem namespace. The standard namespace for filesystem
        attributes is "filesystem". Common attributes of interest are
        G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
        in bytes), G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
        and G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).

        If `cancellable` is not None, then the operation can be cancelled
        by triggering the cancellable object from another thread. If the
        operation was cancelled, the error G_IO_ERROR_CANCELLED will be
        returned.

        If the file does not exist, the G_IO_ERROR_NOT_FOUND error will
        be returned. Other errors are possible too, and depend on what
        kind of filesystem the file is on.
        """
    async def query_filesystem_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously gets the requested information about the filesystem
        that the specified `file` is on. The result is a GFileInfo object
        that contains key-value attributes (such as type or size for the
        file).

        For more details, see `g_file_query_filesystem_info` which is the
        synchronous version of this call.

        When the operation is finished, `callback` will be called. You can
        then call `g_file_query_info_finish` to get the result of the
        operation.
        """
    def query_filesystem_info_finish(self, res: AsyncResult) -> FileInfo:
        """
            Finishes an asynchronous filesystem info query.
        See `g_file_query_filesystem_info_async`.
        """
    def query_info(
        self, attributes: str, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> FileInfo:
        """
            Gets the requested information about specified `file`.
        The result is a GFileInfo object that contains key-value
        attributes (such as the type or size of the file).

        The `attributes` value is a string that specifies the file
        attributes that should be gathered. It is not an error if
        it's not possible to read a particular requested attribute
        from a file - it just won't be set. `attributes` should be a
        comma-separated list of attributes or attribute wildcards.
        The wildcard "*" means all attributes, and a wildcard like
        "standard::*" means all attributes in the standard namespace.
        An example attribute query be "standard::*,owner::user".
        The standard attributes are available as defines, like
        G_FILE_ATTRIBUTE_STANDARD_NAME.

        If `cancellable` is not None, then the operation can be cancelled
        by triggering the cancellable object from another thread. If the
        operation was cancelled, the error G_IO_ERROR_CANCELLED will be
        returned.

        For symlinks, normally the information about the target of the
        symlink is returned, rather than information about the symlink
        itself. However if you pass G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
        in `flags` the information about the symlink itself will be returned.
        Also, for symlinks that point to non-existing files the information
        about the symlink itself will be returned.

        If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
        returned. Other errors are possible too, and depend on what kind of
        filesystem the file is on.
        """
    async def query_info_async(
        self,
        attributes: str,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously gets the requested information about specified `file`.
        The result is a GFileInfo object that contains key-value attributes
        (such as type or size for the file).

        For more details, see `g_file_query_info` which is the synchronous
        version of this call.

        When the operation is finished, `callback` will be called. You can
        then call `g_file_query_info_finish` to get the result of the operation.
        """
    def query_info_finish(self, res: AsyncResult) -> FileInfo:
        """
            Finishes an asynchronous file info query.
        See `g_file_query_info_async`.
        """
    def query_settable_attributes(self, cancellable: Cancellable | None = None) -> FileAttributeInfoList:
        """
            Obtain the list of settable attributes for the file.

        Returns the type and full attribute name of all the attributes
        that can be set on this file. This doesn't mean setting it will
        always succeed though, you might get an access failure, or some
        specific file may not support a specific attribute.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def query_writable_namespaces(self, cancellable: Cancellable | None = None) -> FileAttributeInfoList:
        """
            Obtain the list of attribute namespaces where new attributes
        can be created by a user. An example of this is extended
        attributes (in the "xattr" namespace).

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def read(self, cancellable: Cancellable | None = None) -> FileInputStream:
        """
            Opens a file for reading. The result is a GFileInputStream that
        can be used to read the contents of the file.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
        returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY
        error will be returned. Other errors are possible too, and depend
        on what kind of filesystem the file is on.
        """
    async def read_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously opens `file` for reading.

        For more details, see `g_file_read` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_read_finish` to get the result
        of the operation.
        """
    def read_finish(self, res: AsyncResult) -> FileInputStream:
        """
            Finishes an asynchronous file read operation started with
        `g_file_read_async`.
        """
    def replace(
        self, etag: str | None, make_backup: bool, flags: FileCreateFlags, cancellable: Cancellable | None = None
    ) -> FileOutputStream:
        """
            Returns an output stream for overwriting the file, possibly
        creating a backup copy of the file first. If the file doesn't exist,
        it will be created.

        This will try to replace the file in the safest way possible so
        that any errors during the writing will not affect an already
        existing copy of the file. For instance, for local files it
        may write to a temporary file and then atomically rename over
        the destination when the stream is closed.

        By default files created are generally readable by everyone,
        but if you pass G_FILE_CREATE_PRIVATE in `flags` the file
        will be made readable only to the current user, to the level that
        is supported on the target filesystem.

        If `cancellable` is not None, then the operation can be cancelled
        by triggering the cancellable object from another thread. If the
        operation was cancelled, the error G_IO_ERROR_CANCELLED will be
        returned.

        If you pass in a non-None `etag` value and `file` already exists, then
        this value is compared to the current entity tag of the file, and if
        they differ an G_IO_ERROR_WRONG_ETAG error is returned. This
        generally means that the file has been changed since you last read
        it. You can get the new etag from `g_file_output_stream_get_etag`
        after you've finished writing and closed the GFileOutputStream. When
        you load a new file you can use `g_file_input_stream_query_info` to
        get the etag of the file.

        If `make_backup` is True, this function will attempt to make a
        backup of the current file before overwriting it. If this fails
        a G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
        want to replace anyway, try again with `make_backup` set to False.

        If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will
        be returned, and if the file is some other form of non-regular file
        then a G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
        file systems don't allow all file names, and may return an
        G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
        G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
        possible too, and depend on what kind of filesystem the file is on.
        """
    async def replace_async(
        self,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously overwrites the file, replacing the contents,
        possibly creating a backup copy of the file first.

        For more details, see `g_file_replace` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_replace_finish` to get the result
        of the operation.
        """
    def replace_contents(
        self,
        contents: list,
        length: int,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> tuple[bool, str | None]:
        """
            Replaces the contents of `file` with `contents` of `length` bytes.

        If `etag` is specified (not None), any existing file must have that etag,
        or the error G_IO_ERROR_WRONG_ETAG will be returned.

        If `make_backup` is True, this function will attempt to make a backup
        of `file`. Internally, it uses `g_file_replace`, so will try to replace the
        file contents in the safest way possible. For example, atomic renames are
        used when replacing local files’ contents.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        The returned `new_etag` can be used to verify that the file hasn't
        changed the next time it is saved over.
        """
    async def replace_contents_async(
        self,
        contents: list,
        length: int,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Starts an asynchronous replacement of `file` with the given
        `contents` of `length` bytes. `etag` will replace the document's
        current entity tag.

        When this operation has completed, `callback` will be called with
        `user_user` data, and the operation can be finalized with
        `g_file_replace_contents_finish`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        If `make_backup` is True, this function will attempt to
        make a backup of `file`.

        Note that no copy of `contents` will be made, so it must stay valid
        until `callback` is called. See `g_file_replace_contents_bytes_async`
        for a GBytes version that will automatically hold a reference to the
        contents (without copying) for the duration of the call.
        """
    def replace_contents_bytes_async(
        self,
        contents: GLib.Bytes,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Same as `g_file_replace_contents_async` but takes a GBytes input instead.
        This function will keep a ref on `contents` until the operation is done.
        Unlike `g_file_replace_contents_async` this allows forgetting about the
        content without waiting for the callback.

        When this operation has completed, `callback` will be called with
        `user_user` data, and the operation can be finalized with
        `g_file_replace_contents_finish`.
        """
    def replace_contents_finish(self, res: AsyncResult) -> tuple[bool, str | None]:
        """
            Finishes an asynchronous replace of the given `file`. See
        `g_file_replace_contents_async`. Sets `new_etag` to the new entity
        tag for the document, if present.
        """
    def replace_finish(self, res: AsyncResult) -> FileOutputStream:
        """
            Finishes an asynchronous file replace operation started with
        `g_file_replace_async`.
        """
    def replace_readwrite(
        self, etag: str | None, make_backup: bool, flags: FileCreateFlags, cancellable: Cancellable | None = None
    ) -> FileIOStream:
        """
            Returns an output stream for overwriting the file in readwrite mode,
        possibly creating a backup copy of the file first. If the file doesn't
        exist, it will be created.

        For details about the behaviour, see `g_file_replace` which does the
        same thing but returns an output stream only.

        Note that in many non-local file cases read and write streams are not
        supported, so make sure you really need to do read and write streaming,
        rather than just opening for reading or writing.
        """
    async def replace_readwrite_async(
        self,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously overwrites the file in read-write mode,
        replacing the contents, possibly creating a backup copy
        of the file first.

        For more details, see `g_file_replace_readwrite` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_replace_readwrite_finish` to get
        the result of the operation.
        """
    def replace_readwrite_finish(self, res: AsyncResult) -> FileIOStream:
        """
            Finishes an asynchronous file replace operation started with
        `g_file_replace_readwrite_async`.
        """
    def resolve_relative_path(self, relative_path: str) -> File:
        """
            Resolves a relative path for `file` to an absolute path.

        This call does no blocking I/O.

        If the `relative_path` is an absolute path name, the resolution
        is done absolutely (without taking `file` path as base).
        """
    def set_attribute(
        self,
        attribute: str,
        type: FileAttributeType,
        value_p: object | None,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
            Sets an attribute in the file with attribute name `attribute` to `value_p`.

        Some attributes can be unset by setting `type` to
        G_FILE_ATTRIBUTE_TYPE_INVALID and `value_p` to None.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def set_attribute_byte_string(
        self, attribute: str, value: str, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool:
        """
            Sets `attribute` of type G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to `value`.
        If `attribute` is of a different type, this operation will fail,
        returning False.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def set_attribute_int32(
        self, attribute: str, value: int, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool:
        """
            Sets `attribute` of type G_FILE_ATTRIBUTE_TYPE_INT32 to `value`.
        If `attribute` is of a different type, this operation will fail.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def set_attribute_int64(
        self, attribute: str, value: int, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool:
        """
            Sets `attribute` of type G_FILE_ATTRIBUTE_TYPE_INT64 to `value`.
        If `attribute` is of a different type, this operation will fail.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def set_attribute_string(
        self, attribute: str, value: str, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool:
        """
            Sets `attribute` of type G_FILE_ATTRIBUTE_TYPE_STRING to `value`.
        If `attribute` is of a different type, this operation will fail.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def set_attribute_uint32(
        self, attribute: str, value: int, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool:
        """
            Sets `attribute` of type G_FILE_ATTRIBUTE_TYPE_UINT32 to `value`.
        If `attribute` is of a different type, this operation will fail.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def set_attribute_uint64(
        self, attribute: str, value: int, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool:
        """
            Sets `attribute` of type G_FILE_ATTRIBUTE_TYPE_UINT64 to `value`.
        If `attribute` is of a different type, this operation will fail.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def set_attributes_async(
        self,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously sets the attributes of `file` with `info`.

        For more details, see `g_file_set_attributes_from_info`,
        which is the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_set_attributes_finish` to get
        the result of the operation.
        """
    def set_attributes_finish(self, result: AsyncResult) -> tuple[bool, FileInfo]:
        """
        Finishes setting an attribute started in `g_file_set_attributes_async`.
        """
    def set_attributes_from_info(
        self, info: FileInfo, flags: FileQueryInfoFlags, cancellable: Cancellable | None = None
    ) -> bool:
        """
            Tries to set all attributes in the GFileInfo on the target
        values, not stopping on the first error.

        If there is any error during this operation then `error` will
        be set to the first error. Error on particular fields are flagged
        by setting the "status" field in the attribute value to
        G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
        also detect further errors.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def set_display_name(self, display_name: str, cancellable: Cancellable | None = None) -> File:
        """
            Renames `file` to the specified display name.

        The display name is converted from UTF-8 to the correct encoding
        for the target filesystem if possible and the `file` is renamed to this.

        If you want to implement a rename operation in the user interface the
        edit name (G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
        initial value in the rename widget, and then the result after editing
        should be passed to `g_file_set_display_name`.

        On success the resulting converted filename is returned.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def set_display_name_async(
        self,
        display_name: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously sets the display name for a given GFile.

        For more details, see `g_file_set_display_name` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_set_display_name_finish` to get
        the result of the operation.
        """
    def set_display_name_finish(self, res: AsyncResult) -> File:
        """
            Finishes setting a display name started with
        `g_file_set_display_name_async`.
        """
    async def start_mountable(
        self,
        flags: DriveStartFlags,
        start_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Starts a file of type G_FILE_TYPE_MOUNTABLE.
        Using `start_operation`, you can request callbacks when, for instance,
        passwords are needed during authentication.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_mount_mountable_finish` to get
        the result of the operation.
        """
    def start_mountable_finish(self, result: AsyncResult) -> bool:
        """
            Finishes a start operation. See `g_file_start_mountable` for details.

        Finish an asynchronous start operation that was started
        with `g_file_start_mountable`.
        """
    async def stop_mountable(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Stops a file of type G_FILE_TYPE_MOUNTABLE.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_stop_mountable_finish` to get
        the result of the operation.
        """
    def stop_mountable_finish(self, result: AsyncResult) -> bool:
        """
            Finishes a stop operation, see `g_file_stop_mountable` for details.

        Finish an asynchronous stop operation that was started
        with `g_file_stop_mountable`.
        """
    def supports_thread_contexts(self) -> bool:
        """
            Checks if `file` supports thread-default main contexts
        (see [method`GLib`.MainContext.push_thread_default])
        If this returns False, you cannot perform asynchronous operations on
        `file` in a thread that has a thread-default context.
        """
    def trash(self, cancellable: Cancellable | None = None) -> bool:
        """
            Sends `file` to the "Trashcan", if possible. This is similar to
        deleting it, but the user can recover it before emptying the trashcan.
        Trashing is disabled for system mounts by default (see
        `g_unix_mount_entry_is_system_internal`), so this call can return the
        G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
        mount option can be used to disable `g_file_trash` support for particular
        mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
        Since 2.82, the `x-gvfs-trash` unix mount option can be used to enable
        `g_file_trash` support for particular system mounts.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def trash_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
        Asynchronously sends `file` to the Trash location, if possible.
        """
    def trash_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an asynchronous file trashing operation, started with
        `g_file_trash_async`.
        """
    @deprecated("deprecated")
    async def unmount_mountable(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Unmounts a file of type G_FILE_TYPE_MOUNTABLE.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_unmount_mountable_finish` to get
        the result of the operation.
        """
    @deprecated("deprecated")
    def unmount_mountable_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an unmount operation, see `g_file_unmount_mountable` for details.

        Finish an asynchronous unmount operation that was started
        with `g_file_unmount_mountable`.
        """
    async def unmount_mountable_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Unmounts a file of type G_FILE_TYPE_MOUNTABLE.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.

        When the operation is finished, `callback` will be called.
        You can then call `g_file_unmount_mountable_finish` to get
        the result of the operation.
        """
    def unmount_mountable_with_operation_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an unmount operation,
        see `g_file_unmount_mountable_with_operation` for details.

        Finish an asynchronous unmount operation that was started
        with `g_file_unmount_mountable_with_operation`.
        """

class FileAttributeInfo(GObject.GPointer):
    """
    Information about a specific attribute.
    """

    # gi Fields
    flags: FileAttributeInfoFlags = ...
    """
    a set of GFileAttributeInfoFlags.

    """
    name: str = ...
    """
    the name of the attribute.

    """
    type: FileAttributeType = ...
    """
    the GFileAttributeType type of the attribute.

    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileAttributeInfoList(GObject.GBoxed):
    """
    Acts as a lightweight registry for possible valid file attributes.
    The registry stores Key-Value pair formats as GFileAttributeInfos.
    """

    # gi Fields
    infos: FileAttributeInfo | None = ...
    """
    an array of GFileAttributeInfos.

    """
    n_infos: int = ...
    """
    the number of values in the array.

    """

    # gi Methods
    def add(self, name: str, type: FileAttributeType, flags: FileAttributeInfoFlags) -> None:
        """
            Adds a new attribute with `name` to the `list`, setting
        its `type` and `flags`.
        """
    def dup(self) -> FileAttributeInfoList:
        """
        Makes a duplicate of a file attribute info list.
        """
    def lookup(self, name: str) -> FileAttributeInfo:
        """
        Gets the file attribute with the name `name` from `list`.
        """
    @classmethod
    def new(cls) -> FileAttributeInfoList:
        """
        Creates a new file attribute info list.
        """
    def ref(self) -> FileAttributeInfoList:
        """
        References a file attribute info list.
        """
    def unref(self) -> None:
        """
            Removes a reference from the given `list`. If the reference count
        falls to zero, the `list` is deleted.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class FileAttributeMatcher(GObject.GBoxed):
    """
    Determines if a string matches a file attribute.
    """

    # gi Methods
    def enumerate_namespace(self, ns: str) -> bool:
        """
            Checks if the matcher will match all of the keys in a given namespace.
        This will always return True if a wildcard character is in use (e.g. if
        matcher was created with "standard::*" and `ns` is "standard", or if matcher was created
        using "*" and namespace is anything.)

        TODO: this is awkwardly worded.
        """
    def enumerate_next(self) -> str | None:
        """
        Gets the next matched attribute from a GFileAttributeMatcher.
        """
    def matches(self, attribute: str) -> bool:
        """
            Checks if an attribute will be matched by an attribute matcher. If
        the matcher was created with the "*" matching string, this function
        will always return True.
        """
    def matches_only(self, attribute: str) -> bool:
        """
            Checks if an attribute matcher only matches a given attribute. Always
        returns False if "*" was used when creating the matcher.
        """
    @classmethod
    def new(cls, attributes: str) -> FileAttributeMatcher:
        """
            Creates a new file attribute matcher, which matches attributes
        against a given string. GFileAttributeMatchers are reference
        counted structures, and are created with a reference count of 1. If
        the number of references falls to 0, the GFileAttributeMatcher is
        automatically destroyed.

        The `attributes` string should be formatted with specific keys separated
        from namespaces with a double colon. Several "namespace::key" strings may be
        concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
        The wildcard "*" may be used to match all keys and namespaces, or
        "namespace::*" will match all keys in a given namespace.

        ## Examples of file attribute matcher strings and results

        - `"*"`: matches all attributes.
        - `"standard::is-hidden"`: matches only the key is-hidden in the
          standard namespace.
        - `"standard::type,unix::*"`: matches the type key in the standard
          namespace and all keys in the unix namespace.
        """
    def ref(self) -> FileAttributeMatcher:
        """
        References a file attribute matcher.
        """
    def subtract(self, subtract: FileAttributeMatcher | None = None) -> FileAttributeMatcher | None:
        """
            Subtracts all attributes of `subtract` from `matcher` and returns
        a matcher that supports those attributes.

        Note that currently it is not possible to remove a single
        attribute when the `matcher` matches the whole namespace - or remove
        a namespace or attribute when the matcher matches everything. This
        is a limitation of the current implementation, but may be fixed
        in the future.
        """
    def to_string(self) -> str:
        """
            Prints what the matcher is matching against. The format will be
        equal to the format passed to `g_file_attribute_matcher_new`.
        The output however, might not be identical, as the matcher may
        decide to use a different order or omit needless parts.
        """
    def unref(self) -> None:
        """
            Unreferences `matcher`. If the reference count falls below 1,
        the `matcher` is automatically freed.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class FileDescriptorBased(GObject.GInterface):
    """
    `GFileDescriptorBased` is an interface for file descriptor based IO.

    It is implemented by streams (implementations of [class`Gio`.InputStream] or
    [class`Gio`.OutputStream]) that are based on file descriptors.

    Note that `<gio/gfiledescriptorbased.h>` belongs to the UNIX-specific
    GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
    file or the `GioUnix-2.0` GIR namespace when using it.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_fd(self) -> int:
        """
        Gets the underlying file descriptor.
        """

class FileDescriptorBasedIface(GObject.GPointer):
    """
    An interface for file descriptor based io objects.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def get_fd(self) -> get_fdFileDescriptorBasedIfaceCB:
        """
        Gets the underlying file descriptor.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileEnumerator(GObject.Object):
    """
    `GFileEnumerator` allows you to operate on a set of [iface`Gio`.File] objects,
    returning a [class`Gio`.FileInfo] structure for each file enumerated (e.g.
    [method`Gio`.File.enumerate_children] will return a `GFileEnumerator` for each
    of the children within a directory).

    To get the next file's information from a `GFileEnumerator`, use
    [method`Gio`.FileEnumerator.next_file] or its asynchronous version,
    [method`Gio`.FileEnumerator.next_files_async]. Note that the asynchronous
    version will return a list of [class`Gio`.FileInfo] objects, whereas the
    synchronous will only return the next file in the enumerator.

    The ordering of returned files is unspecified for non-Unix
    platforms; for more information, see [method`GLib`.Dir.read_name].  On Unix,
    when operating on local files, returned files will be sorted by
    inode number.  Effectively you can assume that the ordering of
    returned files will be stable between successive calls (and
    applications) assuming the directory is unchanged.

    If your application needs a specific ordering, such as by name or
    modification time, you will have to implement that in your
    application code.

    To close a `GFileEnumerator`, use [method`Gio`.FileEnumerator.close], or
    its asynchronous version, [method`Gio`.FileEnumerator.close_async]. Once
    a `GFileEnumerator` is closed, no further actions may be performed
    on it, and it should be freed with [method`GObject`.Object.unref].
    """

    class Props(GObject.Object.Props):
        container: File | None
        """
        The container that is being enumerated.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> FileEnumeratorPrivate | None: ...

    # gi Methods
    def __init__(self, container: File | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def close(self, cancellable: Cancellable | None = None) -> bool:
        """
            Releases all resources used by this enumerator, making the
        enumerator return G_IO_ERROR_CLOSED on all calls.

        This will be automatically called when the last reference
        is dropped, but you might want to call this function to make
        sure resources are released as early as possible.
        """
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously closes the file enumerator.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned in
        `g_file_enumerator_close_finish`.
        """
    def close_finish(self, result: AsyncResult) -> bool:
        """
            Finishes closing a file enumerator, started from `g_file_enumerator_close_async`.

        If the file enumerator was already closed when `g_file_enumerator_close_async`
        was called, then this function will report G_IO_ERROR_CLOSED in `error`, and
        return False. If the file enumerator had pending operation when the close
        operation was started, then this function will report G_IO_ERROR_PENDING, and
        return False.  If `cancellable` was not None, then the operation may have been
        cancelled by triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be set, and False will be
        returned.
        """
    def get_child(self, info: FileInfo) -> File:
        """
            Return a new GFile which refers to the file named by `info` in the source
        directory of `enumerator`.  This function is primarily intended to be used
        inside loops with `g_file_enumerator_next_file`.

        To use this, G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
        attributes list used when creating the GFileEnumerator.

        This is a convenience method that's equivalent to:
        |[<!-- language="C" -->
          gchar *name = g_file_info_get_name (info);
          GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
                                           name);
        ]|
        """
    def get_container(self) -> File:
        """
        Get the GFile container which is being enumerated.
        """
    def has_pending(self) -> bool:
        """
        Checks if the file enumerator has pending operations.
        """
    def is_closed(self) -> bool:
        """
        Checks if the file enumerator has been closed.
        """
    def iterate(self, cancellable: Cancellable | None = None) -> tuple[bool, FileInfo, File]:
        """
            This is a version of `g_file_enumerator_next_file` that's easier to
        use correctly from C programs.  With `g_file_enumerator_next_file`,
        the gboolean return value signifies "end of iteration or error", which
        requires allocation of a temporary GError.

        In contrast, with this function, a False return from
        `g_file_enumerator_iterate` *always* means
        "error".  End of iteration is signaled by `out_info` or `out_child` being None.

        Another crucial difference is that the references for `out_info` and
        `out_child` are owned by `direnum` (they are cached as hidden
        properties).  You must not unref them in your own code.  This makes
        memory management significantly easier for C code in combination
        with loops.

        Finally, this function optionally allows retrieving a GFile as
        well.

        You must specify at least one of `out_info` or `out_child`.

        The code pattern for correctly using `g_file_enumerator_iterate` from C
        is:

        |[
        direnum = g_file_enumerate_children (file, ...);
        while (True)
          {
            GFileInfo *info;
            if (!g_file_enumerator_iterate (direnum, &info, None, cancellable, error))
              goto out;
            if (!info)
              break;
            ... do stuff with "info"; do not unref it! ...
          }

        out:
          g_object_unref (direnum); // Note: frees the last `info`
        ]|
        """
    def next_file(self, cancellable: Cancellable | None = None) -> FileInfo | None:
        """
            Returns information for the next file in the enumerated object.
        Will block until the information is available. The GFileInfo
        returned from this function will contain attributes that match the
        attribute string that was passed when the GFileEnumerator was created.

        See the documentation of GFileEnumerator for information about the
        order of returned files.

        On error, returns None and sets `error` to the error. If the
        enumerator is at the end, None will be returned and `error` will
        be unset.
        """
    async def next_files_async(
        self,
        num_files: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Request information for a number of files from the enumerator asynchronously.
        When all I/O for the operation is finished the `callback` will be called with
        the requested information.

        See the documentation of GFileEnumerator for information about the
        order of returned files.

        Once the end of the enumerator is reached, or if an error occurs, the
        `callback` will be called with an empty list. In this case, the previous call
        to `g_file_enumerator_next_files_async` will typically have returned fewer
        than `num_files` items.

        If a request is cancelled the callback will be called with
        G_IO_ERROR_CANCELLED.

        This leads to the following pseudo-code usage:
        |[
        g_autoptr(GFile) dir = get_directory ();
        g_autoptr(GFileEnumerator) enumerator = None;
        g_autolist(GFileInfo) files = None;
        g_autoptr(GError) local_error = None;

        enumerator = yield g_file_enumerate_children_async (dir,
                                                            G_FILE_ATTRIBUTE_STANDARD_NAME ","
                                                            G_FILE_ATTRIBUTE_STANDARD_TYPE,
                                                            G_FILE_QUERY_INFO_NONE,
                                                            G_PRIORITY_DEFAULT,
                                                            cancellable,
                                                            …,
                                                            &local_error);
        if (enumerator == None)
          g_error ("Error enumerating: %s", local_error->message);

        // Loop until no files are returned, either because the end of the enumerator
        // has been reached, or an error was returned.
        do
          {
            files = yield g_file_enumerator_next_files_async (enumerator,
                                                              5,  // number of files to request
                                                              G_PRIORITY_DEFAULT,
                                                              cancellable,
                                                              …,
                                                              &local_error);

            // Process the returned files, but don’t assume that exactly 5 were returned.
            for (GList *l = files; l != None; l = l->next)
              {
                GFileInfo *info = l->data;
                handle_file_info (info);
              }
          }
        while (files != None);

        if (local_error != None &&
            !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
          g_error ("Error while enumerating: %s", local_error->message);
        ]|

        During an async request no other sync and async calls are allowed, and will
        result in G_IO_ERROR_PENDING errors.

        Any outstanding I/O request with higher priority (lower numerical value) will
        be executed before an outstanding request with lower priority. Default
        priority is G_PRIORITY_DEFAULT.
        """
    def next_files_finish(self, result: AsyncResult) -> list:
        """
        Finishes the asynchronous operation started with `g_file_enumerator_next_files_async`.
        """
    def set_pending(self, pending: bool) -> None:
        """
        Sets the file enumerator as having pending operations.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::container"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FileEnumeratorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def _g_reserved7(self) -> object | None: ...
    @builtins.property
    def close_async(self) -> close_asyncFileEnumeratorClassCB: ...
    @builtins.property
    def close_finish(self) -> close_finishFileEnumeratorClassCB: ...
    @builtins.property
    def close_fn(self) -> close_fnFileEnumeratorClassCB: ...
    @builtins.property
    def next_file(self) -> next_fileFileEnumeratorClassCB | None: ...
    @builtins.property
    def next_files_async(self) -> next_files_asyncFileEnumeratorClassCB: ...
    @builtins.property
    def next_files_finish(self) -> next_files_finishFileEnumeratorClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileEnumeratorPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileIOStream(IOStream):
    """
    `GFileIOStream` provides I/O streams that both read and write to the same
    file handle.

    `GFileIOStream` implements [iface`Gio`.Seekable], which allows the I/O
    stream to jump to arbitrary positions in the file and to truncate
    the file, provided the filesystem of the file supports these
    operations.

    To find the position of a file I/O stream, use [method`Gio`.Seekable.tell].

    To find out if a file I/O stream supports seeking, use
    [method`Gio`.Seekable.can_seek]. To position a file I/O stream, use
    [method`Gio`.Seekable.seek]. To find out if a file I/O stream supports
    truncating, use [method`Gio`.Seekable.can_truncate]. To truncate a file I/O
    stream, use [method`Gio`.Seekable.truncate].

    The default implementation of all the `GFileIOStream` operations
    and the implementation of [iface`Gio`.Seekable] just call into the same
    operations on the output stream.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> IOStream | None: ...
    @builtins.property
    def priv(self) -> FileIOStreamPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_etag(self) -> str | None:
        """
            Gets the entity tag for the file when it has been written.
        This must be called after the stream has been written
        and closed, as the etag can change while writing.
        """
    def query_info(self, attributes: str, cancellable: Cancellable | None = None) -> FileInfo:
        """
            Queries a file io stream for the given `attributes`.
        This function blocks while querying the stream. For the asynchronous
        version of this function, see `g_file_io_stream_query_info_async`.
        While the stream is blocked, the stream will set the pending flag
        internally, and any other operations on the stream will fail with
        G_IO_ERROR_PENDING.

        Can fail if the stream was already closed (with `error` being set to
        G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
        set to G_IO_ERROR_PENDING), or if querying info is not supported for
        the stream's interface (with `error` being set to G_IO_ERROR_NOT_SUPPORTED). I
        all cases of failure, None will be returned.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be set, and None will
        be returned.
        """
    async def query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously queries the `stream` for a GFileInfo. When completed,
        `callback` will be called with a GAsyncResult which can be used to
        finish the operation with `g_file_io_stream_query_info_finish`.

        For the synchronous version of this function, see
        `g_file_io_stream_query_info`.
        """
    def query_info_finish(self, result: AsyncResult) -> FileInfo:
        """
            Finalizes the asynchronous query started
        by `g_file_io_stream_query_info_async`.
        """

    # python methods (overrides?)
    def do_can_seek(
        self,
    ) -> bool:
        """
        can_seek(self) -> bool
        """
    def do_can_truncate(
        self,
    ) -> bool:
        """
        can_truncate(self) -> bool
        """
    def do_get_etag(
        self,
    ) -> str | None:
        """
        get_etag(self) -> str or None
        """
    def do_query_info(
        self,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo:
        """
        query_info(self, attributes:str, cancellable:Gio.Cancellable=None) -> Gio.FileInfo
        """
    def do_query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        query_info_async(self, attributes:str, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_query_info_finish(
        self,
        result: AsyncResult,
    ) -> FileInfo:
        """
        query_info_finish(self, result:Gio.AsyncResult) -> Gio.FileInfo
        """
    def do_seek(
        self,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        seek(self, offset:int, type:GLib.SeekType, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_tell(
        self,
    ) -> int:
        """
        tell(self) -> int
        """
    def do_truncate_fn(
        self,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        truncate_fn(self, size:int, cancellable:Gio.Cancellable=None) -> bool
        """

class FileIOStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def can_seek(self) -> can_seekFileIOStreamClassCB: ...
    @builtins.property
    def can_truncate(self) -> can_truncateFileIOStreamClassCB: ...
    @builtins.property
    def get_etag(self) -> get_etagFileIOStreamClassCB | None: ...
    @builtins.property
    def parent_class(self) -> IOStreamClass | None: ...
    @builtins.property
    def query_info(self) -> query_infoFileIOStreamClassCB: ...
    @builtins.property
    def query_info_async(self) -> query_info_asyncFileIOStreamClassCB: ...
    @builtins.property
    def query_info_finish(self) -> query_info_finishFileIOStreamClassCB: ...
    @builtins.property
    def seek(self) -> seekFileIOStreamClassCB: ...
    @builtins.property
    def tell(self) -> tellFileIOStreamClassCB: ...
    @builtins.property
    def truncate_fn(self) -> truncate_fnFileIOStreamClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileIOStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileIcon(GObject.Object):
    """
    `GFileIcon` specifies an icon by pointing to an image file
    to be used as icon.

    It implements [iface`Gio`.LoadableIcon].
    """

    class Props(GObject.Object.Props):
        file: File | None
        """
        The file containing the icon.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, file: File | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_file(self) -> File:
        """
        Gets the GFile associated with the given `icon`.
        """
    @classmethod
    def new(cls, file: File) -> FileIcon:
        """
        Creates a new icon for a file.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FileIconClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileIface(GObject.GPointer):
    """
    An interface for writing VFS file handles.
    """

    # gi Fields
    @builtins.property
    def _query_settable_attributes_async(self) -> object | None:
        """
        Asynchronously gets a list of GFileAttributeInfos that can be set.
        """
    @builtins.property
    def _query_settable_attributes_finish(self) -> object | None:
        """
        Finishes asynchronously querying settable attributes.
        """
    @builtins.property
    def _query_writable_namespaces_async(self) -> object | None:
        """
        Asynchronously gets a list of GFileAttributeInfo namespaces that are writable.
        """
    @builtins.property
    def _query_writable_namespaces_finish(self) -> object | None:
        """
        Finishes asynchronously querying the writable namespaces.
        """
    @builtins.property
    def append_to(self) -> append_toFileIfaceCB:
        """
        Writes to the end of a file.
        """
    @builtins.property
    def append_to_async(self) -> append_to_asyncFileIfaceCB:
        """
        Asynchronously writes to the end of a file.
        """
    @builtins.property
    def append_to_finish(self) -> append_to_finishFileIfaceCB:
        """
        Finishes an asynchronous file append operation.
        """
    @builtins.property
    def copy(self) -> copyFileIfaceCB:
        """
        Copies a file. None if copying is unsupported, which will
        cause `GFile` to use a fallback copy method where it reads from the
        source and writes to the destination.
        """
    @builtins.property
    def copy_async(self) -> copy_asyncFileIfaceCB:
        """
        Asynchronously copies a file.
        """
    @builtins.property
    def copy_finish(self) -> copy_finishFileIfaceCB:
        """
        Finishes an asynchronous copy operation.
        """
    @builtins.property
    def create(self) -> createFileIfaceCB:
        """
        Creates a new file.
        """
    @builtins.property
    def create_async(self) -> create_asyncFileIfaceCB:
        """
        Asynchronously creates a file.
        """
    @builtins.property
    def create_finish(self) -> create_finishFileIfaceCB:
        """
        Finishes asynchronously creating a file.
        """
    @builtins.property
    def create_readwrite(self) -> create_readwriteFileIfaceCB:
        """
        Creates file read/write. Since 2.22.
        """
    @builtins.property
    def create_readwrite_async(self) -> create_readwrite_asyncFileIfaceCB:
        """
        Asynchronously creates file read/write. Since 2.22.
        """
    @builtins.property
    def create_readwrite_finish(self) -> create_readwrite_finishFileIfaceCB:
        """
        Finishes an asynchronous creates read/write. Since 2.22.
        """
    @builtins.property
    def delete_file(self) -> delete_fileFileIfaceCB:
        """
        Deletes a file.
        """
    @builtins.property
    def delete_file_async(self) -> delete_file_asyncFileIfaceCB:
        """
        Asynchronously deletes a file.
        """
    @builtins.property
    def delete_file_finish(self) -> delete_file_finishFileIfaceCB:
        """
        Finishes an asynchronous delete.
        """
    @builtins.property
    def dup(self) -> dupFileIfaceCB:
        """
        Duplicates a GFile.
        """
    @builtins.property
    def eject_mountable(self) -> eject_mountableFileIfaceCB:
        """
        Ejects a mountable.
        """
    @builtins.property
    def eject_mountable_finish(self) -> eject_mountable_finishFileIfaceCB:
        """
        Finishes an eject operation.
        """
    @builtins.property
    def eject_mountable_with_operation(self) -> eject_mountable_with_operationFileIfaceCB:
        """
        Ejects a mountable object using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def eject_mountable_with_operation_finish(self) -> eject_mountable_with_operation_finishFileIfaceCB:
        """
        Finishes an eject operation using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def enumerate_children(self) -> enumerate_childrenFileIfaceCB:
        """
        Gets a GFileEnumerator with the children of a GFile.
        """
    @builtins.property
    def enumerate_children_async(self) -> enumerate_children_asyncFileIfaceCB:
        """
        Asynchronously gets a GFileEnumerator with the children of a GFile.
        """
    @builtins.property
    def enumerate_children_finish(self) -> enumerate_children_finishFileIfaceCB:
        """
        Finishes asynchronously enumerating the children.
        """
    @builtins.property
    def equal(self) -> equalFileIfaceCB:
        """
        Checks equality of two given GFiles.
        """
    @builtins.property
    def find_enclosing_mount(self) -> find_enclosing_mountFileIfaceCB:
        """
        Gets a GMount for the GFile.
        """
    @builtins.property
    def find_enclosing_mount_async(self) -> find_enclosing_mount_asyncFileIfaceCB:
        """
        Asynchronously gets the GMount for a GFile.
        """
    @builtins.property
    def find_enclosing_mount_finish(self) -> find_enclosing_mount_finishFileIfaceCB:
        """
        Finishes asynchronously getting the volume.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def get_basename(self) -> get_basenameFileIfaceCB | None:
        """
        Gets the basename for a given GFile.
        """
    @builtins.property
    def get_child_for_display_name(self) -> get_child_for_display_nameFileIfaceCB:
        """
        Gets the child GFile for a given display name.
        """
    @builtins.property
    def get_parent(self) -> get_parentFileIfaceCB | None:
        """
        Gets the parent directory for the GFile.
        """
    @builtins.property
    def get_parse_name(self) -> get_parse_nameFileIfaceCB:
        """
        Gets the parsed name for the GFile.
        """
    @builtins.property
    def get_path(self) -> get_pathFileIfaceCB | None:
        """
        Gets the current path within a GFile.
        """
    @builtins.property
    def get_relative_path(self) -> get_relative_pathFileIfaceCB | None:
        """
        Gets the path for a GFile relative to a given path.
        """
    @builtins.property
    def get_uri(self) -> get_uriFileIfaceCB:
        """
        Gets a URI for the path within a GFile.
        """
    @builtins.property
    def get_uri_scheme(self) -> get_uri_schemeFileIfaceCB | None:
        """
        Gets the URI scheme for a GFile.
        """
    @builtins.property
    def has_uri_scheme(self) -> has_uri_schemeFileIfaceCB:
        """
        Checks to see if a GFile has a given URI scheme.
        """
    @builtins.property
    def hash(self) -> hashFileIfaceCB:
        """
        Creates a hash of a GFile.
        """
    @builtins.property
    def is_native(self) -> is_nativeFileIfaceCB:
        """
        Checks to see if a file is native to the system.
        """
    @builtins.property
    def make_directory(self) -> make_directoryFileIfaceCB:
        """
        Makes a directory.
        """
    @builtins.property
    def make_directory_async(self) -> make_directory_asyncFileIfaceCB:
        """
        Asynchronously makes a directory.
        """
    @builtins.property
    def make_directory_finish(self) -> make_directory_finishFileIfaceCB:
        """
        Finishes making a directory asynchronously.
        """
    @builtins.property
    def make_symbolic_link(self) -> make_symbolic_linkFileIfaceCB:
        """
         Makes a symbolic link. None if symbolic
        links are unsupported.
        """
    @builtins.property
    def make_symbolic_link_async(self) -> make_symbolic_link_asyncFileIfaceCB:
        """
        Asynchronously makes a symbolic link
        """
    @builtins.property
    def make_symbolic_link_finish(self) -> make_symbolic_link_finishFileIfaceCB:
        """
        Finishes making a symbolic link asynchronously.
        """
    @builtins.property
    def measure_disk_usage(self) -> measure_disk_usageFileIfaceCB:
        """
        Recursively measures the disk usage of `file`. Since 2.38
        """
    @builtins.property
    def measure_disk_usage_async(self) -> object | None:
        """
        Asynchronously recursively measures the disk usage of `file`. Since 2.38
        """
    @builtins.property
    def measure_disk_usage_finish(self) -> measure_disk_usage_finishFileIfaceCB:
        """
        Finishes an asynchronous recursive measurement of the disk usage of `file`. Since 2.38
        """
    @builtins.property
    def monitor_dir(self) -> monitor_dirFileIfaceCB:
        """
        Creates a GFileMonitor for the location.
        """
    @builtins.property
    def monitor_file(self) -> monitor_fileFileIfaceCB:
        """
        Creates a GFileMonitor for the location.
        """
    @builtins.property
    def mount_enclosing_volume(self) -> mount_enclosing_volumeFileIfaceCB:
        """
        Mounts a specified location.
        """
    @builtins.property
    def mount_enclosing_volume_finish(self) -> mount_enclosing_volume_finishFileIfaceCB:
        """
        Finishes mounting a specified location.
        """
    @builtins.property
    def mount_mountable(self) -> mount_mountableFileIfaceCB:
        """
        Mounts a mountable object.
        """
    @builtins.property
    def mount_mountable_finish(self) -> mount_mountable_finishFileIfaceCB:
        """
        Finishes a mounting operation.
        """
    @builtins.property
    def move(self) -> moveFileIfaceCB:
        """
        Moves a file.
        """
    @builtins.property
    def move_async(self) -> move_asyncFileIfaceCB:
        """
        Asynchronously moves a file. Since: 2.72
        """
    @builtins.property
    def move_finish(self) -> move_finishFileIfaceCB:
        """
        Finishes an asynchronous move operation. Since: 2.72
        """
    @builtins.property
    def open_readwrite(self) -> open_readwriteFileIfaceCB:
        """
        Open file read/write. Since 2.22.
        """
    @builtins.property
    def open_readwrite_async(self) -> open_readwrite_asyncFileIfaceCB:
        """
        Asynchronously opens file read/write. Since 2.22.
        """
    @builtins.property
    def open_readwrite_finish(self) -> open_readwrite_finishFileIfaceCB:
        """
        Finishes an asynchronous open read/write. Since 2.22.
        """
    @builtins.property
    def poll_mountable(self) -> poll_mountableFileIfaceCB:
        """
        Polls a mountable object for media changes. Since 2.22.
        """
    @builtins.property
    def poll_mountable_finish(self) -> poll_mountable_finishFileIfaceCB:
        """
        Finishes a poll operation for media changes. Since 2.22.
        """
    @builtins.property
    def prefix_matches(self) -> prefix_matchesFileIfaceCB:
        """
        Checks whether a GFile contains a specified file.
        """
    @builtins.property
    def query_exists(self) -> query_existsFileIfaceCB:
        """
        Queries whether a file exists. Since 2.84
        """
    @builtins.property
    def query_filesystem_info(self) -> query_filesystem_infoFileIfaceCB:
        """
        Gets a GFileInfo for the file system GFile is on.
        """
    @builtins.property
    def query_filesystem_info_async(self) -> query_filesystem_info_asyncFileIfaceCB:
        """
        Asynchronously gets a GFileInfo for the file system GFile is on.
        """
    @builtins.property
    def query_filesystem_info_finish(self) -> query_filesystem_info_finishFileIfaceCB:
        """
        Finishes asynchronously getting the file system info.
        """
    @builtins.property
    def query_info(self) -> query_infoFileIfaceCB:
        """
        Gets the GFileInfo for a GFile.
        """
    @builtins.property
    def query_info_async(self) -> query_info_asyncFileIfaceCB:
        """
        Asynchronously gets the GFileInfo for a GFile.
        """
    @builtins.property
    def query_info_finish(self) -> query_info_finishFileIfaceCB:
        """
        Finishes an asynchronous query info operation.
        """
    @builtins.property
    def query_settable_attributes(self) -> query_settable_attributesFileIfaceCB:
        """
        Returns a list of GFileAttributeInfos that can be set.
        """
    @builtins.property
    def query_writable_namespaces(self) -> query_writable_namespacesFileIfaceCB:
        """
        Returns a list of GFileAttributeInfo namespaces that are writable.
        """
    @builtins.property
    def read_async(self) -> read_asyncFileIfaceCB:
        """
        Asynchronously reads a file.
        """
    @builtins.property
    def read_finish(self) -> read_finishFileIfaceCB:
        """
        Finishes asynchronously reading a file.
        """
    @builtins.property
    def read_fn(self) -> read_fnFileIfaceCB:
        """
        Reads a file asynchronously.
        """
    @builtins.property
    def replace(self) -> replaceFileIfaceCB:
        """
        Replaces the contents of a file.
        """
    @builtins.property
    def replace_async(self) -> replace_asyncFileIfaceCB:
        """
        Asynchronously replaces the contents of a file.
        """
    @builtins.property
    def replace_finish(self) -> replace_finishFileIfaceCB:
        """
        Finishes asynchronously replacing a file.
        """
    @builtins.property
    def replace_readwrite(self) -> replace_readwriteFileIfaceCB:
        """
        Replaces file read/write. Since 2.22.
        """
    @builtins.property
    def replace_readwrite_async(self) -> replace_readwrite_asyncFileIfaceCB:
        """
        Asynchronously replaces file read/write. Since 2.22.
        """
    @builtins.property
    def replace_readwrite_finish(self) -> replace_readwrite_finishFileIfaceCB:
        """
        Finishes an asynchronous replace read/write. Since 2.22.
        """
    @builtins.property
    def resolve_relative_path(self) -> resolve_relative_pathFileIfaceCB:
        """
        Resolves a relative path for a GFile to an absolute path.
        """
    @builtins.property
    def set_attribute(self) -> set_attributeFileIfaceCB:
        """
        Sets a GFileAttributeInfo.
        """
    @builtins.property
    def set_attributes_async(self) -> set_attributes_asyncFileIfaceCB:
        """
        Asynchronously sets a file's attributes.
        """
    @builtins.property
    def set_attributes_finish(self) -> set_attributes_finishFileIfaceCB:
        """
        Finishes setting a file's attributes asynchronously.
        """
    @builtins.property
    def set_attributes_from_info(self) -> set_attributes_from_infoFileIfaceCB:
        """
        Sets a GFileAttributeInfo with information from a GFileInfo.
        """
    @builtins.property
    def set_display_name(self) -> set_display_nameFileIfaceCB:
        """
        Sets the display name for a GFile.
        """
    @builtins.property
    def set_display_name_async(self) -> set_display_name_asyncFileIfaceCB:
        """
        Asynchronously sets a GFile's display name.
        """
    @builtins.property
    def set_display_name_finish(self) -> set_display_name_finishFileIfaceCB:
        """
        Finishes asynchronously setting a GFile's display name.
        """
    @builtins.property
    def start_mountable(self) -> start_mountableFileIfaceCB:
        """
        Starts a mountable object. Since 2.22.
        """
    @builtins.property
    def start_mountable_finish(self) -> start_mountable_finishFileIfaceCB:
        """
        Finishes a start operation. Since 2.22.
        """
    @builtins.property
    def stop_mountable(self) -> stop_mountableFileIfaceCB:
        """
        Stops a mountable. Since 2.22.
        """
    @builtins.property
    def stop_mountable_finish(self) -> stop_mountable_finishFileIfaceCB:
        """
        Finishes a stop operation. Since 2.22.
        """
    @builtins.property
    def supports_thread_contexts(self) -> bool:
        """
        a boolean that indicates whether the GFile implementation supports thread-default contexts. Since 2.22.
        """
    @builtins.property
    def trash(self) -> trashFileIfaceCB:
        """
        Sends a GFile to the Trash location.
        """
    @builtins.property
    def trash_async(self) -> trash_asyncFileIfaceCB:
        """
        Asynchronously sends a GFile to the Trash location.
        """
    @builtins.property
    def trash_finish(self) -> trash_finishFileIfaceCB:
        """
        Finishes an asynchronous file trashing operation.
        """
    @builtins.property
    def unmount_mountable(self) -> unmount_mountableFileIfaceCB:
        """
        Unmounts a mountable object.
        """
    @builtins.property
    def unmount_mountable_finish(self) -> unmount_mountable_finishFileIfaceCB:
        """
        Finishes an unmount operation.
        """
    @builtins.property
    def unmount_mountable_with_operation(self) -> unmount_mountable_with_operationFileIfaceCB:
        """
        Unmounts a mountable object using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def unmount_mountable_with_operation_finish(self) -> unmount_mountable_with_operation_finishFileIfaceCB:
        """
        Finishes an unmount operation using a GMountOperation. Since 2.22.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileInfo(GObject.Object):
    """
    Stores information about a file system object referenced by a [iface`Gio`.File].

    Functionality for manipulating basic metadata for files. `GFileInfo`
    implements methods for getting information that all files should
    contain, and allows for manipulation of extended attributes.

    See the [file attributes](file-attributes.html) document for more
    information on how GIO handles file attributes.

    To obtain a `GFileInfo` for a [iface`Gio`.File], use
    [method`Gio`.File.query_info] (or its async variant). To obtain a `GFileInfo`
    for a file input or output stream, use [method`Gio`.FileInputStream.query_info]
    or [method`Gio`.FileOutputStream.query_info] (or their async variants).

    To change the actual attributes of a file, you should then set the
    attribute in the `GFileInfo` and call [method`Gio`.File.set_attributes_from_info]
    or [method`Gio`.File.set_attributes_async] on a `GFile`.

    However, not all attributes can be changed in the file. For instance,
    the actual size of a file cannot be changed via [method`Gio`.FileInfo.set_size].
    You may call [method`Gio`.File.query_settable_attributes] and
    [method`Gio`.File.query_writable_namespaces] to discover the settable attributes
    of a particular file at runtime.

    The direct accessors, such as [method`Gio`.FileInfo.get_name], are slightly more
    optimized than the generic attribute accessors, such as
    [method`Gio`.FileInfo.get_attribute_byte_string].This optimization will matter
    only if calling the API in a tight loop.

    It is an error to call these accessors without specifying their required file
    attributes when creating the `GFileInfo`. Use
    [method`Gio`.FileInfo.has_attribute] or [method`Gio`.FileInfo.list_attributes]
    to check what attributes are specified for a `GFileInfo`.

    [struct`Gio`.FileAttributeMatcher] allows for searching through a `GFileInfo`
    for attributes.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear_status(self) -> None:
        """
        Clears the status information from `info`.
        """
    def copy_into(self, dest_info: FileInfo) -> None:
        """
            First clears all of the [GFileAttribute](file-attributes.html#file-attributes) of
        `dest_info`, and then copies all of the file attributes from `src_info` to `dest_info`.
        """
    def dup(self) -> FileInfo:
        """
        Duplicates a file info structure.
        """
    def get_access_date_time(self) -> GLib.DateTime | None:
        """
            Gets the access time of the current `info` and returns it as a
        GDateTime.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_TIME_ACCESS. If G_FILE_ATTRIBUTE_TIME_ACCESS_USEC is
        provided, the resulting GDateTime will additionally have microsecond
        precision.

        If nanosecond precision is needed, G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC must
        be queried separately using `g_file_info_get_attribute_uint32`.
        """
    def get_attribute_as_string(self, attribute: str) -> str | None:
        """
            Gets the value of an attribute, formatted as a human readable string.

        This escapes things as needed to make the string valid UTF-8 and readable by
        humans. It’s not meant to be a machine readable or reversible escaping
        format.

        To format file name attributes of type
        [enum`Gio`.FileAttributeType.BYTE_STRING] for output as UTF-8, use
        [func`GLib`.filename_to_utf8] instead:
        ```c
        const char *trash_orig_path_byte_string;
        g_autofree char *trash_orig_path_utf8 = None;

        trash_orig_path_byte_string = g_file_info_get_attribute_byte_string (info, G_FILE_ATTRIBUTE_TRASH_ORIG_PATH);
        trash_orig_path_utf8 = g_filename_to_utf8 (trash_orig_path_byte_string, -1, None, None, None);
        if (trash_orig_path_utf8 != None)
          g_message ("Some larger UTF-8 string with filename embedded as %s", trash_orig_path_utf8);
        ```
        """
    def get_attribute_boolean(self, attribute: str) -> bool:
        """
            Gets the value of a boolean attribute. If the attribute does not
        contain a boolean value, False will be returned.
        """
    def get_attribute_byte_string(self, attribute: str) -> str | None:
        """
            Gets the value of a byte string attribute. If the attribute does
        not contain a byte string, None will be returned.
        """
    def get_attribute_data(self, attribute: str) -> tuple[bool, FileAttributeType, object, FileAttributeStatus]:
        """
        Gets the attribute type, value and status for an attribute key.
        """
    def get_attribute_file_path(self, attribute: str) -> str | None:
        """
            Gets the value of a byte string attribute as a file path.

        If the attribute does not contain a byte string, `None` will be returned.

        This function is meant to be used by language bindings that have specific
        handling for Unix paths.
        """
    def get_attribute_int32(self, attribute: str) -> int:
        """
            Gets a signed 32-bit integer contained within the attribute. If the
        attribute does not contain a signed 32-bit integer, or is invalid,
        0 will be returned.
        """
    def get_attribute_int64(self, attribute: str) -> int:
        """
            Gets a signed 64-bit integer contained within the attribute. If the
        attribute does not contain a signed 64-bit integer, or is invalid,
        0 will be returned.
        """
    def get_attribute_object(self, attribute: str) -> GObject.Object | None:
        """
            Gets the value of a GObject attribute. If the attribute does
        not contain a GObject, None will be returned.
        """
    def get_attribute_status(self, attribute: str) -> FileAttributeStatus:
        """
        Gets the attribute status for an attribute key.
        """
    def get_attribute_string(self, attribute: str) -> str | None:
        """
            Gets the value of a string attribute. If the attribute does
        not contain a string, None will be returned.
        """
    def get_attribute_stringv(self, attribute: str) -> list | None:
        """
            Gets the value of a stringv attribute. If the attribute does
        not contain a stringv, None will be returned.
        """
    def get_attribute_type(self, attribute: str) -> FileAttributeType:
        """
        Gets the attribute type for an attribute key.
        """
    def get_attribute_uint32(self, attribute: str) -> int:
        """
            Gets an unsigned 32-bit integer contained within the attribute. If the
        attribute does not contain an unsigned 32-bit integer, or is invalid,
        0 will be returned.
        """
    def get_attribute_uint64(self, attribute: str) -> int:
        """
            Gets a unsigned 64-bit integer contained within the attribute. If the
        attribute does not contain an unsigned 64-bit integer, or is invalid,
        0 will be returned.
        """
    def get_content_type(self) -> str | None:
        """
            Gets the file's content type.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
        """
    def get_creation_date_time(self) -> GLib.DateTime | None:
        """
            Gets the creation time of the current `info` and returns it as a
        GDateTime.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_TIME_CREATED. If G_FILE_ATTRIBUTE_TIME_CREATED_USEC is
        provided, the resulting GDateTime will additionally have microsecond
        precision.

        If nanosecond precision is needed, G_FILE_ATTRIBUTE_TIME_CREATED_NSEC must
        be queried separately using `g_file_info_get_attribute_uint32`.
        """
    def get_deletion_date(self) -> GLib.DateTime | None:
        """
            Returns the GDateTime representing the deletion date of the file, as
        available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
        G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, None is returned.
        """
    def get_display_name(self) -> str:
        """
            Gets a display name for a file. This is guaranteed to always be set.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
        """
    def get_edit_name(self) -> str:
        """
            Gets the edit name for a file.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
        """
    def get_etag(self) -> str | None:
        """
            Gets the [entity tag][iface`Gio`.File#entity-tags] for a given
        GFileInfo. See G_FILE_ATTRIBUTE_ETAG_VALUE.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_ETAG_VALUE.
        """
    def get_file_type(self) -> FileType:
        """
            Gets a file's type (whether it is a regular file, symlink, etc).
        This is different from the file's content type, see `g_file_info_get_content_type`.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_TYPE.
        """
    def get_icon(self) -> Icon | None:
        """
            Gets the icon for a file.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_ICON.
        """
    def get_is_backup(self) -> bool:
        """
            Checks if a file is a backup file.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP.
        """
    def get_is_hidden(self) -> bool:
        """
            Checks if a file is hidden.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
        """
    def get_is_symlink(self) -> bool:
        """
            Checks if a file is a symlink.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
        """
    def get_modification_date_time(self) -> GLib.DateTime | None:
        """
            Gets the modification time of the current `info` and returns it as a
        GDateTime.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_TIME_MODIFIED. If G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
        provided, the resulting GDateTime will additionally have microsecond
        precision.

        If nanosecond precision is needed, G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC must
        be queried separately using `g_file_info_get_attribute_uint32`.
        """
    @deprecated("deprecated")
    def get_modification_time(self) -> GLib.TimeVal:
        """
            Gets the modification time of the current `info` and sets it
        in `result`.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_TIME_MODIFIED. If G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
        provided it will be used too.
        """
    def get_name(self) -> str:
        """
            Gets the name for a file. This is guaranteed to always be set.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_NAME.
        """
    def get_size(self) -> int:
        """
            Gets the file's size (in bytes). The size is retrieved through the value of
        the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
        from #guint64 to #goffset before returning the result.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_SIZE.
        """
    def get_sort_order(self) -> int:
        """
            Gets the value of the sort_order attribute from the GFileInfo.
        See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
        """
    def get_symbolic_icon(self) -> Icon | None:
        """
            Gets the symbolic icon for a file.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
        """
    def get_symlink_target(self) -> str | None:
        """
            Gets the symlink target for a given GFileInfo.

        It is an error to call this if the GFileInfo does not contain
        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET.
        """
    def has_attribute(self, attribute: str) -> bool:
        """
        Checks if a file info structure has an attribute named `attribute`.
        """
    def has_namespace(self, name_space: str) -> bool:
        """
            Checks if a file info structure has an attribute in the
        specified `name_space`.
        """
    def list_attributes(self, name_space: str | None = None) -> list | None:
        """
        Lists the file info structure's attributes.
        """
    @classmethod
    def new(cls) -> FileInfo:
        """
        Creates a new file info structure.
        """
    def remove_attribute(self, attribute: str) -> None:
        """
        Removes all cases of `attribute` from `info` if it exists.
        """
    def set_access_date_time(self, atime: GLib.DateTime) -> None:
        """
            Sets the G_FILE_ATTRIBUTE_TIME_ACCESS and
        G_FILE_ATTRIBUTE_TIME_ACCESS_USEC attributes in the file info to the
        given date/time value.

        G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC will be cleared.
        """
    def set_attribute(self, attribute: str, type: FileAttributeType, value_p: object) -> None:
        """
            Sets the `attribute` to contain the given value, if possible. To unset the
        attribute, use G_FILE_ATTRIBUTE_TYPE_INVALID for `type`.
        """
    def set_attribute_boolean(self, attribute: str, attr_value: bool) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.
        """
    def set_attribute_byte_string(self, attribute: str, attr_value: str) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.
        """
    def set_attribute_file_path(self, attribute: str, attr_value: str) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.

        This function is meant to be used by language bindings that have specific
        handling for Unix paths.
        """
    def set_attribute_int32(self, attribute: str, attr_value: int) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.
        """
    def set_attribute_int64(self, attribute: str, attr_value: int) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.
        """
    def set_attribute_mask(self, mask: FileAttributeMatcher) -> None:
        """
        Sets `mask` on `info` to match specific attribute types.
        """
    def set_attribute_object(self, attribute: str, attr_value: GObject.Object) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.
        """
    def set_attribute_status(self, attribute: str, status: FileAttributeStatus) -> bool:
        """
            Sets the attribute status for an attribute key. This is only
        needed by external code that implement `g_file_set_attributes_from_info`
        or similar functions.

        The attribute must exist in `info` for this to work. Otherwise False
        is returned and `info` is unchanged.
        """
    def set_attribute_string(self, attribute: str, attr_value: str) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.
        """
    def set_attribute_stringv(self, attribute: str, attr_value: list) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.

        Sinze: 2.22
        """
    def set_attribute_uint32(self, attribute: str, attr_value: int) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.
        """
    def set_attribute_uint64(self, attribute: str, attr_value: int) -> None:
        """
            Sets the `attribute` to contain the given `attr_value`,
        if possible.
        """
    def set_content_type(self, content_type: str) -> None:
        """
            Sets the content type attribute for a given GFileInfo.
        See G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
        """
    def set_creation_date_time(self, creation_time: GLib.DateTime) -> None:
        """
            Sets the G_FILE_ATTRIBUTE_TIME_CREATED and
        G_FILE_ATTRIBUTE_TIME_CREATED_USEC attributes in the file info to the
        given date/time value.

        G_FILE_ATTRIBUTE_TIME_CREATED_NSEC will be cleared.
        """
    def set_display_name(self, display_name: str) -> None:
        """
            Sets the display name for the current GFileInfo.
        See G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
        """
    def set_edit_name(self, edit_name: str) -> None:
        """
            Sets the edit name for the current file.
        See G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
        """
    def set_file_type(self, type: FileType) -> None:
        """
            Sets the file type in a GFileInfo to `type`.
        See G_FILE_ATTRIBUTE_STANDARD_TYPE.
        """
    def set_icon(self, icon: Icon) -> None:
        """
            Sets the icon for a given GFileInfo.
        See G_FILE_ATTRIBUTE_STANDARD_ICON.
        """
    def set_is_hidden(self, is_hidden: bool) -> None:
        """
            Sets the "is_hidden" attribute in a GFileInfo according to `is_hidden`.
        See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
        """
    def set_is_symlink(self, is_symlink: bool) -> None:
        """
            Sets the "is_symlink" attribute in a GFileInfo according to `is_symlink`.
        See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
        """
    def set_modification_date_time(self, mtime: GLib.DateTime) -> None:
        """
            Sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
        G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
        given date/time value.

        G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
        """
    @deprecated("deprecated")
    def set_modification_time(self, mtime: GLib.TimeVal) -> None:
        """
            Sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
        G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
        given time value.

        G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
        """
    def set_name(self, name: str) -> None:
        """
            Sets the name attribute for the current GFileInfo.
        See G_FILE_ATTRIBUTE_STANDARD_NAME.
        """
    def set_size(self, size: int) -> None:
        """
            Sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
        to the given size.
        """
    def set_sort_order(self, sort_order: int) -> None:
        """
            Sets the sort order attribute in the file info structure. See
        G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
        """
    def set_symbolic_icon(self, icon: Icon) -> None:
        """
            Sets the symbolic icon for a given GFileInfo.
        See G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
        """
    def set_symlink_target(self, symlink_target: str) -> None:
        """
            Sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
        to the given symlink target.
        """
    def unset_attribute_mask(self) -> None:
        """
            Unsets a mask set by `g_file_info_set_attribute_mask`, if one
        is set.
        """

class FileInfoClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileInputStream(InputStream):
    """
    `GFileInputStream` provides input streams that take their
    content from a file.

    `GFileInputStream` implements [iface`Gio`.Seekable], which allows the input
    stream to jump to arbitrary positions in the file, provided the
    filesystem of the file allows it. To find the position of a file
    input stream, use [method`Gio`.Seekable.tell]. To find out if a file input
    stream supports seeking, use [vfunc`Gio`.Seekable.can_seek].
    To position a file input stream, use [vfunc`Gio`.Seekable.seek].
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> InputStream | None: ...
    @builtins.property
    def priv(self) -> FileInputStreamPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def query_info(self, attributes: str, cancellable: Cancellable | None = None) -> FileInfo:
        """
            Queries a file input stream the given `attributes`. This function blocks
        while querying the stream. For the asynchronous (non-blocking) version
        of this function, see `g_file_input_stream_query_info_async`. While the
        stream is blocked, the stream will set the pending flag internally, and
        any other operations on the stream will fail with G_IO_ERROR_PENDING.
        """
    async def query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Queries the stream information asynchronously.
        When the operation is finished `callback` will be called.
        You can then call `g_file_input_stream_query_info_finish`
        to get the result of the operation.

        For the synchronous version of this function,
        see `g_file_input_stream_query_info`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be set
        """
    def query_info_finish(self, result: AsyncResult) -> FileInfo:
        """
        Finishes an asynchronous info query operation.
        """

    # python methods (overrides?)
    def do_can_seek(
        self,
    ) -> bool:
        """
        can_seek(self) -> bool
        """
    def do_query_info(
        self,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo:
        """
        query_info(self, attributes:str, cancellable:Gio.Cancellable=None) -> Gio.FileInfo
        """
    def do_query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        query_info_async(self, attributes:str, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_query_info_finish(
        self,
        result: AsyncResult,
    ) -> FileInfo:
        """
        query_info_finish(self, result:Gio.AsyncResult) -> Gio.FileInfo
        """
    def do_seek(
        self,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        seek(self, offset:int, type:GLib.SeekType, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_tell(
        self,
    ) -> int:
        """
        tell(self) -> int
        """

class FileInputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def can_seek(self) -> can_seekFileInputStreamClassCB: ...
    @builtins.property
    def parent_class(self) -> InputStreamClass | None: ...
    @builtins.property
    def query_info(self) -> query_infoFileInputStreamClassCB: ...
    @builtins.property
    def query_info_async(self) -> query_info_asyncFileInputStreamClassCB: ...
    @builtins.property
    def query_info_finish(self) -> query_info_finishFileInputStreamClassCB: ...
    @builtins.property
    def seek(self) -> seekFileInputStreamClassCB: ...
    @builtins.property
    def tell(self) -> tellFileInputStreamClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileMonitor(GObject.Object):
    """
    Monitors a file or directory for changes.

    To obtain a `GFileMonitor` for a file or directory, use
    [method`Gio`.File.monitor], [method`Gio`.File.monitor_file], or
    [method`Gio`.File.monitor_directory].

    To get informed about changes to the file or directory you are
    monitoring, connect to the [signal`Gio`.FileMonitor::changed] signal. The
    signal will be emitted in the thread-default main context (see
    [method`GLib`.MainContext.push_thread_default]) of the thread that the monitor
    was created in (though if the global default main context is blocked, this
    may cause notifications to be blocked even if the thread-default
    context is still running).
    """

    class Props(GObject.Object.Props):
        cancelled: bool
        """
        Whether the monitor has been cancelled.
        """
        rate_limit: int  # [rate-limit]: changed because contained invalid characters
        """
        The limit of the monitor to watch for changes, in milliseconds.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> FileMonitorPrivate | None: ...

    # gi Methods
    def __init__(self, rate_limit: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def cancel(self) -> bool:
        """
        Cancels a file monitor.
        """
    def emit_event(self, child: File, other_file: File, event_type: FileMonitorEvent) -> None:
        """
            Emits the GFileMonitor::changed signal if a change
        has taken place. Should be called from file monitor
        implementations only.

        Implementations are responsible to call this method from the
        thread-default main context (see [method`GLib`.MainContext.push_thread_default])
        of the thread that the monitor was created in.
        """
    @builtins.property
    def is_cancelled(self) -> bool:
        """
        Returns whether the monitor is canceled.
        """
    def set_rate_limit(self, limit_msecs: int) -> None:
        """
            Sets the rate limit to which the `monitor` will report
        consecutive change events to the same file.
        """

    # python methods (overrides?)
    def do_cancel(
        self,
    ) -> bool:
        """
        cancel(self) -> bool
        """
    def do_changed(
        self,
        file: File,
        other_file: File,
        event_type: FileMonitorEvent,
    ) -> None:
        """
        changed(self, file:Gio.File, other_file:Gio.File, event_type:Gio.FileMonitorEvent)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["changed"],
        handler: typing.Callable[[typing_extensions.Self, File, File | None, FileMonitorEvent], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when `file` has been changed.

        If using G_FILE_MONITOR_WATCH_MOVES on a directory monitor, and
        the information is available (and if supported by the backend),
        `event_type` may be G_FILE_MONITOR_EVENT_RENAMED,
        G_FILE_MONITOR_EVENT_MOVED_IN or G_FILE_MONITOR_EVENT_MOVED_OUT.

        In all cases `file` will be a child of the monitored directory.  For
        renames, `file` will be the old name and `other_file` is the new
        name.  For "moved in" events, `file` is the name of the file that
        appeared and `other_file` is the old name that it was moved from (in
        another directory).  For "moved out" events, `file` is the name of
        the file that used to be in this directory and `other_file` is the
        name of the file at its new location.

        It makes sense to treat G_FILE_MONITOR_EVENT_MOVED_IN as
        equivalent to G_FILE_MONITOR_EVENT_CREATED and
        G_FILE_MONITOR_EVENT_MOVED_OUT as equivalent to
        G_FILE_MONITOR_EVENT_DELETED, with extra information.
        G_FILE_MONITOR_EVENT_RENAMED is equivalent to a delete/create
        pair.  This is exactly how the events will be reported in the case
        that the G_FILE_MONITOR_WATCH_MOVES flag is not in use.

        If using the deprecated flag G_FILE_MONITOR_SEND_MOVED flag and `event_type` is
        G_FILE_MONITOR_EVENT_MOVED, `file` will be set to a GFile containing the
        old path, and `other_file` will be set to a GFile containing the new path.

        In all the other cases, `other_file` will be set to None.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::cancelled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rate_limit"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FileMonitorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def cancel(self) -> cancelFileMonitorClassCB: ...
    @builtins.property
    def changed(self) -> changedFileMonitorClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileMonitorPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileOutputStream(OutputStream):
    """
    `GFileOutputStream` provides output streams that write their
    content to a file.

    `GFileOutputStream` implements [iface`Gio`.Seekable], which allows the output
    stream to jump to arbitrary positions in the file and to truncate
    the file, provided the filesystem of the file supports these
    operations.

    To find the position of a file output stream, use [method`Gio`.Seekable.tell].
    To find out if a file output stream supports seeking, use
    [method`Gio`.Seekable.can_seek].To position a file output stream, use
    [method`Gio`.Seekable.seek]. To find out if a file output stream supports
    truncating, use [method`Gio`.Seekable.can_truncate]. To truncate a file output
    stream, use [method`Gio`.Seekable.truncate].
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> OutputStream | None: ...
    @builtins.property
    def priv(self) -> FileOutputStreamPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_etag(self) -> str | None:
        """
            Gets the entity tag for the file when it has been written.
        This must be called after the stream has been written
        and closed, as the etag can change while writing.
        """
    def query_info(self, attributes: str, cancellable: Cancellable | None = None) -> FileInfo:
        """
            Queries a file output stream for the given `attributes`.
        This function blocks while querying the stream. For the asynchronous
        version of this function, see `g_file_output_stream_query_info_async`.
        While the stream is blocked, the stream will set the pending flag
        internally, and any other operations on the stream will fail with
        G_IO_ERROR_PENDING.

        Can fail if the stream was already closed (with `error` being set to
        G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
        set to G_IO_ERROR_PENDING), or if querying info is not supported for
        the stream's interface (with `error` being set to G_IO_ERROR_NOT_SUPPORTED). In
        all cases of failure, None will be returned.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be set, and None will
        be returned.
        """
    async def query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously queries the `stream` for a GFileInfo. When completed,
        `callback` will be called with a GAsyncResult which can be used to
        finish the operation with `g_file_output_stream_query_info_finish`.

        For the synchronous version of this function, see
        `g_file_output_stream_query_info`.
        """
    def query_info_finish(self, result: AsyncResult) -> FileInfo:
        """
            Finalizes the asynchronous query started
        by `g_file_output_stream_query_info_async`.
        """

    # python methods (overrides?)
    def do_can_seek(
        self,
    ) -> bool:
        """
        can_seek(self) -> bool
        """
    def do_can_truncate(
        self,
    ) -> bool:
        """
        can_truncate(self) -> bool
        """
    def do_get_etag(
        self,
    ) -> str | None:
        """
        get_etag(self) -> str or None
        """
    def do_query_info(
        self,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo:
        """
        query_info(self, attributes:str, cancellable:Gio.Cancellable=None) -> Gio.FileInfo
        """
    def do_query_info_async(
        self,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        query_info_async(self, attributes:str, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_query_info_finish(
        self,
        result: AsyncResult,
    ) -> FileInfo:
        """
        query_info_finish(self, result:Gio.AsyncResult) -> Gio.FileInfo
        """
    def do_seek(
        self,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        seek(self, offset:int, type:GLib.SeekType, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_tell(
        self,
    ) -> int:
        """
        tell(self) -> int
        """
    def do_truncate_fn(
        self,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        truncate_fn(self, size:int, cancellable:Gio.Cancellable=None) -> bool
        """

class FileOutputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def can_seek(self) -> can_seekFileOutputStreamClassCB: ...
    @builtins.property
    def can_truncate(self) -> can_truncateFileOutputStreamClassCB: ...
    @builtins.property
    def get_etag(self) -> get_etagFileOutputStreamClassCB | None: ...
    @builtins.property
    def parent_class(self) -> OutputStreamClass | None: ...
    @builtins.property
    def query_info(self) -> query_infoFileOutputStreamClassCB: ...
    @builtins.property
    def query_info_async(self) -> query_info_asyncFileOutputStreamClassCB: ...
    @builtins.property
    def query_info_finish(self) -> query_info_finishFileOutputStreamClassCB: ...
    @builtins.property
    def seek(self) -> seekFileOutputStreamClassCB: ...
    @builtins.property
    def tell(self) -> tellFileOutputStreamClassCB: ...
    @builtins.property
    def truncate_fn(self) -> truncate_fnFileOutputStreamClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FileOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FilenameCompleter(GObject.Object):
    """
    Completes partial file and directory names given a partial string by
    looking in the file system for clues. Can return a list of possible
    completion strings for widget implementations.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_completion_suffix(self, initial_text: str) -> str | None:
        """
        Obtains a completion for `initial_text` from `completer`.
        """
    def get_completions(self, initial_text: str) -> list:
        """
        Gets an array of completion strings for a given initial text.
        """
    @classmethod
    def new(cls) -> FilenameCompleter:
        """
        Creates a new filename completer.
        """
    def set_dirs_only(self, dirs_only: bool) -> None:
        """
            If `dirs_only` is True, `completer` will only
        complete directory names, and not file names.
        """

    # python methods (overrides?)
    def do_got_completion_data(
        self,
    ) -> None:
        """
        got_completion_data(self)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["got-completion-data"],
        handler: typing.Callable[..., None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when the file name completion information comes available.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FilenameCompleterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def got_completion_data(self) -> got_completion_dataFilenameCompleterClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FilterInputStream(InputStream):
    """
    Base class for input stream implementations that perform some
    kind of filtering operation on a base stream. Typical examples
    of filtering operations are character set conversion, compression
    and byte order flipping.
    """

    class Props(InputStream.Props):
        base_stream: InputStream | None  # [base-stream]: changed because contained invalid characters
        """
        The underlying base stream on which the I/O ops will be done.
        """
        close_base_stream: bool  # [close-base-stream]: changed because contained invalid characters
        """
        Whether the base stream should be closed when the filter stream is closed.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def base_stream(self) -> InputStream | None: ...
    @builtins.property
    def parent_instance(self) -> InputStream | None: ...

    # gi Methods
    def __init__(self, base_stream: InputStream | None = ..., close_base_stream: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_base_stream(self) -> InputStream:
        """
        Gets the base stream for the filter stream.
        """
    @builtins.property
    def get_close_base_stream(self) -> bool:
        """
            Returns whether the base stream will be closed when `stream` is
        closed.
        """
    def set_close_base_stream(self, close_base: bool) -> None:
        """
        Sets whether the base stream will be closed when `stream` is closed.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::close_base_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FilterInputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> InputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class FilterOutputStream(OutputStream):
    """
    Base class for output stream implementations that perform some
    kind of filtering operation on a base stream. Typical examples
    of filtering operations are character set conversion, compression
    and byte order flipping.
    """

    class Props(OutputStream.Props):
        base_stream: OutputStream | None  # [base-stream]: changed because contained invalid characters
        """
        The underlying base stream on which the I/O ops will be done.
        """
        close_base_stream: bool  # [close-base-stream]: changed because contained invalid characters
        """
        Whether the base stream should be closed when the filter stream is closed.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def base_stream(self) -> OutputStream | None: ...
    @builtins.property
    def parent_instance(self) -> OutputStream | None: ...

    # gi Methods
    def __init__(self, base_stream: OutputStream | None = ..., close_base_stream: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_base_stream(self) -> OutputStream:
        """
        Gets the base stream for the filter stream.
        """
    @builtins.property
    def get_close_base_stream(self) -> bool:
        """
            Returns whether the base stream will be closed when `stream` is
        closed.
        """
    def set_close_base_stream(self, close_base: bool) -> None:
        """
        Sets whether the base stream will be closed when `stream` is closed.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::close_base_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class FilterOutputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> OutputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IOExtension(GObject.GPointer):
    """
    GIOExtension is an opaque data structure and can only be accessed
    using the following functions.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_name(self) -> str:
        """
            Gets the name under which `extension` was registered.

        Note that the same type may be registered as extension
        for multiple extension points, under different names.
        """
    def get_priority(self) -> int:
        """
        Gets the priority with which `extension` was registered.
        """
    def get_type(self) -> GObject.GType:
        """
        Gets the type associated with `extension`.
        """

class IOExtensionPoint(GObject.GPointer):
    """
    `GIOExtensionPoint` provides a mechanism for modules to extend the
    functionality of the library or application that loaded it in an
    organized fashion.

    An extension point is identified by a name, and it may optionally
    require that any implementation must be of a certain type (or derived
    thereof). Use [func`Gio`.IOExtensionPoint.register] to register an
    extension point, and [method`Gio`.IOExtensionPoint.set_required_type] to
    set a required type.

    A module can implement an extension point by specifying the
    [type`GObject`.Type] that implements the functionality. Additionally, each
    implementation of an extension point has a name, and a priority. Use
    [func`Gio`.IOExtensionPoint.implement] to implement an extension point.

    ```c
    GIOExtensionPoint *ep;

    // Register an extension point
    ep = g_io_extension_point_register ("my-extension-point");
    g_io_extension_point_set_required_type (ep, MY_TYPE_EXAMPLE);
    ```

    ```c
    // Implement an extension point
    G_DEFINE_TYPE (MyExampleImpl, my_example_impl, MY_TYPE_EXAMPLE)
    g_io_extension_point_implement ("my-extension-point",
                                    my_example_impl_get_type (),
                                    "my-example",
                                    10);
    ```

     It is up to the code that registered the extension point how
     it uses the implementations that have been associated with it.
     Depending on the use case, it may use all implementations, or
     only the one with the highest priority, or pick a specific
     one by name.

     To avoid opening all modules just to find out what extension
     points they implement, GIO makes use of a caching mechanism,
     see [gio-querymodules](gio-querymodules.html).
     You are expected to run this command after installing a
     GIO module.

     The `GIO_EXTRA_MODULES` environment variable can be used to
     specify additional directories to automatically load modules
     from. This environment variable has the same syntax as the
     `PATH`. If two modules have the same base name in different
     directories, then the latter one will be ignored. If additional
     directories are specified GIO will load modules from the built-in
     directory last.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_extension_by_name(self, name: str) -> IOExtension:
        """
        Finds a GIOExtension for an extension point by name.
        """
    def get_extensions(self) -> list:
        """
            Gets a list of all extensions that implement this extension point.
        The list is sorted by priority, beginning with the highest priority.
        """
    def get_required_type(self) -> GObject.GType:
        """
        Gets the required type for `extension_point`.
        """
    @staticmethod
    def implement(extension_point_name: str, type: GObject.GType, extension_name: str, priority: int) -> IOExtension:
        """
            Registers `type` as extension for the extension point with name
        `extension_point_name`.

        If `type` has already been registered as an extension for this
        extension point, the existing GIOExtension object is returned.
        """
    @staticmethod
    def lookup(name: str) -> IOExtensionPoint:
        """
        Looks up an existing extension point.
        """
    @staticmethod
    def register(name: str) -> IOExtensionPoint:
        """
        Registers an extension point.
        """
    def set_required_type(self, type: GObject.GType) -> None:
        """
            Sets the required type for `extension_point` to `type`.
        All implementations must henceforth have this type.
        """

class IOModule(GObject.TypeModule):
    """
    Provides an interface and default functions for loading and unloading
    modules. This is used internally to make GIO extensible, but can also
    be used by others to implement module loading.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, filename: str) -> IOModule:
        """
            Creates a new GIOModule that will load the specific
        shared library when in use.
        """
    @staticmethod
    def query() -> list:
        """
            Optional API for GIO modules to implement.

        Should return a list of all the extension points that may be
        implemented in this module.

        This method will not be called in normal use, however it may be
        called when probing existing modules and recording which extension
        points that this model is used for. This means we won't have to
        load and initialize this module unless its needed.

        If this function is not implemented by the module the module will
        always be loaded, initialized and then unloaded on application
        startup so that it can register its extension points during init.

        Note that a module need not actually implement all the extension
        points that `g_io_module_query` returns, since the exact list of
        extension may depend on runtime issues. However all extension
        points actually implemented must be returned by `g_io_module_query`
        (if defined).

        When installing a module that implements `g_io_module_query` you must
        run gio-querymodules in order to build the cache files required for
        lazy loading.

        Since 2.56, this function should be named `g_io_<modulename>_query`, where
        `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
        everything after the first dot removed, and with `-` replaced with `_`
        throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
        Using the new symbol names avoids name clashes when building modules
        statically. The old symbol names continue to be supported, but cannot be used
        for static builds.
        """

class IOModuleClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IOModuleScope(GObject.GPointer):
    """
    Represents a scope for loading IO modules. A scope can be used for blocking
    duplicate modules, or blocking a module you don't want to load.

    The scope can be used with `g_io_modules_load_all_in_directory_with_scope`
    or `g_io_modules_scan_all_in_directory_with_scope`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def block(self, basename: str) -> None:
        """
            Block modules with the given `basename` from being loaded when
        this scope is used with `g_io_modules_scan_all_in_directory_with_scope`
        or `g_io_modules_load_all_in_directory_with_scope`.
        """
    def free(self) -> None:
        """
        Free a module scope.
        """

class IOSchedulerJob(GObject.GPointer):
    """
    Opaque class for defining and scheduling IO jobs.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def send_to_mainloop(self, func: GLib.SourceFunc, *user_data: object | None) -> bool:
        """
            Used from an I/O job to send a callback to be run in the thread
        that the job was started from, waiting for the result (and thus
        blocking the I/O job).
        """
    @deprecated("deprecated")
    def send_to_mainloop_async(self, func: GLib.SourceFunc, *user_data: object | None) -> None:
        """
            Used from an I/O job to send a callback to be run asynchronously in
        the thread that the job was started from. The callback will be run
        when the main loop is available, but at that time the I/O job might
        have finished. The return value from the callback is ignored.

        Note that if you are passing the `user_data` from `g_io_scheduler_push_job`
        on to this function you have to ensure that it is not freed before
        `func` is called, either by passing None as `notify` to
        `g_io_scheduler_push_job` or by using refcounting for `user_data`.
        """

class IOStream(GObject.Object):
    """
    `GIOStream` represents an object that has both read and write streams.
    Generally the two streams act as separate input and output streams,
    but they share some common resources and state. For instance, for
    seekable streams, both streams may use the same position.

    Examples of `GIOStream` objects are [class`Gio`.SocketConnection], which represents
    a two-way network connection; and [class`Gio`.FileIOStream], which represents a
    file handle opened in read-write mode.

    To do the actual reading and writing you need to get the substreams
    with [method`Gio`.IOStream.get_input_stream] and
    [method`Gio`.IOStream.get_output_stream].

    The `GIOStream` object owns the input and the output streams, not the other
    way around, so keeping the substreams alive will not keep the `GIOStream`
    object alive. If the `GIOStream` object is freed it will be closed, thus
    closing the substreams, so even if the substreams stay alive they will
    always return `G_IO_ERROR_CLOSED` for all operations.

    To close a stream use [method`Gio`.IOStream.close] which will close the common
    stream object and also the individual substreams. You can also close
    the substreams themselves. In most cases this only marks the
    substream as closed, so further I/O on it fails but common state in the
    `GIOStream` may still be open. However, some streams may support
    ‘half-closed’ states where one direction of the stream is actually shut down.

    Operations on `GIOStream`s cannot be started while another operation on the
    `GIOStream` or its substreams is in progress. Specifically, an application can
    read from the [class`Gio`.InputStream] and write to the
    [class`Gio`.OutputStream] simultaneously (either in separate threads, or as
    asynchronous operations in the same thread), but an application cannot start
    any `GIOStream` operation while there is a `GIOStream`, `GInputStream` or
    `GOutputStream` operation in progress, and an application can’t start any
    `GInputStream` or `GOutputStream` operation while there is a `GIOStream`
    operation in progress.

    This is a product of individual stream operations being associated with a
    given [type`GLib`.MainContext] (the thread-default context at the time the
    operation was started), rather than entire streams being associated with a
    single `GMainContext`.

    GIO may run operations on `GIOStream`s from other (worker) threads, and this
    may be exposed to application code in the behaviour of wrapper streams, such
    as [class`Gio`.BufferedInputStream] or [class`Gio`.TlsConnection]. With such
    wrapper APIs, application code may only run operations on the base (wrapped)
    stream when the wrapper stream is idle. Note that the semantics of such
    operations may not be well-defined due to the state the wrapper stream leaves
    the base stream in (though they are guaranteed not to crash).
    """

    class Props(GObject.Object.Props):
        closed: bool
        """
        Whether the stream is closed.
        """
        input_stream: InputStream | None  # [input-stream]: changed because contained invalid characters
        """
        The [class`Gio`.InputStream] to read from.
        """
        output_stream: OutputStream | None  # [output-stream]: changed because contained invalid characters
        """
        The [class`Gio`.OutputStream] to write to.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> IOStreamPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear_pending(self) -> None:
        """
        Clears the pending flag on `stream`.
        """
    def close(self, cancellable: Cancellable | None = None) -> bool:
        """
            Closes the stream, releasing resources related to it. This will also
        close the individual input and output streams, if they are not already
        closed.

        Once the stream is closed, all other operations will return
        G_IO_ERROR_CLOSED. Closing a stream multiple times will not
        return an error.

        Closing a stream will automatically flush any outstanding buffers
        in the stream.

        Streams will be automatically closed when the last reference
        is dropped, but you might want to call this function to make sure
        resources are released as early as possible.

        Some streams might keep the backing store of the stream (e.g. a file
        descriptor) open after the stream is closed. See the documentation for
        the individual stream for details.

        On failure the first error that happened will be reported, but the
        close operation will finish as much as possible. A stream that failed
        to close will still return G_IO_ERROR_CLOSED for all operations.
        Still, it is important to check and report the error to the user,
        otherwise there might be a loss of data as all data might not be written.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        Cancelling a close will still leave the stream closed, but some streams
        can use a faster close that doesn't block to e.g. check errors.

        The default implementation of this method just calls close on the
        individual input/output streams.
        """
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Requests an asynchronous close of the stream, releasing resources
        related to it. When the operation is finished `callback` will be
        called. You can then call `g_io_stream_close_finish` to get
        the result of the operation.

        For behaviour details see `g_io_stream_close`.

        The asynchronous methods have a default fallback that uses threads
        to implement asynchronicity, so they are optional for inheriting
        classes. However, if you override one you must override all.
        """
    def close_finish(self, result: AsyncResult) -> bool:
        """
        Closes a stream.
        """
    @builtins.property
    def get_input_stream(self) -> InputStream:
        """
            Gets the input stream for this object. This is used
        for reading.
        """
    @builtins.property
    def get_output_stream(self) -> OutputStream:
        """
            Gets the output stream for this object. This is used for
        writing.
        """
    def has_pending(self) -> bool:
        """
        Checks if a stream has pending actions.
        """
    @builtins.property
    def is_closed(self) -> bool:
        """
        Checks if a stream is closed.
        """
    def set_pending(self) -> bool:
        """
            Sets `stream` to have actions pending. If the pending flag is
        already set or `stream` is closed, it will return False and set
        `error`.
        """
    def splice_async(
        self,
        stream2: IOStream,
        flags: IOStreamSpliceFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously splice the output stream of `stream1` to the input stream of
        `stream2`, and splice the output stream of `stream2` to the input stream of
        `stream1`.

        When the operation is finished `callback` will be called.
        You can then call `g_io_stream_splice_finish` to get the
        result of the operation.
        """
    @staticmethod
    def splice_finish(result: AsyncResult) -> bool:
        """
        Finishes an asynchronous io stream splice operation.
        """

    # python methods (overrides?)
    def do_close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        close_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_close_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        close_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_close_fn(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        close_fn(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_get_input_stream(
        self,
    ) -> InputStream:
        """
        get_input_stream(self) -> Gio.InputStream
        """
    def do_get_output_stream(
        self,
    ) -> OutputStream:
        """
        get_output_stream(self) -> Gio.OutputStream
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::closed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::output_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class IOStreamAdapter(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IOStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved10(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def _g_reserved7(self) -> object | None: ...
    @builtins.property
    def _g_reserved8(self) -> object | None: ...
    @builtins.property
    def _g_reserved9(self) -> object | None: ...
    @builtins.property
    def close_async(self) -> close_asyncIOStreamClassCB: ...
    @builtins.property
    def close_finish(self) -> close_finishIOStreamClassCB: ...
    @builtins.property
    def close_fn(self) -> close_fnIOStreamClassCB: ...
    @builtins.property
    def get_input_stream(self) -> get_input_streamIOStreamClassCB: ...
    @builtins.property
    def get_output_stream(self) -> get_output_streamIOStreamClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class IOStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Icon(GObject.GInterface):
    """
    `GIcon` is a very minimal interface for icons. It provides functions
    for checking the equality of two icons, hashing of icons and
    serializing an icon to and from strings.

    `GIcon` does not provide the actual pixmap for the icon as this is out
    of GIO's scope, however implementations of `GIcon` may contain the name
    of an icon (see [class`Gio`.ThemedIcon]), or the path to an icon
    (see [iface`Gio`.LoadableIcon]).

    To obtain a hash of a `GIcon`, see [method`Gio`.Icon.hash].

    To check if two `GIcon`s are equal, see [method`Gio`.Icon.equal].

    For serializing a `GIcon`, use [method`Gio`.Icon.serialize] and
    [func`Gio`.Icon.deserialize].

    If you want to consume `GIcon` (for example, in a toolkit) you must
    be prepared to handle at least the three following cases:
    [iface`Gio`.LoadableIcon], [class`Gio`.ThemedIcon] and [class`Gio`.EmblemedIcon].
    It may also make sense to have fast-paths for other cases (like handling
    [`GdkPixbuf`](https://docs.gtk.org/gdk-pixbuf/class.Pixbuf.html) directly,
    for example) but all compliant `GIcon` implementations outside of GIO must
    implement [iface`Gio`.LoadableIcon].

    If your application or library provides one or more `GIcon`
    implementations you need to ensure that your new implementation also
    implements [iface`Gio`.LoadableIcon].  Additionally, you must provide an
    implementation of [method`Gio`.Icon.serialize] that gives a result that is
    understood by [func`Gio`.Icon.deserialize], yielding one of the built-in
    icon types.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def deserialize(value: GLib.Variant) -> Icon | None:
        """
        Deserializes a GIcon previously serialized using `g_icon_serialize`.
        """
    def equal(self, icon2: Icon | None = None) -> bool:
        """
        Checks if two icons are equal.
        """
    def hash(self) -> int:
        """
        Gets a hash for an icon.
        """
    @staticmethod
    def new_for_string(str: str) -> Icon:
        """
            Generate a GIcon instance from `str`. This function can fail if
        `str` is not valid - see `g_icon_to_string` for discussion.

        If your application or library provides one or more GIcon
        implementations you need to ensure that each GType is registered
        with the type system prior to calling `g_icon_new_for_string`.
        """
    def serialize(self) -> GLib.Variant | None:
        """
            Serializes a GIcon into a GVariant. An equivalent GIcon can be retrieved
        back by calling `g_icon_deserialize` on the returned value.
        As serialization will avoid using raw icon data when possible, it only
        makes sense to transfer the GVariant between processes on the same machine,
        (as opposed to over the network), and within the same file system namespace.
        """
    def to_string(self) -> str | None:
        """
            Generates a textual representation of `icon` that can be used for
        serialization such as when passing `icon` to a different process or
        saving it to persistent storage. Use `g_icon_new_for_string` to
        get `icon` back from the returned string.

        The encoding of the returned string is proprietary to GIcon except
        in the following two cases

        - If `icon` is a GFileIcon, the returned string is a native path
          (such as `/path/to/my icon.png`) without escaping
          if the GFile for `icon` is a native file.  If the file is not
          native, the returned string is the result of `g_file_get_uri`
          (such as `sftp://path/to/my20icon.png`).

        - If `icon` is a GThemedIcon with exactly one name and no fallbacks,
          the encoding is simply the name (such as `network-server`).
        """

class IconIface(GObject.GPointer):
    """
    GIconIface is used to implement GIcon types for various
    different systems. See GThemedIcon and GLoadableIcon for
    examples of how to implement this interface.
    """

    # gi Fields
    @builtins.property
    def equal(self) -> equalIconIfaceCB:
        """
        Checks if two GIcons are equal.
        """
    @builtins.property
    def from_tokens(self) -> object | None:
        """
            Constructs a GIcon from tokens. Set the GError if
        the tokens are malformed. Don't implement if the GIcon can't be
        serialized (Since 2.20).
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def hash(self) -> hashIconIfaceCB:
        """
        A hash for a given GIcon.
        """
    @builtins.property
    def serialize(self) -> serializeIconIfaceCB | None:
        """
        Serializes a GIcon into a GVariant. Since: 2.38
        """
    @builtins.property
    def to_tokens(self) -> to_tokensIconIfaceCB:
        """
            Serializes a GIcon into tokens. The tokens must not
        contain any whitespace. Don't implement if the GIcon can't be
        serialized (Since 2.20).
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InetAddress(GObject.Object):
    """
    `GInetAddress` represents an IPv4 or IPv6 internet address. Use
    [method`Gio`.Resolver.lookup_by_name] or
    [method`Gio`.Resolver.lookup_by_name_async] to look up the `GInetAddress` for
    a hostname. Use [method`Gio`.Resolver.lookup_by_address] or
    [method`Gio`.Resolver.lookup_by_address_async] to look up the hostname for a
    `GInetAddress`.

    To actually connect to a remote host, you will need a
    [class`Gio`.InetSocketAddress] (which includes a `GInetAddress` as well as a
    port number).
    """

    class Props(GObject.Object.Props):
        bytes: object | None
        """
        The raw address data.
        """
        family: SocketFamily
        """
        The address family (IPv4 or IPv6).
        """
        is_any: bool  # [is-any]: changed because contained invalid characters
        """
        Whether this is the "any" address for its family.
        See `g_inet_address_get_is_any`.
        """
        is_link_local: bool  # [is-link-local]: changed because contained invalid characters
        """
        Whether this is a link-local address.
        See `g_inet_address_get_is_link_local`.
        """
        is_loopback: bool  # [is-loopback]: changed because contained invalid characters
        """
        Whether this is the loopback address for its family.
        See `g_inet_address_get_is_loopback`.
        """
        is_mc_global: bool  # [is-mc-global]: changed because contained invalid characters
        """
        Whether this is a global multicast address.
        See `g_inet_address_get_is_mc_global`.
        """
        is_mc_link_local: bool  # [is-mc-link-local]: changed because contained invalid characters
        """
        Whether this is a link-local multicast address.
        See `g_inet_address_get_is_mc_link_local`.
        """
        is_mc_node_local: bool  # [is-mc-node-local]: changed because contained invalid characters
        """
        Whether this is a node-local multicast address.
        See `g_inet_address_get_is_mc_node_local`.
        """
        is_mc_org_local: bool  # [is-mc-org-local]: changed because contained invalid characters
        """
        Whether this is an organization-local multicast address.
        See `g_inet_address_get_is_mc_org_local`.
        """
        is_mc_site_local: bool  # [is-mc-site-local]: changed because contained invalid characters
        """
        Whether this is a site-local multicast address.
        See `g_inet_address_get_is_mc_site_local`.
        """
        is_multicast: bool  # [is-multicast]: changed because contained invalid characters
        """
        Whether this is a multicast address.
        See `g_inet_address_get_is_multicast`.
        """
        is_site_local: bool  # [is-site-local]: changed because contained invalid characters
        """
        Whether this is a site-local address.
        See `g_inet_address_get_is_loopback`.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> InetAddressPrivate | None: ...

    # gi Methods
    def __init__(self, bytes: object | None = ..., family: SocketFamily = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def equal(self, other_address: InetAddress) -> bool:
        """
        Checks if two GInetAddress instances are equal, e.g. the same address.
        """
    @builtins.property
    def get_family(self) -> SocketFamily:
        """
        Gets `address`'s family
        """
    @builtins.property
    def get_is_any(self) -> bool:
        """
        Tests whether `address` is the "any" address for its family.
        """
    @builtins.property
    def get_is_link_local(self) -> bool:
        """
            Tests whether `address` is a link-local address (that is, if it
        identifies a host on a local network that is not connected to the
        Internet).
        """
    @builtins.property
    def get_is_loopback(self) -> bool:
        """
        Tests whether `address` is the loopback address for its family.
        """
    @builtins.property
    def get_is_mc_global(self) -> bool:
        """
        Tests whether `address` is a global multicast address.
        """
    @builtins.property
    def get_is_mc_link_local(self) -> bool:
        """
        Tests whether `address` is a link-local multicast address.
        """
    @builtins.property
    def get_is_mc_node_local(self) -> bool:
        """
        Tests whether `address` is a node-local multicast address.
        """
    @builtins.property
    def get_is_mc_org_local(self) -> bool:
        """
        Tests whether `address` is an organization-local multicast address.
        """
    @builtins.property
    def get_is_mc_site_local(self) -> bool:
        """
        Tests whether `address` is a site-local multicast address.
        """
    @builtins.property
    def get_is_multicast(self) -> bool:
        """
        Tests whether `address` is a multicast address.
        """
    @builtins.property
    def get_is_site_local(self) -> bool:
        """
            Tests whether `address` is a site-local address such as 10.0.0.1
        (that is, the address identifies a host on a local network that can
        not be reached directly from the Internet, but which may have
        outgoing Internet connectivity via a NAT or firewall).
        """
    def get_native_size(self) -> int:
        """
            Gets the size of the native raw binary address for `address`. This
        is the size of the data that you get from `g_inet_address_to_bytes`.
        """
    @classmethod
    def new_any(cls, family: SocketFamily) -> InetAddress:
        """
            Creates a GInetAddress for the "any" address (unassigned/"don't
        care") for `family`.
        """
    @classmethod
    def new_from_bytes(cls, bytes: list, family: SocketFamily) -> InetAddress:
        """
            Creates a new GInetAddress from the given `family` and `bytes`.
        `bytes` should be 4 bytes for G_SOCKET_FAMILY_IPV4 and 16 bytes for
        G_SOCKET_FAMILY_IPV6.
        """
    @classmethod
    def new_from_string(cls, string: str) -> InetAddress | None:
        """
        Parses `string` as an IP address and creates a new GInetAddress.
        """
    @classmethod
    def new_loopback(cls, family: SocketFamily) -> InetAddress:
        """
        Creates a GInetAddress for the loopback address for `family`.
        """
    def to_string(self) -> str:
        """
        Converts `address` to string form.
        """

    # python methods (overrides?)
    def do_to_string(
        self,
    ) -> str:
        """
        to_string(self) -> str
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::bytes"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_any"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_link_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_loopback"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_global"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_link_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_node_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_org_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_mc_site_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_multicast"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_site_local"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class InetAddressClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def to_bytes(self) -> to_bytesInetAddressClassCB: ...
    @builtins.property
    def to_string(self) -> to_stringInetAddressClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InetAddressMask(GObject.Object):
    """
    `GInetAddressMask` represents a range of IPv4 or IPv6 addresses
    described by a base address and a length indicating how many bits
    of the base address are relevant for matching purposes. These are
    often given in string form. For example, `10.0.0.0/8`, or `fe80::/10`.
    """

    class Props(GObject.Object.Props):
        address: InetAddress | None
        """
        The base address.
        """
        family: SocketFamily
        """
        The address family (IPv4 or IPv6).
        """
        length: int
        """
        The prefix length, in bytes.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> InetAddressMaskPrivate | None: ...

    # gi Methods
    def __init__(self, address: InetAddress | None = ..., length: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def equal(self, mask2: InetAddressMask) -> bool:
        """
        Tests if `mask` and `mask2` are the same mask.
        """
    @builtins.property
    def get_address(self) -> InetAddress:
        """
        Gets `mask`'s base address
        """
    @builtins.property
    def get_family(self) -> SocketFamily:
        """
        Gets the GSocketFamily of `mask`'s address
        """
    @builtins.property
    def get_length(self) -> int:
        """
        Gets `mask`'s length
        """
    def matches(self, address: InetAddress) -> bool:
        """
        Tests if `address` falls within the range described by `mask`.
        """
    @classmethod
    def new(cls, addr: InetAddress, length: int) -> InetAddressMask:
        """
            Creates a new GInetAddressMask representing all addresses whose
        first `length` bits match `addr`.
        """
    @classmethod
    def new_from_string(cls, mask_string: str) -> InetAddressMask:
        """
            Parses `mask_string` as an IP address and (optional) length, and
        creates a new GInetAddressMask. The length, if present, is
        delimited by a "/". If it is not present, then the length is
        assumed to be the full length of the address.
        """
    def to_string(self) -> str:
        """
        Converts `mask` back to its corresponding string form.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::length"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class InetAddressMaskClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InetAddressMaskPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InetAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InetSocketAddress(SocketAddress):
    """
    An IPv4 or IPv6 socket address. That is, the combination of a
    [class`Gio`.InetAddress] and a port number.

    In UNIX terms, `GInetSocketAddress` corresponds to a
    [`struct sockaddr_in` or `struct sockaddr_in6`](man:sockaddr(3type)).
    """

    class Props(SocketAddress.Props):
        address: InetAddress | None
        """
        The address.
        """
        flowinfo: int
        """
        The `sin6_flowinfo` field, for IPv6 addresses.
        """
        port: int
        """
        The port.
        """
        scope_id: int  # [scope-id]: changed because contained invalid characters
        """
        The `sin6_scope_id` field, for IPv6 addresses.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> SocketAddress | None: ...
    @builtins.property
    def priv(self) -> InetSocketAddressPrivate | None: ...

    # gi Methods
    def __init__(
        self, address: InetAddress | None = ..., flowinfo: int = ..., port: int = ..., scope_id: int = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_address(self) -> InetAddress:
        """
        Gets `address`'s GInetAddress.
        """
    @builtins.property
    def get_flowinfo(self) -> int:
        """
            Gets the `sin6_flowinfo` field from `address`,
        which must be an IPv6 address.
        """
    @builtins.property
    def get_port(self) -> int:
        """
        Gets `address`'s port.
        """
    @builtins.property
    def get_scope_id(self) -> int:
        """
            Gets the `sin6_scope_id` field from `address`,
        which must be an IPv6 address.
        """
    @classmethod
    def new(cls, address: InetAddress, port: int) -> InetSocketAddress:
        """
        Creates a new GInetSocketAddress for `address` and `port`.
        """
    @classmethod
    def new_from_string(cls, address: str, port: int) -> InetSocketAddress | None:
        """
            Creates a new GInetSocketAddress for `address` and `port`.

        If `address` is an IPv6 address, it can also contain a scope ID
        (separated from the address by a `%`).
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flowinfo"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::port"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scope_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class InetSocketAddressClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SocketAddressClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InetSocketAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Initable(GObject.GInterface):
    """
    `GInitable` is implemented by objects that can fail during
    initialization. If an object implements this interface then
    it must be initialized as the first thing after construction,
    either via [method`Gio`.Initable.init] or [method`Gio`.AsyncInitable.init_async]
    (the latter is only available if it also implements [iface`Gio`.AsyncInitable]).

    If the object is not initialized, or initialization returns with an
    error, then all operations on the object except ``g_object_ref`` and
    ``g_object_unref`` are considered to be invalid, and have undefined
    behaviour. They will often fail with [func`GLib`.critical] or
    [func`GLib`.warning], but this must not be relied on.

    Users of objects implementing this are not intended to use
    the interface method directly, instead it will be used automatically
    in various ways. For C applications you generally just call
    [func`Gio`.Initable.new] directly, or indirectly via a ``foo_thing_new`` wrapper.
    This will call [method`Gio`.Initable.init] under the cover, returning `None`
    and setting a `GError` on failure (at which point the instance is
    unreferenced).

    For bindings in languages where the native constructor supports
    exceptions the binding could check for objects implementing `GInitable`
    during normal construction and automatically initialize them, throwing
    an exception on failure.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def init(self, cancellable: Cancellable | None = None) -> bool:
        """
            Initializes the object implementing the interface.

        This method is intended for language bindings. If writing in C,
        `g_initable_new` should typically be used instead.

        The object must be initialized before any real use after initial
        construction, either with this function or `g_async_initable_init_async`.

        Implementations may also support cancellation. If `cancellable` is not None,
        then initialization can be cancelled by triggering the cancellable object
        from another thread. If the operation was cancelled, the error
        G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not None and
        the object doesn't support cancellable initialization the error
        G_IO_ERROR_NOT_SUPPORTED will be returned.

        If the object is not initialized, or initialization returns with an
        error, then all operations on the object except `g_object_ref` and
        `g_object_unref` are considered to be invalid, and have undefined
        behaviour. See the [description][iface`Gio`.Initable#description] for more details.

        Callers should not assume that a class which implements GInitable can be
        initialized multiple times, unless the class explicitly documents itself as
        supporting this. Generally, a class’ implementation of `init` can assume
        (and assert) that it will only be called once. Previously, this documentation
        recommended all GInitable implementations should be idempotent; that
        recommendation was relaxed in GLib 2.54.

        If a class explicitly supports being initialized multiple times, it is
        recommended that the method is idempotent: multiple calls with the same
        arguments should return the same results. Only the first call initializes
        the object; further calls return the result of the first call.

        One reason why a class might need to support idempotent initialization is if
        it is designed to be used via the singleton pattern, with a
        GObjectClass.constructor that sometimes returns an existing instance.
        In this pattern, a caller would expect to be able to call `g_initable_init`
        on the result of `g_object_new`, regardless of whether it is in fact a new
        instance.
        """
    @deprecated("deprecated")
    @staticmethod
    def newv(
        object_type: GObject.GType, n_parameters: int, parameters: list, cancellable: Cancellable | None = None
    ) -> GObject.Object:
        """
            Helper function for constructing GInitable object. This is
        similar to `g_object_newv` but also initializes the object
        and returns None, setting an error on failure.
        """

class InitableIface(GObject.GPointer):
    """
    Provides an interface for initializing object such that initialization
    may fail.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def init(self) -> initInitableIfaceCB:
        """
        Initializes the object.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InputMessage(GObject.GPointer):
    """
    Structure used for scatter/gather data input when receiving multiple
    messages or packets in one go. You generally pass in an array of empty
    GInputVectors and the operation will use all the buffers as if they
    were one buffer, and will set `bytes_received` to the total number of bytes
    received across all GInputVectors.

    This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
    the POSIX sockets API (see `man 2 recvmmsg`).

    If `address` is non-None then it is set to the source address the message
    was received from, and the caller must free it afterwards.

    If `control_messages` is non-None then it is set to an array of control
    messages received with the message (if any), and the caller must free it
    afterwards. `num_control_messages` is set to the number of elements in
    this array, which may be zero.

    Flags relevant to this message will be returned in `flags`. For example,
    `MSG_EOR` or `MSG_TRUNC`.
    """

    # gi Fields
    address: SocketAddress | None = ...
    """
    return location
      for a GSocketAddress, or None

    """
    bytes_received: int = ...
    """
    will be set to the number of bytes that have been
      received

    """
    control_messages: list | None = ...
    """
    return location for a
      caller-allocated array of GSocketControlMessages, or None

    """
    flags: int = ...
    """
    collection of GSocketMsgFlags for the received message,
      outputted by the call

    """
    num_control_messages: int = ...
    """
    return location for the number of
      elements in `control_messages`

    """
    num_vectors: int = ...
    """
    the number of input vectors pointed to by `vectors`

    """
    vectors: list | None = ...
    """
    pointer to an
      array of input vectors

    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InputStream(GObject.Object):
    """
    `GInputStream` is a base class for implementing streaming input.

    It has functions to read from a stream ([method`Gio`.InputStream.read]),
    to close a stream ([method`Gio`.InputStream.close]) and to skip some content
    ([method`Gio`.InputStream.skip]).

    To copy the content of an input stream to an output stream without
    manually handling the reads and writes, use [method`Gio`.OutputStream.splice].

    See the documentation for [class`Gio`.IOStream] for details of thread safety
    of streaming APIs.

    All of these functions have async variants too.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> InputStreamPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear_pending(self) -> None:
        """
        Clears the pending flag on `stream`.
        """
    def close(self, cancellable: Cancellable | None = None) -> bool:
        """
            Closes the stream, releasing resources related to it.

        Once the stream is closed, all other operations will return G_IO_ERROR_CLOSED.
        Closing a stream multiple times will not return an error.

        Streams will be automatically closed when the last reference
        is dropped, but you might want to call this function to make sure
        resources are released as early as possible.

        Some streams might keep the backing store of the stream (e.g. a file descriptor)
        open after the stream is closed. See the documentation for the individual
        stream for details.

        On failure the first error that happened will be reported, but the close
        operation will finish as much as possible. A stream that failed to
        close will still return G_IO_ERROR_CLOSED for all operations. Still, it
        is important to check and report the error to the user.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        Cancelling a close will still leave the stream closed, but some streams
        can use a faster close that doesn't block to e.g. check errors.
        """
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Requests an asynchronous closes of the stream, releasing resources related to it.
        When the operation is finished `callback` will be called.
        You can then call `g_input_stream_close_finish` to get the result of the
        operation.

        For behaviour details see `g_input_stream_close`.

        The asynchronous methods have a default fallback that uses threads to implement
        asynchronicity, so they are optional for inheriting classes. However, if you
        override one you must override all.
        """
    def close_finish(self, result: AsyncResult) -> bool:
        """
        Finishes closing a stream asynchronously, started from `g_input_stream_close_async`.
        """
    def has_pending(self) -> bool:
        """
        Checks if an input stream has pending actions.
        """
    def is_closed(self) -> bool:
        """
        Checks if an input stream is closed.
        """
    def read(self, count: int, cancellable: Cancellable | None = None) -> tuple[int, list]:
        """
            Tries to read `count` bytes from the stream into the buffer starting at
        `buffer`. Will block during this read.

        If count is zero returns zero and does nothing. A value of `count`
        larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.

        On success, the number of bytes read into the buffer is returned.
        It is not an error if this is not the same as the requested size, as it
        can happen e.g. near the end of a file. Zero is returned on end of file
        (or if `count` is zero),  but never otherwise.

        The returned `buffer` is not a nul-terminated string, it can contain nul bytes
        at any position, and this function doesn't nul-terminate the `buffer`.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
        operation was partially finished when the operation was cancelled the
        partial result will be returned, without an error.

        On error -1 is returned and `error` is set accordingly.
        """
    def read_all(self, count: int, cancellable: Cancellable | None = None) -> tuple[bool, list, int]:
        """
            Tries to read `count` bytes from the stream into the buffer starting at
        `buffer`. Will block during this read.

        This function is similar to `g_input_stream_read`, except it tries to
        read as many bytes as requested, only stopping on an error or end of stream.

        On a successful read of `count` bytes, or if we reached the end of the
        stream,  True is returned, and `bytes_read` is set to the number of bytes
        read into `buffer`.

        If there is an error during the operation False is returned and `error`
        is set to indicate the error status.

        As a special exception to the normal conventions for functions that
        use GError, if this function returns False (and sets `error`) then
        `bytes_read` will be set to the number of bytes that were successfully
        read before the error was encountered.  This functionality is only
        available from C.  If you need it from another language then you must
        write your own loop around `g_input_stream_read`.
        """
    async def read_all_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> list:
        """
            Request an asynchronous read of `count` bytes from the stream into the
        buffer starting at `buffer`.

        This is the asynchronous equivalent of [method`InputStream`.read_all].

        Call [method`InputStream`.read_all_finish] to collect the result.

        Any outstanding I/O request with higher priority (lower numerical
        value) will be executed before an outstanding request with lower
        priority. Default priority is G_PRIORITY_DEFAULT.
        """
    def read_all_finish(self, result: AsyncResult) -> tuple[bool, int]:
        """
            Finishes an asynchronous stream read operation started with
        [method`InputStream`.read_all_async].

        As a special exception to the normal conventions for functions that
        use GError, if this function returns False (and sets `error`) then
        `bytes_read` will be set to the number of bytes that were successfully
        read before the error was encountered.  This functionality is only
        available from C.  If you need it from another language then you must
        write your own loop around `g_input_stream_read_async`.
        """
    async def read_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> list:
        """
            Request an asynchronous read of `count` bytes from the stream into the buffer
        starting at `buffer`. When the operation is finished `callback` will be called.
        You can then call `g_input_stream_read_finish` to get the result of the
        operation.

        During an async request no other sync and async calls are allowed on `stream`, and will
        result in G_IO_ERROR_PENDING errors.

        A value of `count` larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.

        On success, the number of bytes read into the buffer will be passed to the
        callback. It is not an error if this is not the same as the requested size, as it
        can happen e.g. near the end of a file, but generally we try to read
        as many bytes as requested. Zero is returned on end of file
        (or if `count` is zero),  but never otherwise.

        Any outstanding i/o request with higher priority (lower numerical value) will
        be executed before an outstanding request with lower priority. Default
        priority is G_PRIORITY_DEFAULT.

        The asynchronous methods have a default fallback that uses threads to implement
        asynchronicity, so they are optional for inheriting classes. However, if you
        override one you must override all.
        """
    def read_bytes(self, count: int, cancellable: Cancellable | None = None) -> GLib.Bytes:
        """
            Like `g_input_stream_read`, this tries to read `count` bytes from
        the stream in a blocking fashion. However, rather than reading into
        a user-supplied buffer, this will create a new GBytes containing
        the data that was read. This may be easier to use from language
        bindings.

        If count is zero, returns a zero-length GBytes and does nothing. A
        value of `count` larger than G_MAXSSIZE will cause a
        G_IO_ERROR_INVALID_ARGUMENT error.

        On success, a new GBytes is returned. It is not an error if the
        size of this object is not the same as the requested size, as it
        can happen e.g. near the end of a file. A zero-length GBytes is
        returned on end of file (or if `count` is zero), but never
        otherwise.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
        operation was partially finished when the operation was cancelled the
        partial result will be returned, without an error.

        On error None is returned and `error` is set accordingly.
        """
    async def read_bytes_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Request an asynchronous read of `count` bytes from the stream into a
        new GBytes. When the operation is finished `callback` will be
        called. You can then call `g_input_stream_read_bytes_finish` to get the
        result of the operation.

        During an async request no other sync and async calls are allowed
        on `stream`, and will result in G_IO_ERROR_PENDING errors.

        A value of `count` larger than G_MAXSSIZE will cause a
        G_IO_ERROR_INVALID_ARGUMENT error.

        On success, the new GBytes will be passed to the callback. It is
        not an error if this is smaller than the requested size, as it can
        happen e.g. near the end of a file, but generally we try to read as
        many bytes as requested. Zero is returned on end of file (or if
        `count` is zero), but never otherwise.

        Any outstanding I/O request with higher priority (lower numerical
        value) will be executed before an outstanding request with lower
        priority. Default priority is G_PRIORITY_DEFAULT.
        """
    def read_bytes_finish(self, result: AsyncResult) -> GLib.Bytes:
        """
        Finishes an asynchronous stream read-into-GBytes operation.
        """
    def read_finish(self, result: AsyncResult) -> int:
        """
        Finishes an asynchronous stream read operation.
        """
    def set_pending(self) -> bool:
        """
            Sets `stream` to have actions pending. If the pending flag is
        already set or `stream` is closed, it will return False and set
        `error`.
        """
    def skip(self, count: int, cancellable: Cancellable | None = None) -> int:
        """
            Tries to skip `count` bytes from the stream. Will block during the operation.

        This is identical to `g_input_stream_read`, from a behaviour standpoint,
        but the bytes that are skipped are not returned to the user. Some
        streams have an implementation that is more efficient than reading the data.

        This function is optional for inherited classes, as the default implementation
        emulates it using read.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
        operation was partially finished when the operation was cancelled the
        partial result will be returned, without an error.
        """
    async def skip_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Request an asynchronous skip of `count` bytes from the stream.
        When the operation is finished `callback` will be called.
        You can then call `g_input_stream_skip_finish` to get the result
        of the operation.

        During an async request no other sync and async calls are allowed,
        and will result in G_IO_ERROR_PENDING errors.

        A value of `count` larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.

        On success, the number of bytes skipped will be passed to the callback.
        It is not an error if this is not the same as the requested size, as it
        can happen e.g. near the end of a file, but generally we try to skip
        as many bytes as requested. Zero is returned on end of file
        (or if `count` is zero), but never otherwise.

        Any outstanding i/o request with higher priority (lower numerical value)
        will be executed before an outstanding request with lower priority.
        Default priority is G_PRIORITY_DEFAULT.

        The asynchronous methods have a default fallback that uses threads to
        implement asynchronicity, so they are optional for inheriting classes.
        However, if you override one, you must override all.
        """
    def skip_finish(self, result: AsyncResult) -> int:
        """
        Finishes a stream skip operation.
        """

    # python methods (overrides?)
    def do_close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        close_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_close_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        close_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_close_fn(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        close_fn(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_read_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> list | None:
        """
        read_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None) -> buffer:list
        """
    def do_read_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        read_finish(self, result:Gio.AsyncResult) -> int
        """
    def do_read_fn(
        self,
        buffer: typing.Any,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        read_fn(self, buffer=None, count:int, cancellable:Gio.Cancellable=None) -> int
        """
    def do_skip(
        self,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        skip(self, count:int, cancellable:Gio.Cancellable=None) -> int
        """
    def do_skip_async(
        self,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        skip_async(self, count:int, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_skip_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        skip_finish(self, result:Gio.AsyncResult) -> int
        """

class InputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def close_async(self) -> close_asyncInputStreamClassCB: ...
    @builtins.property
    def close_finish(self) -> close_finishInputStreamClassCB: ...
    @builtins.property
    def close_fn(self) -> close_fnInputStreamClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def read_async(self) -> read_asyncInputStreamClassCB: ...
    @builtins.property
    def read_finish(self) -> read_finishInputStreamClassCB: ...
    @builtins.property
    def read_fn(self) -> read_fnInputStreamClassCB: ...
    @builtins.property
    def skip(self) -> skipInputStreamClassCB: ...
    @builtins.property
    def skip_async(self) -> skip_asyncInputStreamClassCB: ...
    @builtins.property
    def skip_finish(self) -> skip_finishInputStreamClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class InputVector(GObject.GPointer):
    """
    Structure used for scatter/gather data input.
    You generally pass in an array of GInputVectors
    and the operation will store the read data starting in the
    first buffer, switching to the next as needed.
    """

    # gi Fields
    buffer: object | None = ...
    """
    Pointer to a buffer where data will be written.

    """
    size: int = ...
    """
    the available size in `buffer`.

    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListModel(GObject.GInterface):
    """
    `GListModel` is an interface that represents a mutable list of
    [class`GObject`.Object]. Its main intention is as a model for various widgets
    in user interfaces, such as list views, but it can also be used as a
    convenient method of returning lists of data, with support for
    updates.

    Each object in the list may also report changes in itself via some
    mechanism (normally the [signal`GObject`.Object::notify] signal).  Taken
    together with the [signal`Gio`.ListModel::items-changed] signal, this provides
    for a list that can change its membership, and in which the members can
    change their individual properties.

    A good example would be the list of visible wireless network access
    points, where each access point can report dynamic properties such as
    signal strength.

    It is important to note that the `GListModel` itself does not report
    changes to the individual items.  It only reports changes to the list
    membership.  If you want to observe changes to the objects themselves
    then you need to connect signals to the objects that you are
    interested in.

    All items in a `GListModel` are of (or derived from) the same type.
    [method`Gio`.ListModel.get_item_type] returns that type.  The type may be an
    interface, in which case all objects in the list must implement it.

    The semantics are close to that of an array:
    [method`Gio`.ListModel.get_n_items] returns the number of items in the list
    and [method`Gio`.ListModel.get_item] returns an item at a (0-based) position.
    In order to allow implementations to calculate the list length lazily,
    you can also iterate over items: starting from 0, repeatedly call
    [method`Gio`.ListModel.get_item] until it returns `None`.

    An implementation may create objects lazily, but must take care to
    return the same object for a given position until all references to
    it are gone.

    On the other side, a consumer is expected only to hold references on
    objects that are currently ‘user visible’, in order to facilitate the
    maximum level of laziness in the implementation of the list and to
    reduce the required number of signal connections at a given time.

    This interface is intended only to be used from a single thread.  The
    thread in which it is appropriate to use it depends on the particular
    implementation, but typically it will be from the thread that owns
    the thread-default main context (see
    [method`GLib`.MainContext.push_thread_default]) in effect at the time that the
    model was created.

    Over time, it has established itself as good practice for list model
    implementations to provide properties `item-type` and `n-items` to
    ease working with them. While it is not required, it is recommended
    that implementations provide these two properties. They should return
    the values of [method`Gio`.ListModel.get_item_type] and
    [method`Gio`.ListModel.get_n_items] respectively and be defined as such:

    ```c
    properties[PROP_ITEM_TYPE] =
      g_param_spec_gtype ("item-type", None, None, G_TYPE_OBJECT,
                          G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
    properties[PROP_N_ITEMS] =
      g_param_spec_uint ("n-items", None, None, 0, G_MAXUINT, 0,
                         G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_item(self, position: int) -> GObject.Object | None:
        """
            Get the item at `position`.

        If `position` is greater than the number of items in `list`, None is
        returned.

        None is never returned for an index that is smaller than the length
        of the list.

        See also: `g_list_model_get_n_items`
        """
    def get_item_type(self) -> GObject.GType:
        """
            Gets the type of the items in `list`.

        All items returned from `g_list_model_get_item` are of the type
        returned by this function, or a subtype, or if the type is an
        interface, they are an implementation of that interface.

        The item type of a GListModel can not change during the life of the
        model.
        """
    def get_n_items(self) -> int:
        """
            Gets the number of items in `list`.

        Depending on the model implementation, calling this function may be
        less efficient than iterating the list with increasing values for
        `position` until `g_list_model_get_item` returns None.
        """
    def items_changed(self, position: int, removed: int, added: int) -> None:
        """
            Emits the GListModel::items-changed signal on `list`.

        This function should only be called by classes implementing
        GListModel. It has to be called after the internal representation
        of `list` has been updated, because handlers connected to this signal
        might query the new state of the list.

        Implementations must only make changes to the model (as visible to
        its consumer) in places that will not cause problems for that
        consumer.  For models that are driven directly by a write API (such
        as GListStore), changes can be reported in response to uses of that
        API.  For models that represent remote data, changes should only be
        made from a fresh mainloop dispatch.  It is particularly not
        permitted to make changes in response to a call to the GListModel
        consumer API.

        Stated another way: in general, it is assumed that code making a
        series of accesses to the model via the API, without returning to the
        mainloop, and without calling other code, will continue to view the
        same contents of the model.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["items-changed"],
        handler: typing.Callable[[typing_extensions.Self, int, int, int], None],
        *args: typing.Any,
    ) -> int:
        """
            This signal is emitted whenever items were added to or removed
        from `list`. At `position`, `removed` items were removed and `added`
        items were added in their place.

        Note: If `removed != added`, the positions of all later items
        in the model change.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ListModelInterface(GObject.GPointer):
    """
    The virtual function table for GListModel.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        parent GTypeInterface
        """
    @builtins.property
    def get_item(self) -> get_itemListModelInterfaceCB | None:
        """
        the virtual function pointer for `g_list_model_get_item`
        """
    @builtins.property
    def get_item_type(self) -> get_item_typeListModelInterfaceCB:
        """
        the virtual function pointer for `g_list_model_get_item_type`
        """
    @builtins.property
    def get_n_items(self) -> get_n_itemsListModelInterfaceCB:
        """
        the virtual function pointer for `g_list_model_get_n_items`
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ListStore(GObject.Object):
    """
    `GListStore` is a simple implementation of [iface`Gio`.ListModel] that stores
    all items in memory.

    It provides insertions, deletions, and lookups in logarithmic time
    with a fast path for the common case of iterating the list linearly.
    """

    class Props(GObject.Object.Props):
        item_type: GObject.GType  # [item-type]: changed because contained invalid characters
        """
        The type of items contained in this list store. Items must be
        subclasses of GObject.
        """
        n_items: int  # [n-items]: changed because contained invalid characters
        """
        The number of items contained in this list store.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, item_type: GObject.GType = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, item: GObject.Object) -> None:
        """
            Appends `item` to `store`. `item` must be of type GListStore:item-type.

        This function takes a ref on `item`.

        Use `g_list_store_splice` to append multiple items at the same time
        efficiently.
        """
    def find(self, item: GObject.Object) -> tuple[bool, int]:
        """
            Looks up the given `item` in the list store by looping over the items until
        the first occurrence of `item`. If `item` was not found, then `position` will
        not be set, and this method will return False.

        If you need to compare the two items with a custom comparison function, use
        `g_list_store_find_with_equal_func` with a custom GEqualFunc instead.
        """
    def find_with_equal_func(self, item: GObject.Object | None, equal_func: GLib.EqualFunc) -> tuple[bool, int]:
        """
            Looks up the given `item` in the list store by looping over the items and
        comparing them with `equal_func` until the first occurrence of `item` which
        matches. If `item` was not found, then `position` will not be set, and this
        method will return False.

        `item` is always passed as second parameter to `equal_func`.

        Since GLib 2.76 it is possible to pass `None` for `item`.
        """
    def find_with_equal_func_full(
        self, item: GObject.Object | None, equal_func: GLib.EqualFuncFull, *user_data: object | None
    ) -> tuple[bool, int]:
        """
            Like `g_list_store_find_with_equal_func` but with an additional `user_data`
        that is passed to `equal_func`.

        `item` is always passed as second parameter to `equal_func`.

        Since GLib 2.76 it is possible to pass `None` for `item`.
        """
    def insert(self, position: int, item: GObject.Object) -> None:
        """
            Inserts `item` into `store` at `position`. `item` must be of type
        GListStore:item-type or derived from it. `position` must be smaller
        than the length of the list, or equal to it to append.

        This function takes a ref on `item`.

        Use `g_list_store_splice` to insert multiple items at the same time
        efficiently.
        """
    def insert_sorted(self, item: GObject.Object, compare_func: GLib.CompareDataFunc, *user_data: object | None) -> int:
        """
            Inserts `item` into `store` at a position to be determined by the
        `compare_func`.

        The list must already be sorted before calling this function or the
        result is undefined.  Usually you would approach this by only ever
        inserting items by way of this function.

        This function takes a ref on `item`.
        """
    @classmethod
    def new(cls, item_type: GObject.GType) -> ListStore:
        """
            Creates a new GListStore with items of type `item_type`. `item_type`
        must be a subclass of GObject.
        """
    def remove(self, position: int) -> None:
        """
            Removes the item from `store` that is at `position`. `position` must be
        smaller than the current length of the list.

        Use `g_list_store_splice` to remove multiple items at the same time
        efficiently.
        """
    def remove_all(self) -> None:
        """
        Removes all items from `store`.
        """
    def sort(self, compare_func: GLib.CompareDataFunc, *user_data: object | None) -> None:
        """
        Sort the items in `store` according to `compare_func`.
        """
    def splice(self, position: int, n_removals: int, additions: list, n_additions: int) -> None:
        """
            Changes `store` by removing `n_removals` items and adding `n_additions`
        items to it. `additions` must contain `n_additions` items of type
        GListStore:item-type.  None is not permitted.

        This function is more efficient than `g_list_store_insert` and
        `g_list_store_remove`, because it only emits
        GListModel::items-changed once for the change.

        This function takes a ref on each item in `additions`.

        The parameters `position` and `n_removals` must be correct (ie:
        `position` + `n_removals` must be less than or equal to the length of
        the list at the time this function is called).
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::item_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::n_items"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ListStoreClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class LoadableIcon(GObject.GInterface):
    """
    `GLoadableIcon` extends the [iface`Gio`.Icon] interface and adds the ability
    to load icons from streams.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def load(self, size: int, cancellable: Cancellable | None = None) -> tuple[InputStream, str]:
        """
            Loads a loadable icon. For the asynchronous version of this function,
        see `g_loadable_icon_load_async`.
        """
    async def load_async(
        self,
        size: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Loads an icon asynchronously. To finish this function, see
        `g_loadable_icon_load_finish`. For the synchronous, blocking
        version of this function, see `g_loadable_icon_load`.
        """
    def load_finish(self, res: AsyncResult) -> tuple[InputStream, str]:
        """
        Finishes an asynchronous icon load started in `g_loadable_icon_load_async`.
        """

class LoadableIconIface(GObject.GPointer):
    """
    Interface for icons that can be loaded as a stream.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def load(self) -> loadLoadableIconIfaceCB:
        """
        Loads an icon.
        """
    @builtins.property
    def load_async(self) -> load_asyncLoadableIconIfaceCB:
        """
        Loads an icon asynchronously.
        """
    @builtins.property
    def load_finish(self) -> load_finishLoadableIconIfaceCB:
        """
        Finishes an asynchronous icon load.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MemoryInputStream(InputStream):
    """
    `GMemoryInputStream` is a class for using arbitrary
    memory chunks as input for GIO streaming input operations.

    As of GLib 2.34, `GMemoryInputStream` implements
    [iface`Gio`.PollableInputStream].
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> InputStream | None: ...
    @builtins.property
    def priv(self) -> MemoryInputStreamPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_bytes(self, bytes: GLib.Bytes) -> None:
        """
        Appends `bytes` to data that can be read from the input stream.
        """
    def add_data(self, data: list, len: int, destroy: GLib.DestroyNotify | None = None) -> None:
        """
        Appends `data` to data that can be read from the input stream
        """
    @classmethod
    def new(cls) -> MemoryInputStream:
        """
        Creates a new empty GMemoryInputStream.
        """
    @classmethod
    def new_from_bytes(cls, bytes: GLib.Bytes) -> MemoryInputStream:
        """
        Creates a new GMemoryInputStream with data from the given `bytes`.
        """
    @classmethod
    def new_from_data(cls, data: list, len: int, destroy: GLib.DestroyNotify | None = None) -> MemoryInputStream:
        """
        Creates a new GMemoryInputStream with data in memory of a given size.
        """

class MemoryInputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> InputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MemoryInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MemoryMonitor(GObject.GInterface):
    """
    `GMemoryMonitor` will monitor system memory and suggest to the application
    when to free memory so as to leave more room for other applications.
    It is implemented on Linux using the
    [Low Memory Monitor](https://gitlab.freedesktop.org/hadess/low-memory-monitor/)
    ([API documentation](https://hadess.pages.freedesktop.org/low-memory-monitor/)).

    There is also an implementation for use inside Flatpak sandboxes.

    Possible actions to take when the signal is received are:

     - Free caches
     - Save files that haven’t been looked at in a while to disk, ready to be reopened when needed
     - Run a garbage collection cycle
     - Try and compress fragmented allocations
     - Exit on idle if the process has no reason to stay around
     - Call [`malloc_trim(3)`](man:malloc_trim(3)) to return cached heap pages to
       the kernel (if supported by your libc)

    Note that some actions may not always improve system performance, and so
    should be profiled for your application. ``malloc_trim``, for example, may
    make future heap allocations slower (due to releasing cached heap pages back
    to the kernel).

    See [type`Gio`.MemoryMonitorWarningLevel] for details on the various warning
    levels.

    ```c
    static void
    warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
    {
      g_debug ("Warning level: %d", level);
      if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
        drop_caches ();
    }

    static GMemoryMonitor *
    monitor_low_memory (void)
    {
      GMemoryMonitor *m;
      m = g_memory_monitor_dup_default ();
      g_signal_connect (G_OBJECT (m), "low-memory-warning",
                        G_CALLBACK (warning_cb), None);
      return m;
    }
    ```

    Don’t forget to disconnect the [signal`Gio`.MemoryMonitor::low-memory-warning]
    signal, and unref the `GMemoryMonitor` itself when exiting.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def dup_default() -> MemoryMonitor:
        """
        Gets a reference to the default GMemoryMonitor for the system.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["low-memory-warning"],
        handler: typing.Callable[[typing_extensions.Self, MemoryMonitorWarningLevel], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when the system is running low on free memory. The signal
        handler should then take the appropriate action depending on the
        warning level. See the GMemoryMonitorWarningLevel documentation for
        details.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MemoryMonitorInterface(GObject.GPointer):
    """
    The virtual function table for GMemoryMonitor.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def low_memory_warning(self) -> low_memory_warningMemoryMonitorInterfaceCB:
        """
           the virtual function pointer for the
        GMemoryMonitor::low-memory-warning signal.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MemoryOutputStream(OutputStream):
    """
    `GMemoryOutputStream` is a class for using arbitrary
    memory chunks as output for GIO streaming output operations.

    As of GLib 2.34, `GMemoryOutputStream` trivially implements
    [iface`Gio`.PollableOutputStream]: it always polls as ready.
    """

    class Props(OutputStream.Props):
        data: object | None
        """
        Pointer to buffer where data will be written.
        """
        data_size: int  # [data-size]: changed because contained invalid characters
        """
        Size of data written to the buffer.
        """
        size: int
        """
        Current size of the data buffer.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> OutputStream | None: ...
    @builtins.property
    def priv(self) -> MemoryOutputStreamPrivate | None: ...

    # gi Methods
    def __init__(self, data: object | None = ..., size: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_data(self) -> object | None:
        """
            Gets any loaded data from the `ostream`.

        Note that the returned pointer may become invalid on the next
        write or truncate operation on the stream.
        """
    @builtins.property
    def get_data_size(self) -> int:
        """
            Returns the number of bytes from the start up to including the last
        byte written in the stream that has not been truncated away.
        """
    @builtins.property
    def get_size(self) -> int:
        """
            Gets the size of the currently allocated data area (available from
        `g_memory_output_stream_get_data`).

        You probably don't want to use this function on resizable streams.
        See `g_memory_output_stream_get_data_size` instead.  For resizable
        streams the size returned by this function is an implementation
        detail and may be change at any time in response to operations on the
        stream.

        If the stream is fixed-sized (ie: no realloc was passed to
        `g_memory_output_stream_new`) then this is the maximum size of the
        stream and further writes will return G_IO_ERROR_NO_SPACE.

        In any case, if you want the number of bytes currently written to the
        stream, use `g_memory_output_stream_get_data_size`.
        """
    @classmethod
    def new_resizable(cls) -> MemoryOutputStream:
        """
            Creates a new GMemoryOutputStream, using `g_realloc` and `g_free`
        for memory allocation.
        """
    def steal_as_bytes(self) -> GLib.Bytes:
        """
            Returns data from the `ostream` as a GBytes. `ostream` must be
        closed before calling this function.
        """
    def steal_data(self) -> object | None:
        """
            Gets any loaded data from the `ostream`. Ownership of the data
        is transferred to the caller; when no longer needed it must be
        freed using the free function set in `ostream`'s
        GMemoryOutputStream:destroy-function property.

        `ostream` must be closed before calling this function.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::data"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::data_size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::size"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MemoryOutputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> OutputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MemoryOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Menu(MenuModel):
    """
    `GMenu` is a simple implementation of [class`Gio`.MenuModel].
    You populate a `GMenu` by adding [class`Gio`.MenuItem] instances to it.

    There are some convenience functions to allow you to directly
    add items (avoiding [class`Gio`.MenuItem]) for the common cases. To add
    a regular item, use [method`Gio`.Menu.insert]. To add a section, use
    [method`Gio`.Menu.insert_section]. To add a submenu, use
    [method`Gio`.Menu.insert_submenu].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, label: str | None = None, detailed_action: str | None = None) -> None:
        """
            Convenience function for appending a normal menu item to the end of
        `menu`.  Combine `g_menu_item_new` and `g_menu_insert_item` for a more
        flexible alternative.
        """
    def append_item(self, item: MenuItem) -> None:
        """
            Appends `item` to the end of `menu`.

        See `g_menu_insert_item` for more information.
        """
    def append_section(self, label: str | None, section: MenuModel) -> None:
        """
            Convenience function for appending a section menu item to the end of
        `menu`.  Combine `g_menu_item_new_section` and `g_menu_insert_item` for a
        more flexible alternative.
        """
    def append_submenu(self, label: str | None, submenu: MenuModel) -> None:
        """
            Convenience function for appending a submenu menu item to the end of
        `menu`.  Combine `g_menu_item_new_submenu` and `g_menu_insert_item` for a
        more flexible alternative.
        """
    def freeze(self) -> None:
        """
            Marks `menu` as frozen.

        After the menu is frozen, it is an error to attempt to make any
        changes to it.  In effect this means that the GMenu API must no
        longer be used.

        This function causes `g_menu_model_is_mutable` to begin returning
        False, which has some positive performance implications.
        """
    def insert(self, position: int, label: str | None = None, detailed_action: str | None = None) -> None:
        """
            Convenience function for inserting a normal menu item into `menu`.
        Combine `g_menu_item_new` and `g_menu_insert_item` for a more flexible
        alternative.
        """
    def insert_item(self, position: int, item: MenuItem) -> None:
        """
            Inserts `item` into `menu`.

        The "insertion" is actually done by copying all of the attribute and
        link values of `item` and using them to form a new item within `menu`.
        As such, `item` itself is not really inserted, but rather, a menu item
        that is exactly the same as the one presently described by `item`.

        This means that `item` is essentially useless after the insertion
        occurs.  Any changes you make to it are ignored unless it is inserted
        again (at which point its updated values will be copied).

        You should probably just free `item` once you're done.

        There are many convenience functions to take care of common cases.
        See `g_menu_insert`, `g_menu_insert_section` and
        `g_menu_insert_submenu` as well as "prepend" and "append" variants of
        each of these functions.
        """
    def insert_section(self, position: int, label: str | None, section: MenuModel) -> None:
        """
            Convenience function for inserting a section menu item into `menu`.
        Combine `g_menu_item_new_section` and `g_menu_insert_item` for a more
        flexible alternative.
        """
    def insert_submenu(self, position: int, label: str | None, submenu: MenuModel) -> None:
        """
            Convenience function for inserting a submenu menu item into `menu`.
        Combine `g_menu_item_new_submenu` and `g_menu_insert_item` for a more
        flexible alternative.
        """
    @classmethod
    def new(cls) -> Menu:
        """
            Creates a new GMenu.

        The new menu has no items.
        """
    def prepend(self, label: str | None = None, detailed_action: str | None = None) -> None:
        """
            Convenience function for prepending a normal menu item to the start
        of `menu`.  Combine `g_menu_item_new` and `g_menu_insert_item` for a more
        flexible alternative.
        """
    def prepend_item(self, item: MenuItem) -> None:
        """
            Prepends `item` to the start of `menu`.

        See `g_menu_insert_item` for more information.
        """
    def prepend_section(self, label: str | None, section: MenuModel) -> None:
        """
            Convenience function for prepending a section menu item to the start
        of `menu`.  Combine `g_menu_item_new_section` and `g_menu_insert_item` for
        a more flexible alternative.
        """
    def prepend_submenu(self, label: str | None, submenu: MenuModel) -> None:
        """
            Convenience function for prepending a submenu menu item to the start
        of `menu`.  Combine `g_menu_item_new_submenu` and `g_menu_insert_item` for
        a more flexible alternative.
        """
    def remove(self, position: int) -> None:
        """
            Removes an item from the menu.

        `position` gives the index of the item to remove.

        It is an error if position is not in range the range from 0 to one
        less than the number of items in the menu.

        It is not possible to remove items by identity since items are added
        to the menu simply by copying their links and attributes (ie:
        identity of the item itself is not preserved).
        """
    def remove_all(self) -> None:
        """
        Removes all items in the menu.
        """

class MenuAttributeIter(GObject.Object):
    """
    GMenuAttributeIter is an opaque structure type.  You must access it
    using the functions below.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> MenuAttributeIterPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_name(self) -> str:
        """
            Gets the name of the attribute at the current iterator position, as
        a string.

        The iterator is not advanced.
        """
    def get_next(self) -> tuple[bool, str, GLib.Variant]:
        """
            This function combines `g_menu_attribute_iter_next` with
        `g_menu_attribute_iter_get_name` and `g_menu_attribute_iter_get_value`.

        First the iterator is advanced to the next (possibly first) attribute.
        If that fails, then False is returned and there are no other
        effects.

        If successful, `name` and `value` are set to the name and value of the
        attribute that has just been advanced to.  At this point,
        `g_menu_attribute_iter_get_name` and `g_menu_attribute_iter_get_value` will
        return the same values again.

        The value returned in `name` remains valid for as long as the iterator
        remains at the current position.  The value returned in `value` must
        be unreffed using `g_variant_unref` when it is no longer in use.
        """
    def get_value(self) -> GLib.Variant:
        """
            Gets the value of the attribute at the current iterator position.

        The iterator is not advanced.
        """
    def next(self) -> bool:
        """
            Attempts to advance the iterator to the next (possibly first)
        attribute.

        True is returned on success, or False if there are no more
        attributes.

        You must call this function when you first acquire the iterator
        to advance it to the first attribute (and determine if the first
        attribute exists at all).
        """

    # python methods (overrides?)
    def do_get_next(
        self,
    ) -> tuple:
        """
        get_next(self) -> bool, out_name:str, value:GLib.Variant
        """

class MenuAttributeIterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def get_next(self) -> get_nextMenuAttributeIterClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MenuAttributeIterPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MenuItem(GObject.Object):
    """
    GMenuItem is an opaque structure type.  You must access it using the
    functions below.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_attribute_value(self, attribute: str, expected_type: GLib.VariantType | None = None) -> GLib.Variant | None:
        """
            Queries the named `attribute` on `menu_item`.

        If `expected_type` is specified and the attribute does not have this
        type, None is returned.  None is also returned if the attribute
        simply does not exist.
        """
    def get_link(self, link: str) -> MenuModel | None:
        """
        Queries the named `link` on `menu_item`.
        """
    @classmethod
    def new(cls, label: str | None = None, detailed_action: str | None = None) -> MenuItem:
        """
            Creates a new GMenuItem.

        If `label` is non-None it is used to set the "label" attribute of the
        new item.

        If `detailed_action` is non-None it is used to set the "action" and
        possibly the "target" attribute of the new item.  See
        `g_menu_item_set_detailed_action` for more information.
        """
    @classmethod
    def new_from_model(cls, model: MenuModel, item_index: int) -> MenuItem:
        """
            Creates a GMenuItem as an exact copy of an existing menu item in a
        GMenuModel.

        `item_index` must be valid (ie: be sure to call
        `g_menu_model_get_n_items` first).
        """
    @classmethod
    def new_section(cls, label: str | None, section: MenuModel) -> MenuItem:
        """
            Creates a new GMenuItem representing a section.

        This is a convenience API around `g_menu_item_new` and
        `g_menu_item_set_section`.

        The effect of having one menu appear as a section of another is
        exactly as it sounds: the items from `section` become a direct part of
        the menu that `menu_item` is added to.

        Visual separation is typically displayed between two non-empty
        sections.  If `label` is non-None then it will be incorporated into
        this visual indication.  This allows for labeled subsections of a
        menu.

        As a simple example, consider a typical "Edit" menu from a simple
        program.  It probably contains an "Undo" and "Redo" item, followed by
        a separator, followed by "Cut", "Copy" and "Paste".

        This would be accomplished by creating three GMenu instances.  The
        first would be populated with the "Undo" and "Redo" items, and the
        second with the "Cut", "Copy" and "Paste" items.  The first and
        second menus would then be added as submenus of the third.  In XML
        format, this would look something like the following:
        |[
        <menu id='edit-menu'>
          <section>
            <item label='Undo'/>
            <item label='Redo'/>
          </section>
          <section>
            <item label='Cut'/>
            <item label='Copy'/>
            <item label='Paste'/>
          </section>
        </menu>
        ]|

        The following example is exactly equivalent.  It is more illustrative
        of the exact relationship between the menus and items (keeping in
        mind that the 'link' element defines a new menu that is linked to the
        containing one).  The style of the second example is more verbose and
        difficult to read (and therefore not recommended except for the
        purpose of understanding what is really going on).
        |[
        <menu id='edit-menu'>
          <item>
            <link name='section'>
              <item label='Undo'/>
              <item label='Redo'/>
            </link>
          </item>
          <item>
            <link name='section'>
              <item label='Cut'/>
              <item label='Copy'/>
              <item label='Paste'/>
            </link>
          </item>
        </menu>
        ]|
        """
    @classmethod
    def new_submenu(cls, label: str | None, submenu: MenuModel) -> MenuItem:
        """
            Creates a new GMenuItem representing a submenu.

        This is a convenience API around `g_menu_item_new` and
        `g_menu_item_set_submenu`.
        """
    def set_action_and_target_value(self, action: str | None = None, target_value: GLib.Variant | None = None) -> None:
        """
            Sets or unsets the "action" and "target" attributes of `menu_item`.

        If `action` is None then both the "action" and "target" attributes
        are unset (and `target_value` is ignored).

        If `action` is non-None then the "action" attribute is set.  The
        "target" attribute is then set to the value of `target_value` if it is
        non-None or unset otherwise.

        Normal menu items (ie: not submenu, section or other custom item
        types) are expected to have the "action" attribute set to identify
        the action that they are associated with.  The state type of the
        action help to determine the disposition of the menu item.  See
        GAction and GActionGroup for an overview of actions.

        In general, clicking on the menu item will result in activation of
        the named action with the "target" attribute given as the parameter
        to the action invocation.  If the "target" attribute is not set then
        the action is invoked with no parameter.

        If the action has no state then the menu item is usually drawn as a
        plain menu item (ie: with no additional decoration).

        If the action has a boolean state then the menu item is usually drawn
        as a toggle menu item (ie: with a checkmark or equivalent
        indication).  The item should be marked as 'toggled' or 'checked'
        when the boolean state is True.

        If the action has a string state then the menu item is usually drawn
        as a radio menu item (ie: with a radio bullet or equivalent
        indication).  The item should be marked as 'selected' when the string
        state is equal to the value of the `target` property.

        See `g_menu_item_set_action_and_target` or
        `g_menu_item_set_detailed_action` for two equivalent calls that are
        probably more convenient for most uses.
        """
    def set_attribute_value(self, attribute: str, value: GLib.Variant | None = None) -> None:
        """
            Sets or unsets an attribute on `menu_item`.

        The attribute to set or unset is specified by `attribute`. This
        can be one of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
        G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom
        attribute name.
        Attribute names are restricted to lowercase characters, numbers
        and '-'. Furthermore, the names must begin with a lowercase character,
        must not end with a '-', and must not contain consecutive dashes.

        must consist only of lowercase
        ASCII characters, digits and '-'.

        If `value` is non-None then it is used as the new value for the
        attribute.  If `value` is None then the attribute is unset. If
        the `value` GVariant is floating, it is consumed.

        See also `g_menu_item_set_attribute` for a more convenient way to do
        the same.
        """
    def set_detailed_action(self, detailed_action: str) -> None:
        """
            Sets the "action" and possibly the "target" attribute of `menu_item`.

        The format of `detailed_action` is the same format parsed by
        `g_action_parse_detailed_name`.

        See `g_menu_item_set_action_and_target` or
        `g_menu_item_set_action_and_target_value` for more flexible (but
        slightly less convenient) alternatives.

        See also `g_menu_item_set_action_and_target_value` for a description of
        the semantics of the action and target attributes.
        """
    def set_icon(self, icon: Icon) -> None:
        """
            Sets (or unsets) the icon on `menu_item`.

        This call is the same as calling `g_icon_serialize` and using the
        result as the value to `g_menu_item_set_attribute_value` for
        G_MENU_ATTRIBUTE_ICON.

        This API is only intended for use with "noun" menu items; things like
        bookmarks or applications in an "Open With" menu.  Don't use it on
        menu items corresponding to verbs (eg: stock icons for 'Save' or
        'Quit').

        If `icon` is None then the icon is unset.
        """
    def set_label(self, label: str | None = None) -> None:
        """
            Sets or unsets the "label" attribute of `menu_item`.

        If `label` is non-None it is used as the label for the menu item.  If
        it is None then the label attribute is unset.
        """
    def set_link(self, link: str, model: MenuModel | None = None) -> None:
        """
            Creates a link from `menu_item` to `model` if non-None, or unsets it.

        Links are used to establish a relationship between a particular menu
        item and another menu.  For example, G_MENU_LINK_SUBMENU is used to
        associate a submenu with a particular menu item, and G_MENU_LINK_SECTION
        is used to create a section. Other types of link can be used, but there
        is no guarantee that clients will be able to make sense of them.
        Link types are restricted to lowercase characters, numbers
        and '-'. Furthermore, the names must begin with a lowercase character,
        must not end with a '-', and must not contain consecutive dashes.
        """
    def set_section(self, section: MenuModel | None = None) -> None:
        """
            Sets or unsets the "section" link of `menu_item` to `section`.

        The effect of having one menu appear as a section of another is
        exactly as it sounds: the items from `section` become a direct part of
        the menu that `menu_item` is added to.  See `g_menu_item_new_section`
        for more information about what it means for a menu item to be a
        section.
        """
    def set_submenu(self, submenu: MenuModel | None = None) -> None:
        """
            Sets or unsets the "submenu" link of `menu_item` to `submenu`.

        If `submenu` is non-None, it is linked to.  If it is None then the
        link is unset.

        The effect of having one menu appear as a submenu of another is
        exactly as it sounds.
        """

    # python methods (overrides?)
    def set_attribute(
        self,
        attributes: typing.Any,
    ) -> typing.Any: ...

class MenuLinkIter(GObject.Object):
    """
    GMenuLinkIter is an opaque structure type.  You must access it using
    the functions below.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> MenuLinkIterPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_name(self) -> str:
        """
            Gets the name of the link at the current iterator position.

        The iterator is not advanced.
        """
    def get_next(self) -> tuple[bool, str, MenuModel]:
        """
            This function combines `g_menu_link_iter_next` with
        `g_menu_link_iter_get_name` and `g_menu_link_iter_get_value`.

        First the iterator is advanced to the next (possibly first) link.
        If that fails, then False is returned and there are no other effects.

        If successful, `out_link` and `value` are set to the name and GMenuModel
        of the link that has just been advanced to.  At this point,
        `g_menu_link_iter_get_name` and `g_menu_link_iter_get_value` will return the
        same values again.

        The value returned in `out_link` remains valid for as long as the iterator
        remains at the current position.  The value returned in `value` must
        be unreffed using `g_object_unref` when it is no longer in use.
        """
    def get_value(self) -> MenuModel:
        """
            Gets the linked GMenuModel at the current iterator position.

        The iterator is not advanced.
        """
    def next(self) -> bool:
        """
            Attempts to advance the iterator to the next (possibly first)
        link.

        True is returned on success, or False if there are no more links.

        You must call this function when you first acquire the iterator to
        advance it to the first link (and determine if the first link exists
        at all).
        """

    # python methods (overrides?)
    def do_get_next(
        self,
    ) -> tuple:
        """
        get_next(self) -> bool, out_link:str, value:Gio.MenuModel
        """

class MenuLinkIterClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def get_next(self) -> get_nextMenuLinkIterClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MenuLinkIterPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MenuModel(GObject.Object):
    """
    `GMenuModel` represents the contents of a menu — an ordered list of
    menu items. The items are associated with actions, which can be
    activated through them. Items can be grouped in sections, and may
    have submenus associated with them. Both items and sections usually
    have some representation data, such as labels or icons. The type of
    the associated action (ie whether it is stateful, and what kind of
    state it has) can influence the representation of the item.

    The conceptual model of menus in `GMenuModel` is hierarchical:
    sections and submenus are again represented by `GMenuModel`s.
    Menus themselves do not define their own roles. Rather, the role
    of a particular `GMenuModel` is defined by the item that references
    it (or, in the case of the ‘root’ menu, is defined by the context
    in which it is used).

    As an example, consider the visible portions of this menu:

    ## An example menu

    ![](menu-example.png)

    While this kind of deeply nested menu is no longer considered good UI
    practice, it serves as a good example of the concepts in `GMenuModel`.
    There are 8 ‘menus’ visible in the screenshot: one menubar, two
    submenus and 5 sections:

    - the toplevel menubar (containing 4 items)
    - the View submenu (containing 3 sections)
    - the first section of the View submenu (containing 2 items)
    - the second section of the View submenu (containing 1 item)
    - the final section of the View submenu (containing 1 item)
    - the Highlight Mode submenu (containing 2 sections)
    - the Sources section (containing 2 items)
    - the Markup section (containing 2 items)

    The [example](#a-menu-example) illustrates the conceptual connection between
    these 8 menus. Each large block in the figure represents a menu and the
    smaller blocks within the large block represent items in that menu. Some
    items contain references to other menus.

    ## A menu example

    <picture>
      <source srcset="menu-model-dark.svg" media="(prefers-color-scheme: dark)">
      <img src="menu-model-light.svg" alt="menu model">
    </picture>

    Notice that the separators visible in the [example](#an-example-menu)
    appear nowhere in the [menu model](#a-menu-example). This is because
    separators are not explicitly represented in the menu model. Instead,
    a separator is inserted between any two non-empty sections of a menu.
    Section items can have labels just like any other item. In that case,
    a display system may show a section header instead of a separator.

    The motivation for this abstract model of application controls is
    that modern user interfaces tend to make these controls available
    outside the application. Examples include global menus, jumplists,
    dash boards, etc. To support such uses, it is necessary to ‘export’
    information about actions and their representation in menus, which
    is exactly what the action group exporter and the menu model exporter do for
    [iface`Gio`.ActionGroup] and [class`Gio`.MenuModel]. The client-side
    counterparts to make use of the exported information are
    [class`Gio`.DBusActionGroup] and [class`Gio`.DBusMenuModel].

    The API of `GMenuModel` is very generic, with iterators for the
    attributes and links of an item, see
    [method`Gio`.MenuModel.iterate_item_attributes] and
    [method`Gio`.MenuModel.iterate_item_links]. The ‘standard’ attributes and
    link types have predefined names: `G_MENU_ATTRIBUTE_LABEL`,
    `G_MENU_ATTRIBUTE_ACTION`, `G_MENU_ATTRIBUTE_TARGET`, `G_MENU_LINK_SECTION`
    and `G_MENU_LINK_SUBMENU`.

    Items in a `GMenuModel` represent active controls if they refer to
    an action that can get activated when the user interacts with the
    menu item. The reference to the action is encoded by the string ID
    in the `G_MENU_ATTRIBUTE_ACTION` attribute. An action ID uniquely
    identifies an action in an action group. Which action group(s) provide
    actions depends on the context in which the menu model is used.
    E.g. when the model is exported as the application menu of a
    [`GtkApplication`](https://docs.gtk.org/gtk4/class.Application.html),
    actions can be application-wide or window-specific (and thus come from
    two different action groups). By convention, the application-wide actions
    have names that start with `app.`, while the names of window-specific
    actions start with `win.`.

    While a wide variety of stateful actions is possible, the following
    is the minimum that is expected to be supported by all users of exported
    menu information:
    - an action with no parameter type and no state
    - an action with no parameter type and boolean state
    - an action with string parameter type and string state

    ## Stateless

    A stateless action typically corresponds to an ordinary menu item.

    Selecting such a menu item will activate the action (with no parameter).

    ## Boolean State

    An action with a boolean state will most typically be used with a ‘toggle’
    or ‘switch’ menu item. The state can be set directly, but activating the
    action (with no parameter) results in the state being toggled.

    Selecting a toggle menu item will activate the action. The menu item should
    be rendered as ‘checked’ when the state is true.

    ## String Parameter and State

    Actions with string parameters and state will most typically be used to
    represent an enumerated choice over the items available for a group of
    radio menu items. Activating the action with a string parameter is
    equivalent to setting that parameter as the state.

    Radio menu items, in addition to being associated with the action, will
    have a target value. Selecting that menu item will result in activation
    of the action with the target value as the parameter. The menu item should
    be rendered as ‘selected’ when the state of the action is equal to the
    target value of the menu item.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> MenuModelPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_item_attribute_value(
        self, item_index: int, attribute: str, expected_type: GLib.VariantType | None = None
    ) -> GLib.Variant | None:
        """
            Queries the item at position `item_index` in `model` for the attribute
        specified by `attribute`.

        If `expected_type` is non-None then it specifies the expected type of
        the attribute.  If it is None then any type will be accepted.

        If the attribute exists and matches `expected_type` (or if the
        expected type is unspecified) then the value is returned.

        If the attribute does not exist, or does not match the expected type
        then None is returned.
        """
    def get_item_link(self, item_index: int, link: str) -> MenuModel | None:
        """
            Queries the item at position `item_index` in `model` for the link
        specified by `link`.

        If the link exists, the linked GMenuModel is returned.  If the link
        does not exist, None is returned.
        """
    def get_n_items(self) -> int:
        """
        Query the number of items in `model`.
        """
    def is_mutable(self) -> bool:
        """
            Queries if `model` is mutable.

        An immutable GMenuModel will never emit the GMenuModel::items-changed
        signal. Consumers of the model may make optimisations accordingly.
        """
    def items_changed(self, position: int, removed: int, added: int) -> None:
        """
            Requests emission of the GMenuModel::items-changed signal on `model`.

        This function should never be called except by GMenuModel
        subclasses.  Any other calls to this function will very likely lead
        to a violation of the interface of the model.

        The implementation should update its internal representation of the
        menu before emitting the signal.  The implementation should further
        expect to receive queries about the new state of the menu (and
        particularly added menu items) while signal handlers are running.

        The implementation must dispatch this call directly from a mainloop
        entry and not in response to calls -- particularly those from the
        GMenuModel API.  Said another way: the menu must not change while
        user code is running without returning to the mainloop.
        """
    def iterate_item_attributes(self, item_index: int) -> MenuAttributeIter:
        """
            Creates a GMenuAttributeIter to iterate over the attributes of
        the item at position `item_index` in `model`.

        You must free the iterator with `g_object_unref` when you are done.
        """
    def iterate_item_links(self, item_index: int) -> MenuLinkIter:
        """
            Creates a GMenuLinkIter to iterate over the links of the item at
        position `item_index` in `model`.

        You must free the iterator with `g_object_unref` when you are done.
        """

    # python methods (overrides?)
    def do_get_item_attribute_value(
        self,
        item_index: int,
        attribute: str,
        expected_type: GLib.VariantType | None = None,
    ) -> GLib.Variant | None:
        """
        get_item_attribute_value(self, item_index:int, attribute:str, expected_type:GLib.VariantType=None) -> GLib.Variant or None
        """
    def do_get_item_attributes(
        self,
        item_index: int,
    ) -> dict:
        """
        get_item_attributes(self, item_index:int) -> attributes:dict
        """
    def do_get_item_link(
        self,
        item_index: int,
        link: str,
    ) -> MenuModel | None:
        """
        get_item_link(self, item_index:int, link:str) -> Gio.MenuModel or None
        """
    def do_get_item_links(
        self,
        item_index: int,
    ) -> dict:
        """
        get_item_links(self, item_index:int) -> links:dict
        """
    def do_get_n_items(
        self,
    ) -> int:
        """
        get_n_items(self) -> int
        """
    def do_is_mutable(
        self,
    ) -> bool:
        """
        is_mutable(self) -> bool
        """
    def do_iterate_item_attributes(
        self,
        item_index: int,
    ) -> MenuAttributeIter:
        """
        iterate_item_attributes(self, item_index:int) -> Gio.MenuAttributeIter
        """
    def do_iterate_item_links(
        self,
        item_index: int,
    ) -> MenuLinkIter:
        """
        iterate_item_links(self, item_index:int) -> Gio.MenuLinkIter
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["items-changed"],
        handler: typing.Callable[[typing_extensions.Self, int, int, int], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when a change has occurred to the menu.

        The only changes that can occur to a menu is that items are removed
        or added.  Items may not change (except by being removed and added
        back in the same location).  This signal is capable of describing
        both of those changes (at the same time).

        The signal means that starting at the index `position`, `removed`
        items were removed and `added` items were added in their place.  If
        `removed` is zero then only items were added.  If `added` is zero
        then only items were removed.

        As an example, if the menu contains items a, b, c, d (in that
        order) and the signal (2, 1, 3) occurs then the new composition of
        the menu will be a, b, _, _, _, d (with each _ representing some
        new item).

        Signal handlers may query the model (particularly the added items)
        and expect to see the results of the modification that is being
        reported.  The signal is emitted after the modification.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MenuModelClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def get_item_attribute_value(self) -> get_item_attribute_valueMenuModelClassCB | None: ...
    @builtins.property
    def get_item_attributes(self) -> get_item_attributesMenuModelClassCB: ...
    @builtins.property
    def get_item_link(self) -> get_item_linkMenuModelClassCB | None: ...
    @builtins.property
    def get_item_links(self) -> get_item_linksMenuModelClassCB: ...
    @builtins.property
    def get_n_items(self) -> get_n_itemsMenuModelClassCB: ...
    @builtins.property
    def is_mutable(self) -> is_mutableMenuModelClassCB: ...
    @builtins.property
    def iterate_item_attributes(self) -> iterate_item_attributesMenuModelClassCB: ...
    @builtins.property
    def iterate_item_links(self) -> iterate_item_linksMenuModelClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MenuModelPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Mount(GObject.GInterface):
    """
    The `GMount` interface represents a user-visible mount, such as a mounted
    file system.

    `GMount` is a ‘mounted’ filesystem that you can access. Mounted is in
    quotes because it’s not the same as a UNIX mount, it might be a GVFS
    mount, but you can still access the files on it if you use GIO.

    A `GMount` might be associated with a [iface`Gio`.Volume] (such as a USB flash
    drive) which hosts it.

    Unmounting a `GMount` instance is an asynchronous operation. For
    more information about asynchronous operations, see [iface`Gio`.AsyncResult]
    and [class`Gio`.Task]. To unmount a `GMount` instance, first call
    [method`Gio`.Mount.unmount_with_operation] with (at least) the `GMount`
    instance and a [type`Gio`.AsyncReadyCallback].  The callback will be fired
    when the operation has resolved (either with success or failure), and a
    [iface`Gio`.AsyncResult] structure will be passed to the callback.  That
    callback should then call [method`Gio`.Mount.unmount_with_operation_finish]
    with the `GMount` and the [iface`Gio`.AsyncResult] data to see if the
    operation was completed successfully.  If an `error` is present when
    [method`Gio`.Mount.unmount_with_operation_finish] is called, then it will be
    filled with any error information.

    Note, when [porting from GnomeVFS](migrating-gnome-vfs.html), `GMount` is the
    moral equivalent of `GnomeVFSVolume`.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_eject(self) -> bool:
        """
        Checks if `mount` can be ejected.
        """
    def can_unmount(self) -> bool:
        """
        Checks if `mount` can be unmounted.
        """
    @deprecated("deprecated")
    async def eject(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Ejects a mount. This is an asynchronous operation, and is
        finished by calling `g_mount_eject_finish` with the `mount`
        and GAsyncResult data returned in the `callback`.
        """
    @deprecated("deprecated")
    def eject_finish(self, result: AsyncResult) -> bool:
        """
            Finishes ejecting a mount. If any errors occurred during the operation,
        `error` will be set to contain the errors and False will be returned.
        """
    async def eject_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Ejects a mount. This is an asynchronous operation, and is
        finished by calling `g_mount_eject_with_operation_finish` with the `mount`
        and GAsyncResult data returned in the `callback`.
        """
    def eject_with_operation_finish(self, result: AsyncResult) -> bool:
        """
            Finishes ejecting a mount. If any errors occurred during the operation,
        `error` will be set to contain the errors and False will be returned.
        """
    def get_default_location(self) -> File:
        """
            Gets the default location of `mount`. The default location of the given
        `mount` is a path that reflects the main entry point for the user (e.g.
        the home directory, or the root of the volume).
        """
    def get_drive(self) -> Drive | None:
        """
            Gets the drive for the `mount`.

        This is a convenience method for getting the GVolume and then
        using that object to get the GDrive.
        """
    def get_icon(self) -> Icon:
        """
        Gets the icon for `mount`.
        """
    def get_name(self) -> str:
        """
        Gets the name of `mount`.
        """
    def get_root(self) -> File:
        """
        Gets the root directory on `mount`.
        """
    def get_sort_key(self) -> str | None:
        """
        Gets the sort key for `mount`, if any.
        """
    def get_symbolic_icon(self) -> Icon:
        """
        Gets the symbolic icon for `mount`.
        """
    def get_uuid(self) -> str | None:
        """
            Gets the UUID for the `mount`. The reference is typically based on
        the file system UUID for the mount in question and should be
        considered an opaque string. Returns None if there is no UUID
        available.
        """
    def get_volume(self) -> Volume | None:
        """
        Gets the volume for the `mount`.
        """
    async def guess_content_type(
        self,
        force_rescan: bool,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Tries to guess the type of content stored on `mount`. Returns one or
        more textual identifiers of well-known content types (typically
        prefixed with "x-content/"), e.g. x-content/image-dcf for camera
        memory cards. See the
        [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
        specification for more on x-content types.

        This is an asynchronous operation (see
        `g_mount_guess_content_type_sync` for the synchronous version), and
        is finished by calling `g_mount_guess_content_type_finish` with the
        `mount` and GAsyncResult data returned in the `callback`.
        """
    def guess_content_type_finish(self, result: AsyncResult) -> list:
        """
            Finishes guessing content types of `mount`. If any errors occurred
        during the operation, `error` will be set to contain the errors and
        False will be returned. In particular, you may get an
        G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
        guessing.
        """
    def guess_content_type_sync(self, force_rescan: bool, cancellable: Cancellable | None = None) -> list:
        """
            Tries to guess the type of content stored on `mount`. Returns one or
        more textual identifiers of well-known content types (typically
        prefixed with "x-content/"), e.g. x-content/image-dcf for camera
        memory cards. See the
        [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
        specification for more on x-content types.

        This is a synchronous operation and as such may block doing IO;
        see `g_mount_guess_content_type` for the asynchronous version.
        """
    def is_shadowed(self) -> bool:
        """
            Determines if `mount` is shadowed. Applications or libraries should
        avoid displaying `mount` in the user interface if it is shadowed.

        A mount is said to be shadowed if there exists one or more user
        visible objects (currently GMount objects) with a root that is
        inside the root of `mount`.

        One application of shadow mounts is when exposing a single file
        system that is used to address several logical volumes. In this
        situation, a GVolumeMonitor implementation would create two
        GVolume objects (for example, one for the camera functionality of
        the device and one for a SD card reader on the device) with
        activation URIs `gphoto2://[usb:001,002]/store1/`
        and `gphoto2://[usb:001,002]/store2/`. When the
        underlying mount (with root
        `gphoto2://[usb:001,002]/`) is mounted, said
        GVolumeMonitor implementation would create two GMount objects
        (each with their root matching the corresponding volume activation
        root) that would shadow the original mount.

        The proxy monitor in GVfs 2.26 and later, automatically creates and
        manage shadow mounts (and shadows the underlying mount) if the
        activation root on a GVolume is set.
        """
    async def remount(
        self,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Remounts a mount. This is an asynchronous operation, and is
        finished by calling `g_mount_remount_finish` with the `mount`
        and GAsyncResults data returned in the `callback`.

        Remounting is useful when some setting affecting the operation
        of the volume has been changed, as these may need a remount to
        take affect. While this is semantically equivalent with unmounting
        and then remounting not all backends might need to actually be
        unmounted.
        """
    def remount_finish(self, result: AsyncResult) -> bool:
        """
            Finishes remounting a mount. If any errors occurred during the operation,
        `error` will be set to contain the errors and False will be returned.
        """
    def shadow(self) -> None:
        """
            Increments the shadow count on `mount`. Usually used by
        GVolumeMonitor implementations when creating a shadow mount for
        `mount`, see `g_mount_is_shadowed` for more information. The caller
        will need to emit the GMount::changed signal on `mount` manually.
        """
    @deprecated("deprecated")
    async def unmount(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Unmounts a mount. This is an asynchronous operation, and is
        finished by calling `g_mount_unmount_finish` with the `mount`
        and GAsyncResult data returned in the `callback`.
        """
    @deprecated("deprecated")
    def unmount_finish(self, result: AsyncResult) -> bool:
        """
            Finishes unmounting a mount. If any errors occurred during the operation,
        `error` will be set to contain the errors and False will be returned.
        """
    async def unmount_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Unmounts a mount. This is an asynchronous operation, and is
        finished by calling `g_mount_unmount_with_operation_finish` with the `mount`
        and GAsyncResult data returned in the `callback`.
        """
    def unmount_with_operation_finish(self, result: AsyncResult) -> bool:
        """
            Finishes unmounting a mount. If any errors occurred during the operation,
        `error` will be set to contain the errors and False will be returned.
        """
    def unshadow(self) -> None:
        """
            Decrements the shadow count on `mount`. Usually used by
        GVolumeMonitor implementations when destroying a shadow mount for
        `mount`, see `g_mount_is_shadowed` for more information. The caller
        will need to emit the GMount::changed signal on `mount` manually.
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
        Emitted when the mount has been changed.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["pre-unmount"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            This signal may be emitted when the GMount is about to be
        unmounted.

        This signal depends on the backend and is only emitted if
        GIO was used to unmount.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["unmounted"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            This signal is emitted when the GMount have been
        unmounted. If the recipient is holding references to the
        object they should release them so the object can be
        finalized.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MountIface(GObject.GPointer):
    """
    Interface for implementing operations for mounts.
    """

    # gi Fields
    @builtins.property
    def can_eject(self) -> can_ejectMountIfaceCB:
        """
        Checks if a GMount can be ejected.
        """
    @builtins.property
    def can_unmount(self) -> can_unmountMountIfaceCB:
        """
        Checks if a GMount can be unmounted.
        """
    @builtins.property
    def changed(self) -> changedMountIfaceCB:
        """
        Changed signal that is emitted when the mount's state has changed.
        """
    @builtins.property
    def eject(self) -> ejectMountIfaceCB:
        """
        Starts ejecting a GMount.
        """
    @builtins.property
    def eject_finish(self) -> eject_finishMountIfaceCB:
        """
        Finishes an eject operation.
        """
    @builtins.property
    def eject_with_operation(self) -> eject_with_operationMountIfaceCB:
        """
        Starts ejecting a GMount using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def eject_with_operation_finish(self) -> eject_with_operation_finishMountIfaceCB:
        """
        Finishes an eject operation using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def get_default_location(self) -> get_default_locationMountIfaceCB:
        """
        Gets a GFile indication a start location that can be use as the entry point for this mount. Since 2.24.
        """
    @builtins.property
    def get_drive(self) -> get_driveMountIfaceCB | None:
        """
        Gets a GDrive the volume of the mount is located on. Returns None if the GMount is not associated with a GDrive or a GVolume. This is convenience method for getting the GVolume and using that to get the GDrive.
        """
    @builtins.property
    def get_icon(self) -> get_iconMountIfaceCB:
        """
        Gets a GIcon for the GMount.
        """
    @builtins.property
    def get_name(self) -> get_nameMountIfaceCB:
        """
        Gets a string containing the name of the GMount.
        """
    @builtins.property
    def get_root(self) -> get_rootMountIfaceCB:
        """
        Gets a GFile to the root directory of the GMount.
        """
    @builtins.property
    def get_sort_key(self) -> get_sort_keyMountIfaceCB | None:
        """
        Gets a key used for sorting GMount instance or None if no such key exists. Since 2.32.
        """
    @builtins.property
    def get_symbolic_icon(self) -> get_symbolic_iconMountIfaceCB:
        """
        Gets a symbolic GIcon for the GMount. Since 2.34.
        """
    @builtins.property
    def get_uuid(self) -> get_uuidMountIfaceCB | None:
        """
        Gets the UUID for the GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns None if there is no UUID available.
        """
    @builtins.property
    def get_volume(self) -> get_volumeMountIfaceCB | None:
        """
        Gets a GVolume the mount is located on. Returns None if the GMount is not associated with a GVolume.
        """
    @builtins.property
    def guess_content_type(self) -> guess_content_typeMountIfaceCB:
        """
        Starts guessing the type of the content of a GMount.
        See `g_mount_guess_content_type` for more information on content
        type guessing. This operation was added in 2.18.
        """
    @builtins.property
    def guess_content_type_finish(self) -> guess_content_type_finishMountIfaceCB:
        """
        Finishes a content type guessing operation. Added in 2.18.
        """
    @builtins.property
    def guess_content_type_sync(self) -> guess_content_type_syncMountIfaceCB:
        """
        Synchronous variant of `guess_content_type`. Added in 2.18
        """
    @builtins.property
    def pre_unmount(self) -> pre_unmountMountIfaceCB:
        """
        The ::pre-unmount signal that is emitted when the GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.
        """
    @builtins.property
    def remount(self) -> remountMountIfaceCB:
        """
        Starts remounting a GMount.
        """
    @builtins.property
    def remount_finish(self) -> remount_finishMountIfaceCB:
        """
        Finishes a remounting operation.
        """
    @builtins.property
    def unmount(self) -> unmountMountIfaceCB:
        """
        Starts unmounting a GMount.
        """
    @builtins.property
    def unmount_finish(self) -> unmount_finishMountIfaceCB:
        """
        Finishes an unmounting operation.
        """
    @builtins.property
    def unmount_with_operation(self) -> unmount_with_operationMountIfaceCB:
        """
        Starts unmounting a GMount using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def unmount_with_operation_finish(self) -> unmount_with_operation_finishMountIfaceCB:
        """
        Finishes an unmounting operation using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def unmounted(self) -> unmountedMountIfaceCB:
        """
        The unmounted signal that is emitted when the GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MountOperation(GObject.Object):
    """
    `GMountOperation` provides a mechanism for interacting with the user.
    It can be used for authenticating mountable operations, such as loop
    mounting files, hard drive partitions or server locations. It can
    also be used to ask the user questions or show a list of applications
    preventing unmount or eject operations from completing.

    Note that `GMountOperation` is used for more than just [iface`Gio`.Mount]
    objects – for example it is also used in [method`Gio`.Drive.start] and
    [method`Gio`.Drive.stop].

    Users should instantiate a subclass of this that implements all the
    various callbacks to show the required dialogs, such as
    [`GtkMountOperation`](https://docs.gtk.org/gtk4/class.MountOperation.html).
    If no user interaction is desired (for example when automounting
    filesystems at login time), usually `None` can be passed, see each method
    taking a `GMountOperation` for details.

    Throughout the API, the term ‘TCRYPT’ is used to mean ‘compatible with TrueCrypt and VeraCrypt’.
    [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system for
    encrypting file containers, partitions or whole disks, typically used with Windows.
    [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of TrueCrypt with various
    improvements and auditing fixes.
    """

    class Props(GObject.Object.Props):
        anonymous: bool
        """
        Whether to use an anonymous user when authenticating.
        """
        choice: int
        """
        The index of the user's choice when a question is asked during the
        mount operation. See the GMountOperation::ask-question signal.
        """
        domain: str
        """
        The domain to use for the mount operation.
        """
        is_tcrypt_hidden_volume: bool  # [is-tcrypt-hidden-volume]: changed because contained invalid characters
        """
        Whether the device to be unlocked is a TCRYPT hidden volume.
        See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden20Volume.html).
        """
        is_tcrypt_system_volume: bool  # [is-tcrypt-system-volume]: changed because contained invalid characters
        """
        Whether the device to be unlocked is a TCRYPT system volume.
        In this context, a system volume is a volume with a bootloader
        and operating system installed. This is only supported for Windows
        operating systems. For further documentation, see
        [the VeraCrypt documentation](https://www.veracrypt.fr/en/System20Encryption.html).
        """
        password: str
        """
        The password that is used for authentication when carrying out
        the mount operation.
        """
        password_save: PasswordSave  # [password-save]: changed because contained invalid characters
        """
        Determines if and how the password information should be saved.
        """
        pim: int
        """
        The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
        [the VeraCrypt documentation](https://www.veracrypt.fr/en/Personal20Iterations20Multiplier20(PIM).html).
        """
        username: str
        """
        The user name that is used for authentication when carrying out
        the mount operation.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> MountOperationPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        anonymous: bool = ...,
        choice: int = ...,
        domain: str = ...,
        is_tcrypt_hidden_volume: bool = ...,
        is_tcrypt_system_volume: bool = ...,
        password: str = ...,
        password_save: PasswordSave = ...,
        pim: int = ...,
        username: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_anonymous(self) -> bool:
        """
            Check to see whether the mount operation is being used
        for an anonymous user.
        """
    @builtins.property
    def get_choice(self) -> int:
        """
        Gets a choice from the mount operation.
        """
    @builtins.property
    def get_domain(self) -> str | None:
        """
        Gets the domain of the mount operation.
        """
    @builtins.property
    def get_is_tcrypt_hidden_volume(self) -> bool:
        """
            Check to see whether the mount operation is being used
        for a TCRYPT hidden volume.
        """
    @builtins.property
    def get_is_tcrypt_system_volume(self) -> bool:
        """
            Check to see whether the mount operation is being used
        for a TCRYPT system volume.
        """
    @builtins.property
    def get_password(self) -> str | None:
        """
        Gets a password from the mount operation.
        """
    @builtins.property
    def get_password_save(self) -> PasswordSave:
        """
        Gets the state of saving passwords for the mount operation.
        """
    @builtins.property
    def get_pim(self) -> int:
        """
        Gets a PIM from the mount operation.
        """
    @builtins.property
    def get_username(self) -> str | None:
        """
        Get the user name from the mount operation.
        """
    @classmethod
    def new(cls) -> MountOperation:
        """
        Creates a new mount operation.
        """
    def reply(self, result: MountOperationResult) -> None:
        """
        Emits the GMountOperation::reply signal.
        """
    def set_anonymous(self, anonymous: bool) -> None:
        """
        Sets the mount operation to use an anonymous user if `anonymous` is True.
        """
    def set_choice(self, choice: int) -> None:
        """
        Sets a default choice for the mount operation.
        """
    def set_domain(self, domain: str | None = None) -> None:
        """
        Sets the mount operation's domain.
        """
    def set_is_tcrypt_hidden_volume(self, hidden_volume: bool) -> None:
        """
        Sets the mount operation to use a hidden volume if `hidden_volume` is True.
        """
    def set_is_tcrypt_system_volume(self, system_volume: bool) -> None:
        """
        Sets the mount operation to use a system volume if `system_volume` is True.
        """
    def set_password(self, password: str | None = None) -> None:
        """
        Sets the mount operation's password to `password`.
        """
    def set_password_save(self, save: PasswordSave) -> None:
        """
        Sets the state of saving passwords for the mount operation.
        """
    def set_pim(self, pim: int) -> None:
        """
        Sets the mount operation's PIM to `pim`.
        """
    def set_username(self, username: str | None = None) -> None:
        """
        Sets the user name within `op` to `username`.
        """

    # python methods (overrides?)
    def do_aborted(
        self,
    ) -> None:
        """
        aborted(self)
        """
    def do_ask_password(
        self,
        message: str,
        default_user: str,
        default_domain: str,
        flags: AskPasswordFlags,
    ) -> None:
        """
        ask_password(self, message:str, default_user:str, default_domain:str, flags:Gio.AskPasswordFlags)
        """
    def do_ask_question(
        self,
        message: str,
        choices: list,
    ) -> None:
        """
        ask_question(self, message:str, choices:list)
        """
    def do_reply(
        self,
        result: MountOperationResult,
    ) -> None:
        """
        reply(self, result:Gio.MountOperationResult)
        """
    def do_show_processes(
        self,
        message: str,
        processes: list,
        choices: list,
    ) -> None:
        """
        show_processes(self, message:str, processes:list, choices:list)
        """
    def do_show_unmount_progress(
        self,
        message: str,
        time_left: int,
        bytes_left: int,
    ) -> None:
        """
        show_unmount_progress(self, message:str, time_left:int, bytes_left:int)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["aborted"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            Emitted by the backend when e.g. a device becomes unavailable
        while a mount operation is in progress.

        Implementations of GMountOperation should handle this signal
        by dismissing open password dialogs.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["ask-password"],
        handler: typing.Callable[[typing_extensions.Self, str, str, str, AskPasswordFlags], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when a mount operation asks the user for a password.

        If the message contains a line break, the first line should be
        presented as a heading. For example, it may be used as the
        primary text in a GtkMessageDialog.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["ask-question"],
        handler: typing.Callable[[typing_extensions.Self, str, list], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when asking the user a question and gives a list of
        choices for the user to choose from.

        If the message contains a line break, the first line should be
        presented as a heading. For example, it may be used as the
        primary text in a GtkMessageDialog.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["reply"],
        handler: typing.Callable[[typing_extensions.Self, MountOperationResult], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when the user has replied to the mount operation.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["show-processes"],
        handler: typing.Callable[[typing_extensions.Self, str, list, list], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when one or more processes are blocking an operation
        e.g. unmounting/ejecting a GMount or stopping a GDrive.

        Note that this signal may be emitted several times to update the
        list of blocking processes as processes close files. The
        application should only respond with `g_mount_operation_reply` to
        the latest signal (setting GMountOperation:choice to the choice
        the user made).

        If the message contains a line break, the first line should be
        presented as a heading. For example, it may be used as the
        primary text in a GtkMessageDialog.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["show-unmount-progress"],
        handler: typing.Callable[[typing_extensions.Self, str, int, int], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when an unmount operation has been busy for more than some time
        (typically 1.5 seconds).

        When unmounting or ejecting a volume, the kernel might need to flush
        pending data in its buffers to the volume stable storage, and this operation
        can take a considerable amount of time. This signal may be emitted several
        times as long as the unmount operation is outstanding, and then one
        last time when the operation is completed, with `bytes_left` set to zero.

        Implementations of GMountOperation should handle this signal by
        showing an UI notification, and then dismiss it, or show another notification
        of completion, when `bytes_left` reaches zero.

        If the message contains a line break, the first line should be
        presented as a heading. For example, it may be used as the
        primary text in a GtkMessageDialog.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::anonymous"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::choice"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::domain"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_tcrypt_hidden_volume"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::is_tcrypt_system_volume"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::password"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::password_save"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pim"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::username"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class MountOperationClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def _g_reserved7(self) -> object | None: ...
    @builtins.property
    def _g_reserved8(self) -> object | None: ...
    @builtins.property
    def _g_reserved9(self) -> object | None: ...
    @builtins.property
    def aborted(self) -> abortedMountOperationClassCB: ...
    @builtins.property
    def ask_password(self) -> ask_passwordMountOperationClassCB: ...
    @builtins.property
    def ask_question(self) -> ask_questionMountOperationClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def reply(self) -> replyMountOperationClassCB: ...
    @builtins.property
    def show_processes(self) -> show_processesMountOperationClassCB: ...
    @builtins.property
    def show_unmount_progress(self) -> show_unmount_progressMountOperationClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class MountOperationPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NativeSocketAddress(SocketAddress):
    """
    A socket address of some unknown native type.

    This corresponds to a general `struct sockaddr` of a type not otherwise
    handled by GLib.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> SocketAddress | None: ...
    @builtins.property
    def priv(self) -> NativeSocketAddressPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, native: object | None, len: int) -> NativeSocketAddress:
        """
        Creates a new GNativeSocketAddress for `native` and `len`.
        """

class NativeSocketAddressClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SocketAddressClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NativeSocketAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NativeVolumeMonitor(VolumeMonitor):
    # gi Fields
    @builtins.property
    def parent_instance(self) -> VolumeMonitor | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NativeVolumeMonitorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def get_mount_for_mount_path(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> VolumeMonitorClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NetworkAddress(GObject.Object):
    """
    `GNetworkAddress` provides an easy way to resolve a hostname and
    then attempt to connect to that host, handling the possibility of
    multiple IP addresses and multiple address families.

    The enumeration results of resolved addresses *may* be cached as long
    as this object is kept alive which may have unexpected results if
    alive for too long.

    See [iface`Gio`.SocketConnectable] for an example of using the connectable
    interface.
    """

    class Props(GObject.Object.Props):
        hostname: str
        """
        Hostname to resolve.
        """
        port: int
        """
        Network port.
        """
        scheme: str
        """
        URI scheme.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> NetworkAddressPrivate | None: ...

    # gi Methods
    def __init__(self, hostname: str = ..., port: int = ..., scheme: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_hostname(self) -> str:
        """
            Gets `addr`'s hostname. This might be either UTF-8 or ASCII-encoded,
        depending on what `addr` was created with.
        """
    @builtins.property
    def get_port(self) -> int:
        """
        Gets `addr`'s port number
        """
    @builtins.property
    def get_scheme(self) -> str | None:
        """
        Gets `addr`'s scheme
        """
    @classmethod
    def new(cls, hostname: str, port: int) -> NetworkAddress:
        """
            Creates a new GSocketConnectable for connecting to the given
        `hostname` and `port`.

        Note that depending on the configuration of the machine, a
        `hostname` of `localhost` may refer to the IPv4 loopback address
        only, or to both IPv4 and IPv6; use
        `g_network_address_new_loopback` to create a GNetworkAddress that
        is guaranteed to resolve to both addresses.
        """
    @classmethod
    def new_loopback(cls, port: int) -> NetworkAddress:
        """
            Creates a new GSocketConnectable for connecting to the local host
        over a loopback connection to the given `port`. This is intended for
        use in connecting to local services which may be running on IPv4 or
        IPv6.

        The connectable will return IPv4 and IPv6 loopback addresses,
        regardless of how the host resolves `localhost`. By contrast,
        `g_network_address_new` will often only return an IPv4 address when
        resolving `localhost`, and an IPv6 address for `localhost6`.

        `g_network_address_get_hostname` will always return `localhost` for
        a GNetworkAddress created with this constructor.
        """
    @staticmethod
    def parse(host_and_port: str, default_port: int) -> NetworkAddress:
        """
            Creates a new GSocketConnectable for connecting to the given
        `hostname` and `port`. May fail and return None in case
        parsing `host_and_port` fails.

        `host_and_port` may be in any of a number of recognised formats; an IPv6
        address, an IPv4 address, or a domain name (in which case a DNS
        lookup is performed). Quoting with [] is supported for all address
        types. A port override may be specified in the usual way with a
        colon.

        If no port is specified in `host_and_port` then `default_port` will be
        used as the port number to connect to.

        In general, `host_and_port` is expected to be provided by the user
        (allowing them to give the hostname, and a port override if necessary)
        and `default_port` is expected to be provided by the application.

        (The port component of `host_and_port` can also be specified as a
        service name rather than as a numeric port, but this functionality
        is deprecated, because it depends on the contents of /etc/services,
        which is generally quite sparse on platforms other than Linux.)
        """
    @staticmethod
    def parse_uri(uri: str, default_port: int) -> NetworkAddress:
        """
            Creates a new GSocketConnectable for connecting to the given
        `uri`. May fail and return None in case parsing `uri` fails.

        Using this rather than `g_network_address_new` or
        `g_network_address_parse` allows GSocketClient to determine
        when to use application-specific proxy protocols.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::hostname"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::port"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scheme"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class NetworkAddressClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NetworkAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NetworkMonitor(GObject.GInterface):
    """
    `GNetworkMonitor` provides an easy-to-use cross-platform API
    for monitoring network connectivity. On Linux, the available
    implementations are based on the kernel's netlink interface and
    on NetworkManager.

    There is also an implementation for use inside Flatpak sandboxes.
    """

    class Props(GObject.GInterface.Props):
        connectivity: NetworkConnectivity
        """
        More detailed information about the host's network connectivity.
        See `g_network_monitor_get_connectivity` and
        GNetworkConnectivity for more details.
        """
        network_available: bool  # [network-available]: changed because contained invalid characters
        """
        Whether the network is considered available. That is, whether the
        system has a default route for at least one of IPv4 or IPv6.

        Real-world networks are of course much more complicated than
        this; the machine may be connected to a wifi hotspot that
        requires payment before allowing traffic through, or may be
        connected to a functioning router that has lost its own upstream
        connectivity. Some hosts might only be accessible when a VPN is
        active. Other hosts might only be accessible when the VPN is
        not active. Thus, it is best to use `g_network_monitor_can_reach`
        or `g_network_monitor_can_reach_async` to test for reachability
        on a host-by-host basis. (On the other hand, when the property is
        False, the application can reasonably expect that no remote
        hosts at all are reachable, and should indicate this to the user
        in its UI.)

        See also GNetworkMonitor::network-changed.
        """
        network_metered: bool  # [network-metered]: changed because contained invalid characters
        """
        Whether the network is considered metered.

        That is, whether the
        system has traffic flowing through the default connection that is
        subject to limitations set by service providers. For example, traffic
        might be billed by the amount of data transmitted, or there might be a
        quota on the amount of traffic per month. This is typical with tethered
        connections (3G and 4G) and in such situations, bandwidth intensive
        applications may wish to avoid network activity where possible if it will
        cost the user money or use up their limited quota. Anything more than a
        few hundreds of kilobytes of data usage per hour should be avoided without
        asking permission from the user.

        If more information is required about specific devices then the
        system network management API should be used instead (for example,
        NetworkManager or ConnMan).

        If this information is not available then no networks will be
        marked as metered.

        See also GNetworkMonitor:network-available.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_reach(self, connectable: SocketConnectable, cancellable: Cancellable | None = None) -> bool:
        """
            Attempts to determine whether or not the host pointed to by
        `connectable` can be reached, without actually trying to connect to
        it.

        This may return True even when GNetworkMonitor:network-available
        is False, if, for example, `monitor` can determine that
        `connectable` refers to a host on a local network.

        If `monitor` believes that an attempt to connect to `connectable`
        will succeed, it will return True. Otherwise, it will return
        False and set `error` to an appropriate error (such as
        G_IO_ERROR_HOST_UNREACHABLE).

        Note that although this does not attempt to connect to
        `connectable`, it may still block for a brief period of time (eg,
        trying to do multicast DNS on the local network), so if you do not
        want to block, you should use `g_network_monitor_can_reach_async`.
        """
    async def can_reach_async(
        self,
        connectable: SocketConnectable,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously attempts to determine whether or not the host
        pointed to by `connectable` can be reached, without actually
        trying to connect to it.

        For more details, see `g_network_monitor_can_reach`.

        When the operation is finished, `callback` will be called.
        You can then call `g_network_monitor_can_reach_finish`
        to get the result of the operation.
        """
    def can_reach_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an async network connectivity test.
        See `g_network_monitor_can_reach_async`.
        """
    @builtins.property
    def get_connectivity(self) -> NetworkConnectivity:
        """
            Gets a more detailed networking state than
        `g_network_monitor_get_network_available`.

        If GNetworkMonitor:network-available is False, then the
        connectivity state will be G_NETWORK_CONNECTIVITY_LOCAL.

        If GNetworkMonitor:network-available is True, then the
        connectivity state will be G_NETWORK_CONNECTIVITY_FULL (if there
        is full Internet connectivity), G_NETWORK_CONNECTIVITY_LIMITED (if
        the host has a default route, but appears to be unable to actually
        reach the full Internet), or G_NETWORK_CONNECTIVITY_PORTAL (if the
        host is trapped behind a "captive portal" that requires some sort
        of login or acknowledgement before allowing full Internet access).

        Note that in the case of G_NETWORK_CONNECTIVITY_LIMITED and
        G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
        reachable but others are not. In this case, applications can
        attempt to connect to remote servers, but should gracefully fall
        back to their "offline" behavior if the connection attempt fails.
        """
    @staticmethod
    def get_default() -> NetworkMonitor:
        """
        Gets the default GNetworkMonitor for the system.
        """
    @builtins.property
    def get_network_available(self) -> bool:
        """
            Checks if the network is available. "Available" here means that the
        system has a default route available for at least one of IPv4 or
        IPv6. It does not necessarily imply that the public Internet is
        reachable. See GNetworkMonitor:network-available for more details.
        """
    @builtins.property
    def get_network_metered(self) -> bool:
        """
            Checks if the network is metered.
        See GNetworkMonitor:network-metered for more details.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["network-changed"],
        handler: typing.Callable[[typing_extensions.Self, bool], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when the network configuration changes.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connectivity"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::network_available"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::network_metered"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class NetworkMonitorInterface(GObject.GPointer):
    """
    The virtual function table for GNetworkMonitor.
    """

    # gi Fields
    @builtins.property
    def can_reach(self) -> can_reachNetworkMonitorInterfaceCB:
        """
        the virtual function pointer for `g_network_monitor_can_reach`
        """
    @builtins.property
    def can_reach_async(self) -> can_reach_asyncNetworkMonitorInterfaceCB:
        """
           the virtual function pointer for
        `g_network_monitor_can_reach_async`
        """
    @builtins.property
    def can_reach_finish(self) -> can_reach_finishNetworkMonitorInterfaceCB:
        """
           the virtual function pointer for
        `g_network_monitor_can_reach_finish`
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def network_changed(self) -> network_changedNetworkMonitorInterfaceCB:
        """
           the virtual function pointer for the
        GNetworkMonitor::network-changed signal.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NetworkService(GObject.Object):
    """
    Like [class`Gio`.NetworkAddress] does with hostnames, `GNetworkService`
    provides an easy way to resolve a SRV record, and then attempt to
    connect to one of the hosts that implements that service, handling
    service priority/weighting, multiple IP addresses, and multiple
    address families.

    See [struct`Gio`.SrvTarget] for more information about SRV records, and see
    [iface`Gio`.SocketConnectable] for an example of using the connectable
    interface.
    """

    class Props(GObject.Object.Props):
        domain: str
        """
        Network domain, for example `example.com`.
        """
        protocol: str
        """
        Network protocol, for example `tcp`.
        """
        scheme: str
        """
        Network scheme (default is to use service).
        """
        service: str
        """
        Service name, for example `ldap`.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> NetworkServicePrivate | None: ...

    # gi Methods
    def __init__(self, domain: str = ..., protocol: str = ..., scheme: str = ..., service: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_domain(self) -> str:
        """
            Gets the domain that `srv` serves. This might be either UTF-8 or
        ASCII-encoded, depending on what `srv` was created with.
        """
    @builtins.property
    def get_protocol(self) -> str:
        """
        Gets `srv`'s protocol name (eg, "tcp").
        """
    @builtins.property
    def get_scheme(self) -> str:
        """
            Gets the URI scheme used to resolve proxies. By default, the service name
        is used as scheme.
        """
    @builtins.property
    def get_service(self) -> str:
        """
        Gets `srv`'s service name (eg, "ldap").
        """
    @classmethod
    def new(cls, service: str, protocol: str, domain: str) -> NetworkService:
        """
            Creates a new GNetworkService representing the given `service`,
        `protocol`, and `domain`. This will initially be unresolved; use the
        GSocketConnectable interface to resolve it.
        """
    def set_scheme(self, scheme: str) -> None:
        """
            Set's the URI scheme used to resolve proxies. By default, the service name
        is used as scheme.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::domain"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::scheme"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::service"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class NetworkServiceClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class NetworkServicePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Notification(GObject.Object):
    """
    `GNotification` is a mechanism for creating a notification to be shown
    to the user — typically as a pop-up notification presented by the
    desktop environment shell.

    The key difference between `GNotification` and other similar APIs is
    that, if supported by the desktop environment, notifications sent
    with `GNotification` will persist after the application has exited,
    and even across system reboots.

    Since the user may click on a notification while the application is
    not running, applications using `GNotification` should be able to be
    started as a D-Bus service, using [class`Gio`.Application].

    In order for `GNotification` to work, the application must have installed
    a `.desktop` file. For example:
    ```
    [Desktop Entry]
    Name=Test Application
    Comment=Description of what Test Application does
    Exec=gnome-test-application
    Icon=org.gnome.TestApplication
    Terminal=false
    Type=Application
    Categories=GNOME;GTK;TestApplication Category;
    StartupNotify=true
    DBusActivatable=true
    X-GNOME-UsesNotifications=true
    ```

    The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
    that this application uses notifications, so it can be listed in the
    Control Center’s ‘Notifications’ panel.

    The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
    where `org.gnome.TestApplication` is the ID passed to
    [ctor`Gio`.Application.new].

    User interaction with a notification (either the default action, or
    buttons) must be associated with actions on the application (ie:
    `app.` actions).  It is not possible to route user interaction
    through the notification itself, because the object will not exist if
    the application is autostarted as a result of a notification being
    clicked.

    A notification can be sent with [method`Gio`.Application.send_notification].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_button(self, label: str, detailed_action: str) -> None:
        """
            Adds a button to `notification` that activates the action in
        `detailed_action` when clicked. That action must be an
        application-wide action (starting with "app."). If `detailed_action`
        contains a target, the action will be activated with that target as
        its parameter.

        See `g_action_parse_detailed_name` for a description of the format
        for `detailed_action`.
        """
    def add_button_with_target(self, label: str, action: str, target: GLib.Variant | None = None) -> None:
        """
            Adds a button to `notification` that activates `action` when clicked.
        `action` must be an application-wide action (it must start with "app.").

        If `target_format` is given, it is used to collect remaining
        positional parameters into a GVariant instance, similar to
        `g_variant_new`. `action` will be activated with that GVariant as its
        parameter.
        """
    @classmethod
    def new(cls, title: str) -> Notification:
        """
            Creates a new GNotification with `title` as its title.

        After populating `notification` with more details, it can be sent to
        the desktop shell with `g_application_send_notification`. Changing
        any properties after this call will not have any effect until
        resending `notification`.
        """
    def set_body(self, body: str | None = None) -> None:
        """
        Sets the body of `notification` to `body`.
        """
    def set_category(self, category: str | None = None) -> None:
        """
            Sets the type of `notification` to `category`. Categories have a main
        type like `email`, `im` or `device` and can have a detail separated
        by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
        helps the notification server to select proper feedback to the user.

        Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
        """
    def set_default_action(self, detailed_action: str) -> None:
        """
            Sets the default action of `notification` to `detailed_action`. This
        action is activated when the notification is clicked on.

        The action in `detailed_action` must be an application-wide action (it
        must start with "app."). If `detailed_action` contains a target, the
        given action will be activated with that target as its parameter.
        See `g_action_parse_detailed_name` for a description of the format
        for `detailed_action`.

        When no default action is set, the application that the notification
        was sent on is activated.
        """
    def set_default_action_and_target(self, action: str, target: GLib.Variant | None = None) -> None:
        """
            Sets the default action of `notification` to `action`. This action is
        activated when the notification is clicked on. It must be an
        application-wide action (it must start with "app.").

        If `target_format` is given, it is used to collect remaining
        positional parameters into a GVariant instance, similar to
        `g_variant_new`. `action` will be activated with that GVariant as its
        parameter.

        When no default action is set, the application that the notification
        was sent on is activated.
        """
    def set_icon(self, icon: Icon) -> None:
        """
        Sets the icon of `notification` to `icon`.
        """
    def set_priority(self, priority: NotificationPriority) -> None:
        """
            Sets the priority of `notification` to `priority`. See
        GNotificationPriority for possible values.
        """
    def set_title(self, title: str) -> None:
        """
        Sets the title of `notification` to `title`.
        """
    @deprecated("deprecated")
    def set_urgent(self, urgent: bool) -> None:
        """
        Deprecated in favor of `g_notification_set_priority`.
        """

class OutputMessage(GObject.GPointer):
    """
    Structure used for scatter/gather data output when sending multiple
    messages or packets in one go. You generally pass in an array of
    GOutputVectors and the operation will use all the buffers as if they
    were one buffer.

    If `address` is None then the message is sent to the default receiver
    (as previously set by `g_socket_connect`).
    """

    # gi Fields
    address: SocketAddress | None = ...
    """
    a GSocketAddress, or None

    """
    bytes_sent: int = ...
    """
    initialize to 0. Will be set to the number of bytes
        that have been sent

    """
    control_messages: list | None = ...
    """
    a pointer
      to an array of GSocketControlMessages, or None.

    """
    num_control_messages: int = ...
    """
    number of elements in `control_messages`.

    """
    num_vectors: int = ...
    """
    the number of output vectors pointed to by `vectors`.

    """
    vectors: OutputVector | None = ...
    """
    pointer to an array of output vectors

    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class OutputStream(GObject.Object):
    """
    `GOutputStream` is a base class for implementing streaming output.

    It has functions to write to a stream ([method`Gio`.OutputStream.write]),
    to close a stream ([method`Gio`.OutputStream.close]) and to flush pending
    writes ([method`Gio`.OutputStream.flush]).

    To copy the content of an input stream to an output stream without
    manually handling the reads and writes, use [method`Gio`.OutputStream.splice].

    See the documentation for [class`Gio`.IOStream] for details of thread safety
    of streaming APIs.

    All of these functions have async variants too.

    All classes derived from `GOutputStream` *should* implement synchronous
    writing, splicing, flushing and closing streams, but *may* implement
    asynchronous versions.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> OutputStreamPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def clear_pending(self) -> None:
        """
        Clears the pending flag on `stream`.
        """
    def close(self, cancellable: Cancellable | None = None) -> bool:
        """
            Closes the stream, releasing resources related to it.

        Once the stream is closed, all other operations will return G_IO_ERROR_CLOSED.
        Closing a stream multiple times will not return an error.

        Closing a stream will automatically flush any outstanding buffers in the
        stream.

        Streams will be automatically closed when the last reference
        is dropped, but you might want to call this function to make sure
        resources are released as early as possible.

        Some streams might keep the backing store of the stream (e.g. a file descriptor)
        open after the stream is closed. See the documentation for the individual
        stream for details.

        On failure the first error that happened will be reported, but the close
        operation will finish as much as possible. A stream that failed to
        close will still return G_IO_ERROR_CLOSED for all operations. Still, it
        is important to check and report the error to the user, otherwise
        there might be a loss of data as all data might not be written.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        Cancelling a close will still leave the stream closed, but there some streams
        can use a faster close that doesn't block to e.g. check errors. On
        cancellation (as with any error) there is no guarantee that all written
        data will reach the target.
        """
    async def close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Requests an asynchronous close of the stream, releasing resources
        related to it. When the operation is finished `callback` will be
        called. You can then call `g_output_stream_close_finish` to get
        the result of the operation.

        For behaviour details see `g_output_stream_close`.

        The asynchronous methods have a default fallback that uses threads
        to implement asynchronicity, so they are optional for inheriting
        classes. However, if you override one you must override all.
        """
    def close_finish(self, result: AsyncResult) -> bool:
        """
        Closes an output stream.
        """
    def flush(self, cancellable: Cancellable | None = None) -> bool:
        """
            Forces a write of all user-space buffered data for the given
        `stream`. Will block during the operation. Closing the stream will
        implicitly cause a flush.

        This function is optional for inherited classes.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def flush_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Forces an asynchronous write of all user-space buffered data for
        the given `stream`.
        For behaviour details see `g_output_stream_flush`.

        When the operation is finished `callback` will be
        called. You can then call `g_output_stream_flush_finish` to get the
        result of the operation.
        """
    def flush_finish(self, result: AsyncResult) -> bool:
        """
        Finishes flushing an output stream.
        """
    def has_pending(self) -> bool:
        """
        Checks if an output stream has pending actions.
        """
    def is_closed(self) -> bool:
        """
        Checks if an output stream has already been closed.
        """
    def is_closing(self) -> bool:
        """
            Checks if an output stream is being closed. This can be
        used inside e.g. a flush implementation to see if the
        flush (or other i/o operation) is called from within
        the closing operation.
        """
    def set_pending(self) -> bool:
        """
            Sets `stream` to have actions pending. If the pending flag is
        already set or `stream` is closed, it will return False and set
        `error`.
        """
    def splice(
        self, source: InputStream, flags: OutputStreamSpliceFlags, cancellable: Cancellable | None = None
    ) -> int:
        """
        Splices an input stream into an output stream.
        """
    async def splice_async(
        self,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Splices a stream asynchronously.
        When the operation is finished `callback` will be called.
        You can then call `g_output_stream_splice_finish` to get the
        result of the operation.

        For the synchronous, blocking version of this function, see
        `g_output_stream_splice`.
        """
    def splice_finish(self, result: AsyncResult) -> int:
        """
        Finishes an asynchronous stream splice operation.
        """
    def write(self, buffer: list, count: int, cancellable: Cancellable | None = None) -> int:
        """
            Tries to write `count` bytes from `buffer` into the stream. Will block
        during the operation.

        If count is 0, returns 0 and does nothing. A value of `count`
        larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.

        On success, the number of bytes written to the stream is returned.
        It is not an error if this is not the same as the requested size, as it
        can happen e.g. on a partial I/O error, or if there is not enough
        storage in the stream. All writes block until at least one byte
        is written or an error occurs; 0 is never returned (unless
        `count` is 0).

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
        operation was partially finished when the operation was cancelled the
        partial result will be returned, without an error.

        On error -1 is returned and `error` is set accordingly.
        """
    def write_all(self, buffer: list, count: int, cancellable: Cancellable | None = None) -> tuple[bool, int]:
        """
            Tries to write `count` bytes from `buffer` into the stream. Will block
        during the operation.

        This function is similar to `g_output_stream_write`, except it tries to
        write as many bytes as requested, only stopping on an error.

        On a successful write of `count` bytes, True is returned, and `bytes_written`
        is set to `count`.

        If there is an error during the operation False is returned and `error`
        is set to indicate the error status.

        As a special exception to the normal conventions for functions that
        use GError, if this function returns False (and sets `error`) then
        `bytes_written` will be set to the number of bytes that were
        successfully written before the error was encountered.  This
        functionality is only available from C.  If you need it from another
        language then you must write your own loop around
        `g_output_stream_write`.
        """
    async def write_all_async(
        self,
        buffer: list,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Request an asynchronous write of `count` bytes from `buffer` into
        the stream. When the operation is finished `callback` will be called.
        You can then call `g_output_stream_write_all_finish` to get the result of the
        operation.

        This is the asynchronous version of `g_output_stream_write_all`.

        Call `g_output_stream_write_all_finish` to collect the result.

        Any outstanding I/O request with higher priority (lower numerical
        value) will be executed before an outstanding request with lower
        priority. Default priority is G_PRIORITY_DEFAULT.

        Note that no copy of `buffer` will be made, so it must stay valid
        until `callback` is called.
        """
    def write_all_finish(self, result: AsyncResult) -> tuple[bool, int]:
        """
            Finishes an asynchronous stream write operation started with
        `g_output_stream_write_all_async`.

        As a special exception to the normal conventions for functions that
        use GError, if this function returns False (and sets `error`) then
        `bytes_written` will be set to the number of bytes that were
        successfully written before the error was encountered.  This
        functionality is only available from C.  If you need it from another
        language then you must write your own loop around
        `g_output_stream_write_async`.
        """
    async def write_async(
        self,
        buffer: list,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Request an asynchronous write of `count` bytes from `buffer` into
        the stream. When the operation is finished `callback` will be called.
        You can then call `g_output_stream_write_finish` to get the result of the
        operation.

        During an async request no other sync and async calls are allowed,
        and will result in G_IO_ERROR_PENDING errors.

        A value of `count` larger than G_MAXSSIZE will cause a
        G_IO_ERROR_INVALID_ARGUMENT error.

        On success, the number of bytes written will be passed to the
        `callback`. It is not an error if this is not the same as the
        requested size, as it can happen e.g. on a partial I/O error,
        but generally we try to write as many bytes as requested.

        You are guaranteed that this method will never fail with
        G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
        method will just wait until this changes.

        Any outstanding I/O request with higher priority (lower numerical
        value) will be executed before an outstanding request with lower
        priority. Default priority is G_PRIORITY_DEFAULT.

        The asynchronous methods have a default fallback that uses threads
        to implement asynchronicity, so they are optional for inheriting
        classes. However, if you override one you must override all.

        For the synchronous, blocking version of this function, see
        `g_output_stream_write`.

        Note that no copy of `buffer` will be made, so it must stay valid
        until `callback` is called. See `g_output_stream_write_bytes_async`
        for a GBytes version that will automatically hold a reference to
        the contents (without copying) for the duration of the call.
        """
    def write_bytes(self, bytes: GLib.Bytes, cancellable: Cancellable | None = None) -> int:
        """
            A wrapper function for `g_output_stream_write` which takes a
        GBytes as input.  This can be more convenient for use by language
        bindings or in other cases where the refcounted nature of GBytes
        is helpful over a bare pointer interface.

        However, note that this function may still perform partial writes,
        just like `g_output_stream_write`.  If that occurs, to continue
        writing, you will need to create a new GBytes containing just the
        remaining bytes, using `g_bytes_new_from_bytes`. Passing the same
        GBytes instance multiple times potentially can result in duplicated
        data in the output stream.
        """
    async def write_bytes_async(
        self,
        bytes: GLib.Bytes,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            This function is similar to `g_output_stream_write_async`, but
        takes a GBytes as input.  Due to the refcounted nature of GBytes,
        this allows the stream to avoid taking a copy of the data.

        However, note that this function may still perform partial writes,
        just like `g_output_stream_write_async`. If that occurs, to continue
        writing, you will need to create a new GBytes containing just the
        remaining bytes, using `g_bytes_new_from_bytes`. Passing the same
        GBytes instance multiple times potentially can result in duplicated
        data in the output stream.

        For the synchronous, blocking version of this function, see
        `g_output_stream_write_bytes`.
        """
    def write_bytes_finish(self, result: AsyncResult) -> int:
        """
        Finishes a stream write-from-GBytes operation.
        """
    def write_finish(self, result: AsyncResult) -> int:
        """
        Finishes a stream write operation.
        """
    def writev(self, vectors: list, n_vectors: int, cancellable: Cancellable | None = None) -> tuple[bool, int]:
        """
            Tries to write the bytes contained in the `n_vectors` `vectors` into the
        stream. Will block during the operation.

        If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
        does nothing.

        On success, the number of bytes written to the stream is returned.
        It is not an error if this is not the same as the requested size, as it
        can happen e.g. on a partial I/O error, or if there is not enough
        storage in the stream. All writes block until at least one byte
        is written or an error occurs; 0 is never returned (unless
        `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
        operation was partially finished when the operation was cancelled the
        partial result will be returned, without an error.

        Some implementations of `g_output_stream_writev` may have limitations on the
        aggregate buffer size, and will return G_IO_ERROR_INVALID_ARGUMENT if these
        are exceeded. For example, when writing to a local file on UNIX platforms,
        the aggregate buffer size must not exceed G_MAXSSIZE bytes.
        """
    def writev_all(self, vectors: list, n_vectors: int, cancellable: Cancellable | None = None) -> tuple[bool, int]:
        """
            Tries to write the bytes contained in the `n_vectors` `vectors` into the
        stream. Will block during the operation.

        This function is similar to `g_output_stream_writev`, except it tries to
        write as many bytes as requested, only stopping on an error.

        On a successful write of all `n_vectors` vectors, True is returned, and
        `bytes_written` is set to the sum of all the sizes of `vectors`.

        If there is an error during the operation False is returned and `error`
        is set to indicate the error status.

        As a special exception to the normal conventions for functions that
        use GError, if this function returns False (and sets `error`) then
        `bytes_written` will be set to the number of bytes that were
        successfully written before the error was encountered.  This
        functionality is only available from C. If you need it from another
        language then you must write your own loop around
        `g_output_stream_write`.

        The content of the individual elements of `vectors` might be changed by this
        function.
        """
    async def writev_all_async(
        self,
        vectors: list,
        n_vectors: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
        the stream. When the operation is finished `callback` will be called.
        You can then call `g_output_stream_writev_all_finish` to get the result of the
        operation.

        This is the asynchronous version of `g_output_stream_writev_all`.

        Call `g_output_stream_writev_all_finish` to collect the result.

        Any outstanding I/O request with higher priority (lower numerical
        value) will be executed before an outstanding request with lower
        priority. Default priority is G_PRIORITY_DEFAULT.

        Note that no copy of `vectors` will be made, so it must stay valid
        until `callback` is called. The content of the individual elements
        of `vectors` might be changed by this function.
        """
    def writev_all_finish(self, result: AsyncResult) -> tuple[bool, int]:
        """
            Finishes an asynchronous stream write operation started with
        `g_output_stream_writev_all_async`.

        As a special exception to the normal conventions for functions that
        use GError, if this function returns False (and sets `error`) then
        `bytes_written` will be set to the number of bytes that were
        successfully written before the error was encountered.  This
        functionality is only available from C.  If you need it from another
        language then you must write your own loop around
        `g_output_stream_writev_async`.
        """
    async def writev_async(
        self,
        vectors: list,
        n_vectors: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
        the stream. When the operation is finished `callback` will be called.
        You can then call `g_output_stream_writev_finish` to get the result of the
        operation.

        During an async request no other sync and async calls are allowed,
        and will result in G_IO_ERROR_PENDING errors.

        On success, the number of bytes written will be passed to the
        `callback`. It is not an error if this is not the same as the
        requested size, as it can happen e.g. on a partial I/O error,
        but generally we try to write as many bytes as requested.

        You are guaranteed that this method will never fail with
        G_IO_ERROR_WOULD_BLOCK — if `stream` can't accept more data, the
        method will just wait until this changes.

        Any outstanding I/O request with higher priority (lower numerical
        value) will be executed before an outstanding request with lower
        priority. Default priority is G_PRIORITY_DEFAULT.

        The asynchronous methods have a default fallback that uses threads
        to implement asynchronicity, so they are optional for inheriting
        classes. However, if you override one you must override all.

        For the synchronous, blocking version of this function, see
        `g_output_stream_writev`.

        Note that no copy of `vectors` will be made, so it must stay valid
        until `callback` is called.
        """
    def writev_finish(self, result: AsyncResult) -> tuple[bool, int]:
        """
        Finishes a stream writev operation.
        """

    # python methods (overrides?)
    def do_close_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        close_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_close_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        close_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_close_fn(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        close_fn(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_flush(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        flush(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_flush_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        flush_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_flush_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        flush_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_splice(
        self,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        splice(self, source:Gio.InputStream, flags:Gio.OutputStreamSpliceFlags, cancellable:Gio.Cancellable=None) -> int
        """
    def do_splice_async(
        self,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        splice_async(self, source:Gio.InputStream, flags:Gio.OutputStreamSpliceFlags, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_splice_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        splice_finish(self, result:Gio.AsyncResult) -> int
        """
    def do_write_async(
        self,
        buffer: list | None,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        write_async(self, buffer:list=None, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_write_finish(
        self,
        result: AsyncResult,
    ) -> int:
        """
        write_finish(self, result:Gio.AsyncResult) -> int
        """
    def do_write_fn(
        self,
        buffer: list | None = None,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
        write_fn(self, buffer:list=None, cancellable:Gio.Cancellable=None) -> int
        """
    def do_writev_async(
        self,
        vectors: list,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        writev_async(self, vectors:list, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_writev_finish(
        self,
        result: AsyncResult,
    ) -> tuple:
        """
        writev_finish(self, result:Gio.AsyncResult) -> bool, bytes_written:int
        """
    def do_writev_fn(
        self,
        vectors: list,
        cancellable: Cancellable | None = None,
    ) -> tuple:
        """
        writev_fn(self, vectors:list, cancellable:Gio.Cancellable=None) -> bool, bytes_written:int
        """

class OutputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def _g_reserved7(self) -> object | None: ...
    @builtins.property
    def _g_reserved8(self) -> object | None: ...
    @builtins.property
    def close_async(self) -> close_asyncOutputStreamClassCB: ...
    @builtins.property
    def close_finish(self) -> close_finishOutputStreamClassCB: ...
    @builtins.property
    def close_fn(self) -> close_fnOutputStreamClassCB: ...
    @builtins.property
    def flush(self) -> flushOutputStreamClassCB: ...
    @builtins.property
    def flush_async(self) -> flush_asyncOutputStreamClassCB: ...
    @builtins.property
    def flush_finish(self) -> flush_finishOutputStreamClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def splice(self) -> spliceOutputStreamClassCB: ...
    @builtins.property
    def splice_async(self) -> splice_asyncOutputStreamClassCB: ...
    @builtins.property
    def splice_finish(self) -> splice_finishOutputStreamClassCB: ...
    @builtins.property
    def write_async(self) -> write_asyncOutputStreamClassCB: ...
    @builtins.property
    def write_finish(self) -> write_finishOutputStreamClassCB: ...
    @builtins.property
    def write_fn(self) -> write_fnOutputStreamClassCB: ...
    @builtins.property
    def writev_async(self) -> writev_asyncOutputStreamClassCB: ...
    @builtins.property
    def writev_finish(self) -> writev_finishOutputStreamClassCB: ...
    @builtins.property
    def writev_fn(self) -> writev_fnOutputStreamClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class OutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class OutputVector(GObject.GPointer):
    """
    Structure used for scatter/gather data output.
    You generally pass in an array of GOutputVectors
    and the operation will use all the buffers as if they were
    one buffer.
    """

    # gi Fields
    buffer: object | None = ...
    """
    Pointer to a buffer of data to read.

    """
    size: int = ...
    """
    the size of `buffer`.

    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Permission(GObject.Object):
    """
    A `GPermission` represents the status of the caller’s permission to
    perform a certain action.

    You can query if the action is currently allowed and if it is
    possible to acquire the permission so that the action will be allowed
    in the future.

    There is also an API to actually acquire the permission and one to
    release it.

    As an example, a `GPermission` might represent the ability for the
    user to write to a [class`Gio`.Settings] object.  This `GPermission` object
    could then be used to decide if it is appropriate to show a “Click here to
    unlock” button in a dialog and to provide the mechanism to invoke
    when that button is clicked.
    """

    class Props(GObject.Object.Props):
        allowed: bool
        """
        True if the caller currently has permission to perform the action that
        `permission` represents the permission to perform.
        """
        can_acquire: bool  # [can-acquire]: changed because contained invalid characters
        """
        True if it is generally possible to acquire the permission by calling
        `g_permission_acquire`.
        """
        can_release: bool  # [can-release]: changed because contained invalid characters
        """
        True if it is generally possible to release the permission by calling
        `g_permission_release`.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> PermissionPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def acquire(self, cancellable: Cancellable | None = None) -> bool:
        """
            Attempts to acquire the permission represented by `permission`.

        The precise method by which this happens depends on the permission
        and the underlying authentication mechanism.  A simple example is
        that a dialog may appear asking the user to enter their password.

        You should check with `g_permission_get_can_acquire` before calling
        this function.

        If the permission is acquired then True is returned.  Otherwise,
        False is returned and `error` is set appropriately.

        This call is blocking, likely for a very long time (in the case that
        user interaction is required).  See `g_permission_acquire_async` for
        the non-blocking version.
        """
    async def acquire_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Attempts to acquire the permission represented by `permission`.

        This is the first half of the asynchronous version of
        `g_permission_acquire`.
        """
    def acquire_finish(self, result: AsyncResult) -> bool:
        """
            Collects the result of attempting to acquire the permission
        represented by `permission`.

        This is the second half of the asynchronous version of
        `g_permission_acquire`.
        """
    @builtins.property
    def get_allowed(self) -> bool:
        """
            Gets the value of the 'allowed' property.  This property is True if
        the caller currently has permission to perform the action that
        `permission` represents the permission to perform.
        """
    @builtins.property
    def get_can_acquire(self) -> bool:
        """
            Gets the value of the 'can-acquire' property.  This property is True
        if it is generally possible to acquire the permission by calling
        `g_permission_acquire`.
        """
    @builtins.property
    def get_can_release(self) -> bool:
        """
            Gets the value of the 'can-release' property.  This property is True
        if it is generally possible to release the permission by calling
        `g_permission_release`.
        """
    def impl_update(self, allowed: bool, can_acquire: bool, can_release: bool) -> None:
        """
            This function is called by the GPermission implementation to update
        the properties of the permission.  You should never call this
        function except from a GPermission implementation.

        GObject notify signals are generated, as appropriate.
        """
    def release(self, cancellable: Cancellable | None = None) -> bool:
        """
            Attempts to release the permission represented by `permission`.

        The precise method by which this happens depends on the permission
        and the underlying authentication mechanism.  In most cases the
        permission will be dropped immediately without further action.

        You should check with `g_permission_get_can_release` before calling
        this function.

        If the permission is released then True is returned.  Otherwise,
        False is returned and `error` is set appropriately.

        This call is blocking, likely for a very long time (in the case that
        user interaction is required).  See `g_permission_release_async` for
        the non-blocking version.
        """
    async def release_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Attempts to release the permission represented by `permission`.

        This is the first half of the asynchronous version of
        `g_permission_release`.
        """
    def release_finish(self, result: AsyncResult) -> bool:
        """
            Collects the result of attempting to release the permission
        represented by `permission`.

        This is the second half of the asynchronous version of
        `g_permission_release`.
        """

    # python methods (overrides?)
    def do_acquire(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        acquire(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_acquire_async(
        self,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        acquire_async(self, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_acquire_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        acquire_finish(self, result:Gio.AsyncResult) -> bool
        """
    def do_release(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        release(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_release_async(
        self,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        release_async(self, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_release_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        release_finish(self, result:Gio.AsyncResult) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::allowed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_acquire"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::can_release"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PermissionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def acquire(self) -> acquirePermissionClassCB: ...
    @builtins.property
    def acquire_async(self) -> acquire_asyncPermissionClassCB: ...
    @builtins.property
    def acquire_finish(self) -> acquire_finishPermissionClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def release(self) -> releasePermissionClassCB: ...
    @builtins.property
    def release_async(self) -> release_asyncPermissionClassCB: ...
    @builtins.property
    def release_finish(self) -> release_finishPermissionClassCB: ...
    @builtins.property
    def reserved(self) -> list | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PermissionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PollableInputStream(GObject.GInterface):
    """
    `GPollableInputStream` is implemented by [class`Gio`.InputStream]s that
    can be polled for readiness to read. This can be used when
    interfacing with a non-GIO API that expects
    UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.

    Some classes may implement `GPollableInputStream` but have only certain
    instances of that class be pollable. If [method`Gio`.PollableInputStream.can_poll]
    returns false, then the behavior of other `GPollableInputStream` methods is
    undefined.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_poll(self) -> bool:
        """
            Checks if `stream` is actually pollable. Some classes may implement
        GPollableInputStream but have only certain instances of that class
        be pollable. If this method returns False, then the behavior of
        other GPollableInputStream methods is undefined.

        For any given stream, the value returned by this method is constant;
        a stream cannot switch from pollable to non-pollable or vice versa.
        """
    def create_source(self, cancellable: Cancellable | None = None) -> GLib.Source:
        """
            Creates a GSource that triggers when `stream` can be read, or
        `cancellable` is triggered or an error occurs. The callback on the
        source is of the GPollableSourceFunc type.

        As with `g_pollable_input_stream_is_readable`, it is possible that
        the stream may not actually be readable even after the source
        triggers, so you should use `g_pollable_input_stream_read_nonblocking`
        rather than `g_input_stream_read` from the callback.

        The behaviour of this method is undefined if
        `g_pollable_input_stream_can_poll` returns False for `stream`.
        """
    def is_readable(self) -> bool:
        """
            Checks if `stream` can be read.

        Note that some stream types may not be able to implement this 100%
        reliably, and it is possible that a call to `g_input_stream_read`
        after this returns True would still block. To guarantee
        non-blocking behavior, you should always use
        `g_pollable_input_stream_read_nonblocking`, which will return a
        G_IO_ERROR_WOULD_BLOCK error rather than blocking.

        The behaviour of this method is undefined if
        `g_pollable_input_stream_can_poll` returns False for `stream`.
        """
    def read_nonblocking(self, count: int, cancellable: Cancellable | None = None) -> tuple[int, list]:
        """
            Attempts to read up to `count` bytes from `stream` into `buffer`, as
        with `g_input_stream_read`. If `stream` is not currently readable,
        this will immediately return G_IO_ERROR_WOULD_BLOCK, and you can
        use `g_pollable_input_stream_create_source` to create a GSource
        that will be triggered when `stream` is readable.

        Note that since this method never blocks, you cannot actually
        use `cancellable` to cancel it. However, it will return an error
        if `cancellable` has already been cancelled when you call, which
        may happen if you call this method after a source triggers due
        to having been cancelled.

        The behaviour of this method is undefined if
        `g_pollable_input_stream_can_poll` returns False for `stream`.
        """

class PollableInputStreamInterface(GObject.GPointer):
    """
    The interface for pollable input streams.

    The default implementation of `can_poll` always returns True.

    The default implementation of `read_nonblocking` calls
    `g_pollable_input_stream_is_readable`, and then calls
    `g_input_stream_read` if it returns True. This means you only need
    to override it if it is possible that your `is_readable`
    implementation may return True when the stream is not actually
    readable.
    """

    # gi Fields
    @builtins.property
    def can_poll(self) -> can_pollPollableInputStreamInterfaceCB:
        """
        Checks if the GPollableInputStream instance is actually pollable
        """
    @builtins.property
    def create_source(self) -> create_sourcePollableInputStreamInterfaceCB:
        """
        Creates a GSource to poll the stream
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def is_readable(self) -> is_readablePollableInputStreamInterfaceCB:
        """
        Checks if the stream is readable
        """
    @builtins.property
    def read_nonblocking(self) -> read_nonblockingPollableInputStreamInterfaceCB:
        """
          Does a non-blocking read or returns
        G_IO_ERROR_WOULD_BLOCK
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PollableOutputStream(GObject.GInterface):
    """
    `GPollableOutputStream` is implemented by [class`Gio`.OutputStream]s that
    can be polled for readiness to write. This can be used when
    interfacing with a non-GIO API that expects
    UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.

    Some classes may implement `GPollableOutputStream` but have only certain
    instances of that class be pollable. If [method`Gio`.PollableOutputStream.can_poll]
    returns false, then the behavior of other `GPollableOutputStream` methods is
    undefined.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_poll(self) -> bool:
        """
            Checks if `stream` is actually pollable. Some classes may implement
        GPollableOutputStream but have only certain instances of that
        class be pollable. If this method returns False, then the behavior
        of other GPollableOutputStream methods is undefined.

        For any given stream, the value returned by this method is constant;
        a stream cannot switch from pollable to non-pollable or vice versa.
        """
    def create_source(self, cancellable: Cancellable | None = None) -> GLib.Source:
        """
            Creates a GSource that triggers when `stream` can be written, or
        `cancellable` is triggered or an error occurs. The callback on the
        source is of the GPollableSourceFunc type.

        As with `g_pollable_output_stream_is_writable`, it is possible that
        the stream may not actually be writable even after the source
        triggers, so you should use `g_pollable_output_stream_write_nonblocking`
        rather than `g_output_stream_write` from the callback.

        The behaviour of this method is undefined if
        `g_pollable_output_stream_can_poll` returns False for `stream`.
        """
    def is_writable(self) -> bool:
        """
            Checks if `stream` can be written.

        Note that some stream types may not be able to implement this 100%
        reliably, and it is possible that a call to `g_output_stream_write`
        after this returns True would still block. To guarantee
        non-blocking behavior, you should always use
        `g_pollable_output_stream_write_nonblocking`, which will return a
        G_IO_ERROR_WOULD_BLOCK error rather than blocking.

        The behaviour of this method is undefined if
        `g_pollable_output_stream_can_poll` returns False for `stream`.
        """
    def write_nonblocking(self, buffer: list, count: int, cancellable: Cancellable | None = None) -> int:
        """
            Attempts to write up to `count` bytes from `buffer` to `stream`, as
        with `g_output_stream_write`. If `stream` is not currently writable,
        this will immediately return G_IO_ERROR_WOULD_BLOCK, and you can
        use `g_pollable_output_stream_create_source` to create a GSource
        that will be triggered when `stream` is writable.

        Note that since this method never blocks, you cannot actually
        use `cancellable` to cancel it. However, it will return an error
        if `cancellable` has already been cancelled when you call, which
        may happen if you call this method after a source triggers due
        to having been cancelled.

        Also note that if G_IO_ERROR_WOULD_BLOCK is returned some underlying
        transports like D/TLS require that you re-send the same `buffer` and
        `count` in the next write call.

        The behaviour of this method is undefined if
        `g_pollable_output_stream_can_poll` returns False for `stream`.
        """
    def writev_nonblocking(
        self, vectors: list, n_vectors: int, cancellable: Cancellable | None = None
    ) -> tuple[PollableReturn, int]:
        """
            Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream`,
        as with `g_output_stream_writev`. If `stream` is not currently writable,
        this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK`, and you can
        use `g_pollable_output_stream_create_source` to create a GSource
        that will be triggered when `stream` is writable. `error` will *not* be
        set in that case.

        Note that since this method never blocks, you cannot actually
        use `cancellable` to cancel it. However, it will return an error
        if `cancellable` has already been cancelled when you call, which
        may happen if you call this method after a source triggers due
        to having been cancelled.

        Also note that if G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
        transports like D/TLS require that you re-send the same `vectors` and
        `n_vectors` in the next write call.

        The behaviour of this method is undefined if
        `g_pollable_output_stream_can_poll` returns False for `stream`.
        """

class PollableOutputStreamInterface(GObject.GPointer):
    """
    The interface for pollable output streams.

    The default implementation of `can_poll` always returns True.

    The default implementation of `write_nonblocking` calls
    `g_pollable_output_stream_is_writable`, and then calls
    `g_output_stream_write` if it returns True. This means you only
    need to override it if it is possible that your `is_writable`
    implementation may return True when the stream is not actually
    writable.

    The default implementation of `writev_nonblocking` calls
    `g_pollable_output_stream_write_nonblocking` for each vector, and converts
    its return value and error (if set) to a GPollableReturn. You should
    override this where possible to avoid having to allocate a GError to return
    G_IO_ERROR_WOULD_BLOCK.
    """

    # gi Fields
    @builtins.property
    def can_poll(self) -> can_pollPollableOutputStreamInterfaceCB:
        """
        Checks if the GPollableOutputStream instance is actually pollable
        """
    @builtins.property
    def create_source(self) -> create_sourcePollableOutputStreamInterfaceCB:
        """
        Creates a GSource to poll the stream
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def is_writable(self) -> is_writablePollableOutputStreamInterfaceCB:
        """
        Checks if the stream is writable
        """
    @builtins.property
    def write_nonblocking(self) -> write_nonblockingPollableOutputStreamInterfaceCB:
        """
          Does a non-blocking write or returns
        G_IO_ERROR_WOULD_BLOCK
        """
    @builtins.property
    def writev_nonblocking(self) -> writev_nonblockingPollableOutputStreamInterfaceCB:
        """
          Does a vectored non-blocking write, or returns
        G_POLLABLE_RETURN_WOULD_BLOCK
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PowerProfileMonitor(GObject.GInterface):
    """
    `GPowerProfileMonitor` makes it possible for applications as well as OS
    components to monitor system power profiles and act upon them. It currently
    only exports whether the system is in “Power Saver” mode (known as
    “Low Power” mode on some systems).

    When in “Low Power” mode, it is recommended that applications:

    - disable automatic downloads;
    - reduce the rate of refresh from online sources such as calendar or
      email synchronisation;
    - reduce the use of expensive visual effects.

    It is also likely that OS components providing services to applications will
    lower their own background activity, for the sake of the system.

    There are a variety of tools that exist for power consumption analysis, but those
    usually depend on the OS and hardware used. On Linux, one could use `upower` to
    monitor the battery discharge rate, `powertop` to check on the background activity
    or activity at all), `sysprof` to inspect CPU usage, and `intel_gpu_time` to
    profile GPU usage.

    Don’t forget to disconnect the [signal`GObject`.Object::notify] signal for
    [property`Gio`.PowerProfileMonitor:power-saver-enabled], and unref the
    `GPowerProfileMonitor` itself when exiting.
    """

    class Props(GObject.GInterface.Props):
        power_saver_enabled: bool  # [power-saver-enabled]: changed because contained invalid characters
        """
        Whether “Power Saver” mode is enabled on the system.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def dup_default() -> PowerProfileMonitor:
        """
        Gets a reference to the default GPowerProfileMonitor for the system.
        """
    @builtins.property
    def get_power_saver_enabled(self) -> bool:
        """
            Gets whether the system is in “Power Saver” mode.

        You are expected to listen to the
        GPowerProfileMonitor::notify::power-saver-enabled signal to know when the profile has
        changed.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::power_saver_enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class PowerProfileMonitorInterface(GObject.GPointer):
    """
    The virtual function table for GPowerProfileMonitor.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class PropertyAction(GObject.Object):
    """
    A `GPropertyAction` is a way to get a [iface`Gio`.Action] with a state value
    reflecting and controlling the value of a [class`GObject`.Object] property.

    The state of the action will correspond to the value of the property.
    Changing it will change the property (assuming the requested value
    matches the requirements as specified in the [type`GObject`.ParamSpec]).

    Only the most common types are presently supported.  Booleans are
    mapped to booleans, strings to strings, signed/unsigned integers to
    int32/uint32 and floats and doubles to doubles.

    If the property is an enum then the state will be string-typed and
    conversion will automatically be performed between the enum value and
    ‘nick’ string as per the [type`GObject`.EnumValue] table.

    Flags types are not currently supported.

    Properties of object types, boxed types and pointer types are not
    supported and probably never will be.

    Properties of [type`GLib`.Variant] types are not currently supported.

    If the property is boolean-valued then the action will have a `None`
    parameter type, and activating the action (with no parameter) will
    toggle the value of the property.

    In all other cases, the parameter type will correspond to the type of
    the property.

    The general idea here is to reduce the number of locations where a
    particular piece of state is kept (and therefore has to be synchronised
    between). `GPropertyAction` does not have a separate state that is kept
    in sync with the property value — its state is the property value.

    For example, it might be useful to create a [iface`Gio`.Action] corresponding
    to the `visible-child-name` property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html)
    so that the current page can be switched from a menu.  The active radio
    indication in the menu is then directly determined from the active page of
    the `GtkStack`.

    An anti-example would be binding the `active-id` property on a
    [`GtkComboBox`](https://docs.gtk.org/gtk4/class.ComboBox.html). This is
    because the state of the combo box itself is probably uninteresting and is
    actually being used to control something else.

    Another anti-example would be to bind to the `visible-child-name`
    property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html) if
    this value is actually stored in [class`Gio`.Settings].  In that case, the
    real source of the value is* [class`Gio`.Settings].  If you want
    a [iface`Gio`.Action] to control a setting stored in [class`Gio`.Settings],
    see [method`Gio`.Settings.create_action] instead, and possibly combine its
    use with [method`Gio`.Settings.bind].
    """

    class Props(GObject.Object.Props):
        enabled: bool
        """
        If `action` is currently enabled.

        If the action is disabled then calls to `g_action_activate` and
        `g_action_change_state` have no effect.
        """
        invert_boolean: bool  # [invert-boolean]: changed because contained invalid characters
        """
        If True, the state of the action will be the negation of the
        property value, provided the property is boolean.
        """
        name: str
        """
        The name of the action.  This is mostly meaningful for identifying
        the action once it has been added to a GActionMap.
        """
        object: GObject.Object | None
        """
        The object to wrap a property on.

        The object must be a non-None GObject with properties.
        """
        parameter_type: GLib.VariantType | None  # [parameter-type]: changed because contained invalid characters
        """
        The type of the parameter that must be given when activating the
        action.
        """
        property_name: str  # [property-name]: changed because contained invalid characters
        """
        The name of the property to wrap on the object.

        The property must exist on the passed-in object and it must be
        readable and writable (and not construct-only).
        """
        state: GLib.Variant | None
        """
        The state of the action, or None if the action is stateless.
        """
        state_type: GLib.VariantType | None  # [state-type]: changed because contained invalid characters
        """
        The GVariantType of the state that the action has, or None if the
        action is stateless.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self, invert_boolean: bool = ..., name: str = ..., object: GObject.Object | None = ..., property_name: str = ...
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, name: str, object: GObject.Object, property_name: str) -> PropertyAction:
        """
            Creates a GAction corresponding to the value of property
        `property_name` on `object`.

        The property must be existent and readable and writable (and not
        construct-only).

        This function takes a reference on `object` and doesn't release it
        until the action is destroyed.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::invert_boolean"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::object"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parameter_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::property_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Proxy(GObject.GInterface):
    """
    A `GProxy` handles connecting to a remote host via a given type of
    proxy server. It is implemented by the `gio-proxy` extension point.
    The extensions are named after their proxy protocol name. As an
    example, a SOCKS5 proxy implementation can be retrieved with the
    name `socks5` using the function
    [method`Gio`.IOExtensionPoint.get_extension_by_name].
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def connect(
        self, connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | None = None
    ) -> IOStream:
        """
            Given `connection` to communicate with a proxy (eg, a
        GSocketConnection that is connected to the proxy server), this
        does the necessary handshake to connect to `proxy_address`, and if
        required, wraps the GIOStream to handle proxy payload.

        [note from gi-stub-gen] Proxy has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    async def connect_async(
        self,
        connection: IOStream,
        proxy_address: ProxyAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
        Asynchronous version of `g_proxy_connect`.
        """
    def connect_finish(self, result: AsyncResult) -> IOStream:
        """
        See `g_proxy_connect`.
        """
    @staticmethod
    def get_default_for_protocol(protocol: str) -> Proxy | None:
        """
            Find the `gio-proxy` extension point for a proxy implementation that supports
        the specified protocol.
        """
    def supports_hostname(self) -> bool:
        """
            Some proxy protocols expect to be passed a hostname, which they
        will resolve to an IP address themselves. Others, like SOCKS4, do
        not allow this. This function will return False if `proxy` is
        implementing such a protocol. When False is returned, the caller
        should resolve the destination hostname first, and then pass a
        GProxyAddress containing the stringified IP address to
        `g_proxy_connect` or `g_proxy_connect_async`.
        """

class ProxyAddress(InetSocketAddress):
    """
    A [class`Gio`.InetSocketAddress] representing a connection via a proxy server.
    """

    class Props(InetSocketAddress.Props):
        destination_hostname: str  # [destination-hostname]: changed because contained invalid characters
        """
        The proxy destination hostname.
        """
        destination_port: int  # [destination-port]: changed because contained invalid characters
        """
        The proxy destination port.
        """
        destination_protocol: str  # [destination-protocol]: changed because contained invalid characters
        """
        The protocol being spoke to the destination host, or None if
        the GProxyAddress doesn't know.
        """
        password: str
        """
        The proxy password.
        """
        protocol: str
        """
        The proxy protocol.
        """
        uri: str
        """
        The URI string that the proxy was constructed from (or None
        if the creator didn't specify this).
        """
        username: str
        """
        The proxy username.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> InetSocketAddress | None: ...
    @builtins.property
    def priv(self) -> ProxyAddressPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        destination_hostname: str = ...,
        destination_port: int = ...,
        destination_protocol: str = ...,
        password: str = ...,
        protocol: str = ...,
        uri: str = ...,
        username: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_destination_hostname(self) -> str:
        """
            Gets `proxy`'s destination hostname; that is, the name of the host
        that will be connected to via the proxy, not the name of the proxy
        itself.
        """
    @builtins.property
    def get_destination_port(self) -> int:
        """
            Gets `proxy`'s destination port; that is, the port on the
        destination host that will be connected to via the proxy, not the
        port number of the proxy itself.
        """
    @builtins.property
    def get_destination_protocol(self) -> str:
        """
            Gets the protocol that is being spoken to the destination
        server; eg, "http" or "ftp".
        """
    @builtins.property
    def get_password(self) -> str | None:
        """
        Gets `proxy`'s password.
        """
    @builtins.property
    def get_protocol(self) -> str:
        """
        Gets `proxy`'s protocol. eg, "socks" or "http"
        """
    @builtins.property
    def get_uri(self) -> str | None:
        """
        Gets the proxy URI that `proxy` was constructed from.
        """
    @builtins.property
    def get_username(self) -> str | None:
        """
        Gets `proxy`'s username.
        """
    @classmethod
    def new(
        cls,
        inetaddr: InetAddress,
        port: int,
        protocol: str,
        dest_hostname: str,
        dest_port: int,
        username: str | None = None,
        password: str | None = None,
    ) -> ProxyAddress:
        """
            Creates a new GProxyAddress for `inetaddr` with `protocol` that should
        tunnel through `dest_hostname` and `dest_port`.

        (Note that this method doesn't set the GProxyAddress:uri or
        GProxyAddress:destination-protocol fields; use `g_object_new`
        directly if you want to set those.)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::destination_hostname"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::destination_port"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::destination_protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::password"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::username"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ProxyAddressClass(GObject.GPointer):
    """
    Class structure for GProxyAddress.
    """

    # gi Fields
    @builtins.property
    def parent_class(self) -> InetSocketAddressClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ProxyAddressEnumerator(SocketAddressEnumerator):
    """
    `GProxyAddressEnumerator` is a wrapper around
    [class`Gio`.SocketAddressEnumerator] which takes the [class`Gio`.SocketAddress]
    instances returned by the [class`Gio`.SocketAddressEnumerator]
    and wraps them in [class`Gio`.ProxyAddress] instances, using the given
    [property`Gio`.ProxyAddressEnumerator:proxy-resolver].

    This enumerator will be returned (for example, by
    [method`Gio`.SocketConnectable.enumerate]) as appropriate when a proxy is
    configured; there should be no need to manually wrap a
    [class`Gio`.SocketAddressEnumerator] instance with one.
    """

    class Props(SocketAddressEnumerator.Props):
        connectable: SocketConnectable | None
        """
        The connectable being enumerated.
        """
        default_port: int  # [default-port]: changed because contained invalid characters
        """
        The default port to use if GProxyAddressEnumerator:uri does not
        specify one.
        """
        proxy_resolver: ProxyResolver | None  # [proxy-resolver]: changed because contained invalid characters
        """
        The proxy resolver to use.
        """
        uri: str
        """
        The destination URI. Use `none://` for a generic socket.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> SocketAddressEnumerator | None: ...
    @builtins.property
    def priv(self) -> ProxyAddressEnumeratorPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        connectable: SocketConnectable | None = ...,
        default_port: int = ...,
        proxy_resolver: ProxyResolver | None = ...,
        uri: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::connectable"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_port"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::proxy_resolver"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ProxyAddressEnumeratorClass(GObject.GPointer):
    """
    Class structure for GProxyAddressEnumerator.
    """

    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def _g_reserved7(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> SocketAddressEnumeratorClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ProxyAddressEnumeratorPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ProxyAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ProxyInterface(GObject.GPointer):
    """
    Provides an interface for handling proxy connection and payload.
    """

    # gi Fields
    @builtins.property
    def connect(self) -> connectProxyInterfaceCB:
        """
        Connect to proxy server and wrap (if required) the #connection
              to handle payload.
        """
    @builtins.property
    def connect_async(self) -> connect_asyncProxyInterfaceCB:
        """
        Same as `connect` but asynchronous.
        """
    @builtins.property
    def connect_finish(self) -> connect_finishProxyInterfaceCB:
        """
        Returns the result of `connect_async`
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def supports_hostname(self) -> supports_hostnameProxyInterfaceCB:
        """
        Returns whether the proxy supports hostname lookups.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ProxyResolver(GObject.GInterface):
    """
    `GProxyResolver` provides synchronous and asynchronous network proxy
    resolution. `GProxyResolver` is used within [class`Gio`.SocketClient] through
    the method [method`Gio`.SocketConnectable.proxy_enumerate].

    Implementations of `GProxyResolver` based on
    [libproxy](https://github.com/libproxy/libproxy) and GNOME settings can be
    found in [glib-networking](https://gitlab.gnome.org/GNOME/glib-networking).
    GIO comes with an implementation for use inside Flatpak portals.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_default() -> ProxyResolver:
        """
        Gets the default GProxyResolver for the system.
        """
    def is_supported(self) -> bool:
        """
            Checks if `resolver` can be used on this system. (This is used
        internally; `g_proxy_resolver_get_default` will only return a proxy
        resolver that returns True for this method.)
        """
    def lookup(self, uri: str, cancellable: Cancellable | None = None) -> list:
        """
            Looks into the system proxy configuration to determine what proxy,
        if any, to use to connect to `uri`. The returned proxy URIs are of
        the form `<protocol>://[user[:password]@]host[:port]` or
        `direct://`, where `<protocol>` could be http, rtsp, socks
        or other proxying protocol.

        If you don't know what network protocol is being used on the
        socket, you should use `none` as the URI protocol.
        In this case, the resolver might still return a generic proxy type
        (such as SOCKS), but would not return protocol-specific proxy types
        (such as http).

        `direct://` is used when no proxy is needed.
        Direct connection should not be attempted unless it is part of the
        returned array of proxies.
        """
    async def lookup_async(
        self,
        uri: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronous lookup of proxy. See `g_proxy_resolver_lookup` for more
        details.
        """
    def lookup_finish(self, result: AsyncResult) -> list:
        """
            Call this function to obtain the array of proxy URIs when
        `g_proxy_resolver_lookup_async` is complete. See
        `g_proxy_resolver_lookup` for more details.
        """

class ProxyResolverInterface(GObject.GPointer):
    """
    The virtual function table for GProxyResolver.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def is_supported(self) -> is_supportedProxyResolverInterfaceCB:
        """
        the virtual function pointer for `g_proxy_resolver_is_supported`
        """
    @builtins.property
    def lookup(self) -> lookupProxyResolverInterfaceCB:
        """
        the virtual function pointer for `g_proxy_resolver_lookup`
        """
    @builtins.property
    def lookup_async(self) -> lookup_asyncProxyResolverInterfaceCB:
        """
           the virtual function pointer for
        `g_proxy_resolver_lookup_async`
        """
    @builtins.property
    def lookup_finish(self) -> lookup_finishProxyResolverInterfaceCB:
        """
           the virtual function pointer for
        `g_proxy_resolver_lookup_finish`
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class RemoteActionGroup(GObject.GInterface):
    """
    The `GRemoteActionGroup` interface is implemented by [iface`Gio`.ActionGroup]
    instances that either transmit action invocations to other processes
    or receive action invocations in the local process from other
    processes.

    The interface has `_full` variants of the two
    methods on [iface`Gio`.ActionGroup] used to activate actions:
    [method`Gio`.ActionGroup.activate_action] and
    [method`Gio`.ActionGroup.change_action_state]. These variants allow a
    ‘platform data’ [struct`GLib`.Variant] to be specified: a dictionary providing
    context for the action invocation (for example: timestamps, startup
    notification IDs, etc).

    [class`Gio`.DBusActionGroup] implements `GRemoteActionGroup`.  This provides a
    mechanism to send platform data for action invocations over D-Bus.

    Additionally, [method`Gio`.DBusConnection.export_action_group] will check if
    the exported [iface`Gio`.ActionGroup] implements `GRemoteActionGroup` and use
    the `_full` variants of the calls if available.  This
    provides a mechanism by which to receive platform data for action
    invocations that arrive by way of D-Bus.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def activate_action_full(
        self, action_name: str, parameter: GLib.Variant | None, platform_data: GLib.Variant
    ) -> None:
        """
            Activates the remote action.

        This is the same as `g_action_group_activate_action` except that it
        allows for provision of "platform data" to be sent along with the
        activation request.  This typically contains details such as the user
        interaction timestamp or startup notification information.

        `platform_data` must be non-None and must have the type
        G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
        """
    def change_action_state_full(self, action_name: str, value: GLib.Variant, platform_data: GLib.Variant) -> None:
        """
            Changes the state of a remote action.

        This is the same as `g_action_group_change_action_state` except that
        it allows for provision of "platform data" to be sent along with the
        state change request.  This typically contains details such as the
        user interaction timestamp or startup notification information.

        `platform_data` must be non-None and must have the type
        G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
        """

class RemoteActionGroupInterface(GObject.GPointer):
    """
    The virtual function table for GRemoteActionGroup.
    """

    # gi Fields
    @builtins.property
    def activate_action_full(self) -> activate_action_fullRemoteActionGroupInterfaceCB:
        """
        the virtual function pointer for `g_remote_action_group_activate_action_full`
        """
    @builtins.property
    def change_action_state_full(self) -> change_action_state_fullRemoteActionGroupInterfaceCB:
        """
        the virtual function pointer for `g_remote_action_group_change_action_state_full`
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Resolver(GObject.Object):
    """
    The object that handles DNS resolution. Use [func`Gio`.Resolver.get_default]
    to get the default resolver.

    `GResolver` provides cancellable synchronous and asynchronous DNS
    resolution, for hostnames ([method`Gio`.Resolver.lookup_by_address],
    [method`Gio`.Resolver.lookup_by_name] and their async variants) and SRV
    (service) records ([method`Gio`.Resolver.lookup_service]).

    [class`Gio`.NetworkAddress] and [class`Gio`.NetworkService] provide wrappers
    around `GResolver` functionality that also implement
    [iface`Gio`.SocketConnectable], making it easy to connect to a remote
    host/service.

    The default resolver (see [func`Gio`.Resolver.get_default]) has a timeout of
    30s set on it since GLib 2.78. Earlier versions of GLib did not support
    resolver timeouts.

    This is an abstract type; subclasses of it implement different resolvers for
    different platforms and situations.
    """

    class Props(GObject.Object.Props):
        timeout: int
        """
        The timeout applied to all resolver lookups, in milliseconds.

        This may be changed through the lifetime of the GResolver. The new value
        will apply to any lookups started after the change, but not to any
        already-ongoing lookups.

        If this is `0`, no timeout is applied to lookups.

        No timeout was applied to lookups before this property was added in
        GLib 2.78.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> ResolverPrivate | None: ...

    # gi Methods
    def __init__(self, timeout: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_default() -> Resolver:
        """
            Gets the default GResolver. You should unref it when you are done
        with it. GResolver may use its reference count as a hint about how
        many threads it should allocate for concurrent DNS resolutions.
        """
    @builtins.property
    def get_timeout(self) -> int:
        """
        Get the timeout applied to all resolver lookups. See GResolver:timeout.
        """
    def lookup_by_address(self, address: InetAddress, cancellable: Cancellable | None = None) -> str:
        """
            Synchronously reverse-resolves `address` to determine its
        associated hostname.

        If the DNS resolution fails, `error` (if non-None) will be set to
        a value from GResolverError.

        If `cancellable` is non-None, it can be used to cancel the
        operation, in which case `error` (if non-None) will be set to
        G_IO_ERROR_CANCELLED.
        """
    async def lookup_by_address_async(
        self,
        address: InetAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Begins asynchronously reverse-resolving `address` to determine its
        associated hostname, and eventually calls `callback`, which must
        call `g_resolver_lookup_by_address_finish` to get the final result.
        """
    def lookup_by_address_finish(self, result: AsyncResult) -> str:
        """
            Retrieves the result of a previous call to
        `g_resolver_lookup_by_address_async`.

        If the DNS resolution failed, `error` (if non-None) will be set to
        a value from GResolverError. If the operation was cancelled,
        `error` will be set to G_IO_ERROR_CANCELLED.
        """
    def lookup_by_name(self, hostname: str, cancellable: Cancellable | None = None) -> list:
        """
            Synchronously resolves `hostname` to determine its associated IP
        address(es). `hostname` may be an ASCII-only or UTF-8 hostname, or
        the textual form of an IP address (in which case this just becomes
        a wrapper around `g_inet_address_new_from_string`).

        On success, `g_resolver_lookup_by_name` will return a non-empty GList of
        GInetAddress, sorted in order of preference and guaranteed to not
        contain duplicates. That is, if using the result to connect to
        `hostname`, you should attempt to connect to the first address
        first, then the second if the first fails, etc. If you are using
        the result to listen on a socket, it is appropriate to add each
        result using e.g. `g_socket_listener_add_address`.

        If the DNS resolution fails, `error` (if non-None) will be set to a
        value from GResolverError and None will be returned.

        If `cancellable` is non-None, it can be used to cancel the
        operation, in which case `error` (if non-None) will be set to
        G_IO_ERROR_CANCELLED.

        If you are planning to connect to a socket on the resolved IP
        address, it may be easier to create a GNetworkAddress and use its
        GSocketConnectable interface.
        """
    async def lookup_by_name_async(
        self,
        hostname: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Begins asynchronously resolving `hostname` to determine its
        associated IP address(es), and eventually calls `callback`, which
        must call `g_resolver_lookup_by_name_finish` to get the result.
        See `g_resolver_lookup_by_name` for more details.
        """
    def lookup_by_name_finish(self, result: AsyncResult) -> list:
        """
            Retrieves the result of a call to
        `g_resolver_lookup_by_name_async`.

        If the DNS resolution failed, `error` (if non-None) will be set to
        a value from GResolverError. If the operation was cancelled,
        `error` will be set to G_IO_ERROR_CANCELLED.
        """
    def lookup_by_name_with_flags(
        self, hostname: str, flags: ResolverNameLookupFlags, cancellable: Cancellable | None = None
    ) -> list:
        """
            This differs from `g_resolver_lookup_by_name` in that you can modify
        the lookup behavior with `flags`. For example this can be used to limit
        results with G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
        """
    async def lookup_by_name_with_flags_async(
        self,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Begins asynchronously resolving `hostname` to determine its
        associated IP address(es), and eventually calls `callback`, which
        must call `g_resolver_lookup_by_name_with_flags_finish` to get the result.
        See `g_resolver_lookup_by_name` for more details.
        """
    def lookup_by_name_with_flags_finish(self, result: AsyncResult) -> list:
        """
            Retrieves the result of a call to
        `g_resolver_lookup_by_name_with_flags_async`.

        If the DNS resolution failed, `error` (if non-None) will be set to
        a value from GResolverError. If the operation was cancelled,
        `error` will be set to G_IO_ERROR_CANCELLED.
        """
    def lookup_records(
        self, rrname: str, record_type: ResolverRecordType, cancellable: Cancellable | None = None
    ) -> list:
        """
            Synchronously performs a DNS record lookup for the given `rrname` and returns
        a list of records as GVariant tuples. See GResolverRecordType for
        information on what the records contain for each `record_type`.

        If the DNS resolution fails, `error` (if non-None) will be set to
        a value from GResolverError and None will be returned.

        If `cancellable` is non-None, it can be used to cancel the
        operation, in which case `error` (if non-None) will be set to
        G_IO_ERROR_CANCELLED.
        """
    async def lookup_records_async(
        self,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Begins asynchronously performing a DNS lookup for the given
        `rrname`, and eventually calls `callback`, which must call
        `g_resolver_lookup_records_finish` to get the final result. See
        `g_resolver_lookup_records` for more details.
        """
    def lookup_records_finish(self, result: AsyncResult) -> list:
        """
            Retrieves the result of a previous call to
        `g_resolver_lookup_records_async`. Returns a non-empty list of records as
        GVariant tuples. See GResolverRecordType for information on what the
        records contain.

        If the DNS resolution failed, `error` (if non-None) will be set to
        a value from GResolverError. If the operation was cancelled,
        `error` will be set to G_IO_ERROR_CANCELLED.
        """
    def lookup_service(self, service: str, protocol: str, domain: str, cancellable: Cancellable | None = None) -> list:
        """
            Synchronously performs a DNS SRV lookup for the given `service` and
        `protocol` in the given `domain` and returns an array of GSrvTarget.
        `domain` may be an ASCII-only or UTF-8 hostname. Note also that the
        `service` and `protocol` arguments do not include the leading underscore
        that appears in the actual DNS entry.

        On success, `g_resolver_lookup_service` will return a non-empty GList of
        GSrvTarget, sorted in order of preference. (That is, you should
        attempt to connect to the first target first, then the second if
        the first fails, etc.)

        If the DNS resolution fails, `error` (if non-None) will be set to
        a value from GResolverError and None will be returned.

        If `cancellable` is non-None, it can be used to cancel the
        operation, in which case `error` (if non-None) will be set to
        G_IO_ERROR_CANCELLED.

        If you are planning to connect to the service, it is usually easier
        to create a GNetworkService and use its GSocketConnectable
        interface.
        """
    async def lookup_service_async(
        self,
        service: str,
        protocol: str,
        domain: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Begins asynchronously performing a DNS SRV lookup for the given
        `service` and `protocol` in the given `domain`, and eventually calls
        `callback`, which must call `g_resolver_lookup_service_finish` to
        get the final result. See `g_resolver_lookup_service` for more
        details.
        """
    def lookup_service_finish(self, result: AsyncResult) -> list:
        """
            Retrieves the result of a previous call to
        `g_resolver_lookup_service_async`.

        If the DNS resolution failed, `error` (if non-None) will be set to
        a value from GResolverError. If the operation was cancelled,
        `error` will be set to G_IO_ERROR_CANCELLED.
        """
    def set_default(self) -> None:
        """
            Sets `resolver` to be the application's default resolver (reffing
        `resolver`, and unreffing the previous default resolver, if any).
        Future calls to `g_resolver_get_default` will return this resolver.

        This can be used if an application wants to perform any sort of DNS
        caching or "pinning"; it can implement its own GResolver that
        calls the original default resolver for DNS operations, and
        implements its own cache policies on top of that, and then set
        itself as the default resolver for all later code to use.
        """
    def set_timeout(self, timeout_ms: int) -> None:
        """
        Set the timeout applied to all resolver lookups. See GResolver:timeout.
        """

    # python methods (overrides?)
    def do_lookup_by_address(
        self,
        address: InetAddress,
        cancellable: Cancellable | None = None,
    ) -> str:
        """
        lookup_by_address(self, address:Gio.InetAddress, cancellable:Gio.Cancellable=None) -> str
        """
    def do_lookup_by_address_async(
        self,
        address: InetAddress,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_by_address_async(self, address:Gio.InetAddress, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_by_address_finish(
        self,
        result: AsyncResult,
    ) -> str:
        """
        lookup_by_address_finish(self, result:Gio.AsyncResult) -> str
        """
    def do_lookup_by_name(
        self,
        hostname: str,
        cancellable: Cancellable | None = None,
    ) -> list:
        """
        lookup_by_name(self, hostname:str, cancellable:Gio.Cancellable=None) -> list
        """
    def do_lookup_by_name_async(
        self,
        hostname: str,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_by_name_async(self, hostname:str, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_by_name_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_by_name_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_lookup_by_name_with_flags(
        self,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list:
        """
        lookup_by_name_with_flags(self, hostname:str, flags:Gio.ResolverNameLookupFlags, cancellable:Gio.Cancellable=None) -> list
        """
    def do_lookup_by_name_with_flags_async(
        self,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_by_name_with_flags_async(self, hostname:str, flags:Gio.ResolverNameLookupFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_by_name_with_flags_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_by_name_with_flags_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_lookup_records(
        self,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
    ) -> list:
        """
        lookup_records(self, rrname:str, record_type:Gio.ResolverRecordType, cancellable:Gio.Cancellable=None) -> list
        """
    def do_lookup_records_async(
        self,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_records_async(self, rrname:str, record_type:Gio.ResolverRecordType, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_records_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_records_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_lookup_service_async(
        self,
        rrname: str,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_service_async(self, rrname:str, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_service_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_service_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_reload(
        self,
    ) -> None:
        """
        reload(self)
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["reload"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            Emitted when the resolver notices that the system resolver
        configuration has changed.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::timeout"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ResolverClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def lookup_by_address(self) -> lookup_by_addressResolverClassCB: ...
    @builtins.property
    def lookup_by_address_async(self) -> lookup_by_address_asyncResolverClassCB: ...
    @builtins.property
    def lookup_by_address_finish(self) -> lookup_by_address_finishResolverClassCB: ...
    @builtins.property
    def lookup_by_name(self) -> lookup_by_nameResolverClassCB: ...
    @builtins.property
    def lookup_by_name_async(self) -> lookup_by_name_asyncResolverClassCB: ...
    @builtins.property
    def lookup_by_name_finish(self) -> lookup_by_name_finishResolverClassCB: ...
    @builtins.property
    def lookup_by_name_with_flags(self) -> lookup_by_name_with_flagsResolverClassCB: ...
    @builtins.property
    def lookup_by_name_with_flags_async(self) -> lookup_by_name_with_flags_asyncResolverClassCB: ...
    @builtins.property
    def lookup_by_name_with_flags_finish(self) -> lookup_by_name_with_flags_finishResolverClassCB: ...
    @builtins.property
    def lookup_records(self) -> lookup_recordsResolverClassCB: ...
    @builtins.property
    def lookup_records_async(self) -> lookup_records_asyncResolverClassCB: ...
    @builtins.property
    def lookup_records_finish(self) -> lookup_records_finishResolverClassCB: ...
    @builtins.property
    def lookup_service(self) -> object | None: ...
    @builtins.property
    def lookup_service_async(self) -> lookup_service_asyncResolverClassCB: ...
    @builtins.property
    def lookup_service_finish(self) -> lookup_service_finishResolverClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def reload(self) -> reloadResolverClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ResolverPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Resource(GObject.GBoxed):
    """
    Applications and libraries often contain binary or textual data that is
    really part of the application, rather than user data. For instance
    [`GtkBuilder`](https://docs.gtk.org/gtk4/class.Builder.html) `.ui` files,
    splashscreen images, [class`Gio`.Menu] markup XML, CSS files, icons, etc.
    These are often shipped as files in `$datadir/appname`, or manually
    included as literal strings in the code.

    The `GResource` API and the
    [`glib-compile-resources`](glib-compile-resources.html) program provide a
    convenient and efficient alternative to this which has some nice properties.
    You maintain the files as normal files, so it’s easy to edit them, but during
    the build the files are combined into a binary bundle that is linked into the
    executable. This means that loading the resource files are efficient (as they
    are already in memory, shared with other instances) and simple (no need to
    check for things like I/O errors or locate the files in the filesystem). It
    also makes it easier to create relocatable applications.

    Resource files can also be marked as compressed. Such files will be included
    in the resource bundle in a compressed form, but will be automatically
    uncompressed when the resource is used. This is very useful e.g. for larger
    text files that are parsed once (or rarely) and then thrown away.

    Resource files can also be marked to be preprocessed, by setting the value of the
    `preprocess` attribute to a comma-separated list of preprocessing options.
    The only options currently supported are:

     - `xml-stripblanks` which will use the [`xmllint`](man:xmllint(1)) command
       to strip ignorable whitespace from the XML file. For this to work,
       the `XMLLINT` environment variable must be set to the full path to
       the xmllint executable, or xmllint must be in the `PATH`; otherwise
       the preprocessing step is skipped.

     - `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
       `gdk-pixbuf-pixdata` command to convert images to the [`GdkPixdata`](https://docs.gtk.org/gdk-pixbuf/class.Pixdata.html)
       format, which allows you to create pixbufs directly using the data inside
       the resource file, rather than an (uncompressed) copy of it. For this, the
       `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
       `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to
       the `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will
       abort. `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as
       `GResource` supports embedding modern image formats just as well. Instead
       of using it, embed a PNG or SVG file in your `GResource`.

     - `json-stripblanks` which will use the
       [`json-glib-format`](man:json-glib-format(1)) command to strip ignorable
       whitespace from the JSON file. For this to work, the `JSON_GLIB_FORMAT`
       environment variable must be set to the full path to the
       `json-glib-format` executable, or it must be in the `PATH`; otherwise the
       preprocessing step is skipped. In addition, at least version 1.6 of
       `json-glib-format` is required.

    Resource files will be exported in the `GResource` namespace using the
    combination of the given `prefix` and the filename from the `file` element.
    The `alias` attribute can be used to alter the filename to expose them at a
    different location in the resource namespace. Typically, this is used to
    include files from a different source directory without exposing the source
    directory in the resource namespace, as in the example below.

    Resource bundles are created by the
    [`glib-compile-resources`](glib-compile-resources.html) program
    which takes an XML file that describes the bundle, and a set of files that
    the XML references. These are combined into a binary resource bundle.

    An example resource description:
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <gresources>
      <gresource prefix="/org/gtk/Example">
        <file>data/splashscreen.png</file>
        <file compressed="true">dialog.ui</file>
        <file preprocess="xml-stripblanks">menumarkup.xml</file>
        <file alias="example.css">data/example.css</file>
      </gresource>
    </gresources>
    ```

    This will create a resource bundle with the following files:
    ```
    /org/gtk/Example/data/splashscreen.png
    /org/gtk/Example/dialog.ui
    /org/gtk/Example/menumarkup.xml
    /org/gtk/Example/example.css
    ```

    Note that all resources in the process share the same namespace, so use
    Java-style path prefixes (like in the above example) to avoid conflicts.

    You can then use [`glib-compile-resources`](glib-compile-resources.html) to
    compile the XML to a binary bundle that you can load with
    [func`Gio`.Resource.load]. However, it’s more common to use the
    `--generate-source` and `--generate-header` arguments to create a source file
    and header to link directly into your application.
    This will generate ``get_resource``, ``register_resource`` and
    ``unregister_resource`` functions, prefixed by the `--c-name` argument passed
    to [`glib-compile-resources`](glib-compile-resources.html). ``get_resource``
    returns the generated `GResource` object. The register and unregister
    functions register the resource so its files can be accessed using
    [func`Gio`.resources_lookup_data].

    Once a `GResource` has been created and registered all the data in it can be
    accessed globally in the process by using API calls like
    [func`Gio`.resources_open_stream] to stream the data or
    [func`Gio`.resources_lookup_data] to get a direct pointer to the data. You can
    also use URIs like `resource:///org/gtk/Example/data/splashscreen.png` with
    [iface`Gio`.File] to access the resource data.

    Some higher-level APIs, such as [`GtkApplication`](https://docs.gtk.org/gtk4/class.Application.html),
    will automatically load resources from certain well-known paths in the
    resource namespace as a convenience. See the documentation for those APIs
    for details.

    There are two forms of the generated source, the default version uses the
    compiler support for constructor and destructor functions (where available)
    to automatically create and register the `GResource` on startup or library
    load time. If you pass `--manual-register`, two functions to
    register/unregister the resource are created instead. This requires an
    explicit initialization call in your application/library, but it works on all
    platforms, even on the minor ones where constructors are not supported.
    (Constructor support is available for at least Win32, Mac OS and Linux.)

    Note that resource data can point directly into the data segment of e.g. a
    library, so if you are unloading libraries during runtime you need to be very
    careful with keeping around pointers to data from a resource, as this goes
    away when the library is unloaded. However, in practice this is not generally
    a problem, since most resource accesses are for your own resources, and
    resource data is often used once, during parsing, and then released.

    # Overlays

    When debugging a program or testing a change to an installed version, it is
    often useful to be able to replace resources in the program or library,
    without recompiling, for debugging or quick hacking and testing purposes.
    Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment
    variable to selectively overlay resources with replacements from the
    filesystem.  It is a `G_SEARCHPATH_SEPARATOR`-separated list of substitutions
    to perform during resource lookups. It is ignored when running in a setuid
    process.

    A substitution has the form

    ```
    /org/gtk/libgtk=/home/desrt/gtk-overlay
    ```

    The part before the `=` is the resource subpath for which the overlay
    applies.  The part after is a filesystem path which contains files and
    subdirectories as you would like to be loaded as resources with the
    equivalent names.

    In the example above, if an application tried to load a resource with the
    resource path `/org/gtk/libgtk/ui/gtkdialog.ui` then `GResource` would check
    the filesystem path `/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was
    found there, it would be used instead.  This is an overlay, not an outright
    replacement, which means that if a file is not found at that path, the
    built-in version will be used instead.  Whiteouts are not currently
    supported.

    Substitutions must start with a slash, and must not contain a trailing slash
    before the `=`.  The path after the slash should ideally be absolute, but
    this is not strictly required.  It is possible to overlay the location of a
    single resource with an individual file.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def _register(self) -> None:
        """
            Registers the resource with the process-global set of resources.

        Once a resource is registered the files in it can be accessed
        with the global resource lookup functions like
        [func`Gio`.resources_lookup_data].
        """
    def _unregister(self) -> None:
        """
        Unregisters the resource from the process-global set of resources.
        """
    def enumerate_children(self, path: str, lookup_flags: ResourceLookupFlags) -> list:
        """
            Returns all the names of children at the specified `path` in the resource.

        The return result is a `None` terminated list of strings which should
        be released with [func`GLib`.strfreev].

        If `path` is invalid or does not exist in the [struct`Gio`.Resource],
        G_RESOURCE_ERROR_NOT_FOUND will be returned.

        `lookup_flags` controls the behaviour of the lookup.
        """
    def get_info(self, path: str, lookup_flags: ResourceLookupFlags) -> tuple[bool, int, int]:
        """
            Looks for a file at the specified `path` in the resource and
        if found returns information about it.

        `lookup_flags` controls the behaviour of the lookup.

        The only error this can return is G_RESOURCE_ERROR_NOT_FOUND, if `path` was
        not found in `resource`.
        """
    def has_children(self, path: str) -> bool:
        """
            Returns whether the specified `path` in the resource
        has children.
        """
    @staticmethod
    def load(filename: str) -> Resource:
        """
            Loads a binary resource bundle and creates a [struct`Gio`.Resource]
        representation of it, allowing you to query it for data.

        If you want to use this resource in the global resource namespace you need
        to register it with [func`Gio`.resources_register].

        If `filename` is empty or the data in it is corrupt,
        G_RESOURCE_ERROR_INTERNAL will be returned. If `filename` doesn’t exist, or
        there is an error in reading it, an error from [ctor`GLib`.MappedFile.new]
        will be returned.
        """
    def lookup_data(self, path: str, lookup_flags: ResourceLookupFlags) -> GLib.Bytes:
        """
            Looks for a file at the specified `path` in the resource and
        returns a [struct`GLib`.Bytes] that lets you directly access the data in
        memory.

        The data is always followed by a zero byte, so you
        can safely use the data as a C string. However, that byte
        is not included in the size of the [struct`GLib`.Bytes].

        For uncompressed resource files this is a pointer directly into
        the resource bundle, which is typically in some read-only data section
        in the program binary. For compressed files, memory is allocated on
        the heap and the data is automatically uncompressed.

        `lookup_flags` controls the behaviour of the lookup.

        This can return error G_RESOURCE_ERROR_NOT_FOUND if `path` was not found in
        `resource`, or G_RESOURCE_ERROR_INTERNAL if decompression of a compressed
        resource failed.
        """
    @classmethod
    def new_from_data(cls, data: GLib.Bytes) -> Resource:
        """
            Creates a [struct`Gio`.Resource] from a reference to the binary resource bundle.

        This will keep a reference to `data` while the resource lives, so
        the data should not be modified or freed.

        If you want to use this resource in the global resource namespace you need
        to register it with [func`Gio`.resources_register].

        Note: `data` must be backed by memory that is at least pointer aligned.
        Otherwise this function will internally create a copy of the memory since
        GLib 2.56, or in older versions fail and exit the process.

        If `data` is empty or corrupt, G_RESOURCE_ERROR_INTERNAL will be returned.
        """
    def open_stream(self, path: str, lookup_flags: ResourceLookupFlags) -> InputStream:
        """
            Looks for a file at the specified `path` in the resource and
        returns a [class`Gio`.InputStream] that lets you read the data.

        `lookup_flags` controls the behaviour of the lookup.

        The only error this can return is G_RESOURCE_ERROR_NOT_FOUND, if `path` was
        not found in `resource`.
        """
    def ref(self) -> Resource:
        """
            Atomically increments the reference count of `resource` by one.

        This function is threadsafe and may be called from any thread.
        """
    def unref(self) -> None:
        """
            Atomically decrements the reference count of `resource` by one.

        If the reference count drops to 0, all memory allocated by the resource is
        released. This function is threadsafe and may be called from any
        thread.
        """

class Seekable(GObject.GInterface):
    """
    `GSeekable` is implemented by streams (implementations of
    [class`Gio`.InputStream] or [class`Gio`.OutputStream]) that support seeking.

    Seekable streams largely fall into two categories: resizable and
    fixed-size.

    `GSeekable` on fixed-sized streams is approximately the same as POSIX
    [``lseek``](man:lseek(2)) on a block device (for example: attempting to seek
    past the end of the device is an error).  Fixed streams typically cannot be
    truncated.

    `GSeekable` on resizable streams is approximately the same as POSIX
    [``lseek``](man:lseek(2)) on a normal file.  Seeking past the end and writing
    data will usually cause the stream to resize by introducing zero bytes.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_seek(self) -> bool:
        """
        Tests if the stream supports the GSeekableIface.
        """
    def can_truncate(self) -> bool:
        """
            Tests if the length of the stream can be adjusted with
        `g_seekable_truncate`.
        """
    def seek(self, offset: int, type: GLib.SeekType, cancellable: Cancellable | None = None) -> bool:
        """
            Seeks in the stream by the given `offset`, modified by `type`.

        Attempting to seek past the end of the stream will have different
        results depending on if the stream is fixed-sized or resizable.  If
        the stream is resizable then seeking past the end and then writing
        will result in zeros filling the empty space.  Seeking past the end
        of a resizable stream and reading will result in EOF.  Seeking past
        the end of a fixed-sized stream will fail.

        Any operation that would result in a negative offset will fail.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    def tell(self) -> int:
        """
        Tells the current position within the stream.
        """
    def truncate(self, offset: int, cancellable: Cancellable | None = None) -> bool:
        """
            Sets the length of the stream to `offset`. If the stream was previously
        larger than `offset`, the extra data is discarded. If the stream was
        previously shorter than `offset`, it is extended with NUL ('\\0') bytes.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
        operation was partially finished when the operation was cancelled the
        partial result will be returned, without an error.
        """

class SeekableIface(GObject.GPointer):
    """
    Provides an interface for implementing seekable functionality on I/O Streams.
    """

    # gi Fields
    @builtins.property
    def can_seek(self) -> can_seekSeekableIfaceCB:
        """
        Checks if seeking is supported by the stream.
        """
    @builtins.property
    def can_truncate(self) -> can_truncateSeekableIfaceCB:
        """
        Checks if truncation is supported by the stream.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def seek(self) -> seekSeekableIfaceCB:
        """
        Seeks to a location within a stream.
        """
    @builtins.property
    def tell(self) -> tellSeekableIfaceCB:
        """
        Tells the current location within a stream.
        """
    @builtins.property
    def truncate_fn(self) -> truncate_fnSeekableIfaceCB:
        """
        Truncates a stream.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Settings(GObject.Object):
    """
    The `GSettings` class provides a convenient API for storing and retrieving
    application settings.

    Reads and writes can be considered to be non-blocking.  Reading
    settings with `GSettings` is typically extremely fast: on
    approximately the same order of magnitude (but slower than) a
    [struct`GLib`.HashTable] lookup.  Writing settings is also extremely fast in
    terms of time to return to your application, but can be extremely expensive
    for other threads and other processes.  Many settings backends
    (including dconf) have lazy initialisation which means in the common
    case of the user using their computer without modifying any settings
    a lot of work can be avoided.  For dconf, the D-Bus service doesn’t
    even need to be started in this case.  For this reason, you should
    only ever modify `GSettings` keys in response to explicit user action.
    Particular care should be paid to ensure that modifications are not
    made during startup — for example, when setting the initial value
    of preferences widgets.  The built-in [method`Gio`.Settings.bind]
    functionality is careful not to write settings in response to notify signals
    as a result of modifications that it makes to widgets.

    When creating a `GSettings` instance, you have to specify a schema
    that describes the keys in your settings and their types and default
    values, as well as some other information.

    Normally, a schema has a fixed path that determines where the settings
    are stored in the conceptual global tree of settings. However, schemas
    can also be ‘[relocatable](#relocatable-schemas)’, i.e. not equipped with
    a fixed path. This is
    useful e.g. when the schema describes an ‘account’, and you want to be
    able to store a arbitrary number of accounts.

    Paths must start with and end with a forward slash character (`/`)
    and must not contain two sequential slash characters.  Paths should
    be chosen based on a domain name associated with the program or
    library to which the settings belong.  Examples of paths are
    `/org/gtk/settings/file-chooser/` and `/ca/desrt/dconf-editor/`.
    Paths should not start with `/apps/`, `/desktop/` or `/system/` as
    they often did in GConf.

    Unlike other configuration systems (like GConf), GSettings does not
    restrict keys to basic types like strings and numbers. GSettings stores
    values as [struct`GLib`.Variant], and allows any [type`GLib`.VariantType] for
    keys. Key names are restricted to lowercase characters, numbers and `-`.
    Furthermore, the names must begin with a lowercase character, must not end
    with a `-`, and must not contain consecutive dashes.

    Similar to GConf, the default values in GSettings schemas can be
    localized, but the localized values are stored in gettext catalogs
    and looked up with the domain that is specified in the
    `gettext-domain` attribute of the `<schemalist>` or `<schema>`
    elements and the category that is specified in the `l10n` attribute of
    the `<default>` element. The string which is translated includes all text in
    the `<default>` element, including any surrounding quotation marks.

    The `l10n` attribute must be set to `messages` or `time`, and sets the
    [locale category for
    translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
    The `messages` category should be used by default; use `time` for
    translatable date or time formats. A translation comment can be added as an
    XML comment immediately above the `<default>` element — it is recommended to
    add these comments to aid translators understand the meaning and
    implications of the default value. An optional translation `context`
    attribute can be set on the `<default>` element to disambiguate multiple
    defaults which use the same string.

    For example:
    ```xml
     <!-- Translators: A list of words which are not allowed to be typed, in
          GVariant serialization syntax.
          See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
     <default l10n='messages' context='Banned words'>['bad', 'words']</default>
    ```

    Translations of default values must remain syntactically valid serialized
    [struct`GLib`.Variant]s (e.g. retaining any surrounding quotation marks) or
    runtime errors will occur.

    GSettings uses schemas in a compact binary form that is created
    by the [`glib-compile-schemas`](glib-compile-schemas.html)
    utility. The input is a schema description in an XML format.

    A DTD for the gschema XML format can be found here:
    [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)

    The [`glib-compile-schemas`](glib-compile-schemas.html) tool expects schema
    files to have the extension `.gschema.xml`.

    At runtime, schemas are identified by their ID (as specified in the
    `id` attribute of the `<schema>` element). The convention for schema
    IDs is to use a dotted name, similar in style to a D-Bus bus name,
    e.g. `org.gnome.SessionManager`. In particular, if the settings are
    for a specific service that owns a D-Bus bus name, the D-Bus bus name
    and schema ID should match. For schemas which deal with settings not
    associated with one named application, the ID should not use
    StudlyCaps, e.g. `org.gnome.font-rendering`.

    In addition to [struct`GLib`.Variant] types, keys can have types that have
    enumerated types. These can be described by a `<choice>`,
    `<enum>` or `<flags>` element, as seen in the
    second example below. The underlying type of such a key
    is string, but you can use [method`Gio`.Settings.get_enum],
    [method`Gio`.Settings.set_enum], [method`Gio`.Settings.get_flags],
    [method`Gio`.Settings.set_flags] access the numeric values corresponding to
    the string value of enum and flags keys.

    An example for default value:
    ```xml
    <schemalist>
      <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">

        <key name="greeting" type="s">
          <default l10n="messages">"Hello, earthlings"</default>
          <summary>A greeting</summary>
          <description>
            Greeting of the invading martians
          </description>
        </key>

        <key name="box" type="(ii)">
          <default>(20,30)</default>
        </key>

        <key name="empty-string" type="s">
          <default>""</default>
          <summary>Empty strings have to be provided in GVariant form</summary>
        </key>

      </schema>
    </schemalist>
    ```

    An example for ranges, choices and enumerated types:
    ```xml
    <schemalist>

      <enum id="org.gtk.Test.myenum">
        <value nick="first" value="1"/>
        <value nick="second" value="2"/>
      </enum>

      <flags id="org.gtk.Test.myflags">
        <value nick="flag1" value="1"/>
        <value nick="flag2" value="2"/>
        <value nick="flag3" value="4"/>
      </flags>

      <schema id="org.gtk.Test">

        <key name="key-with-range" type="i">
          <range min="1" max="100"/>
          <default>10</default>
        </key>

        <key name="key-with-choices" type="s">
          <choices>
            <choice value='Elisabeth'/>
            <choice value='Annabeth'/>
            <choice value='Joe'/>
          </choices>
          <aliases>
            <alias value='Anna' target='Annabeth'/>
            <alias value='Beth' target='Elisabeth'/>
          </aliases>
          <default>'Joe'</default>
        </key>

        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
          <default>'first'</default>
        </key>

        <key name='flags-key' flags='org.gtk.Test.myflags'>
          <default>["flag1","flag2"]</default>
        </key>
      </schema>
    </schemalist>
    ```

    ## Vendor overrides

    Default values are defined in the schemas that get installed by
    an application. Sometimes, it is necessary for a vendor or distributor
    to adjust these defaults. Since patching the XML source for the schema
    is inconvenient and error-prone,
    [`glib-compile-schemas`](glib-compile-schemas.html) reads so-called ‘vendor
    override’ files. These are keyfiles in the same directory as the XML
    schema sources which can override default values. The schema ID serves
    as the group name in the key file, and the values are expected in
    serialized [struct`GLib`.Variant] form, as in the following example:
    ```
    [org.gtk.Example]
    key1='string'
    key2=1.5
    ```

    `glib-compile-schemas` expects schema files to have the extension
    `.gschema.override`.

    ## Delay-apply mode

    By default, values set on a [class`Gio`.Settings] instance immediately start
    to be written to the backend (although these writes may not complete by the
    time that [method`Gio`.Settings.set]) returns; see [func`Gio`.Settings.sync]).

    In order to allow groups of settings to be changed simultaneously and
    atomically, GSettings also supports a ‘delay-apply’ mode. In this mode,
    updated values are kept locally in the [class`Gio`.Settings] instance until
    they are explicitly applied by calling [method`Gio`.Settings.apply].

    For example, this could be useful for a preferences dialog where the
    preferences all need to be applied simultaneously when the user clicks ‘Save’.

    Switching a [class`Gio`.Settings] instance to ‘delay-apply’ mode is a one-time
    irreversible operation: from that point onwards, *all* changes made to that
    [class`Gio`.Settings] have to be explicitly applied by calling
    [method`Gio`.Settings.apply]. The ‘delay-apply’ mode is also propagated to any
    child settings objects subsequently created using
    [method`Gio`.Settings.get_child].

    At any point, the set of unapplied changes can be queried using
    [property`Gio`.Settings:has-unapplied], and discarded by calling
    [method`Gio`.Settings.revert].

    ## Binding

    A very convenient feature of GSettings lets you bind [class`GObject`.Object]
    properties directly to settings, using [method`Gio`.Settings.bind]. Once a
    [class`GObject`.Object] property has been bound to a setting, changes on
    either side are automatically propagated to the other side. GSettings handles
    details like mapping between [class`GObject`.Object] and [struct`GLib`.Variant]
    types, and preventing infinite cycles.

    This makes it very easy to hook up a preferences dialog to the
    underlying settings. To make this even more convenient, GSettings
    looks for a boolean property with the name `sensitivity` and
    automatically binds it to the writability of the bound setting.
    If this ‘magic’ gets in the way, it can be suppressed with the
    `G_SETTINGS_BIND_NO_SENSITIVITY` flag.

    ## Relocatable schemas

    A relocatable schema is one with no `path` attribute specified on its
    `<schema>` element. By using [ctor`Gio`.Settings.new_with_path], a `GSettings`
    object can be instantiated for a relocatable schema, assigning a path to the
    instance. Paths passed to [ctor`Gio`.Settings.new_with_path] will typically be
    constructed dynamically from a constant prefix plus some form of instance
    identifier; but they must still be valid GSettings paths. Paths could also
    be constant and used with a globally installed schema originating from a
    dependency library.

    For example, a relocatable schema could be used to store geometry information
    for different windows in an application. If the schema ID was
    `org.foo.MyApp.Window`, it could be instantiated for paths
    `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
    `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
    they can be specified as `<child>` elements in the parent schema, e.g.:
    ```xml
    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
      <child name="main" schema="org.foo.MyApp.Window"/>
    </schema>
    ```

    ## Build system integration

    ### Meson

    GSettings is natively supported by Meson’s [GNOME module](https://mesonbuild.com/Gnome-module.html).

    You can install the schemas as any other data file:

    ```
    install_data(
      'org.foo.MyApp.gschema.xml',
      install_dir: get_option('datadir') / 'glib-2.0/schemas',
    )
    ```

    You can use `gnome.`post_install`` function to compile the schemas on
    installation:

    ```
    gnome = import('gnome')
    gnome.post_install(
      glib_compile_schemas: true,
    )
    ```

    If an enumerated type defined in a C header file is to be used in a GSettings
    schema, it can either be defined manually using an `<enum>` element in the
    schema XML, or it can be extracted automatically from the C header. This
    approach is preferred, as it ensures the two representations are always
    synchronised. To do so, you will need to use the `gnome.`mkenums`` function
    with the following templates:

    ```
    schemas_enums = gnome.mkenums('org.foo.MyApp.enums.xml',
      comments: '<!-- `comment`@ -->',
      fhead: '<schemalist>',
      vhead: '  <`type`@ id="org.foo.MyApp.`EnumName`@">',
      vprod: '    <value nick="`valuenick`@" value="`valuenum`@"/>',
      vtail: '  </`type`@>',
      ftail: '</schemalist>',
      sources: enum_sources,
      install_header: true,
      install_dir: get_option('datadir') / 'glib-2.0/schemas',
    )
    ```

    It is recommended to validate your schemas as part of the test suite for
    your application:

    ```
    test('validate-schema',
      find_program('glib-compile-schemas'),
      args: ['--strict', '--dry-run', meson.`current_source_dir`],
    )
    ```

    If your application allows running uninstalled, you should also use the
    `gnome.`compile_schemas`` function to compile the schemas in the current
    build directory:

    ```
    gnome.`compile_schemas`
    ```

    ### Autotools

    GSettings comes with autotools integration to simplify compiling and
    installing schemas. To add GSettings support to an application, add the
    following to your `configure.ac`:
    ```
    GLIB_GSETTINGS
    ```

    In the appropriate `Makefile.am`, use the following snippet to compile and
    install the named schema:
    ```
    gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
    EXTRA_DIST = $(gsettings_SCHEMAS)

    `GSETTINGS_RULES`@
    ```

    If an enumerated type defined in a C header file is to be used in a GSettings
    schema, it can either be defined manually using an `<enum>` element in the
    schema XML, or it can be extracted automatically from the C header. This
    approach is preferred, as it ensures the two representations are always
    synchronised. To do so, add the following to the relevant `Makefile.am`:
    ```
    gsettings_ENUM_NAMESPACE = org.foo.MyApp
    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
    ```

    `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
    which are specified in `gsettings_ENUM_FILES`. This will generate a
    `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
    automatically included in the schema compilation, install and uninstall
    rules. It should not be committed to version control or included in
    `EXTRA_DIST`.

    ## Localization

    No changes are needed to the build system to mark a schema XML file for
    translation. Assuming it sets the `gettext-domain` attribute, a schema may
    be marked for translation by adding it to `POTFILES.in`, assuming gettext
    0.19 or newer is in use (the preferred method for translation):
    ```
    data/org.foo.MyApp.gschema.xml
    ```

    Alternatively, if intltool 0.50.1 is in use:
    ```
    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
    ```

    GSettings will use gettext to look up translations for the `<summary>` and
    `<description>` elements, and also any `<default>` elements which have a
    `l10n` attribute set.

    Translations **must not** be included in the `.gschema.xml` file by the build
    system, for example by using a rule to generate the XML file from a template.
    """

    class Props(GObject.Object.Props):
        backend: SettingsBackend | None
        """
        The name of the context that the settings are stored in.
        """
        delay_apply: bool  # [delay-apply]: changed because contained invalid characters
        """
        Whether the [class`Gio`.Settings] object is in
        [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).
        """
        has_unapplied: bool  # [has-unapplied]: changed because contained invalid characters
        """
        Whether the [class`Gio`.Settings] object has outstanding changes.

        These changes will be applied when [method`Gio`.Settings.apply] is called.
        """
        path: str
        """
        The path within the backend where the settings are stored.
        """
        schema: str
        """
        The name of the schema that describes the types of keys
        for this [class`Gio`.Settings] object.

        The type of this property is *not* [struct`Gio`.SettingsSchema].
        [struct`Gio`.SettingsSchema] has only existed since version 2.32 and
        unfortunately this name was used in previous versions to refer to
        the schema ID rather than the schema itself.  Take care to use the
        [property`Gio`.Settings:settings-schema] property if you wish to pass in a
        [struct`Gio`.SettingsSchema].
        """
        schema_id: str  # [schema-id]: changed because contained invalid characters
        """
        The name of the schema that describes the types of keys
        for this [class`Gio`.Settings] object.
        """
        settings_schema: SettingsSchema | None  # [settings-schema]: changed because contained invalid characters
        """
        The [struct`Gio`.SettingsSchema] describing the types of keys for this
        [class`Gio`.Settings] object.

        Ideally, this property would be called [property`Gio`.Settings:schema].
        [struct`Gio`.SettingsSchema]
        has only existed since version 2.32, however, and before then the
        [property`Gio`.Settings:schema] property was used to refer to the ID of the schema rather
        than the schema itself.  Take care.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> SettingsPrivate | None: ...

    # gi Methods
    def apply(self) -> None:
        """
            Applies any changes that have been made to the settings.

        This function does nothing unless `settings` is in
        [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).  In the normal
        case settings are always applied immediately.
        """
    def bind(self, key: str, object: GObject.Object, property: str, flags: SettingsBindFlags) -> None:
        """
            Create a binding between the `key` in the `settings` object
        and the property `property` of `object`.

        The binding uses the default GIO mapping functions to map
        between the settings and property values. These functions
        handle booleans, numeric types and string types in a
        straightforward way. Use [method`Gio`.Settings.bind_with_mapping] if
        you need a custom mapping, or map between types that are not
        supported by the default mapping functions.

        Unless the `flags` include [flags`Gio`.SettingsBindFlags.NO_SENSITIVITY], this
        function also establishes a binding between the writability of
        `key` and the `sensitive` property of `object` (if `object` has
        a boolean property by that name). See [method`Gio`.Settings.bind_writable]
        for more details about writable bindings.

        Note that the lifecycle of the binding is tied to `object`,
        and that you can have only one binding per object property.
        If you bind the same property twice on the same object, the second
        binding overrides the first one.
        """
    def bind_with_mapping(
        self,
        key: str,
        object: GObject.Object,
        property: str,
        flags: SettingsBindFlags,
        get_mapping: GObject.Closure | None = None,
        set_mapping: GObject.Closure | None = None,
    ) -> None:
        """
            Create a binding between the `key` in the `settings` object
        and the property `property` of `object`.

        The binding uses the provided mapping functions to map between
        settings and property values.

        Note that the lifecycle of the binding is tied to `object`,
        and that you can have only one binding per object property.
        If you bind the same property twice on the same object, the second
        binding overrides the first one.
        """
    def bind_writable(self, key: str, object: GObject.Object, property: str, inverted: bool) -> None:
        """
            Create a binding between the writability of `key` in the
        `settings` object and the property `property` of `object`.

        The property must be boolean; `sensitive` or `visible`
        properties of widgets are the most likely candidates.

        Writable bindings are always uni-directional; changes of the
        writability of the setting will be propagated to the object
        property, not the other way.

        When the `inverted` argument is true, the binding inverts the
        value as it passes from the setting to the object, i.e. `property`
        will be set to true if the key is not writable.

        Note that the lifecycle of the binding is tied to `object`,
        and that you can have only one binding per object property.
        If you bind the same property twice on the same object, the second
        binding overrides the first one.
        """
    def create_action(self, key: str) -> Action:
        """
            Creates a [iface`Gio`.Action] corresponding to a given [class`Gio`.Settings] key.

        The action has the same name as the key.

        The value of the key becomes the state of the action and the action
        is enabled when the key is writable.  Changing the state of the
        action results in the key being written to.  Changes to the value or
        writability of the key cause appropriate change notifications to be
        emitted for the action.

        For boolean-valued keys, action activations take no parameter and
        result in the toggling of the value.  For all other types,
        activations take the new value for the key (which must have the
        correct type).
        """
    def delay(self) -> None:
        """
            Changes the [class`Gio`.Settings] object into
        [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).

        In this
        mode, changes to `settings` are not immediately propagated to the
        backend, but kept locally until [method`Gio`.Settings.apply] is called.
        """
    def get_boolean(self, key: str) -> bool:
        """
            Gets the value that is stored at `key` in `settings`.

        A convenience variant of [method`Gio`.Settings.get] for booleans.

        It is a programmer error to give a `key` that isn’t specified as
        having a `b` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def get_child(self, name: str) -> Settings:
        """
            Creates a child settings object which has a base path of
        `base-path/name`, where `base-path` is the base path of
        `settings` and `name` is as specified by the caller.

        The schema for the child settings object must have been declared
        in the schema of `settings` using a `<child>` element.

        The created child settings object will inherit the
        [property`Gio`.Settings:delay-apply] mode from `settings`.
        """
    def get_default_value(self, key: str) -> GLib.Variant | None:
        """
            Gets the ‘default value’ of a key.

        This is the value that would be read if [method`Gio`.Settings.reset] were to be
        called on the key.

        Note that this may be a different value than returned by
        [method`Gio`.SettingsSchemaKey.get_default_value] if the system administrator
        has provided a default value.

        Comparing the return values of [method`Gio`.Settings.get_default_value] and
        [method`Gio`.Settings.get_value] is not sufficient for determining if a value
        has been set because the user may have explicitly set the value to
        something that happens to be equal to the default.  The difference
        here is that if the default changes in the future, the user’s key
        will still be set.

        This function may be useful for adding an indication to a UI of what
        the default value was before the user set it.

        It is a programmer error to give a `key` that isn’t contained in the
        schema for `settings`.
        """
    def get_double(self, key: str) -> float:
        """
            Gets the value that is stored at `key` in `settings`.

        A convenience variant of [method`Gio`.Settings.get] for doubles.

        It is a programmer error to give a `key` that isn’t specified as
        having a `d` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def get_enum(self, key: str) -> int:
        """
            Gets the value that is stored in `settings` for `key` and converts it
        to the enum value that it represents.

        In order to use this function the type of the value must be a string
        and it must be marked in the schema file as an enumerated type.

        It is a programmer error to give a `key` that isn’t contained in the
        schema for `settings` or is not marked as an enumerated type.

        If the value stored in the configuration database is not a valid
        value for the enumerated type then this function will return the
        default value.
        """
    def get_flags(self, key: str) -> int:
        """
            Gets the value that is stored in `settings` for `key` and converts it
        to the flags value that it represents.

        In order to use this function the type of the value must be an array
        of strings and it must be marked in the schema file as a flags type.

        It is a programmer error to give a `key` that isn’t contained in the
        schema for `settings` or is not marked as a flags type.

        If the value stored in the configuration database is not a valid
        value for the flags type then this function will return the default
        value.
        """
    @builtins.property
    def get_has_unapplied(self) -> bool:
        """
            Returns whether the [class`Gio`.Settings] object has any unapplied
        changes.

        This can only be the case if it is in
        [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).
        """
    def get_int(self, key: str) -> int:
        """
            Gets the value that is stored at `key` in `settings`.

        A convenience variant of [method`Gio`.Settings.get] for 32-bit integers.

        It is a programmer error to give a `key` that isn’t specified as
        having an `i` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def get_int64(self, key: str) -> int:
        """
            Gets the value that is stored at `key` in `settings`.

        A convenience variant of [method`Gio`.Settings.get] for 64-bit integers.

        It is a programmer error to give a `key` that isn’t specified as
        having an `x` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def get_mapped(self, key: str, mapping: SettingsGetMapping, *user_data: object | None) -> object | None:
        """
            Gets the value that is stored at `key` in `settings`, subject to
        application-level validation/mapping.

        You should use this function when the application needs to perform
        some processing on the value of the key (for example, parsing).  The
        `mapping` function performs that processing.  If the function
        indicates that the processing was unsuccessful (due to a parse error,
        for example) then the mapping is tried again with another value.

        This allows a robust ‘fall back to defaults’ behaviour to be
        implemented somewhat automatically.

        The first value that is tried is the user’s setting for the key.  If
        the mapping function fails to map this value, other values may be
        tried in an unspecified order (system or site defaults, translated
        schema default values, untranslated schema default values, etc).

        If the mapping function fails for all possible values, one additional
        attempt is made: the mapping function is called with a `None` value.
        If the mapping function still indicates failure at this point then
        the application will be aborted.

        The result parameter for the `mapping` function is pointed to a
        `gpointer` which is initially set to `None`.  The same pointer is given
        to each invocation of `mapping`.  The final value of that `gpointer` is
        what is returned by this function.  `None` is valid; it is returned
        just as any other value would be.
        """
    @deprecated("deprecated")
    def get_range(self, key: str) -> GLib.Variant:
        """
        Queries the range of a key.
        """
    def get_string(self, key: str) -> str:
        """
            Gets the value that is stored at `key` in `settings`.

        A convenience variant of [method`Gio`.Settings.get] for strings.

        It is a programmer error to give a `key` that isn’t specified as
        having an `s` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def get_strv(self, key: str) -> list:
        """
            A convenience variant of [method`Gio`.Settings.get] for string arrays.

        It is a programmer error to give a `key` that isn’t specified as
        having an `as` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def get_uint(self, key: str) -> int:
        """
            Gets the value that is stored at `key` in `settings`.

        A convenience variant of [method`Gio`.Settings.get] for 32-bit unsigned
        integers.

        It is a programmer error to give a `key` that isn’t specified as
        having a `u` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def get_uint64(self, key: str) -> int:
        """
            Gets the value that is stored at `key` in `settings`.

        A convenience variant of [method`Gio`.Settings.get] for 64-bit unsigned
        integers.

        It is a programmer error to give a `key` that isn’t specified as
        having a `t` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def get_user_value(self, key: str) -> GLib.Variant | None:
        """
            Checks the ‘user value’ of a key, if there is one.

        The user value of a key is the last value that was set by the user.

        After calling [method`Gio`.Settings.reset] this function should always return
        `None` (assuming something is not wrong with the system
        configuration).

        It is possible that [method`Gio`.Settings.get_value] will return a different
        value than this function.  This can happen in the case that the user
        set a value for a key that was subsequently locked down by the system
        administrator — this function will return the user’s old value.

        This function may be useful for adding a ‘reset’ option to a UI or
        for providing indication that a particular value has been changed.

        It is a programmer error to give a `key` that isn’t contained in the
        schema for `settings`.
        """
    def get_value(self, key: str) -> GLib.Variant:
        """
            Gets the value that is stored in `settings` for `key`.

        It is a programmer error to give a `key` that isn’t contained in the
        schema for `settings`.
        """
    def is_writable(self, name: str) -> bool:
        """
        Finds out if a key can be written.
        """
    def list_children(self) -> list:
        """
            Gets the list of children on `settings`.

        The list is exactly the list of strings for which it is not an error
        to call [method`Gio`.Settings.get_child].

        There is little reason to call this function from ‘normal’ code, since
        you should already know what children are in your schema. This function
        may still be useful there for introspection reasons, however.

        You should free the return value with [func`GLib`.strfreev] when you are done
        with it.
        """
    @deprecated("deprecated")
    def list_keys(self) -> list:
        """
            Introspects the list of keys on `settings`.

        You should probably not be calling this function from ‘normal’ code
        (since you should already know what keys are in your schema).  This
        function is intended for introspection reasons.

        You should free the return value with [func`GLib`.strfreev] when you are done
        with it.
        """
    @deprecated("deprecated")
    @staticmethod
    def list_relocatable_schemas() -> list:
        """
        Deprecated.
        """
    @deprecated("deprecated")
    @staticmethod
    def list_schemas() -> list:
        """
        Deprecated.
        """
    @classmethod
    def new(cls, schema_id: str) -> Settings:
        """
            Creates a new [class`Gio`.Settings] object with the schema specified by
        `schema_id`.

        It is an error for the schema to not exist: schemas are an
        essential part of a program, as they provide type information.
        If schemas need to be dynamically loaded (for example, from an
        optional runtime dependency), [method`Gio`.SettingsSchemaSource.lookup]
        can be used to test for their existence before loading them.

        Signals on the newly created [class`Gio`.Settings] object will be dispatched
        via the thread-default [struct`GLib`.MainContext] in effect at the time of the
        call to [ctor`Gio`.Settings.new].  The new [class`Gio`.Settings] will hold a reference
        on the context.  See [method`GLib`.MainContext.push_thread_default].
        """
    @classmethod
    def new_full(
        cls, schema: SettingsSchema, backend: SettingsBackend | None = None, path: str | None = None
    ) -> Settings:
        """
            Creates a new [class`Gio`.Settings] object with a given schema, backend and
        path.

        It should be extremely rare that you ever want to use this function.
        It is made available for advanced use-cases (such as plugin systems
        that want to provide access to schemas loaded from custom locations,
        etc).

        At the most basic level, a [class`Gio`.Settings] object is a pure composition of
        four things: a [struct`Gio`.SettingsSchema], a [class`Gio`.SettingsBackend], a path within that
        backend, and a [struct`GLib`.MainContext] to which signals are dispatched.

        This constructor therefore gives you full control over constructing
        [class`Gio`.Settings] instances.  The first 3 parameters are given directly as
        `schema`, `backend` and `path`, and the main context is taken from the
        thread-default (as per [ctor`Gio`.Settings.new]).

        If `backend` is `None` then the default backend is used.

        If `path` is `None` then the path from the schema is used.  It is an
        error if `path` is `None` and the schema has no path of its own or if
        `path` is non-`None` and not equal to the path that the schema does
        have.
        """
    @classmethod
    def new_with_backend(cls, schema_id: str, backend: SettingsBackend) -> Settings:
        """
            Creates a new [class`Gio`.Settings] object with the schema specified by
        `schema_id` and a given [class`Gio`.SettingsBackend].

        Creating a [class`Gio`.Settings] object with a different backend allows accessing
        settings from a database other than the usual one. For example, it may make
        sense to pass a backend corresponding to the ‘defaults’ settings database on
        the system to get a settings object that modifies the system default
        settings instead of the settings for this user.
        """
    @classmethod
    def new_with_backend_and_path(cls, schema_id: str, backend: SettingsBackend, path: str) -> Settings:
        """
            Creates a new [class`Gio`.Settings] object with the schema specified by
        `schema_id` and a given [class`Gio`.SettingsBackend] and path.

        This is a mix of [ctor`Gio`.Settings.new_with_backend] and
        [ctor`Gio`.Settings.new_with_path].
        """
    @classmethod
    def new_with_path(cls, schema_id: str, path: str) -> Settings:
        """
            Creates a new [class`Gio`.Settings] object with the relocatable schema specified
        by `schema_id` and a given path.

        You only need to do this if you want to directly create a settings
        object with a schema that doesn’t have a specified path of its own.
        That’s quite rare.

        It is a programmer error to call this function for a schema that
        has an explicitly specified path.

        It is a programmer error if `path` is not a valid path.  A valid path
        begins and ends with `/` and does not contain two consecutive `/`
        characters.
        """
    @deprecated("deprecated")
    def range_check(self, key: str, value: GLib.Variant) -> bool:
        """
            Checks if the given `value` is of the correct type and within the
        permitted range for `key`.
        """
    def reset(self, key: str) -> None:
        """
            Resets `key` to its default value.

        This call resets the key, as much as possible, to its default value.
        That might be the value specified in the schema or the one set by the
        administrator.
        """
    def revert(self) -> None:
        """
            Reverts all unapplied changes to the settings.

        This function does nothing unless `settings` is in
        [‘delay-apply’ mode](class.Settings.html#delay-apply-mode).  In the normal
        case settings are always applied immediately.

        Change notifications will be emitted for affected keys.
        """
    def set_boolean(self, key: str, value: bool) -> bool:
        """
            Sets `key` in `settings` to `value`.

        A convenience variant of [method`Gio`.Settings.set] for booleans.

        It is a programmer error to give a `key` that isn’t specified as
        having a `b` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def set_double(self, key: str, value: float) -> bool:
        """
            Sets `key` in `settings` to `value`.

        A convenience variant of [method`Gio`.Settings.set] for doubles.

        It is a programmer error to give a `key` that isn’t specified as
        having a `d` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def set_enum(self, key: str, value: int) -> bool:
        """
            Looks up the enumerated type nick for `value` and writes it to `key`,
        within `settings`.

        It is a programmer error to give a `key` that isn’t contained in the
        schema for `settings` or is not marked as an enumerated type, or for
        `value` not to be a valid value for the named type.

        After performing the write, accessing `key` directly with
        [method`Gio`.Settings.get_string] will return the ‘nick’ associated with
        `value`.
        """
    def set_flags(self, key: str, value: int) -> bool:
        """
            Looks up the flags type nicks for the bits specified by `value`, puts
        them in an array of strings and writes the array to `key`, within
        `settings`.

        It is a programmer error to give a `key` that isn’t contained in the
        schema for `settings` or is not marked as a flags type, or for `value`
        to contain any bits that are not value for the named type.

        After performing the write, accessing `key` directly with
        [method`Gio`.Settings.get_strv] will return an array of ‘nicks’; one for each
        bit in `value`.
        """
    def set_int(self, key: str, value: int) -> bool:
        """
            Sets `key` in `settings` to `value`.

        A convenience variant of [method`Gio`.Settings.set] for 32-bit integers.

        It is a programmer error to give a `key` that isn’t specified as
        having an `i` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def set_int64(self, key: str, value: int) -> bool:
        """
            Sets `key` in `settings` to `value`.

        A convenience variant of [method`Gio`.Settings.set] for 64-bit integers.

        It is a programmer error to give a `key` that isn’t specified as
        having an `x` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def set_string(self, key: str, value: str) -> bool:
        """
            Sets `key` in `settings` to `value`.

        A convenience variant of [method`Gio`.Settings.set] for strings.

        It is a programmer error to give a `key` that isn’t specified as
        having an `s` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def set_strv(self, key: str, value: list | None = None) -> bool:
        """
            Sets `key` in `settings` to `value`.

        A convenience variant of [method`Gio`.Settings.set] for string arrays.  If
        `value` is `None`, then `key` is set to be the empty array.

        It is a programmer error to give a `key` that isn’t specified as
        having an `as` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def set_uint(self, key: str, value: int) -> bool:
        """
            Sets `key` in `settings` to `value`.

        A convenience variant of [method`Gio`.Settings.set] for 32-bit unsigned
        integers.

        It is a programmer error to give a `key` that isn’t specified as
        having a `u` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def set_uint64(self, key: str, value: int) -> bool:
        """
            Sets `key` in `settings` to `value`.

        A convenience variant of [method`Gio`.Settings.set] for 64-bit unsigned
        integers.

        It is a programmer error to give a `key` that isn’t specified as
        having a `t` type in the schema for `settings` (see [struct`GLib`.VariantType]).
        """
    def set_value(self, key: str, value: GLib.Variant) -> bool:
        """
            Sets `key` in `settings` to `value`.

        It is a programmer error to give a `key` that isn’t contained in the
        schema for `settings` or for `value` to have the incorrect type, per
        the schema.

        If `value` is floating then this function consumes the reference.
        """
    @staticmethod
    def sync() -> None:
        """
            Ensures that all pending operations are complete for the default backend.

        Writes made to a [class`Gio`.Settings] are handled asynchronously.  For this
        reason, it is very unlikely that the changes have it to disk by the
        time [method`Gio`.Settings.set] returns.

        This call will block until all of the writes have made it to the
        backend.  Since the main loop is not running, no change notifications
        will be dispatched during this call (but some may be queued by the
        time the call is done).
        """
    @staticmethod
    def unbind(object: GObject.Object, property: str) -> None:
        """
            Removes an existing binding for `property` on `object`.

        Note that bindings are automatically removed when the
        object is finalized, so it is rarely necessary to call this
        function.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initializer for a GObject based classes with support for property
        sets through the use of explicit keyword arguments.
        """
    def keys(
        self,
    ) -> typing.Any: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["change-event"],
        handler: typing.Callable[[typing_extensions.Self, list | None, int], bool],
        *args: typing.Any,
    ) -> int:
        """
            Emitted once per change event that affects this settings object.

        You should connect to this signal
        only if you are interested in viewing groups of changes before they
        are split out into multiple emissions of the [signal`Gio`.Settings::changed] signal.
        For most use cases it is more appropriate to use the [signal`Gio`.Settings::changed] signal.

        In the event that the change event applies to one or more specified
        keys, `keys` will be an array of [alias`GLib`.Quark]s of length `n_keys`.  In the
        event that the change event applies to the [class`Gio`.Settings] object as a
        whole (ie: potentially every key has been changed) then `keys` will
        be `None` and `n_keys` will be `0`.

        The default handler for this signal invokes the [signal`Gio`.Settings::changed] signal
        for each affected key.  If any other connected handler returns
        true then this default functionality will be suppressed.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["changed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when a key has potentially changed.

        You should call one of the [method`Gio`.Settings.get] calls to check the new
        value.

        This signal supports detailed connections.  You can connect to the
        detailed signal `changed::x` in order to only receive callbacks
        when key `x` changes.

        Note that `settings` only emits this signal if you have read `key` at
        least once while a signal handler was already connected for `key`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["writable-change-event"],
        handler: typing.Callable[[typing_extensions.Self, int], bool],
        *args: typing.Any,
    ) -> int:
        """
            Emitted once per writability change event that affects this settings object.

        You should connect
        to this signal if you are interested in viewing groups of changes
        before they are split out into multiple emissions of the
        [signal`Gio`.Settings::writable-changed] signal.  For most use cases it is more
        appropriate to use the [signal`Gio`.Settings::writable-changed] signal.

        In the event that the writability change applies only to a single
        key, `key` will be set to the [alias`GLib`.Quark] for that key.  In the event
        that the writability change affects the entire settings object,
        `key` will be `0`.

        The default handler for this signal invokes the [signal`Gio`.Settings::writable-changed]
        and [signal`Gio`.Settings::changed] signals for each affected key.  This is done because
        changes in writability might also imply changes in value (if for
        example, a new mandatory setting is introduced).  If any other
        connected handler returns true then this default functionality
        will be suppressed.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["writable-changed"],
        handler: typing.Callable[[typing_extensions.Self, str], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when the writability of a key has potentially changed.

        You should call [method`Gio`.Settings.is_writable] in order to determine the
        new status.

        This signal supports detailed connections.  You can connect to the
        detailed signal `writable-changed::x` in order to only receive
        callbacks when the writability of `x` changes.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::backend"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::delay_apply"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::has_unapplied"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::schema"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::schema_id"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::settings_schema"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SettingsBackend(GObject.Object):
    """
    The `GSettingsBackend` interface defines a generic interface for
    non-strictly-typed data that is stored in a hierarchy. To implement
    an alternative storage backend for [class`Gio`.Settings], you need to
    implement the `GSettingsBackend` interface and then make it implement the
    extension point `G_SETTINGS_BACKEND_EXTENSION_POINT_NAME`.

    The interface defines methods for reading and writing values, a
    method for determining if writing of certain values will fail
    (lockdown) and a change notification mechanism.

    The semantics of the interface are very precisely defined and
    implementations must carefully adhere to the expectations of
    callers that are documented on each of the interface methods.

    Some of the `GSettingsBackend` functions accept or return a
    [struct`GLib`.Tree]. These trees always have strings as keys and
    [struct`GLib`.Variant] as values.

    The `GSettingsBackend` API is exported to allow third-party
    implementations, but does not carry the same stability guarantees
    as the public GIO API. For this reason, you have to define the
    C preprocessor symbol `G_SETTINGS_ENABLE_BACKEND` before including
    `gio/gsettingsbackend.h`.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> SettingsBackendPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def changed(self, key: str, origin_tag: object | None = None) -> None:
        """
            Signals that a single key has possibly changed.  Backend
        implementations should call this if a key has possibly changed its
        value.

        `key` must be a valid key (ie starting with a slash, not containing
        '//', and not ending with a slash).

        The implementation must call this function during any call to
        `g_settings_backend_write`, before the call returns (except in the
        case that no keys are actually changed and it cares to detect this
        fact).  It may not rely on the existence of a mainloop for
        dispatching the signal later.

        The implementation may call this function at any other time it likes
        in response to other events (such as changes occurring outside of the
        program).  These calls may originate from a mainloop or may originate
        in response to any other action (including from calls to
        `g_settings_backend_write`).

        In the case that this call is in response to a call to
        `g_settings_backend_write` then `origin_tag` must be set to the same
        value that was passed to that call.
        """
    def changed_tree(self, tree: GLib.Tree, origin_tag: object | None = None) -> None:
        """
            This call is a convenience wrapper.  It gets the list of changes from
        `tree`, computes the longest common prefix and calls
        `g_settings_backend_changed`.
        """
    @staticmethod
    def flatten_tree(tree: GLib.Tree) -> tuple[str, list, list]:
        """
            Calculate the longest common prefix of all keys in a tree and write
        out an array of the key names relative to that prefix and,
        optionally, the value to store at each of those keys.

        You must free the value returned in `path`, `keys` and `values` using
        `g_free`.  You should not attempt to free or unref the contents of
        `keys` or `values`.
        """
    @staticmethod
    def get_default() -> SettingsBackend:
        """
            Returns the default GSettingsBackend. It is possible to override
        the default by setting the `GSETTINGS_BACKEND` environment variable
        to the name of a settings backend.

        The user gets a reference to the backend.
        """
    def keys_changed(self, path: str, items: list, origin_tag: object | None = None) -> None:
        """
            Signals that a list of keys have possibly changed.  Backend
        implementations should call this if keys have possibly changed their
        values.

        `path` must be a valid path (ie starting and ending with a slash and
        not containing '//').  Each string in `items` must form a valid key
        name when `path` is prefixed to it (ie: each item must not start or
        end with '/' and must not contain '//').

        The meaning of this signal is that any of the key names resulting
        from the contatenation of `path` with each item in `items` may have
        changed.

        The same rules for when notifications must occur apply as per
        `g_settings_backend_changed`.  These two calls can be used
        interchangeably if exactly one item has changed (although in that
        case `g_settings_backend_changed` is definitely preferred).

        For efficiency reasons, the implementation should strive for `path` to
        be as long as possible (ie: the longest common prefix of all of the
        keys that were changed) but this is not strictly required.
        """
    def path_changed(self, path: str, origin_tag: object | None = None) -> None:
        """
            Signals that all keys below a given path may have possibly changed.
        Backend implementations should call this if an entire path of keys
        have possibly changed their values.

        `path` must be a valid path (ie starting and ending with a slash and
        not containing '//').

        The meaning of this signal is that any of the key which has a name
        starting with `path` may have changed.

        The same rules for when notifications must occur apply as per
        `g_settings_backend_changed`.  This call might be an appropriate
        reasponse to a 'reset' call but implementations are also free to
        explicitly list the keys that were affected by that call if they can
        easily do so.

        For efficiency reasons, the implementation should strive for `path` to
        be as long as possible (ie: the longest common prefix of all of the
        keys that were changed) but this is not strictly required.  As an
        example, if this function is called with the path of "/" then every
        single key in the application will be notified of a possible change.
        """
    def path_writable_changed(self, path: str) -> None:
        """
            Signals that the writability of all keys below a given path may have
        changed.

        Since GSettings performs no locking operations for itself, this call
        will always be made in response to external events.
        """
    def writable_changed(self, key: str) -> None:
        """
            Signals that the writability of a single key has possibly changed.

        Since GSettings performs no locking operations for itself, this call
        will always be made in response to external events.
        """

    # python methods (overrides?)
    def do_get_writable(
        self,
        key: str,
    ) -> bool:
        """
        get_writable(self, key:str) -> bool
        """
    def do_read(
        self,
        key: str,
        expected_type: GLib.VariantType,
        default_value: bool,
    ) -> GLib.Variant:
        """
        read(self, key:str, expected_type:GLib.VariantType, default_value:bool) -> GLib.Variant
        """
    def do_read_user_value(
        self,
        key: str,
        expected_type: GLib.VariantType,
    ) -> GLib.Variant:
        """
        read_user_value(self, key:str, expected_type:GLib.VariantType) -> GLib.Variant
        """
    def do_reset(
        self,
        key: str,
        origin_tag: typing.Any = None,
    ) -> None:
        """
        reset(self, key:str, origin_tag=None)
        """
    def do_subscribe(
        self,
        name: str,
    ) -> None:
        """
        subscribe(self, name:str)
        """
    def do_sync(
        self,
    ) -> None:
        """
        sync(self)
        """
    def do_unsubscribe(
        self,
        name: str,
    ) -> None:
        """
        unsubscribe(self, name:str)
        """
    def do_write(
        self,
        key: str,
        value: GLib.Variant,
        origin_tag: typing.Any = None,
    ) -> bool:
        """
        write(self, key:str, value:GLib.Variant, origin_tag=None) -> bool
        """
    def do_write_tree(
        self,
        tree: GLib.Tree,
        origin_tag: typing.Any = None,
    ) -> bool:
        """
        write_tree(self, tree:GLib.Tree, origin_tag=None) -> bool
        """

class SettingsBackendClass(GObject.GPointer):
    """
    Class structure for GSettingsBackend.
    """

    # gi Fields
    @builtins.property
    def get_permission(self) -> object | None:
        """
        virtual method to get permission of a key
        """
    @builtins.property
    def get_writable(self) -> get_writableSettingsBackendClassCB:
        """
        virtual method to get if a key is writable
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def read(self) -> readSettingsBackendClassCB:
        """
        virtual method to read a key's value
        """
    @builtins.property
    def read_user_value(self) -> read_user_valueSettingsBackendClassCB:
        """
        virtual method to read user's key value
        """
    @builtins.property
    def reset(self) -> resetSettingsBackendClassCB:
        """
        virtual method to reset state
        """
    @builtins.property
    def subscribe(self) -> subscribeSettingsBackendClassCB:
        """
        virtual method to subscribe to key changes
        """
    @builtins.property
    def sync(self) -> syncSettingsBackendClassCB:
        """
        virtual method to sync state
        """
    @builtins.property
    def unsubscribe(self) -> unsubscribeSettingsBackendClassCB:
        """
        virtual method to unsubscribe to key changes
        """
    @builtins.property
    def write(self) -> writeSettingsBackendClassCB:
        """
        virtual method to change key's value
        """
    @builtins.property
    def write_tree(self) -> write_treeSettingsBackendClassCB:
        """
        virtual method to change a tree of keys
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SettingsBackendPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SettingsClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def change_event(self) -> change_eventSettingsClassCB: ...
    @builtins.property
    def changed(self) -> changedSettingsClassCB: ...
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def writable_change_event(self) -> writable_change_eventSettingsClassCB: ...
    @builtins.property
    def writable_changed(self) -> writable_changedSettingsClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SettingsPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SettingsSchema(GObject.GBoxed):
    """
    The [struct`Gio`.SettingsSchemaSource] and `GSettingsSchema` APIs provide a
    mechanism for advanced control over the loading of schemas and a
    mechanism for introspecting their content.

    Plugin loading systems that wish to provide plugins a way to access
    settings face the problem of how to make the schemas for these
    settings visible to GSettings.  Typically, a plugin will want to ship
    the schema along with itself and it won't be installed into the
    standard system directories for schemas.

    [struct`Gio`.SettingsSchemaSource] provides a mechanism for dealing with this
    by allowing the creation of a new ‘schema source’ from which schemas can
    be acquired.  This schema source can then become part of the metadata
    associated with the plugin and queried whenever the plugin requires
    access to some settings.

    Consider the following example:

    ```c
    typedef struct
    {
       …
       GSettingsSchemaSource *schema_source;
       …
    } Plugin;

    Plugin *
    initialise_plugin (const gchar *dir)
    {
      Plugin *plugin;

      …

      plugin->schema_source =
        g_settings_schema_source_new_from_directory (dir,
          g_settings_schema_source_get_default (), False, None);

      …

      return plugin;
    }

    …

    GSettings *
    plugin_get_settings (Plugin      *plugin,
                         const gchar *schema_id)
    {
      GSettingsSchema *schema;

      if (schema_id == None)
        schema_id = plugin->identifier;

      schema = g_settings_schema_source_lookup (plugin->schema_source,
                                                schema_id, False);

      if (schema == None)
        {
          … disable the plugin or abort, etc …
        }

      return g_settings_new_full (schema, None, None);
    }
    ```

    The code above shows how hooks should be added to the code that
    initialises (or enables) the plugin to create the schema source and
    how an API can be added to the plugin system to provide a convenient
    way for the plugin to access its settings, using the schemas that it
    ships.

    From the standpoint of the plugin, it would need to ensure that it
    ships a gschemas.compiled file as part of itself, and then simply do
    the following:

    ```c
    {
      GSettings *settings;
      gint some_value;

      settings = plugin_get_settings (self, None);
      some_value = g_settings_get_int (settings, "some-value");
      …
    }
    ```

    It's also possible that the plugin system expects the schema source
    files (ie: `.gschema.xml` files) instead of a `gschemas.compiled` file.
    In that case, the plugin loading system must compile the schemas for
    itself before attempting to create the settings source.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_id(self) -> str:
        """
        Get the ID of `schema`.
        """
    def get_key(self, name: str) -> SettingsSchemaKey:
        """
            Gets the key named `name` from `schema`.

        It is a programmer error to request a key that does not exist.  See
        `g_settings_schema_list_keys`.
        """
    def get_path(self) -> str | None:
        """
            Gets the path associated with `schema`, or None.

        Schemas may be single-instance or relocatable.  Single-instance
        schemas correspond to exactly one set of keys in the backend
        database: those located at the path returned by this function.

        Relocatable schemas can be referenced by other schemas and can
        therefore describe multiple sets of keys at different locations.  For
        relocatable schemas, this function will return None.
        """
    def has_key(self, name: str) -> bool:
        """
        Checks if `schema` has a key named `name`.
        """
    def list_children(self) -> list:
        """
            Gets the list of children in `schema`.

        You should free the return value with `g_strfreev` when you are done
        with it.
        """
    def list_keys(self) -> list:
        """
            Introspects the list of keys on `schema`.

        You should probably not be calling this function from "normal" code
        (since you should already know what keys are in your schema).  This
        function is intended for introspection reasons.
        """
    def ref(self) -> SettingsSchema:
        """
        Increase the reference count of `schema`, returning a new reference.
        """
    def unref(self) -> None:
        """
        Decrease the reference count of `schema`, possibly freeing it.
        """

class SettingsSchemaKey(GObject.GBoxed):
    """
    GSettingsSchemaKey is an opaque data structure and can only be accessed
    using the following functions.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_default_value(self) -> GLib.Variant:
        """
            Gets the default value for `key`.

        Note that this is the default value according to the schema.  System
        administrator defaults and lockdown are not visible via this API.
        """
    def get_description(self) -> str | None:
        """
            Gets the description for `key`.

        If no description has been provided in the schema for `key`, returns
        None.

        The description can be one sentence to several paragraphs in length.
        Paragraphs are delimited with a double newline.  Descriptions can be
        translated and the value returned from this function is is the
        current locale.

        This function is slow.  The summary and description information for
        the schemas is not stored in the compiled schema database so this
        function has to parse all of the source XML files in the schema
        directory.
        """
    def get_name(self) -> str:
        """
        Gets the name of `key`.
        """
    def get_range(self) -> GLib.Variant:
        """
            Queries the range of a key.

        This function will return a GVariant that fully describes the range
        of values that are valid for `key`.

        The type of GVariant returned is `(sv)`. The string describes
        the type of range restriction in effect. The type and meaning of
        the value contained in the variant depends on the string.

        If the string is `'type'` then the variant contains an empty array.
        The element type of that empty array is the expected type of value
        and all values of that type are valid.

        If the string is `'enum'` then the variant contains an array
        enumerating the possible values. Each item in the array is
        a possible valid value and no other values are valid.

        If the string is `'flags'` then the variant contains an array. Each
        item in the array is a value that may appear zero or one times in an
        array to be used as the value for this key. For example, if the
        variant contained the array `['x', 'y']` then the valid values for
        the key would be `[]`, `['x']`, `['y']`, `['x', 'y']` and
        `['y', 'x']`.

        Finally, if the string is `'range'` then the variant contains a pair
        of like-typed values -- the minimum and maximum permissible values
        for this key.

        This information should not be used by normal programs.  It is
        considered to be a hint for introspection purposes.  Normal programs
        should already know what is permitted by their own schema.  The
        format may change in any way in the future -- but particularly, new
        forms may be added to the possibilities described above.

        You should free the returned value with `g_variant_unref` when it is
        no longer needed.
        """
    def get_summary(self) -> str | None:
        """
            Gets the summary for `key`.

        If no summary has been provided in the schema for `key`, returns
        None.

        The summary is a short description of the purpose of the key; usually
        one short sentence.  Summaries can be translated and the value
        returned from this function is is the current locale.

        This function is slow.  The summary and description information for
        the schemas is not stored in the compiled schema database so this
        function has to parse all of the source XML files in the schema
        directory.
        """
    def get_value_type(self) -> GLib.VariantType:
        """
        Gets the GVariantType of `key`.
        """
    def range_check(self, value: GLib.Variant) -> bool:
        """
            Checks if the given `value` is within the
        permitted range for `key`.

        It is a programmer error if `value` is not of the correct type — you
        must check for this first.
        """
    def ref(self) -> SettingsSchemaKey:
        """
        Increase the reference count of `key`, returning a new reference.
        """
    def unref(self) -> None:
        """
        Decrease the reference count of `key`, possibly freeing it.
        """

class SettingsSchemaSource(GObject.GBoxed):
    """
    This is an opaque structure type.  You may not access it directly.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_default() -> SettingsSchemaSource | None:
        """
            Gets the default system schema source.

        This function is not required for normal uses of GSettings but it
        may be useful to authors of plugin management systems or to those who
        want to introspect the content of schemas.

        If no schemas are installed, None will be returned.

        The returned source may actually consist of multiple schema sources
        from different directories, depending on which directories were given
        in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
        lookups performed against the default source should probably be done
        recursively.
        """
    def list_schemas(self, recursive: bool) -> tuple[list, list]:
        """
            Lists the schemas in a given source.

        If `recursive` is True then include parent sources.  If False then
        only include the schemas from one source (ie: one directory).  You
        probably want True.

        Non-relocatable schemas are those for which you can call
        `g_settings_new`.  Relocatable schemas are those for which you must
        use `g_settings_new_with_path`.

        Do not call this function from normal programs.  This is designed for
        use by database editors, commandline tools, etc.
        """
    def lookup(self, schema_id: str, recursive: bool) -> SettingsSchema | None:
        """
            Looks up a schema with the identifier `schema_id` in `source`.

        This function is not required for normal uses of GSettings but it
        may be useful to authors of plugin management systems or to those who
        want to introspect the content of schemas.

        If the schema isn't found directly in `source` and `recursive` is True
        then the parent sources will also be checked.

        If the schema isn't found, None is returned.
        """
    @classmethod
    def new_from_directory(
        cls, directory: str, parent: SettingsSchemaSource | None, trusted: bool
    ) -> SettingsSchemaSource:
        """
            Attempts to create a new schema source corresponding to the contents
        of the given directory.

        This function is not required for normal uses of GSettings but it
        may be useful to authors of plugin management systems.

        The directory should contain a file called `gschemas.compiled` as
        produced by the [glib-compile-schemas][glib-compile-schemas] tool.

        If `trusted` is True then `gschemas.compiled` is trusted not to be
        corrupted. This assumption has a performance advantage, but can result
        in crashes or inconsistent behaviour in the case of a corrupted file.
        Generally, you should set `trusted` to True for files installed by the
        system and to False for files in the home directory.

        In either case, an empty file or some types of corruption in the file will
        result in G_FILE_ERROR_INVAL being returned.

        If `parent` is non-None then there are two effects.

        First, if `g_settings_schema_source_lookup` is called with the
        `recursive` flag set to True and the schema can not be found in the
        source, the lookup will recurse to the parent.

        Second, any references to other schemas specified within this
        source (ie: `child` or `extends`) references may be resolved
        from the `parent`.

        For this second reason, except in very unusual situations, the
        `parent` should probably be given as the default schema source, as
        returned by `g_settings_schema_source_get_default`.
        """
    def ref(self) -> SettingsSchemaSource:
        """
        Increase the reference count of `source`, returning a new reference.
        """
    def unref(self) -> None:
        """
        Decrease the reference count of `source`, possibly freeing it.
        """

class SimpleAction(GObject.Object):
    """
    A `GSimpleAction` is the obvious simple implementation of the
    [iface`Gio`.Action] interface. This is the easiest way to create an action for
    purposes of adding it to a [class`Gio`.SimpleActionGroup].
    """

    class Props(GObject.Object.Props):
        enabled: bool
        """
        If `action` is currently enabled.

        If the action is disabled then calls to `g_action_activate` and
        `g_action_change_state` have no effect.
        """
        name: str
        """
        The name of the action. This is mostly meaningful for identifying
        the action once it has been added to a GSimpleActionGroup.
        """
        parameter_type: GLib.VariantType | None  # [parameter-type]: changed because contained invalid characters
        """
        The type of the parameter that must be given when activating the
        action.
        """
        state: GLib.Variant | None
        """
        The state of the action, or None if the action is stateless.
        """
        state_type: GLib.VariantType | None  # [state-type]: changed because contained invalid characters
        """
        The GVariantType of the state that the action has, or None if the
        action is stateless.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        enabled: bool = ...,
        name: str = ...,
        parameter_type: GLib.VariantType | None = ...,
        state: GLib.Variant | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, name: str, parameter_type: GLib.VariantType | None = None) -> SimpleAction:
        """
            Creates a new action.

        The created action is stateless. See `g_simple_action_new_stateful` to create
        an action that has state.
        """
    @classmethod
    def new_stateful(cls, name: str, parameter_type: GLib.VariantType | None, state: GLib.Variant) -> SimpleAction:
        """
            Creates a new stateful action.

        All future state values must have the same GVariantType as the initial
        `state`.

        If the `state` GVariant is floating, it is consumed.
        """
    def set_enabled(self, enabled: bool) -> None:
        """
            Sets the action as enabled or not.

        An action must be enabled in order to be activated or in order to
        have its state changed from outside callers.

        This should only be called by the implementor of the action.  Users
        of the action should not attempt to modify its enabled flag.
        """
    def set_state(self, value: GLib.Variant) -> None:
        """
            Sets the state of the action.

        This directly updates the 'state' property to the given value.

        This should only be called by the implementor of the action.  Users
        of the action should not attempt to directly modify the 'state'
        property.  Instead, they should call `g_action_change_state` to
        request the change.

        If the `value` GVariant is floating, it is consumed.
        """
    def set_state_hint(self, state_hint: GLib.Variant | None = None) -> None:
        """
            Sets the state hint for the action.

        See `g_action_get_state_hint` for more information about
        action state hints.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["activate"],
        handler: typing.Callable[[typing_extensions.Self, GLib.Variant | None], None],
        *args: typing.Any,
    ) -> int:
        """
            Indicates that the action was just activated.

        `parameter` will always be of the expected type, i.e. the parameter type
        specified when the action was created. If an incorrect type is given when
        activating the action, this signal is not emitted.

        Since GLib 2.40, if no handler is connected to this signal then the
        default behaviour for boolean-stated actions with a None parameter
        type is to toggle them via the GSimpleAction::change-state signal.
        For stateful actions where the state type is equal to the parameter
        type, the default is to forward them directly to
        GSimpleAction::change-state.  This should allow almost all users
        of GSimpleAction to connect only one handler or the other.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["change-state"],
        handler: typing.Callable[[typing_extensions.Self, GLib.Variant | None], None],
        *args: typing.Any,
    ) -> int:
        """
            Indicates that the action just received a request to change its
        state.

        `value` will always be of the correct state type, i.e. the type of the
        initial state passed to `g_simple_action_new_stateful`. If an incorrect
        type is given when requesting to change the state, this signal is not
        emitted.

        If no handler is connected to this signal then the default
        behaviour is to call `g_simple_action_set_state` to set the state
        to the requested value. If you connect a signal handler then no
        default action is taken. If the state should change then you must
        call `g_simple_action_set_state` from the handler.

        An example of a 'change-state' handler:
        |[<!-- language="C" -->
        static void
        change_volume_state (GSimpleAction *action,
                             GVariant      *value,
                             gpointer       user_data)
        {
          gint requested;

          requested = g_variant_get_int32 (value);

          // Volume only goes from 0 to 10
          if (0 <= requested && requested <= 10)
            g_simple_action_set_state (action, value);
        }
        ]|

        The handler need not set the state to the requested value.
        It could set it to any value at all, or take some other action.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::enabled"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::parameter_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::state_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SimpleActionGroup(GObject.Object):
    """
    `GSimpleActionGroup` is a hash table filled with [iface`Gio`.Action] objects,
    implementing the [iface`Gio`.ActionGroup] and [iface`Gio`.ActionMap]
    interfaces.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> SimpleActionGroupPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def add_entries(self, entries: list, n_entries: int, user_data: object | None = None) -> None:
        """
            A convenience function for creating multiple GSimpleAction instances
        and adding them to the action group.
        """
    @deprecated("deprecated")
    def insert(self, action: Action) -> None:
        """
            Adds an action to the action group.

        If the action group already contains an action with the same name as
        `action` then the old action is dropped from the group.

        The action group takes its own reference on `action`.
        """
    @deprecated("deprecated")
    def lookup(self, action_name: str) -> Action:
        """
            Looks up the action with the name `action_name` in the group.

        If no such action exists, returns None.
        """
    @classmethod
    def new(cls) -> SimpleActionGroup:
        """
        Creates a new, empty, GSimpleActionGroup.
        """
    @deprecated("deprecated")
    def remove(self, action_name: str) -> None:
        """
            Removes the named action from the action group.

        If no action of this name is in the group then nothing happens.
        """

class SimpleActionGroupClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SimpleActionGroupPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SimpleAsyncResult(GObject.Object):
    """
    As of GLib 2.46, `GSimpleAsyncResult` is deprecated in favor of
    [class`Gio`.Task], which provides a simpler API.

    `GSimpleAsyncResult` implements [iface`Gio`.AsyncResult].

    `GSimpleAsyncResult` handles [type`Gio`.AsyncReadyCallback]s, error
    reporting, operation cancellation and the final state of an operation,
    completely transparent to the application. Results can be returned
    as a pointer e.g. for functions that return data that is collected
    asynchronously, a boolean value for checking the success or failure
    of an operation, or a `gssize` for operations which return the number
    of bytes modified by the operation; all of the simple return cases
    are covered.

    Most of the time, an application will not need to know of the details
    of this API; it is handled transparently, and any necessary operations
    are handled by [iface`Gio`.AsyncResult]’s interface. However, if implementing
    a new GIO module, for writing language bindings, or for complex
    applications that need better control of how asynchronous operations
    are completed, it is important to understand this functionality.

    `GSimpleAsyncResult`s are tagged with the calling function to ensure
    that asynchronous functions and their finishing functions are used
    together correctly.

    To create a new `GSimpleAsyncResult`, call [ctor`Gio`.SimpleAsyncResult.new].
    If the result needs to be created for a `GError`, use
    [ctor`Gio`.SimpleAsyncResult.new_from_error] or
    [ctor`Gio`.SimpleAsyncResult.new_take_error]. If a `GError` is not available
    (e.g. the asynchronous operation doesn’t take a `GError` argument),
    but the result still needs to be created for an error condition, use
    [ctor`Gio`.SimpleAsyncResult.new_error] (or
    [method`Gio`.SimpleAsyncResult.set_error_va] if your application or binding
    requires passing a variable argument list directly), and the error can then
    be propagated through the use of
    [method`Gio`.SimpleAsyncResult.propagate_error].

    An asynchronous operation can be made to ignore a cancellation event by
    calling [method`Gio`.SimpleAsyncResult.set_handle_cancellation] with a
    `GSimpleAsyncResult` for the operation and `False`. This is useful for
    operations that are dangerous to cancel, such as close (which would
    cause a leak if cancelled before being run).

    `GSimpleAsyncResult` can integrate into GLib’s event loop,
    [type`GLib`.MainLoop], or it can use [type`GLib`.Thread]s.
    [method`Gio`.SimpleAsyncResult.complete] will finish an I/O task directly
    from the point where it is called.
    [method`Gio`.SimpleAsyncResult.complete_in_idle] will finish it from an idle
    handler in the  thread-default main context (see
    [method`GLib`.MainContext.push_thread_default]) where the `GSimpleAsyncResult`
    was created. [method`Gio`.SimpleAsyncResult.run_in_thread] will run the job in
    a separate thread and then use
    [method`Gio`.SimpleAsyncResult.complete_in_idle] to deliver the result.

    To set the results of an asynchronous function,
    [method`Gio`.SimpleAsyncResult.set_op_res_gpointer],
    [method`Gio`.SimpleAsyncResult.set_op_res_gboolean], and
    [method`Gio`.SimpleAsyncResult.set_op_res_gssize]
    are provided, setting the operation's result to a `gpointer`, `gboolean`, or
    `gssize`, respectively.

    Likewise, to get the result of an asynchronous function,
    [method`Gio`.SimpleAsyncResult.get_op_res_gpointer],
    [method`Gio`.SimpleAsyncResult.get_op_res_gboolean], and
    [method`Gio`.SimpleAsyncResult.get_op_res_gssize] are
    provided, getting the operation’s result as a `gpointer`, `gboolean`, and
    `gssize`, respectively.

    For the details of the requirements implementations must respect, see
    [iface`Gio`.AsyncResult].  A typical implementation of an asynchronous
    operation using `GSimpleAsyncResult` looks something like this:

    ```c
    static void
    baked_cb (Cake    *cake,
              gpointer user_data)
    {
      // In this example, this callback is not given a reference to the cake,
      // so the GSimpleAsyncResult has to take a reference to it.
      GSimpleAsyncResult *result = user_data;

      if (cake == None)
        g_simple_async_result_set_error (result,
                                         BAKER_ERRORS,
                                         BAKER_ERROR_NO_FLOUR,
                                         "Go to the supermarket");
      else
        g_simple_async_result_set_op_res_gpointer (result,
                                                   g_object_ref (cake),
                                                   g_object_unref);


      // In this example, we assume that baked_cb is called as a callback from
      // the mainloop, so it's safe to complete the operation synchronously here.
      // If, however, _baker_prepare_cake () might call its callback without
      // first returning to the mainloop — inadvisable, but some APIs do so —
      // we would need to use `g_simple_async_result_complete_in_idle`.
      g_simple_async_result_complete (result);
      g_object_unref (result);
    }

    void
    baker_bake_cake_async (Baker              *self,
                           guint               radius,
                           GAsyncReadyCallback callback,
                           gpointer            user_data)
    {
      GSimpleAsyncResult *simple;
      Cake               *cake;

      if (radius < 3)
        {
          g_simple_async_report_error_in_idle (G_OBJECT (self),
                                               callback,
                                               user_data,
                                               BAKER_ERRORS,
                                               BAKER_ERROR_TOO_SMALL,
                                               "%ucm radius cakes are silly",
                                               radius);
          return;
        }

      simple = g_simple_async_result_new (G_OBJECT (self),
                                          callback,
                                          user_data,
                                          baker_bake_cake_async);
      cake = _baker_get_cached_cake (self, radius);

      if (cake != None)
        {
          g_simple_async_result_set_op_res_gpointer (simple,
                                                     g_object_ref (cake),
                                                     g_object_unref);
          g_simple_async_result_complete_in_idle (simple);
          g_object_unref (simple);
          // Drop the reference returned by `_baker_get_cached_cake`;
          // the GSimpleAsyncResult has taken its own reference.
          g_object_unref (cake);
          return;
        }

      _baker_prepare_cake (self, radius, baked_cb, simple);
    }

    Cake *
    baker_bake_cake_finish (Baker        *self,
                            GAsyncResult *result,
                            GError      **error)
    {
      GSimpleAsyncResult *simple;
      Cake               *cake;

      g_return_val_if_fail (g_simple_async_result_is_valid (result,
                                                            G_OBJECT (self),
                                                            baker_bake_cake_async),
                            None);

      simple = (GSimpleAsyncResult *) result;

      if (g_simple_async_result_propagate_error (simple, error))
        return None;

      cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
      return g_object_ref (cake);
    }
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @deprecated("deprecated")
    def complete(self) -> None:
        """
            Completes an asynchronous I/O job immediately. Must be called in
        the thread where the asynchronous result was to be delivered, as it
        invokes the callback directly. If you are in a different thread use
        `g_simple_async_result_complete_in_idle`.

        Calling this function takes a reference to `simple` for as long as
        is needed to complete the call.
        """
    @deprecated("deprecated")
    def complete_in_idle(self) -> None:
        """
            Completes an asynchronous function in an idle handler in the
        thread-default main context (see [method`GLib`.MainContext.push_thread_default])
        of the thread that `simple` was initially created in
        (and re-pushes that context around the invocation of the callback).

        Calling this function takes a reference to `simple` for as long as
        is needed to complete the call.
        """
    @deprecated("deprecated")
    def get_op_res_gboolean(self) -> bool:
        """
        Gets the operation result boolean from within the asynchronous result.
        """
    @deprecated("deprecated")
    def get_op_res_gssize(self) -> int:
        """
        Gets a gssize from the asynchronous result.
        """
    @deprecated("deprecated")
    @staticmethod
    def is_valid(result: AsyncResult, source: GObject.Object | None = None, source_tag: object | None = None) -> bool:
        """
            Ensures that the data passed to the _finish function of an async
        operation is consistent.  Three checks are performed.

        First, `result` is checked to ensure that it is really a
        GSimpleAsyncResult.  Second, `source` is checked to ensure that it
        matches the source object of `result`.  Third, `source_tag` is
        checked to ensure that it is equal to the `source_tag` argument given
        to `g_simple_async_result_new` (which, by convention, is a pointer
        to the _async function corresponding to the _finish function from
        which this function is called).  (Alternatively, if either
        `source_tag` or `result`'s source tag is None, then the source tag
        check is skipped.)
        """
    @deprecated("deprecated")
    @classmethod
    def new(
        cls,
        source_object: GObject.Object | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
        source_tag: object | None = None,
    ) -> SimpleAsyncResult:
        """
            Creates a GSimpleAsyncResult.

        The common convention is to create the GSimpleAsyncResult in the
        function that starts the asynchronous operation and use that same
        function as the `source_tag`.

        If your operation supports cancellation with GCancellable (which it
        probably should) then you should provide the user's cancellable to
        `g_simple_async_result_set_check_cancellable` immediately after
        this function returns.
        """
    @deprecated("deprecated")
    @classmethod
    def new_from_error(
        cls,
        source_object: GObject.Object | None,
        callback: AsyncReadyCallback | None,
        *user_data: object | None,
        error: GLib.Error,
    ) -> SimpleAsyncResult:
        """
        Creates a GSimpleAsyncResult from an error condition.
        """
    @deprecated("deprecated")
    def propagate_error(self) -> bool:
        """
            Propagates an error from within the simple asynchronous result to
        a given destination.

        If the GCancellable given to a prior call to
        `g_simple_async_result_set_check_cancellable` is cancelled then this
        function will return True with `dest` set appropriately.
        """
    @deprecated("deprecated")
    def set_check_cancellable(self, check_cancellable: Cancellable | None = None) -> None:
        """
            Sets a GCancellable to check before dispatching results.

        This function has one very specific purpose: the provided cancellable
        is checked at the time of `g_simple_async_result_propagate_error` If
        it is cancelled, these functions will return an "Operation was
        cancelled" error (G_IO_ERROR_CANCELLED).

        Implementors of cancellable asynchronous functions should use this in
        order to provide a guarantee to their callers that cancelling an
        async operation will reliably result in an error being returned for
        that operation (even if a positive result for the operation has
        already been sent as an idle to the main context to be dispatched).

        The checking described above is done regardless of any call to the
        unrelated `g_simple_async_result_set_handle_cancellation` function.
        """
    @deprecated("deprecated")
    def set_from_error(self, error: GLib.Error) -> None:
        """
        Sets the result from a GError.
        """
    @deprecated("deprecated")
    def set_handle_cancellation(self, handle_cancellation: bool) -> None:
        """
            Sets whether to handle cancellation within the asynchronous operation.

        This function has nothing to do with
        `g_simple_async_result_set_check_cancellable`.  It only refers to the
        GCancellable passed to `g_simple_async_result_run_in_thread`.
        """
    @deprecated("deprecated")
    def set_op_res_gboolean(self, op_res: bool) -> None:
        """
        Sets the operation result to a boolean within the asynchronous result.
        """
    @deprecated("deprecated")
    def set_op_res_gssize(self, op_res: int) -> None:
        """
            Sets the operation result within the asynchronous result to
        the given `op_res`.
        """

class SimpleAsyncResultClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SimpleIOStream(IOStream):
    """
    `GSimpleIOStream` creates a [class`Gio`.IOStream] from an arbitrary
    [class`Gio`.InputStream] and [class`Gio`.OutputStream]. This allows any pair of
    input and output streams to be used with [class`Gio`.IOStream] methods.

    This is useful when you obtained a [class`Gio`.InputStream] and a
    [class`Gio`.OutputStream] by other means, for instance creating them with
    platform specific methods as
    [``g_unix_input_stream_new``](../gio-unix/ctor.UnixInputStream.new.html)
    (from `gio-unix-2.0.pc` / `GioUnix-2.0`), and you want to
    take advantage of the methods provided by [class`Gio`.IOStream].
    """

    class Props(IOStream.Props):
        input_stream: InputStream | None  # [input-stream]: changed because contained invalid characters
        """
        The [class`Gio`.InputStream] to read from.
        """
        output_stream: OutputStream | None  # [output-stream]: changed because contained invalid characters
        """
        The [class`Gio`.OutputStream] to write to.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, input_stream: InputStream | None = ..., output_stream: OutputStream | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, input_stream: InputStream, output_stream: OutputStream) -> SimpleIOStream:
        """
            Creates a new GSimpleIOStream wrapping `input_stream` and `output_stream`.
        See also GIOStream.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::input_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::output_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SimplePermission(Permission):
    """
    `GSimplePermission` is a trivial implementation of [class`Gio`.Permission]
    that represents a permission that is either always or never allowed.  The
    value is given at construction and doesn’t change.

    Calling [method`Gio`.Permission.acquire] or [method`Gio`.Permission.release]
    on a `GSimplePermission` will result in errors.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, allowed: bool) -> SimplePermission:
        """
            Creates a new GPermission instance that represents an action that is
        either always or never allowed.
        """

class SimpleProxyResolver(GObject.Object):
    """
    `GSimpleProxyResolver` is a simple [iface`Gio`.ProxyResolver] implementation
    that handles a single default proxy, multiple URI-scheme-specific
    proxies, and a list of hosts that proxies should not be used for.

    `GSimpleProxyResolver` is never the default proxy resolver, but it
    can be used as the base class for another proxy resolver
    implementation, or it can be created and used manually, such as
    with [method`Gio`.SocketClient.set_proxy_resolver].
    """

    class Props(GObject.Object.Props):
        default_proxy: str  # [default-proxy]: changed because contained invalid characters
        """
        The default proxy URI that will be used for any URI that doesn't
        match GSimpleProxyResolver:ignore-hosts, and doesn't match any
        of the schemes set with `g_simple_proxy_resolver_set_uri_proxy`.

        Note that as a special case, if this URI starts with
        "socks://", GSimpleProxyResolver will treat it as referring
        to all three of the socks5, socks4a, and socks4 proxy types.
        """
        ignore_hosts: list | None  # [ignore-hosts]: changed because contained invalid characters
        """
        A list of hostnames and IP addresses that the resolver should
        allow direct connections to.

        Entries can be in one of 4 formats:

        - A hostname, such as "example.com", ".example.com", or
          "*.example.com", any of which match "example.com" or
          any subdomain of it.

        - An IPv4 or IPv6 address, such as "192.168.1.1",
          which matches only that address.

        - A hostname or IP address followed by a port, such as
          "example.com:80", which matches whatever the hostname or IP
          address would match, but only for URLs with the (explicitly)
          indicated port. In the case of an IPv6 address, the address
          part must appear in brackets: "[::1]:443"

        - An IP address range, given by a base address and prefix length,
          such as "fe80::/10", which matches any address in that range.

        Note that when dealing with Unicode hostnames, the matching is
        done against the ASCII form of the name.

        Also note that hostname exclusions apply only to connections made
        to hosts identified by name, and IP address exclusions apply only
        to connections made to hosts identified by address. That is, if
        example.com has an address of 192.168.1.1, and the :ignore-hosts list
        contains only "192.168.1.1", then a connection to "example.com"
        (eg, via a GNetworkAddress) will use the proxy, and a connection to
        "192.168.1.1" (eg, via a GInetSocketAddress) will not.

        These rules match the "ignore-hosts"/"noproxy" rules most
        commonly used by other applications.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> SimpleProxyResolverPrivate | None: ...

    # gi Methods
    def __init__(self, default_proxy: str = ..., ignore_hosts: list | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def new(default_proxy: str | None = None, ignore_hosts: list | None = None) -> ProxyResolver:
        """
            Creates a new GSimpleProxyResolver. See
        GSimpleProxyResolver:default-proxy and
        GSimpleProxyResolver:ignore-hosts for more details on how the
        arguments are interpreted.
        """
    def set_default_proxy(self, default_proxy: str | None = None) -> None:
        """
            Sets the default proxy on `resolver`, to be used for any URIs that
        don't match GSimpleProxyResolver:ignore-hosts or a proxy set
        via `g_simple_proxy_resolver_set_uri_proxy`.

        If `default_proxy` starts with "socks://",
        GSimpleProxyResolver will treat it as referring to all three of
        the socks5, socks4a, and socks4 proxy types.
        """
    def set_ignore_hosts(self, ignore_hosts: list) -> None:
        """
            Sets the list of ignored hosts.

        See GSimpleProxyResolver:ignore-hosts for more details on how the
        `ignore_hosts` argument is interpreted.
        """
    def set_uri_proxy(self, uri_scheme: str, proxy: str) -> None:
        """
            Adds a URI-scheme-specific proxy to `resolver`; URIs whose scheme
        matches `uri_scheme` (and which don't match
        GSimpleProxyResolver:ignore-hosts) will be proxied via `proxy`.

        As with GSimpleProxyResolver:default-proxy, if `proxy` starts with
        "socks://", GSimpleProxyResolver will treat it
        as referring to all three of the socks5, socks4a, and socks4 proxy
        types.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::default_proxy"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ignore_hosts"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SimpleProxyResolverClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SimpleProxyResolverPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Socket(GObject.Object):
    """
    A `GSocket` is a low-level networking primitive. It is a more or less
    direct mapping of the BSD socket API in a portable GObject based API.
    It supports both the UNIX socket implementations and winsock2 on Windows.

    `GSocket` is the platform independent base upon which the higher level
    network primitives are based. Applications are not typically meant to
    use it directly, but rather through classes like [class`Gio`.SocketClient],
    [class`Gio`.SocketService] and [class`Gio`.SocketConnection]. However there may
    be cases where direct use of `GSocket` is useful.

    `GSocket` implements the [iface`Gio`.Initable] interface, so if it is manually
    constructed by e.g. [ctor`GObject`.Object.new] you must call
    [method`Gio`.Initable.init] and check the results before using the object.
    This is done automatically in [ctor`Gio`.Socket.new] and
    [ctor`Gio`.Socket.new_from_fd], so these functions can return `None`.

    Sockets operate in two general modes, blocking or non-blocking. When
    in blocking mode all operations (which don’t take an explicit blocking
    parameter) block until the requested operation
    is finished or there is an error. In non-blocking mode all calls that
    would block return immediately with a `G_IO_ERROR_WOULD_BLOCK` error.
    To know when a call would successfully run you can call
    [method`Gio`.Socket.condition_check], or [method`Gio`.Socket.condition_wait].
    You can also use [method`Gio`.Socket.create_source] and attach it to a
    [type`GLib`.MainContext] to get callbacks when I/O is possible.
    Note that all sockets are always set to non blocking mode in the system, and
    blocking mode is emulated in `GSocket`.

    When working in non-blocking mode applications should always be able to
    handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other
    function said that I/O was possible. This can easily happen in case
    of a race condition in the application, but it can also happen for other
    reasons. For instance, on Windows a socket is always seen as writable
    until a write returns `G_IO_ERROR_WOULD_BLOCK`.

    `GSocket`s can be either connection oriented or datagram based.
    For connection oriented types you must first establish a connection by
    either connecting to an address or accepting a connection from another
    address. For connectionless socket types the target/source address is
    specified or received in each I/O operation.

    All socket file descriptors are set to be close-on-exec.

    Note that creating a `GSocket` causes the signal `SIGPIPE` to be
    ignored for the remainder of the program. If you are writing a
    command-line utility that uses `GSocket`, you may need to take into
    account the fact that your program will not automatically be killed
    if it tries to write to `stdout` after it has been closed.

    Like most other APIs in GLib, `GSocket` is not inherently thread safe. To use
    a `GSocket` concurrently from multiple threads, you must implement your own
    locking.

    ## Nagle’s algorithm

    Since GLib 2.80, `GSocket` will automatically set the `TCP_NODELAY` option on
    all `G_SOCKET_TYPE_STREAM` sockets. This disables
    [Nagle’s algorithm](https://en.wikipedia.org/wiki/Nagle27s_algorithm) as it
    typically does more harm than good on modern networks.

    If your application needs Nagle’s algorithm enabled, call
    [method`Gio`.Socket.set_option] after constructing a `GSocket` to enable it:
    ```c
    socket = g_socket_new (…, G_SOCKET_TYPE_STREAM, …);
    if (socket != None)
      {
        g_socket_set_option (socket, IPPROTO_TCP, TCP_NODELAY, False, &local_error);
        // handle error if needed
      }
    ```
    """

    class Props(GObject.Object.Props):
        blocking: bool
        """
        Whether I/O on this socket is blocking.
        """
        broadcast: bool
        """
        Whether the socket should allow sending to broadcast addresses.
        """
        family: SocketFamily
        """
        The socket’s address family.
        """
        fd: int
        """
        The socket’s file descriptor.
        """
        keepalive: bool
        """
        Whether to keep the connection alive by sending periodic pings.
        """
        listen_backlog: int  # [listen-backlog]: changed because contained invalid characters
        """
        The number of outstanding connections in the listen queue.
        """
        local_address: SocketAddress | None  # [local-address]: changed because contained invalid characters
        """
        The local address the socket is bound to.
        """
        multicast_loopback: bool  # [multicast-loopback]: changed because contained invalid characters
        """
        Whether outgoing multicast packets loop back to the local host.
        """
        multicast_ttl: int  # [multicast-ttl]: changed because contained invalid characters
        """
        Time-to-live out outgoing multicast packets
        """
        protocol: SocketProtocol
        """
        The ID of the protocol to use, or `-1` for unknown.
        """
        remote_address: SocketAddress | None  # [remote-address]: changed because contained invalid characters
        """
        The remote address the socket is connected to.
        """
        timeout: int
        """
        The timeout in seconds on socket I/O
        """
        ttl: int
        """
        Time-to-live for outgoing unicast packets
        """
        type: SocketType
        """
        The socket’s type.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> SocketPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        blocking: bool = ...,
        broadcast: bool = ...,
        family: SocketFamily = ...,
        fd: int = ...,
        keepalive: bool = ...,
        listen_backlog: int = ...,
        multicast_loopback: bool = ...,
        multicast_ttl: int = ...,
        protocol: SocketProtocol = ...,
        timeout: int = ...,
        ttl: int = ...,
        type: SocketType = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def accept(self, cancellable: Cancellable | None = None) -> Socket:
        """
            Accept incoming connections on a connection-based socket. This removes
        the first outstanding connection request from the listening socket and
        creates a GSocket object for it.

        The `socket` must be bound to a local address with `g_socket_bind` and
        must be listening for incoming connections (`g_socket_listen`).

        If there are no outstanding connections then the operation will block
        or return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
        To be notified of an incoming connection, wait for the G_IO_IN condition.
        """
    def bind(self, address: SocketAddress, allow_reuse: bool) -> bool:
        """
            When a socket is created it is attached to an address family, but it
        doesn't have an address in this family. `g_socket_bind` assigns the
        address (sometimes called name) of the socket.

        It is generally required to bind to a local address before you can
        receive connections. (See `g_socket_listen` and `g_socket_accept` ).
        In certain situations, you may also want to bind a socket that will be
        used to initiate connections, though this is not normally required.

        If `socket` is a TCP socket, then `allow_reuse` controls the setting
        of the `SO_REUSEADDR` socket option; normally it should be True for
        server sockets (sockets that you will eventually call
        `g_socket_accept` on), and False for client sockets. (Failing to
        set this flag on a server socket may cause `g_socket_bind` to return
        G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
        immediately restarted.)

        If `socket` is a UDP socket, then `allow_reuse` determines whether or
        not other UDP sockets can be bound to the same address at the same
        time. In particular, you can have several UDP sockets bound to the
        same address, and they will all receive all of the multicast and
        broadcast packets sent to that address. (The behavior of unicast
        UDP packets to an address with multiple listeners is not defined.)
        """
    def check_connect_result(self) -> bool:
        """
            Checks and resets the pending connect error for the socket.
        This is used to check for errors when `g_socket_connect` is
        used in non-blocking mode.
        """
    def close(self) -> bool:
        """
            Closes the socket, shutting down any active connection.

        Closing a socket does not wait for all outstanding I/O operations
        to finish, so the caller should not rely on them to be guaranteed
        to complete even if the close returns with no error.

        Once the socket is closed, all other operations will return
        G_IO_ERROR_CLOSED. Closing a socket multiple times will not
        return an error.

        Sockets will be automatically closed when the last reference
        is dropped, but you might want to call this function to make sure
        resources are released as early as possible.

        Beware that due to the way that TCP works, it is possible for
        recently-sent data to be lost if either you close a socket while the
        G_IO_IN condition is set, or else if the remote connection tries to
        send something to you after you close the socket but before it has
        finished reading all of the data you sent. There is no easy generic
        way to avoid this problem; the easiest fix is to design the network
        protocol such that the client will never send data "out of turn".
        Another solution is for the server to half-close the connection by
        calling `g_socket_shutdown` with only the `shutdown_write` flag set,
        and then wait for the client to notice this and close its side of the
        connection, after which the server can safely call `g_socket_close`.
        (This is what GTcpConnection does if you call
        `g_tcp_connection_set_graceful_disconnect`. But of course, this
        only works if the client will close its connection after the server
        does.)
        """
    def condition_check(self, condition: GLib.IOCondition) -> GLib.IOCondition:
        """
            Checks on the readiness of `socket` to perform operations.
        The operations specified in `condition` are checked for and masked
        against the currently-satisfied conditions on `socket`. The result
        is returned.

        Note that on Windows, it is possible for an operation to return
        G_IO_ERROR_WOULD_BLOCK even immediately after
        `g_socket_condition_check` has claimed that the socket is ready for
        writing. Rather than calling `g_socket_condition_check` and then
        writing to the socket if it succeeds, it is generally better to
        simply try writing to the socket right away, and try again later if
        the initial attempt returns G_IO_ERROR_WOULD_BLOCK.

        It is meaningless to specify G_IO_ERR or G_IO_HUP in condition;
        these conditions will always be set in the output if they are true.

        This call never blocks.
        """
    def condition_timed_wait(
        self, condition: GLib.IOCondition, timeout_us: int, cancellable: Cancellable | None = None
    ) -> bool:
        """
            Waits for up to `timeout_us` microseconds for `condition` to become true
        on `socket`. If the condition is met, True is returned.

        If `cancellable` is cancelled before the condition is met, or if
        `timeout_us` (or the socket's GSocket:timeout) is reached before the
        condition is met, then False is returned and `error`, if non-None,
        is set to the appropriate value (G_IO_ERROR_CANCELLED or
        G_IO_ERROR_TIMED_OUT).

        If you don't want a timeout, use `g_socket_condition_wait`.
        (Alternatively, you can pass -1 for `timeout_us`.)

        Note that although `timeout_us` is in microseconds for consistency with
        other GLib APIs, this function actually only has millisecond
        resolution, and the behavior is undefined if `timeout_us` is not an
        exact number of milliseconds.
        """
    def condition_wait(self, condition: GLib.IOCondition, cancellable: Cancellable | None = None) -> bool:
        """
            Waits for `condition` to become true on `socket`. When the condition
        is met, True is returned.

        If `cancellable` is cancelled before the condition is met, or if the
        socket has a timeout set and it is reached before the condition is
        met, then False is returned and `error`, if non-None, is set to
        the appropriate value (G_IO_ERROR_CANCELLED or
        G_IO_ERROR_TIMED_OUT).

        See also `g_socket_condition_timed_wait`.
        """
    def connect(self, address: SocketAddress, cancellable: Cancellable | None = None) -> bool:
        """
            Connect the socket to the specified remote address.

        For connection oriented socket this generally means we attempt to make
        a connection to the `address`. For a connection-less socket it sets
        the default address for `g_socket_send` and discards all incoming datagrams
        from other sources.

        Generally connection oriented sockets can only connect once, but
        connection-less sockets can connect multiple times to change the
        default address.

        If the connect call needs to do network I/O it will block, unless
        non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned
        and the user can be notified of the connection finishing by waiting
        for the G_IO_OUT condition. The result of the connection must then be
        checked with `g_socket_check_connect_result`.

        [note from gi-stub-gen] Socket has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    def connection_factory_create_connection(self) -> SocketConnection:
        """
            Creates a GSocketConnection subclass of the right type for
        `socket`.
        """
    def get_available_bytes(self) -> int:
        """
            Get the amount of data pending in the OS input buffer, without blocking.

        If `socket` is a UDP or SCTP socket, this will return the size of
        just the next packet, even if additional packets are buffered after
        that one.

        Note that on Windows, this function is rather inefficient in the
        UDP case, and so if you know any plausible upper bound on the size
        of the incoming packet, it is better to just do a
        `g_socket_receive` with a buffer of that size, rather than calling
        `g_socket_get_available_bytes` first and then doing a receive of
        exactly the right size.
        """
    @builtins.property
    def get_blocking(self) -> bool:
        """
            Gets the blocking mode of the socket. For details on blocking I/O,
        see `g_socket_set_blocking`.
        """
    @builtins.property
    def get_broadcast(self) -> bool:
        """
            Gets the broadcast setting on `socket`; if True,
        it is possible to send packets to broadcast
        addresses.
        """
    def get_credentials(self) -> Credentials:
        """
            Returns the credentials of the foreign process connected to this
        socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX
        sockets).

        If this operation isn't supported on the OS, the method fails with
        the G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
        by reading the SO_PEERCRED option on the underlying socket.

        This method can be expected to be available on the following platforms:

        - Linux since GLib 2.26
        - OpenBSD since GLib 2.30
        - Solaris, Illumos and OpenSolaris since GLib 2.40
        - NetBSD since GLib 2.42
        - macOS, tvOS, iOS since GLib 2.66

        Other ways to obtain credentials from a foreign peer includes the
        GUnixCredentialsMessage type and
        `g_unix_connection_send_credentials` /
        `g_unix_connection_receive_credentials` functions.
        """
    @builtins.property
    def get_family(self) -> SocketFamily:
        """
        Gets the socket family of the socket.
        """
    @builtins.property
    def get_fd(self) -> int:
        """
            Returns the underlying OS socket object. On unix this
        is a socket file descriptor, and on Windows this is
        a Winsock2 SOCKET handle. This may be useful for
        doing platform specific or otherwise unusual operations
        on the socket.
        """
    @builtins.property
    def get_keepalive(self) -> bool:
        """
            Gets the keepalive mode of the socket. For details on this,
        see `g_socket_set_keepalive`.
        """
    @builtins.property
    def get_listen_backlog(self) -> int:
        """
            Gets the listen backlog setting of the socket. For details on this,
        see `g_socket_set_listen_backlog`.
        """
    @builtins.property
    def get_local_address(self) -> SocketAddress:
        """
            Try to get the local address of a bound socket. This is only
        useful if the socket has been bound to a local address,
        either explicitly or implicitly when connecting.
        """
    @builtins.property
    def get_multicast_loopback(self) -> bool:
        """
            Gets the multicast loopback setting on `socket`; if True (the
        default), outgoing multicast packets will be looped back to
        multicast listeners on the same host.
        """
    @builtins.property
    def get_multicast_ttl(self) -> int:
        """
            Gets the multicast time-to-live setting on `socket`; see
        `g_socket_set_multicast_ttl` for more details.
        """
    def get_option(self, level: int, optname: int) -> tuple[bool, int]:
        """
            Gets the value of an integer-valued option on `socket`, as with
        `getsockopt`. (If you need to fetch a  non-integer-valued option,
        you will need to call `getsockopt` directly.)

        The [`<gio/gnetworking.h>`](networking.html)
        header pulls in system headers that will define most of the
        standard/portable socket options. For unusual socket protocols or
        platform-dependent options, you may need to include additional
        headers.

        Note that even for socket options that are a single byte in size,
        `value` is still a pointer to a #gint variable, not a #guchar;
        `g_socket_get_option` will handle the conversion internally.
        """
    @builtins.property
    def get_protocol(self) -> SocketProtocol:
        """
            Gets the socket protocol id the socket was created with.
        In case the protocol is unknown, -1 is returned.
        """
    @builtins.property
    def get_remote_address(self) -> SocketAddress:
        """
            Try to get the remote address of a connected socket. This is only
        useful for connection oriented sockets that have been connected.
        """
    def get_socket_type(self) -> SocketType:
        """
        Gets the socket type of the socket.
        """
    @builtins.property
    def get_timeout(self) -> int:
        """
            Gets the timeout setting of the socket. For details on this, see
        `g_socket_set_timeout`.
        """
    @builtins.property
    def get_ttl(self) -> int:
        """
            Gets the unicast time-to-live setting on `socket`; see
        `g_socket_set_ttl` for more details.
        """
    def is_closed(self) -> bool:
        """
        Checks whether a socket is closed.
        """
    def is_connected(self) -> bool:
        """
            Check whether the socket is connected. This is only useful for
        connection-oriented sockets.

        If using `g_socket_shutdown`, this function will return True until the
        socket has been shut down for reading and writing. If you do a non-blocking
        connect, this function will not return True until after you call
        `g_socket_check_connect_result`.
        """
    def join_multicast_group(self, group: InetAddress, source_specific: bool, iface: str | None = None) -> bool:
        """
            Registers `socket` to receive multicast messages sent to `group`.
        `socket` must be a G_SOCKET_TYPE_DATAGRAM socket, and must have
        been bound to an appropriate interface and port with
        `g_socket_bind`.

        If `iface` is None, the system will automatically pick an interface
        to bind to based on `group`.

        If `source_specific` is True, source-specific multicast as defined
        in RFC 4604 is used. Note that on older platforms this may fail
        with a G_IO_ERROR_NOT_SUPPORTED error.

        To bind to a given source-specific multicast address, use
        `g_socket_join_multicast_group_ssm` instead.
        """
    def join_multicast_group_ssm(
        self, group: InetAddress, source_specific: InetAddress | None = None, iface: str | None = None
    ) -> bool:
        """
            Registers `socket` to receive multicast messages sent to `group`.
        `socket` must be a G_SOCKET_TYPE_DATAGRAM socket, and must have
        been bound to an appropriate interface and port with
        `g_socket_bind`.

        If `iface` is None, the system will automatically pick an interface
        to bind to based on `group`.

        If `source_specific` is not None, use source-specific multicast as
        defined in RFC 4604. Note that on older platforms this may fail
        with a G_IO_ERROR_NOT_SUPPORTED error.

        Note that this function can be called multiple times for the same
        `group` with different `source_specific` in order to receive multicast
        packets from more than one source.
        """
    def leave_multicast_group(self, group: InetAddress, source_specific: bool, iface: str | None = None) -> bool:
        """
            Removes `socket` from the multicast group defined by `group`, `iface`,
        and `source_specific` (which must all have the same values they had
        when you joined the group).

        `socket` remains bound to its address and port, and can still receive
        unicast messages after calling this.

        To unbind to a given source-specific multicast address, use
        `g_socket_leave_multicast_group_ssm` instead.
        """
    def leave_multicast_group_ssm(
        self, group: InetAddress, source_specific: InetAddress | None = None, iface: str | None = None
    ) -> bool:
        """
            Removes `socket` from the multicast group defined by `group`, `iface`,
        and `source_specific` (which must all have the same values they had
        when you joined the group).

        `socket` remains bound to its address and port, and can still receive
        unicast messages after calling this.
        """
    def listen(self) -> bool:
        """
            Marks the socket as a server socket, i.e. a socket that is used
        to accept incoming requests using `g_socket_accept`.

        Before calling this the socket must be bound to a local address using
        `g_socket_bind`.

        To set the maximum amount of outstanding clients, use
        `g_socket_set_listen_backlog`.
        """
    @classmethod
    def new(cls, family: SocketFamily, type: SocketType, protocol: SocketProtocol) -> Socket:
        """
            Creates a new GSocket with the defined family, type and protocol.
        If `protocol` is 0 (G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
        for the family and type is used.

        The `protocol` is a family and type specific int that specifies what
        kind of protocol to use. GSocketProtocol lists several common ones.
        Many families only support one protocol, and use 0 for this, others
        support several and using 0 means to use the default protocol for
        the family and type.

        The protocol id is passed directly to the operating
        system, so you can use protocols not listed in GSocketProtocol if you
        know the protocol number used for it.
        """
    @classmethod
    def new_from_fd(cls, fd: int) -> Socket:
        """
            Creates a new GSocket from a native file descriptor
        or winsock SOCKET handle.

        This reads all the settings from the file descriptor so that
        all properties should work. Note that the file descriptor
        will be set to non-blocking mode, independent on the blocking
        mode of the GSocket.

        On success, the returned GSocket takes ownership of `fd`. On failure, the
        caller must close `fd` themselves.

        Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
        descriptor.  Instead, a GError will be set with code G_IO_ERROR_FAILED
        """
    def receive(self, size: int, cancellable: Cancellable | None = None) -> tuple[int, list]:
        """
            Receive data (up to `size` bytes) from a socket. This is mainly used by
        connection-oriented sockets; it is identical to `g_socket_receive_from`
        with `address` set to None.

        For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
        `g_socket_receive` will always read either 0 or 1 complete messages from
        the socket. If the received message is too large to fit in `buffer`, then
        the data beyond `size` bytes will be discarded, without any explicit
        indication that this has occurred.

        For G_SOCKET_TYPE_STREAM sockets, `g_socket_receive` can return any
        number of bytes, up to `size`. If more than `size` bytes have been
        received, the additional data will be returned in future calls to
        `g_socket_receive`.

        If the socket is in blocking mode the call will block until there
        is some data to receive, the connection is closed, or there is an
        error. If there is no data available and the socket is in
        non-blocking mode, a G_IO_ERROR_WOULD_BLOCK error will be
        returned. To be notified when data is available, wait for the
        G_IO_IN condition.

        On error -1 is returned and `error` is set accordingly.
        """
    def receive_bytes(self, size: int, timeout_us: int, cancellable: Cancellable | None = None) -> GLib.Bytes:
        """
            Receives data (up to `size` bytes) from a socket.

        This function is a variant of [method`Gio`.Socket.receive] which returns a
        [struct`GLib`.Bytes] rather than a plain buffer.

        Pass `-1` to `timeout_us` to block indefinitely until data is received (or
        the connection is closed, or there is an error). Pass `0` to use the default
        timeout from [property`Gio`.Socket:timeout], or pass a positive number to wait
        for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
        """
    def receive_bytes_from(
        self, size: int, timeout_us: int, cancellable: Cancellable | None = None
    ) -> tuple[GLib.Bytes, SocketAddress]:
        """
            Receive data (up to `size` bytes) from a socket.

        This function is a variant of [method`Gio`.Socket.receive_from] which returns
        a [struct`GLib`.Bytes] rather than a plain buffer.

        If `address` is non-None then `address` will be set equal to the
        source address of the received packet.

        The `address` is owned by the caller.

        Pass `-1` to `timeout_us` to block indefinitely until data is received (or
        the connection is closed, or there is an error). Pass `0` to use the default
        timeout from [property`Gio`.Socket:timeout], or pass a positive number to wait
        for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
        """
    def receive_from(self, size: int, cancellable: Cancellable | None = None) -> tuple[int, SocketAddress, list]:
        """
            Receive data (up to `size` bytes) from a socket.

        If `address` is non-None then `address` will be set equal to the
        source address of the received packet.
        `address` is owned by the caller.

        See `g_socket_receive` for additional information.
        """
    def receive_message(
        self, vectors: list, num_vectors: int, flags: int, cancellable: Cancellable | None = None
    ) -> tuple[int, SocketAddress, list | None, int, int]:
        """
            Receive data from a socket.  For receiving multiple messages, see
        `g_socket_receive_messages`; for easier use, see
        `g_socket_receive` and `g_socket_receive_from`.

        If `address` is non-None then `address` will be set equal to the
        source address of the received packet.
        `address` is owned by the caller.

        `vector` must point to an array of GInputVector structs and
        `num_vectors` must be the length of this array.  These structs
        describe the buffers that received data will be scattered into.
        If `num_vectors` is -1, then `vectors` is assumed to be terminated
        by a GInputVector with a None buffer pointer.

        As a special case, if `num_vectors` is 0 (in which case, `vectors`
        may of course be None), then a single byte is received and
        discarded. This is to facilitate the common practice of sending a
        single '\\0' byte for the purposes of transferring ancillary data.

        `messages`, if non-None, will be set to point to a newly-allocated
        array of GSocketControlMessage instances or None if no such
        messages was received. These correspond to the control messages
        received from the kernel, one GSocketControlMessage per message
        from the kernel. This array is None-terminated and must be freed
        by the caller using `g_free` after calling `g_object_unref` on each
        element. If `messages` is None, any control messages received will
        be discarded.

        `num_messages`, if non-None, will be set to the number of control
        messages received.

        If both `messages` and `num_messages` are non-None, then
        `num_messages` gives the number of GSocketControlMessage instances
        in `messages` (ie: not including the None terminator).

        `flags` is an in/out parameter. The commonly available arguments
        for this are available in the GSocketMsgFlags enum, but the
        values there are the same as the system values, and the flags
        are passed in as-is, so you can pass in system-specific flags too
        (and `g_socket_receive_message` may pass system-specific flags out).
        Flags passed in to the parameter affect the receive operation; flags returned
        out of it are relevant to the specific returned message.

        As with `g_socket_receive`, data may be discarded if `socket` is
        G_SOCKET_TYPE_DATAGRAM or G_SOCKET_TYPE_SEQPACKET and you do not
        provide enough buffer space to read a complete message. You can pass
        G_SOCKET_MSG_PEEK in `flags` to peek at the current message without
        removing it from the receive queue, but there is no portable way to find
        out the length of the message other than by reading it into a
        sufficiently-large buffer.

        If the socket is in blocking mode the call will block until there
        is some data to receive, the connection is closed, or there is an
        error. If there is no data available and the socket is in
        non-blocking mode, a G_IO_ERROR_WOULD_BLOCK error will be
        returned. To be notified when data is available, wait for the
        G_IO_IN condition.

        On error -1 is returned and `error` is set accordingly.
        """
    def receive_messages(
        self, messages: list, num_messages: int, flags: int, cancellable: Cancellable | None = None
    ) -> int:
        """
            Receive multiple data messages from `socket` in one go.  This is the most
        complicated and fully-featured version of this call. For easier use, see
        `g_socket_receive`, `g_socket_receive_from`, and `g_socket_receive_message`.

        `messages` must point to an array of GInputMessage structs and
        `num_messages` must be the length of this array. Each GInputMessage
        contains a pointer to an array of GInputVector structs describing the
        buffers that the data received in each message will be written to. Using
        multiple GInputVectors is more memory-efficient than manually copying data
        out of a single buffer to multiple sources, and more system-call-efficient
        than making multiple calls to `g_socket_receive`, such as in scenarios where
        a lot of data packets need to be received (e.g. high-bandwidth video
        streaming over RTP/UDP).

        `flags` modify how all messages are received. The commonly available
        arguments for this are available in the GSocketMsgFlags enum, but the
        values there are the same as the system values, and the flags
        are passed in as-is, so you can pass in system-specific flags too. These
        flags affect the overall receive operation. Flags affecting individual
        messages are returned in GInputMessage.flags.

        The other members of GInputMessage are treated as described in its
        documentation.

        If GSocket:blocking is True the call will block until `num_messages` have
        been received, or the end of the stream is reached.

        If GSocket:blocking is False the call will return up to `num_messages`
        without blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
        operating system to be received.

        In blocking mode, if GSocket:timeout is positive and is reached before any
        messages are received, G_IO_ERROR_TIMED_OUT is returned, otherwise up to
        `num_messages` are returned. (Note: This is effectively the
        behaviour of `MSG_WAITFORONE` with `recvmmsg`.)

        To be notified when messages are available, wait for the
        G_IO_IN condition. Note though that you may still receive
        G_IO_ERROR_WOULD_BLOCK from `g_socket_receive_messages` even if you were
        previously notified of a G_IO_IN condition.

        If the remote peer closes the connection, any messages queued in the
        operating system will be returned, and subsequent calls to
        `g_socket_receive_messages` will return 0 (with no error set).

        On error -1 is returned and `error` is set accordingly. An error will only
        be returned if zero messages could be received; otherwise the number of
        messages successfully received before the error will be returned.
        """
    def receive_with_blocking(
        self, size: int, blocking: bool, cancellable: Cancellable | None = None
    ) -> tuple[int, list]:
        """
            This behaves exactly the same as `g_socket_receive`, except that
        the choice of blocking or non-blocking behavior is determined by
        the `blocking` argument rather than by `socket`'s properties.
        """
    def send(self, buffer: list, size: int, cancellable: Cancellable | None = None) -> int:
        """
            Tries to send `size` bytes from `buffer` on the socket. This is
        mainly used by connection-oriented sockets; it is identical to
        `g_socket_send_to` with `address` set to None.

        If the socket is in blocking mode the call will block until there is
        space for the data in the socket queue. If there is no space available
        and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
        will be returned. To be notified when space is available, wait for the
        G_IO_OUT condition. Note though that you may still receive
        G_IO_ERROR_WOULD_BLOCK from `g_socket_send` even if you were previously
        notified of a G_IO_OUT condition. (On Windows in particular, this is
        very common due to the way the underlying APIs work.)

        On error -1 is returned and `error` is set accordingly.
        """
    def send_message(
        self,
        address: SocketAddress | None,
        vectors: list,
        num_vectors: int,
        messages: list | None,
        num_messages: int,
        flags: int,
        cancellable: Cancellable | None = None,
    ) -> int:
        """
            Send data to `address` on `socket`.  For sending multiple messages see
        `g_socket_send_messages`; for easier use, see
        `g_socket_send` and `g_socket_send_to`.

        If `address` is None then the message is sent to the default receiver
        (set by `g_socket_connect`).

        `vectors` must point to an array of GOutputVector structs and
        `num_vectors` must be the length of this array. (If `num_vectors` is -1,
        then `vectors` is assumed to be terminated by a GOutputVector with a
        None buffer pointer.) The GOutputVector structs describe the buffers
        that the sent data will be gathered from. Using multiple
        GOutputVectors is more memory-efficient than manually copying
        data from multiple sources into a single buffer, and more
        network-efficient than making multiple calls to `g_socket_send`.

        `messages`, if non-None, is taken to point to an array of `num_messages`
        GSocketControlMessage instances. These correspond to the control
        messages to be sent on the socket.
        If `num_messages` is -1 then `messages` is treated as a None-terminated
        array.

        `flags` modify how the message is sent. The commonly available arguments
        for this are available in the GSocketMsgFlags enum, but the
        values there are the same as the system values, and the flags
        are passed in as-is, so you can pass in system-specific flags too.

        If the socket is in blocking mode the call will block until there is
        space for the data in the socket queue. If there is no space available
        and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
        will be returned. To be notified when space is available, wait for the
        G_IO_OUT condition. Note though that you may still receive
        G_IO_ERROR_WOULD_BLOCK from `g_socket_send` even if you were previously
        notified of a G_IO_OUT condition. (On Windows in particular, this is
        very common due to the way the underlying APIs work.)

        The sum of the sizes of each GOutputVector in vectors must not be
        greater than G_MAXSSIZE. If the message can be larger than this,
        then it is mandatory to use the `g_socket_send_message_with_timeout`
        function.

        On error -1 is returned and `error` is set accordingly.
        """
    def send_message_with_timeout(
        self,
        address: SocketAddress | None,
        vectors: list,
        num_vectors: int,
        messages: list | None,
        num_messages: int,
        flags: int,
        timeout_us: int,
        cancellable: Cancellable | None = None,
    ) -> tuple[PollableReturn, int]:
        """
            This behaves exactly the same as `g_socket_send_message`, except that
        the choice of timeout behavior is determined by the `timeout_us` argument
        rather than by `socket`'s properties.

        On error G_POLLABLE_RETURN_FAILED is returned and `error` is set accordingly, or
        if the socket is currently not writable G_POLLABLE_RETURN_WOULD_BLOCK is
        returned. `bytes_written` will contain 0 in both cases.
        """
    def send_messages(
        self, messages: list, num_messages: int, flags: int, cancellable: Cancellable | None = None
    ) -> int:
        """
            Send multiple data messages from `socket` in one go.  This is the most
        complicated and fully-featured version of this call. For easier use, see
        `g_socket_send`, `g_socket_send_to`, and `g_socket_send_message`.

        `messages` must point to an array of GOutputMessage structs and
        `num_messages` must be the length of this array. Each GOutputMessage
        contains an address to send the data to, and a pointer to an array of
        GOutputVector structs to describe the buffers that the data to be sent
        for each message will be gathered from. Using multiple GOutputVectors is
        more memory-efficient than manually copying data from multiple sources
        into a single buffer, and more network-efficient than making multiple
        calls to `g_socket_send`. Sending multiple messages in one go avoids the
        overhead of making a lot of syscalls in scenarios where a lot of data
        packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
        or where the same data needs to be sent to multiple recipients.

        `flags` modify how the message is sent. The commonly available arguments
        for this are available in the GSocketMsgFlags enum, but the
        values there are the same as the system values, and the flags
        are passed in as-is, so you can pass in system-specific flags too.

        If the socket is in blocking mode the call will block until there is
        space for all the data in the socket queue. If there is no space available
        and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
        will be returned if no data was written at all, otherwise the number of
        messages sent will be returned. To be notified when space is available,
        wait for the G_IO_OUT condition. Note though that you may still receive
        G_IO_ERROR_WOULD_BLOCK from `g_socket_send` even if you were previously
        notified of a G_IO_OUT condition. (On Windows in particular, this is
        very common due to the way the underlying APIs work.)

        On error -1 is returned and `error` is set accordingly. An error will only
        be returned if zero messages could be sent; otherwise the number of messages
        successfully sent before the error will be returned.
        """
    def send_to(
        self, address: SocketAddress | None, buffer: list, size: int, cancellable: Cancellable | None = None
    ) -> int:
        """
            Tries to send `size` bytes from `buffer` to `address`. If `address` is
        None then the message is sent to the default receiver (set by
        `g_socket_connect`).

        See `g_socket_send` for additional information.
        """
    def send_with_blocking(
        self, buffer: list, size: int, blocking: bool, cancellable: Cancellable | None = None
    ) -> int:
        """
            This behaves exactly the same as `g_socket_send`, except that
        the choice of blocking or non-blocking behavior is determined by
        the `blocking` argument rather than by `socket`'s properties.
        """
    def set_blocking(self, blocking: bool) -> None:
        """
            Sets the blocking mode of the socket. In blocking mode
        all operations (which don’t take an explicit blocking parameter) block until
        they succeed or there is an error. In
        non-blocking mode all functions return results immediately or
        with a G_IO_ERROR_WOULD_BLOCK error.

        All sockets are created in blocking mode. However, note that the
        platform level socket is always non-blocking, and blocking mode
        is a GSocket level feature.
        """
    def set_broadcast(self, broadcast: bool) -> None:
        """
            Sets whether `socket` should allow sending to broadcast addresses.
        This is False by default.
        """
    def set_keepalive(self, keepalive: bool) -> None:
        """
            Sets or unsets the SO_KEEPALIVE flag on the underlying socket. When
        this flag is set on a socket, the system will attempt to verify that the
        remote socket endpoint is still present if a sufficiently long period of
        time passes with no data being exchanged. If the system is unable to
        verify the presence of the remote endpoint, it will automatically close
        the connection.

        This option is only functional on certain kinds of sockets. (Notably,
        G_SOCKET_PROTOCOL_TCP sockets.)

        The exact time between pings is system- and protocol-dependent, but will
        normally be at least two hours. Most commonly, you would set this flag
        on a server socket if you want to allow clients to remain idle for long
        periods of time, but also want to ensure that connections are eventually
        garbage-collected if clients crash or become unreachable.
        """
    def set_listen_backlog(self, backlog: int) -> None:
        """
            Sets the maximum number of outstanding connections allowed
        when listening on this socket. If more clients than this are
        connecting to the socket and the application is not handling them
        on time then the new connections will be refused.

        Note that this must be called before `g_socket_listen` and has no
        effect if called after that.
        """
    def set_multicast_loopback(self, loopback: bool) -> None:
        """
            Sets whether outgoing multicast packets will be received by sockets
        listening on that multicast address on the same host. This is True
        by default.
        """
    def set_multicast_ttl(self, ttl: int) -> None:
        """
            Sets the time-to-live for outgoing multicast datagrams on `socket`.
        By default, this is 1, meaning that multicast packets will not leave
        the local network.
        """
    def set_option(self, level: int, optname: int, value: int) -> bool:
        """
            Sets the value of an integer-valued option on `socket`, as with
        `setsockopt`. (If you need to set a non-integer-valued option,
        you will need to call `setsockopt` directly.)

        The [`<gio/gnetworking.h>`](networking.html)
        header pulls in system headers that will define most of the
        standard/portable socket options. For unusual socket protocols or
        platform-dependent options, you may need to include additional
        headers.
        """
    def set_timeout(self, timeout: int) -> None:
        """
            Sets the time in seconds after which I/O operations on `socket` will
        time out if they have not yet completed.

        On a blocking socket, this means that any blocking GSocket
        operation will time out after `timeout` seconds of inactivity,
        returning G_IO_ERROR_TIMED_OUT.

        On a non-blocking socket, calls to `g_socket_condition_wait` will
        also fail with G_IO_ERROR_TIMED_OUT after the given time. Sources
        created with `g_socket_create_source` will trigger after
        `timeout` seconds of inactivity, with the requested condition
        set, at which point calling `g_socket_receive`, `g_socket_send`,
        `g_socket_check_connect_result`, etc, will fail with
        G_IO_ERROR_TIMED_OUT.

        If `timeout` is 0 (the default), operations will never time out
        on their own.

        Note that if an I/O operation is interrupted by a signal, this may
        cause the timeout to be reset.
        """
    def set_ttl(self, ttl: int) -> None:
        """
            Sets the time-to-live for outgoing unicast packets on `socket`.
        By default the platform-specific default value is used.
        """
    def shutdown(self, shutdown_read: bool, shutdown_write: bool) -> bool:
        """
            Shut down part or all of a full-duplex connection.

        If `shutdown_read` is True then the receiving side of the connection
        is shut down, and further reading is disallowed.

        If `shutdown_write` is True then the sending side of the connection
        is shut down, and further writing is disallowed.

        It is allowed for both `shutdown_read` and `shutdown_write` to be True.

        One example where it is useful to shut down only one side of a connection is
        graceful disconnect for TCP connections where you close the sending side,
        then wait for the other side to close the connection, thus ensuring that the
        other side saw all sent data.
        """
    def speaks_ipv4(self) -> bool:
        """
            Checks if a socket is capable of speaking IPv4.

        IPv4 sockets are capable of speaking IPv4.  On some operating systems
        and under some combinations of circumstances IPv6 sockets are also
        capable of speaking IPv4.  See RFC 3493 section 3.7 for more
        information.

        No other types of sockets are currently considered as being capable
        of speaking IPv4.
        """

class SocketAddress(GObject.Object):
    """
    `GSocketAddress` is the equivalent of
    [`struct sockaddr`](man:sockaddr(3type)) and its subtypes in the BSD sockets
    API. This is an abstract class; use [class`Gio`.InetSocketAddress] for
    internet sockets, or [class`Gio`.UnixSocketAddress] for UNIX domain sockets.
    """

    class Props(GObject.Object.Props):
        family: SocketFamily
        """
        The family of the socket address.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_family(self) -> SocketFamily:
        """
        Gets the socket family type of `address`.
        """
    def get_native_size(self) -> int:
        """
            Gets the size of `address`'s native struct sockaddr.
        You can use this to allocate memory to pass to
        `g_socket_address_to_native`.
        """
    @classmethod
    def new_from_native(cls, native: object, len: int) -> SocketAddress:
        """
            Creates a GSocketAddress subclass corresponding to the native
        struct sockaddr `native`.
        """
    def to_native(self, dest: object | None, destlen: int) -> bool:
        """
            Converts a GSocketAddress to a native struct sockaddr, which can
        be passed to low-level functions like `connect` or `bind`.

        If not enough space is available, a G_IO_ERROR_NO_SPACE error
        is returned. If the address type is not known on the system
        then a G_IO_ERROR_NOT_SUPPORTED error is returned.
        """

    # python methods (overrides?)
    def do_get_family(
        self,
    ) -> SocketFamily:
        """
        get_family(self) -> Gio.SocketFamily
        """
    def do_get_native_size(
        self,
    ) -> int:
        """
        get_native_size(self) -> int
        """
    def do_to_native(
        self,
        dest: typing.Any,
        destlen: int,
    ) -> bool:
        """
        to_native(self, dest=None, destlen:int) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::family"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SocketAddressClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def get_family(self) -> get_familySocketAddressClassCB: ...
    @builtins.property
    def get_native_size(self) -> get_native_sizeSocketAddressClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def to_native(self) -> to_nativeSocketAddressClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketAddressEnumerator(GObject.Object):
    """
    `GSocketAddressEnumerator` is an enumerator type for
    [class`Gio`.SocketAddress] instances. It is returned by enumeration functions
    such as [method`Gio`.SocketConnectable.enumerate], which returns a
    `GSocketAddressEnumerator` to list each [class`Gio`.SocketAddress] which could
    be used to connect to that [iface`Gio`.SocketConnectable].

    Enumeration is typically a blocking operation, so the asynchronous methods
    [method`Gio`.SocketAddressEnumerator.next_async] and
    [method`Gio`.SocketAddressEnumerator.next_finish] should be used where
    possible.

    Each `GSocketAddressEnumerator` can only be enumerated once. Once
    [method`Gio`.SocketAddressEnumerator.next] has returned `None`, further
    enumeration with that `GSocketAddressEnumerator` is not possible, and it can
    be unreffed.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def next(self, cancellable: Cancellable | None = None) -> SocketAddress | None:
        """
            Retrieves the next GSocketAddress from `enumerator`. Note that this
        may block for some amount of time. (Eg, a GNetworkAddress may need
        to do a DNS lookup before it can return an address.) Use
        `g_socket_address_enumerator_next_async` if you need to avoid
        blocking.

        If `enumerator` is expected to yield addresses, but for some reason
        is unable to (eg, because of a DNS error), then the first call to
        `g_socket_address_enumerator_next` will return an appropriate error
        in `*error`. However, if the first call to
        `g_socket_address_enumerator_next` succeeds, then any further
        internal errors (other than `cancellable` being triggered) will be
        ignored.
        """
    async def next_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously retrieves the next GSocketAddress from `enumerator`
        and then calls `callback`, which must call
        `g_socket_address_enumerator_next_finish` to get the result.

        It is an error to call this multiple times before the previous callback has finished.
        """
    def next_finish(self, result: AsyncResult) -> SocketAddress | None:
        """
            Retrieves the result of a completed call to
        `g_socket_address_enumerator_next_async`. See
        `g_socket_address_enumerator_next` for more information about
        error handling.
        """

    # python methods (overrides?)
    def do_next(
        self,
        cancellable: Cancellable | None = None,
    ) -> SocketAddress | None:
        """
        next(self, cancellable:Gio.Cancellable=None) -> Gio.SocketAddress or None
        """
    def do_next_async(
        self,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        next_async(self, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_next_finish(
        self,
        result: AsyncResult,
    ) -> SocketAddress | None:
        """
        next_finish(self, result:Gio.AsyncResult) -> Gio.SocketAddress or None
        """

class SocketAddressEnumeratorClass(GObject.GPointer):
    """
    Class structure for GSocketAddressEnumerator.
    """

    # gi Fields
    @builtins.property
    def next(self) -> nextSocketAddressEnumeratorClassCB | None:
        """
        Virtual method for `g_socket_address_enumerator_next`.
        """
    @builtins.property
    def next_async(self) -> next_asyncSocketAddressEnumeratorClassCB:
        """
        Virtual method for `g_socket_address_enumerator_next_async`.
        """
    @builtins.property
    def next_finish(self) -> next_finishSocketAddressEnumeratorClassCB | None:
        """
        Virtual method for `g_socket_address_enumerator_next_finish`.
        """
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved10(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def _g_reserved7(self) -> object | None: ...
    @builtins.property
    def _g_reserved8(self) -> object | None: ...
    @builtins.property
    def _g_reserved9(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketClient(GObject.Object):
    """
    `GSocketClient` is a lightweight high-level utility class for connecting to
    a network host using a connection oriented socket type.

    You create a `GSocketClient` object, set any options you want, and then
    call a sync or async connect operation, which returns a
    [class`Gio`.SocketConnection] subclass on success.

    The type of the [class`Gio`.SocketConnection] object returned depends on the
    type of the underlying socket that is in use. For instance, for a TCP/IP
    connection it will be a [class`Gio`.TcpConnection].

    As `GSocketClient` is a lightweight object, you don't need to cache it. You
    can just create a new one any time you need one.
    """

    class Props(GObject.Object.Props):
        enable_proxy: bool  # [enable-proxy]: changed because contained invalid characters
        """
        Enable proxy support.
        """
        family: SocketFamily
        """
        The address family to use for socket construction.
        """
        local_address: SocketAddress | None  # [local-address]: changed because contained invalid characters
        """
        The local address constructed sockets will be bound to.
        """
        protocol: SocketProtocol
        """
        The protocol to use for socket construction, or `0` for default.
        """
        proxy_resolver: ProxyResolver | None  # [proxy-resolver]: changed because contained invalid characters
        """
        The proxy resolver to use
        """
        timeout: int
        """
        The I/O timeout for sockets, in seconds, or `0` for none.
        """
        tls: bool
        """
        Whether to create TLS connections.
        """
        tls_validation_flags: (
            TlsCertificateFlags  # [tls-validation-flags]: changed because contained invalid characters
        )
        """
        The TLS validation flags used when creating TLS connections. The
        default value is G_TLS_CERTIFICATE_VALIDATE_ALL.

        GLib guarantees that if certificate verification fails, at least one
        flag will be set, but it does not guarantee that all possible flags
        will be set. Accordingly, you may not safely decide to ignore any
        particular type of error. For example, it would be incorrect to mask
        G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
        because this could potentially be the only error flag set even if
        other problems exist with the certificate. Therefore, there is no
        safe way to use this property. This is not a horrible problem,
        though, because you should not be attempting to ignore validation
        errors anyway. If you really must ignore TLS certificate errors,
        connect to the GSocketClient::event signal, wait for it to be
        emitted with G_SOCKET_CLIENT_TLS_HANDSHAKING, and use that to
        connect to GTlsConnection::accept-certificate.
        """
        type: SocketType
        """
        The type to use for socket construction.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> SocketClientPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        enable_proxy: bool = ...,
        family: SocketFamily = ...,
        local_address: SocketAddress | None = ...,
        protocol: SocketProtocol = ...,
        proxy_resolver: ProxyResolver | None = ...,
        timeout: int = ...,
        tls: bool = ...,
        tls_validation_flags: TlsCertificateFlags = ...,
        type: SocketType = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_application_proxy(self, protocol: str) -> None:
        """
            Enable proxy protocols to be handled by the application. When the
        indicated proxy protocol is returned by the GProxyResolver,
        GSocketClient will consider this protocol as supported but will
        not try to find a GProxy instance to handle handshaking. The
        application must check for this case by calling
        `g_socket_connection_get_remote_address` on the returned
        GSocketConnection, and seeing if it's a GProxyAddress of the
        appropriate type, to determine whether or not it needs to handle
        the proxy handshaking itself.

        This should be used for proxy protocols that are dialects of
        another protocol such as HTTP proxy. It also allows cohabitation of
        proxy protocols that are reused between protocols. A good example
        is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
        be use as generic socket proxy through the HTTP CONNECT method.

        When the proxy is detected as being an application proxy, TLS handshake
        will be skipped. This is required to let the application do the proxy
        specific handshake.
        """
    def connect(self, connectable: SocketConnectable, cancellable: Cancellable | None = None) -> SocketConnection:
        """
            Tries to resolve the `connectable` and make a network connection to it.

        Upon a successful connection, a new GSocketConnection is constructed
        and returned.  The caller owns this new object and must drop their
        reference to it when finished with it.

        The type of the GSocketConnection object returned depends on the type of
        the underlying socket that is used. For instance, for a TCP/IP connection
        it will be a GTcpConnection.

        The socket created will be the same family as the address that the
        `connectable` resolves to, unless family is set with `g_socket_client_set_family`
        or indirectly via `g_socket_client_set_local_address`. The socket type
        defaults to G_SOCKET_TYPE_STREAM but can be set with
        `g_socket_client_set_socket_type`.

        If a local address is specified with `g_socket_client_set_local_address` the
        socket will be bound to this address before connecting.

        [note from gi-stub-gen] SocketClient has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    async def connect_async(
        self,
        connectable: SocketConnectable,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            This is the asynchronous version of `g_socket_client_connect`.

        You may wish to prefer the asynchronous version even in synchronous
        command line programs because, since 2.60, it implements
        [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
        recommendations to work around long connection timeouts in networks
        where IPv6 is broken by performing an IPv4 connection simultaneously
        without waiting for IPv6 to time out, which is not supported by the
        synchronous call. (This is not an API guarantee, and may change in
        the future.)

        When the operation is finished `callback` will be
        called. You can then call `g_socket_client_connect_finish` to get
        the result of the operation.
        """
    def connect_finish(self, result: AsyncResult) -> SocketConnection:
        """
        Finishes an async connect operation. See `g_socket_client_connect_async`
        """
    def connect_to_host(
        self, host_and_port: str, default_port: int, cancellable: Cancellable | None = None
    ) -> SocketConnection:
        """
            This is a helper function for `g_socket_client_connect`.

        Attempts to create a TCP connection to the named host.

        `host_and_port` may be in any of a number of recognized formats; an IPv6
        address, an IPv4 address, or a domain name (in which case a DNS
        lookup is performed).  Quoting with [] is supported for all address
        types.  A port override may be specified in the usual way with a
        colon.  Ports may be given as decimal numbers or symbolic names (in
        which case an /etc/services lookup is performed).

        If no port override is given in `host_and_port` then `default_port` will be
        used as the port number to connect to.

        In general, `host_and_port` is expected to be provided by the user (allowing
        them to give the hostname, and a port override if necessary) and
        `default_port` is expected to be provided by the application.

        In the case that an IP address is given, a single connection
        attempt is made.  In the case that a name is given, multiple
        connection attempts may be made, in turn and according to the
        number of address records in DNS, until a connection succeeds.

        Upon a successful connection, a new GSocketConnection is constructed
        and returned.  The caller owns this new object and must drop their
        reference to it when finished with it.

        In the event of any failure (DNS error, service not found, no hosts
        connectable) None is returned and `error` (if non-None) is set
        accordingly.
        """
    async def connect_to_host_async(
        self,
        host_and_port: str,
        default_port: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            This is the asynchronous version of `g_socket_client_connect_to_host`.

        When the operation is finished `callback` will be
        called. You can then call `g_socket_client_connect_to_host_finish` to get
        the result of the operation.
        """
    def connect_to_host_finish(self, result: AsyncResult) -> SocketConnection:
        """
        Finishes an async connect operation. See `g_socket_client_connect_to_host_async`
        """
    def connect_to_service(self, domain: str, service: str, cancellable: Cancellable | None = None) -> SocketConnection:
        """
            Attempts to create a TCP connection to a service.

        This call looks up the SRV record for `service` at `domain` for the
        "tcp" protocol.  It then attempts to connect, in turn, to each of
        the hosts providing the service until either a connection succeeds
        or there are no hosts remaining.

        Upon a successful connection, a new GSocketConnection is constructed
        and returned.  The caller owns this new object and must drop their
        reference to it when finished with it.

        In the event of any failure (DNS error, service not found, no hosts
        connectable) None is returned and `error` (if non-None) is set
        accordingly.
        """
    async def connect_to_service_async(
        self,
        domain: str,
        service: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            This is the asynchronous version of
        `g_socket_client_connect_to_service`.
        """
    def connect_to_service_finish(self, result: AsyncResult) -> SocketConnection:
        """
        Finishes an async connect operation. See `g_socket_client_connect_to_service_async`
        """
    def connect_to_uri(self, uri: str, default_port: int, cancellable: Cancellable | None = None) -> SocketConnection:
        """
            This is a helper function for `g_socket_client_connect`.

        Attempts to create a TCP connection with a network URI.

        `uri` may be any valid URI containing an "authority" (hostname/port)
        component. If a port is not specified in the URI, `default_port`
        will be used. TLS will be negotiated if GSocketClient:tls is True.
        (GSocketClient does not know to automatically assume TLS for
        certain URI schemes.)

        Using this rather than `g_socket_client_connect` or
        `g_socket_client_connect_to_host` allows GSocketClient to
        determine when to use application-specific proxy protocols.

        Upon a successful connection, a new GSocketConnection is constructed
        and returned.  The caller owns this new object and must drop their
        reference to it when finished with it.

        In the event of any failure (DNS error, service not found, no hosts
        connectable) None is returned and `error` (if non-None) is set
        accordingly.
        """
    async def connect_to_uri_async(
        self,
        uri: str,
        default_port: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            This is the asynchronous version of `g_socket_client_connect_to_uri`.

        When the operation is finished `callback` will be
        called. You can then call `g_socket_client_connect_to_uri_finish` to get
        the result of the operation.
        """
    def connect_to_uri_finish(self, result: AsyncResult) -> SocketConnection:
        """
        Finishes an async connect operation. See `g_socket_client_connect_to_uri_async`
        """
    @builtins.property
    def get_enable_proxy(self) -> bool:
        """
        Gets the proxy enable state; see `g_socket_client_set_enable_proxy`
        """
    @builtins.property
    def get_family(self) -> SocketFamily:
        """
            Gets the socket family of the socket client.

        See `g_socket_client_set_family` for details.
        """
    @builtins.property
    def get_local_address(self) -> SocketAddress | None:
        """
            Gets the local address of the socket client.

        See `g_socket_client_set_local_address` for details.
        """
    @builtins.property
    def get_protocol(self) -> SocketProtocol:
        """
            Gets the protocol name type of the socket client.

        See `g_socket_client_set_protocol` for details.
        """
    @builtins.property
    def get_proxy_resolver(self) -> ProxyResolver:
        """
            Gets the GProxyResolver being used by `client`. Normally, this will
        be the resolver returned by `g_proxy_resolver_get_default`, but you
        can override it with `g_socket_client_set_proxy_resolver`.
        """
    def get_socket_type(self) -> SocketType:
        """
            Gets the socket type of the socket client.

        See `g_socket_client_set_socket_type` for details.
        """
    @builtins.property
    def get_timeout(self) -> int:
        """
            Gets the I/O timeout time for sockets created by `client`.

        See `g_socket_client_set_timeout` for details.
        """
    @builtins.property
    def get_tls(self) -> bool:
        """
            Gets whether `client` creates TLS connections. See
        `g_socket_client_set_tls` for details.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_tls_validation_flags(self) -> TlsCertificateFlags:
        """
            Gets the TLS validation flags used creating TLS connections via
        `client`.

        This function does not work as originally designed and is impossible
        to use correctly. See GSocketClient:tls-validation-flags for more
        information.
        """
    @classmethod
    def new(cls) -> SocketClient:
        """
        Creates a new GSocketClient with the default options.
        """
    def set_enable_proxy(self, enable: bool) -> None:
        """
            Sets whether or not `client` attempts to make connections via a
        proxy server. When enabled (the default), GSocketClient will use a
        GProxyResolver to determine if a proxy protocol such as SOCKS is
        needed, and automatically do the necessary proxy negotiation.

        See also `g_socket_client_set_proxy_resolver`.
        """
    def set_family(self, family: SocketFamily) -> None:
        """
            Sets the socket family of the socket client.
        If this is set to something other than G_SOCKET_FAMILY_INVALID
        then the sockets created by this object will be of the specified
        family.

        This might be useful for instance if you want to force the local
        connection to be an ipv4 socket, even though the address might
        be an ipv6 mapped to ipv4 address.
        """
    def set_local_address(self, address: SocketAddress | None = None) -> None:
        """
            Sets the local address of the socket client.
        The sockets created by this object will bound to the
        specified address (if not None) before connecting.

        This is useful if you want to ensure that the local
        side of the connection is on a specific port, or on
        a specific interface.
        """
    def set_protocol(self, protocol: SocketProtocol) -> None:
        """
            Sets the protocol of the socket client.
        The sockets created by this object will use of the specified
        protocol.

        If `protocol` is G_SOCKET_PROTOCOL_DEFAULT that means to use the default
        protocol for the socket family and type.
        """
    def set_proxy_resolver(self, proxy_resolver: ProxyResolver | None = None) -> None:
        """
            Overrides the GProxyResolver used by `client`. You can call this if
        you want to use specific proxies, rather than using the system
        default proxy settings.

        Note that whether or not the proxy resolver is actually used
        depends on the setting of GSocketClient:enable-proxy, which is not
        changed by this function (but which is True by default)
        """
    def set_socket_type(self, type: SocketType) -> None:
        """
            Sets the socket type of the socket client.
        The sockets created by this object will be of the specified
        type.

        It doesn't make sense to specify a type of G_SOCKET_TYPE_DATAGRAM,
        as GSocketClient is used for connection oriented services.
        """
    def set_timeout(self, timeout: int) -> None:
        """
            Sets the I/O timeout for sockets created by `client`. `timeout` is a
        time in seconds, or 0 for no timeout (the default).

        The timeout value affects the initial connection attempt as well,
        so setting this may cause calls to `g_socket_client_connect`, etc,
        to fail with G_IO_ERROR_TIMED_OUT.
        """
    def set_tls(self, tls: bool) -> None:
        """
            Sets whether `client` creates TLS (aka SSL) connections. If `tls` is
        True, `client` will wrap its connections in a GTlsClientConnection
        and perform a TLS handshake when connecting.

        Note that since GSocketClient must return a GSocketConnection,
        but GTlsClientConnection is not a GSocketConnection, this
        actually wraps the resulting GTlsClientConnection in a
        GTcpWrapperConnection when returning it. You can use
        `g_tcp_wrapper_connection_get_base_io_stream` on the return value
        to extract the GTlsClientConnection.

        If you need to modify the behavior of the TLS handshake (eg, by
        setting a client-side certificate to use, or connecting to the
        GTlsConnection::accept-certificate signal), you can connect to
        `client`'s GSocketClient::event signal and wait for it to be
        emitted with G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
        a chance to see the GTlsClientConnection before the handshake
        starts.
        """
    @deprecated("deprecated")
    def set_tls_validation_flags(self, flags: TlsCertificateFlags) -> None:
        """
            Sets the TLS validation flags used when creating TLS connections
        via `client`. The default value is G_TLS_CERTIFICATE_VALIDATE_ALL.

        This function does not work as originally designed and is impossible
        to use correctly. See GSocketClient:tls-validation-flags for more
        information.
        """

    # python methods (overrides?)
    def do_event(
        self,
        event: SocketClientEvent,
        connectable: SocketConnectable,
        connection: IOStream,
    ) -> None:
        """
        event(self, event:Gio.SocketClientEvent, connectable:Gio.SocketConnectable, connection:Gio.IOStream)
        """

class SocketClientClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def event(self) -> eventSocketClientClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketClientPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketConnectable(GObject.GInterface):
    """
    Objects that describe one or more potential socket endpoints
    implement `GSocketConnectable`. Callers can then use
    [method`Gio`.SocketConnectable.enumerate] to get a
    [class`Gio`.SocketAddressEnumerator] to try out each socket address in turn
    until one succeeds, as shown in the sample code below.

    ```c
    MyConnectionType *
    connect_to_host (const char    *hostname,
                     guint16        port,
                     GCancellable  *cancellable,
                     GError       **error)
    {
      MyConnection *conn = None;
      GSocketConnectable *addr;
      GSocketAddressEnumerator *enumerator;
      GSocketAddress *sockaddr;
      GError *conn_error = None;

      addr = g_network_address_new (hostname, port);
      enumerator = g_socket_connectable_enumerate (addr);
      g_object_unref (addr);

      // Try each sockaddr until we succeed. Record the first connection error,
      // but not any further ones (since they'll probably be basically the same
      // as the first).
      while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
        {
          conn = connect_to_sockaddr (sockaddr, conn_error ? None : &conn_error);
          g_object_unref (sockaddr);
        }
      g_object_unref (enumerator);

      if (conn)
        {
          if (conn_error)
            {
              // We couldn't connect to the first address, but we succeeded
              // in connecting to a later address.
              g_error_free (conn_error);
            }
          return conn;
        }
      else if (error)
        {
          /// Either initial lookup failed, or else the caller cancelled us.
          if (conn_error)
            g_error_free (conn_error);
          return None;
        }
      else
        {
          g_error_propagate (error, conn_error);
          return None;
        }
    }
    ```
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def enumerate(self) -> SocketAddressEnumerator:
        """
        Creates a GSocketAddressEnumerator for `connectable`.
        """
    def proxy_enumerate(self) -> SocketAddressEnumerator:
        """
            Creates a GSocketAddressEnumerator for `connectable` that will
        return a GProxyAddress for each of its addresses that you must connect
        to via a proxy.

        If `connectable` does not implement
        `g_socket_connectable_proxy_enumerate`, this will fall back to
        calling `g_socket_connectable_enumerate`.
        """
    def to_string(self) -> str:
        """
            Format a GSocketConnectable as a string. This is a human-readable format for
        use in debugging output, and is not a stable serialization format. It is not
        suitable for use in user interfaces as it exposes too much information for a
        user.

        If the GSocketConnectable implementation does not support string formatting,
        the implementation’s type name will be returned as a fallback.
        """

class SocketConnectableIface(GObject.GPointer):
    """
    Provides an interface for returning a GSocketAddressEnumerator
    and GProxyAddressEnumerator
    """

    # gi Fields
    @builtins.property
    def enumerate(self) -> enumerateSocketConnectableIfaceCB:
        """
        Creates a GSocketAddressEnumerator
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def proxy_enumerate(self) -> proxy_enumerateSocketConnectableIfaceCB:
        """
        Creates a GProxyAddressEnumerator
        """
    @builtins.property
    def to_string(self) -> to_stringSocketConnectableIfaceCB:
        """
         Format the connectable’s address as a string for debugging.
        Implementing this is optional. (Since: 2.48)
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketConnection(IOStream):
    """
    `GSocketConnection` is a [class`Gio`.IOStream] for a connected socket. They
    can be created either by [class`Gio`.SocketClient] when connecting to a host,
    or by [class`Gio`.SocketListener] when accepting a new client.

    The type of the `GSocketConnection` object returned from these calls
    depends on the type of the underlying socket that is in use. For
    instance, for a TCP/IP connection it will be a [class`Gio`.TcpConnection].

    Choosing what type of object to construct is done with the socket
    connection factory, and it is possible for third parties to register
    custom socket connection types for specific combination of socket
    family/type/protocol using [func`Gio`.SocketConnection.factory_register_type].

    To close a `GSocketConnection`, use [method`Gio`.IOStream.close]. Closing both
    substreams of the [class`Gio`.IOStream] separately will not close the
    underlying [class`Gio`.Socket].
    """

    class Props(IOStream.Props):
        socket: Socket | None
        """
        The underlying [class`Gio`.Socket].
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> IOStream | None: ...
    @builtins.property
    def priv(self) -> SocketConnectionPrivate | None: ...

    # gi Methods
    def __init__(self, socket: Socket | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def connect(self, address: SocketAddress, cancellable: Cancellable | None = None) -> bool:
        """
            Connect `connection` to the specified remote address.

        [note from gi-stub-gen] SocketConnection has a connect() method which shadows the signal connect() method to add handlers to GObject.Signals. You can still connect to signals using: GObject.Object.connect(object, 'signal-name', handler)
        """
    async def connect_async(
        self,
        address: SocketAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously connect `connection` to the specified remote address.

        This clears the GSocket:blocking flag on `connection`'s underlying
        socket if it is currently set.

        If GSocket:timeout is set, the operation will time out and return
        G_IO_ERROR_TIMED_OUT after that period. Otherwise, it will continue
        indefinitely until operating system timeouts (if any) are hit.

        Use `g_socket_connection_connect_finish` to retrieve the result.
        """
    def connect_finish(self, result: AsyncResult) -> bool:
        """
        Gets the result of a `g_socket_connection_connect_async` call.
        """
    @staticmethod
    def factory_lookup_type(family: SocketFamily, type: SocketType, protocol_id: int) -> GObject.GType:
        """
            Looks up the GType to be used when creating socket connections on
        sockets with the specified `family`, `type` and `protocol_id`.

        If no type is registered, the GSocketConnection base type is returned.
        """
    @staticmethod
    def factory_register_type(g_type: GObject.GType, family: SocketFamily, type: SocketType, protocol: int) -> None:
        """
            Looks up the GType to be used when creating socket connections on
        sockets with the specified `family`, `type` and `protocol`.

        If no type is registered, the GSocketConnection base type is returned.
        """
    def get_local_address(self) -> SocketAddress:
        """
        Try to get the local address of a socket connection.
        """
    def get_remote_address(self) -> SocketAddress:
        """
            Try to get the remote address of a socket connection.

        Since GLib 2.40, when used with `g_socket_client_connect` or
        `g_socket_client_connect_async`, during emission of
        G_SOCKET_CLIENT_CONNECTING, this function will return the remote
        address that will be used for the connection.  This allows
        applications to print e.g. "Connecting to example.com
        (10.42.77.3)...".
        """
    @builtins.property
    def get_socket(self) -> Socket:
        """
            Gets the underlying GSocket object of the connection.
        This can be useful if you want to do something unusual on it
        not supported by the GSocketConnection APIs.
        """
    def is_connected(self) -> bool:
        """
            Checks if `connection` is connected. This is equivalent to calling
        `g_socket_is_connected` on `connection`'s underlying GSocket.
        """

class SocketConnectionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> IOStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketControlMessage(GObject.Object):
    """
    A `GSocketControlMessage` is a special-purpose utility message that
    can be sent to or received from a [class`Gio`.Socket]. These types of
    messages are often called ‘ancillary data’.

    The message can represent some sort of special instruction to or
    information from the socket or can represent a special kind of
    transfer to the peer (for example, sending a file descriptor over
    a UNIX socket).

    These messages are sent with [method`Gio`.Socket.send_message] and received
    with [method`Gio`.Socket.receive_message].

    To extend the set of control message that can be sent, subclass this
    class and override the `get_size`, `get_level`, `get_type` and `serialize`
    methods.

    To extend the set of control messages that can be received, subclass
    this class and implement the `deserialize` method. Also, make sure your
    class is registered with the [type`GObject`.Type] type system before calling
    [method`Gio`.Socket.receive_message] to read such a message.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> SocketControlMessagePrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def deserialize(level: int, type: int, size: int, data: list) -> SocketControlMessage | None:
        """
            Tries to deserialize a socket control message of a given
        `level` and `type`. This will ask all known (to GType) subclasses
        of GSocketControlMessage if they can understand this kind
        of message and if so deserialize it into a GSocketControlMessage.

        If there is no implementation for this kind of control message, None
        will be returned.
        """
    def get_level(self) -> int:
        """
            Returns the "level" (i.e. the originating protocol) of the control message.
        This is often SOL_SOCKET.
        """
    def get_msg_type(self) -> int:
        """
            Returns the protocol specific type of the control message.
        For instance, for UNIX fd passing this would be SCM_RIGHTS.
        """
    def get_size(self) -> int:
        """
            Returns the space required for the control message, not including
        headers or alignment.
        """
    def serialize(self, data: object) -> None:
        """
            Converts the data in the message to bytes placed in the
        message.

        `data` is guaranteed to have enough space to fit the size
        returned by `g_socket_control_message_get_size` on this
        object.
        """

    # python methods (overrides?)
    def do_get_level(
        self,
    ) -> int:
        """
        get_level(self) -> int
        """
    def do_get_size(
        self,
    ) -> int:
        """
        get_size(self) -> int
        """
    def do_get_type(
        self,
    ) -> int:
        """
        get_type(self) -> int
        """
    def do_serialize(
        self,
        data: typing.Any,
    ) -> None:
        """
        serialize(self, data)
        """

class SocketControlMessageClass(GObject.GPointer):
    """
    Class structure for GSocketControlMessage.
    """

    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def deserialize(self) -> object | None:
        """
        Tries to deserialize a message.
        """
    @builtins.property
    def get_level(self) -> get_levelSocketControlMessageClassCB:
        """
        gets the protocol of the message.
        """
    @builtins.property
    def get_size(self) -> get_sizeSocketControlMessageClassCB:
        """
        gets the size of the message.
        """
    @builtins.property
    def get_type(self) -> get_typeSocketControlMessageClassCB:
        """
        gets the protocol specific type of the message.
        """
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def serialize(self) -> serializeSocketControlMessageClassCB:
        """
        Writes out the message data.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketControlMessagePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketListener(GObject.Object):
    """
    A `GSocketListener` is an object that keeps track of a set
    of server sockets and helps you accept sockets from any of the
    socket, either sync or async.

    Add addresses and ports to listen on using
    [method`Gio`.SocketListener.add_address] and
    [method`Gio`.SocketListener.add_inet_port]. These will be listened on until
    [method`Gio`.SocketListener.close] is called. Dropping your final reference to
    the `GSocketListener` will not cause [method`Gio`.SocketListener.close] to be
    called implicitly, as some references to the `GSocketListener` may be held
    internally.

    If you want to implement a network server, also look at
    [class`Gio`.SocketService] and [class`Gio`.ThreadedSocketService] which are
    subclasses of `GSocketListener` that make this even easier.
    """

    class Props(GObject.Object.Props):
        listen_backlog: int  # [listen-backlog]: changed because contained invalid characters
        """
        The number of outstanding connections in the listen queue.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> SocketListenerPrivate | None: ...

    # gi Methods
    def __init__(self, listen_backlog: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def accept(self, cancellable: Cancellable | None = None) -> tuple[SocketConnection, GObject.Object | None]:
        """
            Blocks waiting for a client to connect to any of the sockets added
        to the listener. Returns a GSocketConnection for the socket that was
        accepted.

        If `source_object` is not None it will be filled out with the source
        object specified when the corresponding socket or address was added
        to the listener.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def accept_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            This is the asynchronous version of `g_socket_listener_accept`.

        When the operation is finished `callback` will be
        called. You can then call `g_socket_listener_accept_finish`
        to get the result of the operation.
        """
    def accept_finish(self, result: AsyncResult) -> tuple[SocketConnection, GObject.Object | None]:
        """
        Finishes an async accept operation. See `g_socket_listener_accept_async`
        """
    def accept_socket(self, cancellable: Cancellable | None = None) -> tuple[Socket, GObject.Object | None]:
        """
            Blocks waiting for a client to connect to any of the sockets added
        to the listener. Returns the GSocket that was accepted.

        If you want to accept the high-level GSocketConnection, not a GSocket,
        which is often the case, then you should use `g_socket_listener_accept`
        instead.

        If `source_object` is not None it will be filled out with the source
        object specified when the corresponding socket or address was added
        to the listener.

        If `cancellable` is not None, then the operation can be cancelled by
        triggering the cancellable object from another thread. If the operation
        was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
        """
    async def accept_socket_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            This is the asynchronous version of `g_socket_listener_accept_socket`.

        When the operation is finished `callback` will be
        called. You can then call `g_socket_listener_accept_socket_finish`
        to get the result of the operation.
        """
    def accept_socket_finish(self, result: AsyncResult) -> tuple[Socket, GObject.Object | None]:
        """
        Finishes an async accept operation. See `g_socket_listener_accept_socket_async`
        """
    def add_address(
        self,
        address: SocketAddress,
        type: SocketType,
        protocol: SocketProtocol,
        source_object: GObject.Object | None = None,
    ) -> tuple[bool, SocketAddress]:
        """
            Creates a socket of type `type` and protocol `protocol`, binds
        it to `address` and adds it to the set of sockets we're accepting
        sockets from.

        Note that adding an IPv6 address, depending on the platform,
        may or may not result in a listener that also accepts IPv4
        connections.  For more deterministic behavior, see
        `g_socket_listener_add_inet_port`.

        `source_object` will be passed out in the various calls
        to accept to identify this particular source, which is
        useful if you're listening on multiple addresses and do
        different things depending on what address is connected to.

        If successful and `effective_address` is non-None then it will
        be set to the address that the binding actually occurred at.  This
        is helpful for determining the port number that was used for when
        requesting a binding to port 0 (ie: "any port").  This address, if
        requested, belongs to the caller and must be freed.

        Call `g_socket_listener_close` to stop listening on `address`; this will not
        be done automatically when you drop your final reference to `listener`, as
        references may be held internally.
        """
    def add_any_inet_port(self, source_object: GObject.Object | None = None) -> int:
        """
            Listens for TCP connections on any available port number for both
        IPv6 and IPv4 (if each is available).

        This is useful if you need to have a socket for incoming connections
        but don't care about the specific port number.

        `source_object` will be passed out in the various calls
        to accept to identify this particular source, which is
        useful if you're listening on multiple addresses and do
        different things depending on what address is connected to.
        """
    def add_inet_port(self, port: int, source_object: GObject.Object | None = None) -> bool:
        """
            Helper function for `g_socket_listener_add_address` that
        creates a TCP/IP socket listening on IPv4 and IPv6 (if
        supported) on the specified port on all interfaces.

        `source_object` will be passed out in the various calls
        to accept to identify this particular source, which is
        useful if you're listening on multiple addresses and do
        different things depending on what address is connected to.

        Call `g_socket_listener_close` to stop listening on `port`; this will not
        be done automatically when you drop your final reference to `listener`, as
        references may be held internally.
        """
    def add_socket(self, socket: Socket, source_object: GObject.Object | None = None) -> bool:
        """
            Adds `socket` to the set of sockets that we try to accept
        new clients from. The socket must be bound to a local
        address and listened to.

        `source_object` will be passed out in the various calls
        to accept to identify this particular source, which is
        useful if you're listening on multiple addresses and do
        different things depending on what address is connected to.

        The `socket` will not be automatically closed when the `listener` is finalized
        unless the listener held the final reference to the socket. Before GLib 2.42,
        the `socket` was automatically closed on finalization of the `listener`, even
        if references to it were held elsewhere.
        """
    def close(self) -> None:
        """
        Closes all the sockets in the listener.
        """
    @classmethod
    def new(cls) -> SocketListener:
        """
            Creates a new GSocketListener with no sockets to listen for.
        New listeners can be added with e.g. `g_socket_listener_add_address`
        or `g_socket_listener_add_inet_port`.
        """
    def set_backlog(self, listen_backlog: int) -> None:
        """
            Sets the listen backlog on the sockets in the listener. This must be called
        before adding any sockets, addresses or ports to the GSocketListener (for
        example, by calling `g_socket_listener_add_inet_port`) to be effective.

        See `g_socket_set_listen_backlog` for details
        """

    # python methods (overrides?)
    def do_changed(
        self,
    ) -> None:
        """
        changed(self)
        """
    def do_event(
        self,
        event: SocketListenerEvent,
        socket: Socket,
    ) -> None:
        """
        event(self, event:Gio.SocketListenerEvent, socket:Gio.Socket)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["event"],
        handler: typing.Callable[[typing_extensions.Self, SocketListenerEvent, Socket], None],
        *args: typing.Any,
    ) -> int:
        """
            Emitted when `listener`'s activity on `socket` changes state.
        Note that when `listener` is used to listen on both IPv4 and
        IPv6, a separate set of signals will be emitted for each, and
        the order they happen in is undefined.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::listen_backlog"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SocketListenerClass(GObject.GPointer):
    """
    Class structure for GSocketListener.
    """

    # gi Fields
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def changed(self) -> changedSocketListenerClassCB:
        """
        virtual method called when the set of socket listened to changes
        """
    @builtins.property
    def event(self) -> eventSocketListenerClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketListenerPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketService(SocketListener):
    """
    A `GSocketService` is an object that represents a service that
    is provided to the network or over local sockets.  When a new
    connection is made to the service the [signal`Gio`.SocketService::incoming]
    signal is emitted.

    A `GSocketService` is a subclass of [class`Gio`.SocketListener] and you need
    to add the addresses you want to accept connections on with the
    [class`Gio`.SocketListener] APIs.

    There are two options for implementing a network service based on
    `GSocketService`. The first is to create the service using
    [ctor`Gio`.SocketService.new] and to connect to the
    [signal`Gio`.SocketService::incoming] signal. The second is to subclass
    `GSocketService` and override the default signal handler implementation.

    In either case, the handler must immediately return, or else it
    will block additional incoming connections from being serviced.
    If you are interested in writing connection handlers that contain
    blocking code then see [class`Gio`.ThreadedSocketService].

    The socket service runs on the main loop of the
    thread-default context (see
    [method`GLib`.MainContext.push_thread_default]) of the thread it is
    created in, and is not threadsafe in general. However, the calls to start and
    stop the service are thread-safe so these can be used from threads that
    handle incoming clients.
    """

    class Props(SocketListener.Props):
        active: bool
        """
        Whether the service is currently accepting connections.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> SocketListener | None: ...
    @builtins.property
    def priv(self) -> SocketServicePrivate | None: ...

    # gi Methods
    def __init__(self, active: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def is_active(self) -> bool:
        """
            Check whether the service is active or not. An active
        service will accept new clients that connect, while
        a non-active service will let connecting clients queue
        up until the service is started.
        """
    @classmethod
    def new(cls) -> SocketService:
        """
            Creates a new GSocketService with no sockets to listen for.
        New listeners can be added with e.g. `g_socket_listener_add_address`
        or `g_socket_listener_add_inet_port`.

        New services are created active, there is no need to call
        `g_socket_service_start`, unless `g_socket_service_stop` has been
        called before.
        """
    def start(self) -> None:
        """
            Restarts the service, i.e. start accepting connections
        from the added sockets when the mainloop runs. This only needs
        to be called after the service has been stopped from
        `g_socket_service_stop`.

        This call is thread-safe, so it may be called from a thread
        handling an incoming client request.
        """
    def stop(self) -> None:
        """
            Stops the service, i.e. stops accepting connections
        from the added sockets when the mainloop runs.

        This call is thread-safe, so it may be called from a thread
        handling an incoming client request.

        Note that this only stops accepting new connections; it does not
        close the listening sockets, and you can call
        `g_socket_service_start` again later to begin listening again. To
        close the listening sockets, call `g_socket_listener_close`. (This
        will happen automatically when the GSocketService is finalized.)

        This must be called before calling `g_socket_listener_close` as
        the socket service will start accepting connections immediately
        when a new socket is added.
        """

    # python methods (overrides?)
    def do_incoming(
        self,
        connection: SocketConnection,
        source_object: GObject.Object,
    ) -> bool:
        """
        incoming(self, connection:Gio.SocketConnection, source_object:GObject.Object) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["incoming"],
        handler: typing.Callable[[typing_extensions.Self, SocketConnection, GObject.Object | None], bool],
        *args: typing.Any,
    ) -> int:
        """
            The ::incoming signal is emitted when a new incoming connection
        to `service` needs to be handled. The handler must initiate the
        handling of `connection`, but may not block; in essence,
        asynchronous operations must be used.

        `connection` will be unreffed once the signal handler returns,
        so you need to ref it yourself if you are planning to use it.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::active"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SocketServiceClass(GObject.GPointer):
    """
    Class structure for GSocketService.
    """

    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def incoming(self) -> incomingSocketServiceClassCB:
        """
        signal emitted when new connections are accepted
        """
    @builtins.property
    def parent_class(self) -> SocketListenerClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SocketServicePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class SrvTarget(GObject.GBoxed):
    """
    A single target host/port that a network service is running on.

    SRV (service) records are used by some network protocols to provide
    service-specific aliasing and load-balancing. For example, XMPP
    (Jabber) uses SRV records to locate the XMPP server for a domain;
    rather than connecting directly to ‘example.com’ or assuming a
    specific server hostname like ‘xmpp.example.com’, an XMPP client
    would look up the `xmpp-client` SRV record for ‘example.com’, and
    then connect to whatever host was pointed to by that record.

    You can use [method`Gio`.Resolver.lookup_service] or
    [method`Gio`.Resolver.lookup_service_async] to find the `GSrvTarget`s
    for a given service. However, if you are simply planning to connect
    to the remote service, you can use [class`Gio`.NetworkService]’s
    [iface`Gio`.SocketConnectable] interface and not need to worry about
    `GSrvTarget` at all.
    """

    # gi Methods
    def copy(self) -> SrvTarget:
        """
        Copies `target`
        """
    def free(self) -> None:
        """
        Frees `target`
        """
    def get_hostname(self) -> str:
        """
            Gets `target`'s hostname (in ASCII form; if you are going to present
        this to the user, you should use `g_hostname_is_ascii_encoded` to
        check if it contains encoded Unicode segments, and use
        `g_hostname_to_unicode` to convert it if it does.)
        """
    def get_port(self) -> int:
        """
        Gets `target`'s port
        """
    def get_priority(self) -> int:
        """
            Gets `target`'s priority. You should not need to look at this;
        GResolver already sorts the targets according to the algorithm in
        RFC 2782.
        """
    def get_weight(self) -> int:
        """
            Gets `target`'s weight. You should not need to look at this;
        GResolver already sorts the targets according to the algorithm in
        RFC 2782.
        """
    @classmethod
    def new(cls, hostname: str, port: int, priority: int, weight: int) -> SrvTarget:
        """
            Creates a new GSrvTarget with the given parameters.

        You should not need to use this; normally GSrvTargets are
        created by GResolver.
        """

    # python methods (overrides?)
    @staticmethod
    def __init__(
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

class StaticResource(GObject.GPointer):
    """
    `GStaticResource` is an opaque data structure and can only be accessed
    using the following functions.
    """

    # gi Fields
    @builtins.property
    def data(self) -> int: ...
    @builtins.property
    def data_len(self) -> int: ...
    @builtins.property
    def next(self) -> StaticResource | None: ...
    @builtins.property
    def padding(self) -> object | None: ...
    @builtins.property
    def resource(self) -> Resource | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def fini(self) -> None:
        """
            Finalizes a [struct`Gio`.Resource] initialized by
        [method`Gio`.StaticResource.init].

        This is normally used by code generated by
        [`glib-compile-resources`](glib-compile-resources.html)
        and is not typically used by other code.
        """
    def get_resource(self) -> Resource:
        """
            Gets the [struct`Gio`.Resource] that was registered by a call to
        [method`Gio`.StaticResource.init].

        This is normally used by code generated by
        [`glib-compile-resources`](glib-compile-resources.html)
        and is not typically used by other code.
        """
    def init(self) -> None:
        """
            Initializes a [struct`Gio`.Resource] from static data using a
        [struct`Gio`.StaticResource].

        This is normally used by code generated by
        [`glib-compile-resources`](glib-compile-resources.html)
        and is not typically used by other code.
        """

class Subprocess(GObject.Object):
    """
    `GSubprocess` allows the creation of and interaction with child
    processes.

    Processes can be communicated with using standard GIO-style APIs (ie:
    [class`Gio`.InputStream], [class`Gio`.OutputStream]). There are GIO-style APIs
    to wait for process termination (ie: cancellable and with an asynchronous
    variant).

    There is an API to force a process to terminate, as well as a
    race-free API for sending UNIX signals to a subprocess.

    One major advantage that GIO brings over the core GLib library is
    comprehensive API for asynchronous I/O, such
    [method`Gio`.OutputStream.splice_async].  This makes `GSubprocess`
    significantly more powerful and flexible than equivalent APIs in
    some other languages such as the `subprocess.py`
    included with Python.  For example, using `GSubprocess` one could
    create two child processes, reading standard output from the first,
    processing it, and writing to the input stream of the second, all
    without blocking the main loop.

    A powerful [method`Gio`.Subprocess.communicate] API is provided similar to the
    ``communicate`` method of `subprocess.py`. This enables very easy
    interaction with a subprocess that has been opened with pipes.

    `GSubprocess` defaults to tight control over the file descriptors open
    in the child process, avoiding dangling-FD issues that are caused by
    a simple ``fork``/``exec``.  The only open file descriptors in the
    spawned process are ones that were explicitly specified by the
    `GSubprocess` API (unless `G_SUBPROCESS_FLAGS_INHERIT_FDS` was
    specified).

    `GSubprocess` will quickly reap all child processes as they exit,
    avoiding ‘zombie processes’ remaining around for long periods of
    time.  [method`Gio`.Subprocess.wait] can be used to wait for this to happen,
    but it will happen even without the call being explicitly made.

    As a matter of principle, `GSubprocess` has no API that accepts
    shell-style space-separated strings.  It will, however, match the
    typical shell behaviour of searching the `PATH` for executables that do
    not contain a directory separator in their name. By default, the `PATH`
    of the current process is used.  You can specify
    `G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP` to use the `PATH` of the
    launcher environment instead.

    `GSubprocess` attempts to have a very simple API for most uses (ie:
    spawning a subprocess with arguments and support for most typical
    kinds of input and output redirection).  See [ctor`Gio`.Subprocess.new]. The
    [class`Gio`.SubprocessLauncher] API is provided for more complicated cases
    (advanced types of redirection, environment variable manipulation,
    change of working directory, child setup functions, etc).

    A typical use of `GSubprocess` will involve calling
    [ctor`Gio`.Subprocess.new], followed by [method`Gio`.Subprocess.wait_async] or
    [method`Gio`.Subprocess.wait].  After the process exits, the status can be
    checked using functions such as [method`Gio`.Subprocess.get_if_exited] (which
    are similar to the familiar `WIFEXITED`-style POSIX macros).

    Note that as of GLib 2.82, creating a `GSubprocess` causes the signal
    `SIGPIPE` to be ignored for the remainder of the program. If you are writing
    a command-line utility that uses `GSubprocess`, you may need to take into
    account the fact that your program will not automatically be killed
    if it tries to write to `stdout` after it has been closed.
    """

    class Props(GObject.Object.Props):
        argv: list | None
        """
        Argument vector.
        """
        flags: SubprocessFlags
        """
        Subprocess flags.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, argv: list | None = ..., flags: SubprocessFlags = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def communicate(
        self, stdin_buf: GLib.Bytes | None = None, cancellable: Cancellable | None = None
    ) -> tuple[bool, GLib.Bytes | None, GLib.Bytes | None]:
        """
            Communicate with the subprocess until it terminates, and all input
        and output has been completed.

        If `stdin_buf` is given, the subprocess must have been created with
        G_SUBPROCESS_FLAGS_STDIN_PIPE.  The given data is fed to the
        stdin of the subprocess and the pipe is closed (ie: EOF).

        At the same time (as not to cause blocking when dealing with large
        amounts of data), if G_SUBPROCESS_FLAGS_STDOUT_PIPE or
        G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those
        streams.  The data that was read is returned in `stdout` and/or
        the `stderr`.

        If the subprocess was created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
        `stdout_buf` will contain the data read from stdout.  Otherwise, for
        subprocesses not created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
        `stdout_buf` will be set to None.  Similar provisions apply to
        `stderr_buf` and G_SUBPROCESS_FLAGS_STDERR_PIPE.

        As usual, any output variable may be given as None to ignore it.

        If you desire the stdout and stderr data to be interleaved, create
        the subprocess with G_SUBPROCESS_FLAGS_STDOUT_PIPE and
        G_SUBPROCESS_FLAGS_STDERR_MERGE.  The merged result will be returned
        in `stdout_buf` and `stderr_buf` will be set to None.

        In case of any error (including cancellation), False will be
        returned with `error` set.  Some or all of the stdin data may have
        been written.  Any stdout or stderr data that has been read will be
        discarded. None of the out variables (aside from `error`) will have
        been set to anything in particular and should not be inspected.

        In the case that True is returned, the subprocess has exited and the
        exit status inspection APIs (eg: `g_subprocess_get_if_exited`,
        `g_subprocess_get_exit_status`) may be used.

        You should not attempt to use any of the subprocess pipes after
        starting this function, since they may be left in strange states,
        even if the operation was cancelled.  You should especially not
        attempt to interact with the pipes while the operation is in progress
        (either from another thread or if using the asynchronous version).
        """
    async def communicate_async(
        self,
        stdin_buf: GLib.Bytes | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronous version of `g_subprocess_communicate`.  Complete
        invocation with `g_subprocess_communicate_finish`.
        """
    def communicate_finish(self, result: AsyncResult) -> tuple[bool, GLib.Bytes | None, GLib.Bytes | None]:
        """
        Complete an invocation of `g_subprocess_communicate_async`.
        """
    def communicate_utf8(
        self, stdin_buf: str | None = None, cancellable: Cancellable | None = None
    ) -> tuple[bool, str | None, str | None]:
        """
            Like `g_subprocess_communicate`, but validates the output of the
        process as UTF-8, and returns it as a regular NUL terminated string.

        On error, `stdout_buf` and `stderr_buf` will be set to undefined values and
        should not be used.
        """
    async def communicate_utf8_async(
        self,
        stdin_buf: str | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronous version of `g_subprocess_communicate_utf8`.  Complete
        invocation with `g_subprocess_communicate_utf8_finish`.
        """
    def communicate_utf8_finish(self, result: AsyncResult) -> tuple[bool, str | None, str | None]:
        """
        Complete an invocation of `g_subprocess_communicate_utf8_async`.
        """
    def force_exit(self) -> None:
        """
            Use an operating-system specific method to attempt an immediate,
        forceful termination of the process.  There is no mechanism to
        determine whether or not the request itself was successful;
        however, you can use `g_subprocess_wait` to monitor the status of
        the process after calling this function.

        On Unix, this function sends SIGKILL.
        """
    def get_exit_status(self) -> int:
        """
            Check the exit status of the subprocess, given that it exited
        normally.  This is the value passed to the `exit` system call or the
        return value from main.

        This is equivalent to the system WEXITSTATUS macro.

        It is an error to call this function before `g_subprocess_wait` and
        unless `g_subprocess_get_if_exited` returned True.
        """
    def get_identifier(self) -> str | None:
        """
            On UNIX, returns the process ID as a decimal string.
        On Windows, returns the result of `GetProcessId` also as a string.
        If the subprocess has terminated, this will return None.
        """
    def get_if_exited(self) -> bool:
        """
            Check if the given subprocess exited normally (ie: by way of `exit`
        or return from `main`).

        This is equivalent to the system WIFEXITED macro.

        It is an error to call this function before `g_subprocess_wait` has
        returned.
        """
    def get_if_signaled(self) -> bool:
        """
            Check if the given subprocess terminated in response to a signal.

        This is equivalent to the system WIFSIGNALED macro.

        It is an error to call this function before `g_subprocess_wait` has
        returned.
        """
    def get_status(self) -> int:
        """
            Gets the raw status code of the process, as from `waitpid`.

        This value has no particular meaning, but it can be used with the
        macros defined by the system headers such as WIFEXITED.  It can also
        be used with `g_spawn_check_wait_status`.

        It is more likely that you want to use `g_subprocess_get_if_exited`
        followed by `g_subprocess_get_exit_status`.

        It is an error to call this function before `g_subprocess_wait` has
        returned.
        """
    def get_stderr_pipe(self) -> InputStream | None:
        """
            Gets the GInputStream from which to read the stderr output of
        `subprocess`.

        The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE,
        otherwise None will be returned.
        """
    def get_stdin_pipe(self) -> OutputStream | None:
        """
            Gets the GOutputStream that you can write to in order to give data
        to the stdin of `subprocess`.

        The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE and
        not G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise None will be returned.
        """
    def get_stdout_pipe(self) -> InputStream | None:
        """
            Gets the GInputStream from which to read the stdout output of
        `subprocess`.

        The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
        otherwise None will be returned.
        """
    def get_successful(self) -> bool:
        """
            Checks if the process was "successful".  A process is considered
        successful if it exited cleanly with an exit status of 0, either by
        way of the `exit` system call or return from `main`.

        It is an error to call this function before `g_subprocess_wait` has
        returned.
        """
    def get_term_sig(self) -> int:
        """
            Get the signal number that caused the subprocess to terminate, given
        that it terminated due to a signal.

        This is equivalent to the system WTERMSIG macro.

        It is an error to call this function before `g_subprocess_wait` and
        unless `g_subprocess_get_if_signaled` returned True.
        """
    @classmethod
    def new(cls, argv: list, flags: SubprocessFlags) -> Subprocess:
        """
            Create a new process with the given flags and varargs argument
        list.  By default, matching the `g_spawn_async` defaults, the
        child's stdin will be set to the system null device, and
        stdout/stderr will be inherited from the parent.  You can use
        `flags` to control this behavior.

        The argument list must be terminated with None.
        """
    def send_signal(self, signal_num: int) -> None:
        """
            Sends the UNIX signal `signal_num` to the subprocess, if it is still
        running.

        This API is race-free.  If the subprocess has terminated, it will not
        be signalled.

        This API is not available on Windows.
        """
    def wait(self, cancellable: Cancellable | None = None) -> bool:
        """
            Synchronously wait for the subprocess to terminate.

        After the process terminates you can query its exit status with
        functions such as `g_subprocess_get_if_exited` and
        `g_subprocess_get_exit_status`.

        This function does not fail in the case of the subprocess having
        abnormal termination.  See `g_subprocess_wait_check` for that.

        Cancelling `cancellable` doesn't kill the subprocess.  Call
        `g_subprocess_force_exit` if it is desirable.
        """
    async def wait_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Wait for the subprocess to terminate.

        This is the asynchronous version of `g_subprocess_wait`.
        """
    def wait_check(self, cancellable: Cancellable | None = None) -> bool:
        """
        Combines `g_subprocess_wait` with `g_spawn_check_wait_status`.
        """
    async def wait_check_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Combines `g_subprocess_wait_async` with `g_spawn_check_wait_status`.

        This is the asynchronous version of `g_subprocess_wait_check`.
        """
    def wait_check_finish(self, result: AsyncResult) -> bool:
        """
            Collects the result of a previous call to
        `g_subprocess_wait_check_async`.
        """
    def wait_finish(self, result: AsyncResult) -> bool:
        """
            Collects the result of a previous call to
        `g_subprocess_wait_async`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::argv"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class SubprocessLauncher(GObject.Object):
    """
    This class contains a set of options for launching child processes,
    such as where its standard input and output will be directed, the
    argument list, the environment, and more.

    While the [class`Gio`.Subprocess] class has high level functions covering
    popular cases, use of this class allows access to more advanced
    options.  It can also be used to launch multiple subprocesses with
    a similar configuration.
    """

    class Props(GObject.Object.Props):
        flags: SubprocessFlags
        """
        [flags`Gio`.SubprocessFlags] for launched processes.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, flags: SubprocessFlags = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def close(self) -> None:
        """
            Closes all the file descriptors previously passed to the object with
        `g_subprocess_launcher_take_fd`, `g_subprocess_launcher_take_stderr_fd`, etc.

        After calling this method, any subsequent calls to `g_subprocess_launcher_spawn` or `g_subprocess_launcher_spawnv` will
        return G_IO_ERROR_CLOSED. This method is idempotent if
        called more than once.

        This function is called automatically when the GSubprocessLauncher
        is disposed, but is provided separately so that garbage collected
        language bindings can call it earlier to guarantee when FDs are closed.
        """
    def getenv(self, variable: str) -> str | None:
        """
            Returns the value of the environment variable `variable` in the
        environment of processes launched from this launcher.

        On UNIX, the returned string can be an arbitrary byte string.
        On Windows, it will be UTF-8.
        """
    @classmethod
    def new(cls, flags: SubprocessFlags) -> SubprocessLauncher:
        """
            Creates a new GSubprocessLauncher.

        The launcher is created with the default options.  A copy of the
        environment of the calling process is made at the time of this call
        and will be used as the environment that the process is launched in.
        """
    def set_cwd(self, cwd: str) -> None:
        """
            Sets the current working directory that processes will be launched
        with.

        By default processes are launched with the current working directory
        of the launching process at the time of launch.
        """
    def set_environ(self, env: list) -> None:
        """
            Replace the entire environment of processes launched from this
        launcher with the given 'environ' variable.

        Typically you will build this variable by using `g_listenv` to copy
        the process 'environ' and using the functions `g_environ_setenv`,
        `g_environ_unsetenv`, etc.

        As an alternative, you can use `g_subprocess_launcher_setenv`,
        `g_subprocess_launcher_unsetenv`, etc.

        Pass an empty array to set an empty environment. Pass None to inherit the
        parent process’ environment. As of GLib 2.54, the parent process’ environment
        will be copied when `g_subprocess_launcher_set_environ` is called.
        Previously, it was copied when the subprocess was executed. This means the
        copied environment may now be modified (using `g_subprocess_launcher_setenv`,
        etc.) before launching the subprocess.

        On UNIX, all strings in this array can be arbitrary byte strings.
        On Windows, they should be in UTF-8.
        """
    def set_flags(self, flags: SubprocessFlags) -> None:
        """
            Sets the flags on the launcher.

        The default flags are G_SUBPROCESS_FLAGS_NONE.

        You may not set flags that specify conflicting options for how to
        handle a particular stdio stream (eg: specifying both
        G_SUBPROCESS_FLAGS_STDIN_PIPE and
        G_SUBPROCESS_FLAGS_STDIN_INHERIT).

        You may also not set a flag that conflicts with a previous call to a
        function like `g_subprocess_launcher_set_stdin_file_path` or
        `g_subprocess_launcher_take_stdout_fd`.
        """
    def set_stderr_file_path(self, path: str | None = None) -> None:
        """
            Sets the file path to use as the stderr for spawned processes.

        If `path` is None then any previously given path is unset.

        The file will be created or truncated when the process is spawned, as
        would be the case if using '2>' at the shell.

        If you want to send both stdout and stderr to the same file then use
        G_SUBPROCESS_FLAGS_STDERR_MERGE.

        You may not set a stderr file path if a stderr fd is already set or
        if the launcher flags contain any flags directing stderr elsewhere.

        This feature is only available on UNIX.
        """
    def set_stdin_file_path(self, path: str | None = None) -> None:
        """
            Sets the file path to use as the stdin for spawned processes.

        If `path` is None then any previously given path is unset.

        The file must exist or spawning the process will fail.

        You may not set a stdin file path if a stdin fd is already set or if
        the launcher flags contain any flags directing stdin elsewhere.

        This feature is only available on UNIX.
        """
    def set_stdout_file_path(self, path: str | None = None) -> None:
        """
            Sets the file path to use as the stdout for spawned processes.

        If `path` is None then any previously given path is unset.

        The file will be created or truncated when the process is spawned, as
        would be the case if using '>' at the shell.

        You may not set a stdout file path if a stdout fd is already set or
        if the launcher flags contain any flags directing stdout elsewhere.

        This feature is only available on UNIX.
        """
    def setenv(self, variable: str, value: str, overwrite: bool) -> None:
        """
            Sets the environment variable `variable` in the environment of
        processes launched from this launcher.

        On UNIX, both the variable's name and value can be arbitrary byte
        strings, except that the variable's name cannot contain '='.
        On Windows, they should be in UTF-8.
        """
    def spawnv(self, argv: list) -> Subprocess:
        """
        Creates a GSubprocess given a provided array of arguments.
        """
    def take_fd(self, source_fd: int, target_fd: int) -> None:
        """
            Transfer an arbitrary file descriptor from parent process to the
        child.  This function takes ownership of the `source_fd`; it will be closed
        in the parent when `self` is freed.

        By default, all file descriptors from the parent will be closed.
        This function allows you to create (for example) a custom ``pipe`` or
        ``socketpair`` before launching the process, and choose the target
        descriptor in the child.

        An example use case is GNUPG, which has a command line argument
        `--passphrase-fd` providing a file descriptor number where it expects
        the passphrase to be written.
        """
    def take_stderr_fd(self, fd: int) -> None:
        """
            Sets the file descriptor to use as the stderr for spawned processes.

        If `fd` is -1 then any previously given fd is unset.

        Note that the default behaviour is to pass stderr through to the
        stderr of the parent process.

        The passed `fd` belongs to the GSubprocessLauncher.  It will be
        automatically closed when the launcher is finalized.  The file
        descriptor will also be closed on the child side when executing the
        spawned process.

        You may not set a stderr fd if a stderr file path is already set or
        if the launcher flags contain any flags directing stderr elsewhere.

        This feature is only available on UNIX.
        """
    def take_stdin_fd(self, fd: int) -> None:
        """
            Sets the file descriptor to use as the stdin for spawned processes.

        If `fd` is -1 then any previously given fd is unset.

        Note that if your intention is to have the stdin of the calling
        process inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT
        is a better way to go about doing that.

        The passed `fd` is noted but will not be touched in the current
        process.  It is therefore necessary that it be kept open by the
        caller until the subprocess is spawned.  The file descriptor will
        also not be explicitly closed on the child side, so it must be marked
        O_CLOEXEC if that's what you want.

        You may not set a stdin fd if a stdin file path is already set or if
        the launcher flags contain any flags directing stdin elsewhere.

        This feature is only available on UNIX.
        """
    def take_stdout_fd(self, fd: int) -> None:
        """
            Sets the file descriptor to use as the stdout for spawned processes.

        If `fd` is -1 then any previously given fd is unset.

        Note that the default behaviour is to pass stdout through to the
        stdout of the parent process.

        The passed `fd` is noted but will not be touched in the current
        process.  It is therefore necessary that it be kept open by the
        caller until the subprocess is spawned.  The file descriptor will
        also not be explicitly closed on the child side, so it must be marked
        O_CLOEXEC if that's what you want.

        You may not set a stdout fd if a stdout file path is already set or
        if the launcher flags contain any flags directing stdout elsewhere.

        This feature is only available on UNIX.
        """
    def unsetenv(self, variable: str) -> None:
        """
            Removes the environment variable `variable` from the environment of
        processes launched from this launcher.

        On UNIX, the variable's name can be an arbitrary byte string not
        containing '='. On Windows, it should be in UTF-8.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class Task(GObject.Object):
    """
    A `GTask` represents and manages a cancellable ‘task’.

    ## Asynchronous operations

    The most common usage of `GTask` is as a [iface`Gio`.AsyncResult], to
    manage data during an asynchronous operation. You call
    [ctor`Gio`.Task.new] in the ‘start’ method, followed by
    [method`Gio`.Task.set_task_data] and the like if you need to keep some
    additional data associated with the task, and then pass the
    task object around through your asynchronous operation.
    Eventually, you will call a method such as
    [method`Gio`.Task.return_pointer] or [method`Gio`.Task.return_error], which
    will save the value you give it and then invoke the task’s callback
    function in the thread-default main context (see
    [method`GLib`.MainContext.push_thread_default])
    where it was created (waiting until the next iteration of the main
    loop first, if necessary). The caller will pass the `GTask` back to
    the operation’s finish function (as a [iface`Gio`.AsyncResult]), and you can
    use [method`Gio`.Task.propagate_pointer] or the like to extract the
    return value.

    Using `GTask` requires the thread-default [struct`GLib`.MainContext] from when
    the `GTask` was constructed to be running at least until the task has
    completed and its data has been freed.

    If a `GTask` has been constructed and its callback set, it is an error to
    not call `g_task_return_*()` on it. GLib will warn at runtime if this happens
    (since 2.76).

    Here is an example for using `GTask` as a [iface`Gio`.AsyncResult]:
    ```c
    typedef struct {
      CakeFrostingType frosting;
      char *message;
    } DecorationData;

    static void
    decoration_data_free (DecorationData *decoration)
    {
      g_free (decoration->message);
      g_slice_free (DecorationData, decoration);
    }

    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      DecorationData *decoration = g_task_get_task_data (task);
      GError *error = None;

      if (cake == None)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }

      if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
        {
          g_object_unref (cake);
          // `g_task_return_error` takes ownership of error
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }

      g_task_return_pointer (task, cake, g_object_unref);
      g_object_unref (task);
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      DecorationData *decoration;
      Cake  *cake;

      task = g_task_new (self, cancellable, callback, user_data);
      if (radius < 3)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
                                   "%ucm radius cakes are silly",
                                   radius);
          g_object_unref (task);
          return;
        }

      cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
      if (cake != None)
        {
          // `_baker_get_cached_cake` returns a reffed cake
          g_task_return_pointer (task, cake, g_object_unref);
          g_object_unref (task);
          return;
        }

      decoration = g_slice_new (DecorationData);
      decoration->frosting = frosting;
      decoration->message = g_strdup (message);
      g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);

      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), None);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
    ```

    ## Chained asynchronous operations

    `GTask` also tries to simplify asynchronous operations that
    internally chain together several smaller asynchronous
    operations. [method`Gio`.Task.get_cancellable], [method`Gio`.Task.get_context],
    and [method`Gio`.Task.get_priority] allow you to get back the task’s
    [class`Gio`.Cancellable], [struct`GLib`.MainContext], and
    [I/O priority](iface.AsyncResult.html#io-priority)
    when starting a new subtask, so you don’t have to keep track
    of them yourself. [method`Gio`.Task.attach_source] simplifies the case
    of waiting for a source to fire (automatically using the correct
    [struct`GLib`.MainContext] and priority).

    Here is an example for chained asynchronous operations:
    ```c
    typedef struct {
      Cake *cake;
      CakeFrostingType frosting;
      char *message;
    } BakingData;

    static void
    decoration_data_free (BakingData *bd)
    {
      if (bd->cake)
        g_object_unref (bd->cake);
      g_free (bd->message);
      g_slice_free (BakingData, bd);
    }

    static void
    decorated_cb (Cake         *cake,
                  GAsyncResult *result,
                  gpointer      user_data)
    {
      GTask *task = user_data;
      GError *error = None;

      if (!cake_decorate_finish (cake, result, &error))
        {
          g_object_unref (cake);
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }

      // `baking_data_free` will drop its ref on the cake, so we have to
      // take another here to give to the caller.
      g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
      g_object_unref (task);
    }

    static gboolean
    decorator_ready (gpointer user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);

      cake_decorate_async (bd->cake, bd->frosting, bd->message,
                           g_task_get_cancellable (task),
                           decorated_cb, task);

      return G_SOURCE_REMOVE;
    }

    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);
      GError *error = None;

      if (cake == None)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }

      bd->cake = cake;

      // Bail out now if the user has already cancelled
      if (g_task_return_error_if_cancelled (task))
        {
          g_object_unref (task);
          return;
        }

      if (cake_decorator_available (cake))
        decorator_ready (task);
      else
        {
          GSource *source;

          source = cake_decorator_wait_source_new (cake);
          // Attach `source` to `task`’s GMainContext and have it call
          // `decorator_ready` when it is ready.
          g_task_attach_source (task, source, decorator_ready);
          g_source_unref (source);
        }
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           gint                 priority,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      BakingData *bd;

      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_priority (task, priority);

      bd = g_slice_new0 (BakingData);
      bd->frosting = frosting;
      bd->message = g_strdup (message);
      g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);

      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), None);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
    ```

    ## Asynchronous operations from synchronous ones

    You can use [method`Gio`.Task.run_in_thread] to turn a synchronous
    operation into an asynchronous one, by running it in a thread.
    When it completes, the result will be dispatched to the thread-default
    main context (see [method`GLib`.MainContext.push_thread_default])
    where the `GTask` was created.

    Running a task in a thread:
    ```c
    typedef struct {
      guint radius;
      CakeFlavor flavor;
      CakeFrostingType frosting;
      char *message;
    } CakeData;

    static void
    cake_data_free (CakeData *cake_data)
    {
      g_free (cake_data->message);
      g_slice_free (CakeData, cake_data);
    }

    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = None;

      cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
                        cake_data->frosting, cake_data->message,
                        cancellable, &error);
      if (cake)
        g_task_return_pointer (task, cake, g_object_unref);
      else
        g_task_return_error (task, error);
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;

      cake_data = g_slice_new (CakeData);
      cake_data->radius = radius;
      cake_data->flavor = flavor;
      cake_data->frosting = frosting;
      cake_data->message = g_strdup (message);
      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_run_in_thread (task, bake_cake_thread);
      g_object_unref (task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), None);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
    ```

    ## Adding cancellability to uncancellable tasks

    Finally, [method`Gio`.Task.run_in_thread] and
    [method`Gio`.Task.run_in_thread_sync] can be used to turn an uncancellable
    operation into a cancellable one. If you call
    [method`Gio`.Task.set_return_on_cancel], passing `True`, then if the task’s
    [class`Gio`.Cancellable] is cancelled, it will return control back to the
    caller immediately, while allowing the task thread to continue running in the
    background (and simply discarding its result when it finally does finish).
    Provided that the task thread is careful about how it uses
    locks and other externally-visible resources, this allows you
    to make ‘GLib-friendly’ asynchronous and cancellable
    synchronous variants of blocking APIs.

    Cancelling a task:
    ```c
    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = None;

      cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
                        cake_data->frosting, cake_data->message,
                        &error);
      if (error)
        {
          g_task_return_error (task, error);
          return;
        }

      // If the task has already been cancelled, then we don’t want to add
      // the cake to the cake cache. Likewise, we don’t  want to have the
      // task get cancelled in the middle of updating the cache.
      // `g_task_set_return_on_cancel` will return True here if it managed
      // to disable return-on-cancel, or False if the task was cancelled
      // before it could.
      if (g_task_set_return_on_cancel (task, False))
        {
          // If the caller cancels at this point, their
          // GAsyncReadyCallback won’t be invoked until we return,
          // so we don’t have to worry that this code will run at
          // the same time as that code does. But if there were
          // other functions that might look at the cake cache,
          // then we’d probably need a GMutex here as well.
          baker_add_cake_to_cache (baker, cake);
          g_task_return_pointer (task, cake, g_object_unref);
        }
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;

      cake_data = g_slice_new (CakeData);

      ...

      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, True);
      g_task_run_in_thread (task, bake_cake_thread);
    }

    Cake *
    baker_bake_cake_sync (Baker               *self,
                          guint                radius,
                          CakeFlavor           flavor,
                          CakeFrostingType     frosting,
                          const char          *message,
                          GCancellable        *cancellable,
                          GError             **error)
    {
      CakeData *cake_data;
      GTask *task;
      Cake *cake;

      cake_data = g_slice_new (CakeData);

      ...

      task = g_task_new (self, cancellable, None, None);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, True);
      g_task_run_in_thread_sync (task, bake_cake_thread);

      cake = g_task_propagate_pointer (task, error);
      g_object_unref (task);
      return cake;
    }
    ```

    ## Porting from [class`Gio`.SimpleAsyncResult]

    `GTask`’s API attempts to be simpler than [class`Gio`.SimpleAsyncResult]’s
    in several ways:

    - You can save task-specific data with [method`Gio`.Task.set_task_data], and
      retrieve it later with [method`Gio`.Task.get_task_data]. This replaces the
      abuse of [method`Gio`.SimpleAsyncResult.set_op_res_gpointer] for the same
      purpose with [class`Gio`.SimpleAsyncResult].
    - In addition to the task data, `GTask` also keeps track of the
      [priority](iface.AsyncResult.html#io-priority), [class`Gio`.Cancellable],
      and [struct`GLib`.MainContext] associated with the task, so tasks that
      consist of a chain of simpler asynchronous operations will have easy access
      to those values when starting each sub-task.
    - [method`Gio`.Task.return_error_if_cancelled] provides simplified
      handling for cancellation. In addition, cancellation
      overrides any other `GTask` return value by default, like
      [class`Gio`.SimpleAsyncResult] does when
      [method`Gio`.SimpleAsyncResult.set_check_cancellable] is called.
      (You can use [method`Gio`.Task.set_check_cancellable] to turn off that
      behavior.) On the other hand, [method`Gio`.Task.run_in_thread]
      guarantees that it will always run your
      `task_func`, even if the task’s [class`Gio`.Cancellable]
      is already cancelled before the task gets a chance to run;
      you can start your `task_func` with a
      [method`Gio`.Task.return_error_if_cancelled] check if you need the
      old behavior.
    - The ‘return’ methods (eg, [method`Gio`.Task.return_pointer])
      automatically cause the task to be ‘completed’ as well, and
      there is no need to worry about the ‘complete’ vs ‘complete in idle’
      distinction. (`GTask` automatically figures out
      whether the task’s callback can be invoked directly, or
      if it needs to be sent to another [struct`GLib`.MainContext], or delayed
      until the next iteration of the current [struct`GLib`.MainContext].)
    - The ‘finish’ functions for `GTask` based operations are generally
      much simpler than [class`Gio`.SimpleAsyncResult] ones, normally consisting
      of only a single call to [method`Gio`.Task.propagate_pointer] or the like.
      Since [method`Gio`.Task.propagate_pointer] ‘steals’ the return value from
      the `GTask`, it is not necessary to juggle pointers around to
      prevent it from being freed twice.
    - With [class`Gio`.SimpleAsyncResult], it was common to call
      [method`Gio`.SimpleAsyncResult.propagate_error] from the
      ``_finish`` wrapper function, and have
      virtual method implementations only deal with successful
      returns. This behavior is deprecated, because it makes it
      difficult for a subclass to chain to a parent class’s async
      methods. Instead, the wrapper function should just be a
      simple wrapper, and the virtual method should call an
      appropriate `g_task_propagate_` function.
      Note that wrapper methods can now use
      [method`Gio`.AsyncResult.legacy_propagate_error] to do old-style
      [class`Gio`.SimpleAsyncResult] error-returning behavior, and
      [method`Gio`.AsyncResult.is_tagged] to check if a result is tagged as
      having come from the ``_async`` wrapper
      function (for ‘short-circuit’ results, such as when passing
      `0` to [method`Gio`.InputStream.read_async]).

    ## Thread-safety considerations

    Due to some infelicities in the API design, there is a
    thread-safety concern that users of `GTask` have to be aware of:

    If the `main` thread drops its last reference to the source object
    or the task data before the task is finalized, then the finalizers
    of these objects may be called on the worker thread.

    This is a problem if the finalizers use non-threadsafe API, and
    can lead to hard-to-debug crashes. Possible workarounds include:

    - Clear task data in a signal handler for `notify::completed`
    - Keep iterating a main context in the main thread and defer
      dropping the reference to the source object to that main
      context when the task is finalized
    """

    class Props(GObject.Object.Props):
        completed: bool
        """
        Whether the task has completed, meaning its callback (if set) has been
        invoked.

        This can only happen after `g_task_return_pointer`,
        `g_task_return_error` or one of the other return functions have been called
        on the task. However, it is not guaranteed to happen immediately after
        those functions are called, as the task’s callback may need to be scheduled
        to run in a different thread.

        That means it is **not safe** to use this property to track whether a
        return function has been called on the GTask. Callers must do that
        tracking themselves, typically by linking the lifetime of the GTask to the
        control flow of their code.

        This property is guaranteed to change from False to True exactly once.

        The GObject::notify signal for this change is emitted in the same main
        context as the task’s callback, immediately after that callback is invoked.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_cancellable(self) -> Cancellable | None:
        """
        Gets `task`'s GCancellable
        """
    def get_check_cancellable(self) -> bool:
        """
            Gets `task`'s check-cancellable flag. See
        `g_task_set_check_cancellable` for more details.
        """
    @builtins.property
    def get_completed(self) -> bool:
        """
            Gets the value of GTask:completed. This changes from False to True after
        the task’s callback is invoked, and will return False if called from inside
        the callback.
        """
    def get_context(self) -> GLib.MainContext:
        """
            Gets the GMainContext that `task` will return its result in (that
        is, the context that was the thread-default main context
        (see [method`GLib`.MainContext.push_thread_default])
        at the point when `task` was created).

        This will always return a non-None value, even if the task's
        context is the default GMainContext.
        """
    def get_name(self) -> str | None:
        """
        Gets `task`’s name. See `g_task_set_name`.
        """
    def get_priority(self) -> int:
        """
        Gets `task`'s priority
        """
    def get_return_on_cancel(self) -> bool:
        """
            Gets `task`'s return-on-cancel flag. See
        `g_task_set_return_on_cancel` for more details.
        """
    def get_source_object(self) -> GObject.Object | None:
        """
            Gets the source object from `task`. Like
        `g_async_result_get_source_object`, but does not ref the object.
        """
    def get_source_tag(self) -> object | None:
        """
        Gets `task`'s source tag. See `g_task_set_source_tag`.
        """
    def get_task_data(self) -> object | None:
        """
        Gets `task`'s `task_data`.
        """
    def had_error(self) -> bool:
        """
        Tests if `task` resulted in an error.
        """
    @staticmethod
    def is_valid(result: AsyncResult, source_object: GObject.Object | None = None) -> bool:
        """
            Checks that `result` is a GTask, and that `source_object` is its
        source object (or that `source_object` is None and `result` has no
        source object). This can be used in `g_return_if_fail` checks.
        """
    @classmethod
    def new(
        cls,
        source_object: GObject.Object | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *callback_data: object | None,
    ) -> Task:
        """
            Creates a GTask acting on `source_object`, which will eventually be
        used to invoke `callback` in the current thread-default main context
        (see [method`GLib`.MainContext.push_thread_default]).

        Call this in the "start" method of your asynchronous method, and
        pass the GTask around throughout the asynchronous operation. You
        can use `g_task_set_task_data` to attach task-specific data to the
        object, which you can retrieve later via `g_task_get_task_data`.

        By default, if `cancellable` is cancelled, then the return value of
        the task will always be G_IO_ERROR_CANCELLED, even if the task had
        already completed before the cancellation. This allows for
        simplified handling in cases where cancellation may imply that
        other objects that the task depends on have been destroyed. If you
        do not want this behavior, you can use
        `g_task_set_check_cancellable` to change it.
        """
    def propagate_boolean(self) -> bool:
        """
            Gets the result of `task` as a #gboolean.

        If the task resulted in an error, or was cancelled, then this will
        instead return False and set `error`.

        Since this method transfers ownership of the return value (or
        error) to the caller, you may only call it once.
        """
    def propagate_int(self) -> int:
        """
            Gets the result of `task` as an integer (#gssize).

        If the task resulted in an error, or was cancelled, then this will
        instead return -1 and set `error`.

        Since this method transfers ownership of the return value (or
        error) to the caller, you may only call it once.
        """
    def propagate_pointer(self) -> object | None:
        """
            Gets the result of `task` as a pointer, and transfers ownership
        of that value to the caller.

        If the task resulted in an error, or was cancelled, then this will
        instead return None and set `error`.

        Since this method transfers ownership of the return value (or
        error) to the caller, you may only call it once.
        """
    def propagate_value(self) -> tuple[bool, GObject.Value]:
        """
            Gets the result of `task` as a GValue, and transfers ownership of
        that value to the caller. As with `g_task_return_value`, this is
        a generic low-level method; `g_task_propagate_pointer` and the like
        will usually be more useful for C code.

        If the task resulted in an error, or was cancelled, then this will
        instead set `error` and return False.

        Since this method transfers ownership of the return value (or
        error) to the caller, you may only call it once.
        """
    @staticmethod
    def report_error(
        source_object: GObject.Object | None,
        callback: AsyncReadyCallback | None,
        *callback_data: object | None,
        source_tag: object | None,
        error: GLib.Error,
    ) -> None:
        """
            Creates a GTask and then immediately calls `g_task_return_error`
        on it. Use this in the wrapper function of an asynchronous method
        when you want to avoid even calling the virtual method. You can
        then use `g_async_result_is_tagged` in the finish method wrapper to
        check if the result there is tagged as having been created by the
        wrapper method, and deal with it appropriately if so.

        See also `g_task_report_new_error`.
        """
    def return_boolean(self, result: bool) -> None:
        """
            Sets `task`'s result to `result` and completes the task (see
        `g_task_return_pointer` for more discussion of exactly what this
        means).
        """
    def return_error(self, error: GLib.Error) -> None:
        """
            Sets `task`'s result to `error` (which `task` assumes ownership of)
        and completes the task (see `g_task_return_pointer` for more
        discussion of exactly what this means).

        Note that since the task takes ownership of `error`, and since the
        task may be completed before returning from `g_task_return_error`,
        you cannot assume that `error` is still valid after calling this.
        Call `g_error_copy` on the error if you need to keep a local copy
        as well.

        See also [method`Gio`.Task.return_new_error],
        [method`Gio`.Task.return_new_error_literal].
        """
    def return_error_if_cancelled(self) -> bool:
        """
            Checks if `task`'s GCancellable has been cancelled, and if so, sets
        `task`'s error accordingly and completes the task (see
        `g_task_return_pointer` for more discussion of exactly what this
        means).
        """
    def return_int(self, result: int) -> None:
        """
            Sets `task`'s result to `result` and completes the task (see
        `g_task_return_pointer` for more discussion of exactly what this
        means).
        """
    def return_new_error_literal(self, domain: int, code: int, message: str) -> None:
        """
            Sets `task`’s result to a new [type`GLib`.Error] created from `domain`, `code`,
        `message` and completes the task.

        See [method`Gio`.Task.return_pointer] for more discussion of exactly what
        ‘completing the task’ means.

        See also [method`Gio`.Task.return_new_error].
        """
    def return_pointer(self, result: object | None = None, result_destroy: GLib.DestroyNotify | None = None) -> None:
        """
            Sets `task`'s result to `result` and completes the task. If `result`
        is not None, then `result_destroy` will be used to free `result` if
        the caller does not take ownership of it with
        `g_task_propagate_pointer`.

        "Completes the task" means that for an ordinary asynchronous task
        it will either invoke the task's callback, or else queue that
        callback to be invoked in the proper GMainContext, or in the next
        iteration of the current GMainContext. For a task run via
        `g_task_run_in_thread` or `g_task_run_in_thread_sync`, calling this
        method will save `result` to be returned to the caller later, but
        the task will not actually be completed until the GTaskThreadFunc
        exits.

        Note that since the task may be completed before returning from
        `g_task_return_pointer`, you cannot assume that `result` is still
        valid after calling this, unless you are still holding another
        reference on it.
        """
    def return_value(self, result: GObject.Value | None = None) -> None:
        """
            Sets `task`'s result to `result` (by copying it) and completes the task.

        If `result` is None then a GValue of type G_TYPE_POINTER
        with a value of None will be used for the result.

        This is a very generic low-level method intended primarily for use
        by language bindings; for C code, `g_task_return_pointer` and the
        like will normally be much easier to use.
        """
    def run_in_thread(self, task_func: TaskThreadFunc) -> None:
        """
            Runs `task_func` in another thread. When `task_func` returns, `task`'s
        GAsyncReadyCallback will be invoked in `task`'s GMainContext.

        This takes a ref on `task` until the task completes.

        See GTaskThreadFunc for more details about how `task_func` is handled.

        Although GLib currently rate-limits the tasks queued via
        `g_task_run_in_thread`, you should not assume that it will always
        do this. If you have a very large number of tasks to run (several tens of
        tasks), but don't want them to all run at once, you should only queue a
        limited number of them (around ten) at a time.

        Be aware that if your task depends on other tasks to complete, use of this
        function could lead to a livelock if the other tasks also use this function
        and enough of them (around 10) execute in a dependency chain, as that will
        exhaust the thread pool. If this situation is possible, consider using a
        separate worker thread or thread pool explicitly, rather than using
        `g_task_run_in_thread`.
        """
    def run_in_thread_sync(self, task_func: TaskThreadFunc) -> None:
        """
            Runs `task_func` in another thread, and waits for it to return or be
        cancelled. You can use `g_task_propagate_pointer`, etc, afterward
        to get the result of `task_func`.

        See GTaskThreadFunc for more details about how `task_func` is handled.

        Normally this is used with tasks created with a None
        `callback`, but note that even if the task does
        have a callback, it will not be invoked when `task_func` returns.
        GTask:completed will be set to True just before this function returns.

        Although GLib currently rate-limits the tasks queued via
        `g_task_run_in_thread_sync`, you should not assume that it will
        always do this. If you have a very large number of tasks to run,
        but don't want them to all run at once, you should only queue a
        limited number of them at a time.
        """
    def set_check_cancellable(self, check_cancellable: bool) -> None:
        """
            Sets or clears `task`'s check-cancellable flag. If this is True
        (the default), then `g_task_propagate_pointer`, etc, and
        `g_task_had_error` will check the task's GCancellable first, and
        if it has been cancelled, then they will consider the task to have
        returned an "Operation was cancelled" error
        (G_IO_ERROR_CANCELLED), regardless of any other error or return
        value the task may have had.

        If `check_cancellable` is False, then the GTask will not check the
        cancellable itself, and it is up to `task`'s owner to do this (eg,
        via `g_task_return_error_if_cancelled`).

        If you are using `g_task_set_return_on_cancel` as well, then
        you must leave check-cancellable set True.
        """
    def set_name(self, name: str | None = None) -> None:
        """
            Sets `task`’s name, used in debugging and profiling. The name defaults to
        None.

        The task name should describe in a human readable way what the task does.
        For example, ‘Open file’ or ‘Connect to network host’. It is used to set the
        name of the GSource used for idle completion of the task.

        This function may only be called before the `task` is first used in a thread
        other than the one it was constructed in.
        """
    def set_priority(self, priority: int) -> None:
        """
            Sets `task`'s priority. If you do not call this, it will default to
        G_PRIORITY_DEFAULT.

        This will affect the priority of GSources created with
        `g_task_attach_source` and the scheduling of tasks run in threads,
        and can also be explicitly retrieved later via
        `g_task_get_priority`.
        """
    def set_return_on_cancel(self, return_on_cancel: bool) -> bool:
        """
            Sets or clears `task`'s return-on-cancel flag. This is only
        meaningful for tasks run via `g_task_run_in_thread` or
        `g_task_run_in_thread_sync`.

        If `return_on_cancel` is True, then cancelling `task`'s
        GCancellable will immediately cause it to return, as though the
        task's GTaskThreadFunc had called
        `g_task_return_error_if_cancelled` and then returned.

        This allows you to create a cancellable wrapper around an
        uninterruptible function. The GTaskThreadFunc just needs to be
        careful that it does not modify any externally-visible state after
        it has been cancelled. To do that, the thread should call
        `g_task_set_return_on_cancel` again to (atomically) set
        return-on-cancel False before making externally-visible changes;
        if the task gets cancelled before the return-on-cancel flag could
        be changed, `g_task_set_return_on_cancel` will indicate this by
        returning False.

        You can disable and re-enable this flag multiple times if you wish.
        If the task's GCancellable is cancelled while return-on-cancel is
        False, then calling `g_task_set_return_on_cancel` to set it True
        again will cause the task to be cancelled at that point.

        If the task's GCancellable is already cancelled before you call
        `g_task_run_in_thread`/`g_task_run_in_thread_sync`, then the
        GTaskThreadFunc will still be run (for consistency), but the task
        will also be completed right away.
        """
    def set_source_tag(self, source_tag: object | None = None) -> None:
        """
            Sets `task`'s source tag.

        You can use this to tag a task return
        value with a particular pointer (usually a pointer to the function
        doing the tagging) and then later check it using
        `g_task_get_source_tag` (or `g_async_result_is_tagged`) in the
        task's "finish" function, to figure out if the response came from a
        particular place.

        A macro wrapper around this function will automatically set the
        task’s name to the string form of `source_tag` if it’s not already
        set, for convenience.
        """
    def set_static_name(self, name: str | None = None) -> None:
        """
            Sets `task`’s name, used in debugging and profiling.

        This is a variant of `g_task_set_name` that avoids copying `name`.

        This function is called automatically by [method`Gio`.Task.set_source_tag]
        unless a name is set.
        """
    def set_task_data(
        self, task_data: object | None = None, task_data_destroy: GLib.DestroyNotify | None = None
    ) -> None:
        """
        Sets `task`'s task data (freeing the existing task data, if any).
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::completed"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TaskClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TcpConnection(SocketConnection):
    """
    This is the subclass of [class`Gio`.SocketConnection] that is created
    for TCP/IP sockets.
    """

    class Props(SocketConnection.Props):
        graceful_disconnect: bool  # [graceful-disconnect]: changed because contained invalid characters
        """
        Whether [method`Gio`.IOStream.close] does a graceful disconnect.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> SocketConnection | None: ...
    @builtins.property
    def priv(self) -> TcpConnectionPrivate | None: ...

    # gi Methods
    def __init__(self, graceful_disconnect: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_graceful_disconnect(self) -> bool:
        """
            Checks if graceful disconnects are used. See
        `g_tcp_connection_set_graceful_disconnect`.
        """
    def set_graceful_disconnect(self, graceful_disconnect: bool) -> None:
        """
            This enables graceful disconnects on close. A graceful disconnect
        means that we signal the receiving end that the connection is terminated
        and wait for it to close the connection before closing the connection.

        A graceful disconnect means that we can be sure that we successfully sent
        all the outstanding data to the other end, or get an error reported.
        However, it also means we have to wait for all the data to reach the
        other side and for it to acknowledge this by closing the socket, which may
        take a while. For this reason it is disabled by default.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::graceful_disconnect"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TcpConnectionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SocketConnectionClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TcpConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TcpWrapperConnection(TcpConnection):
    """
    A `GTcpWrapperConnection` can be used to wrap a [class`Gio`.IOStream] that is
    based on a [class`Gio`.Socket], but which is not actually a
    [class`Gio`.SocketConnection]. This is used by [class`Gio`.SocketClient] so
    that it can always return a [class`Gio`.SocketConnection], even when the
    connection it has actually created is not directly a
    [class`Gio`.SocketConnection].
    """

    class Props(TcpConnection.Props):
        base_io_stream: IOStream | None  # [base-io-stream]: changed because contained invalid characters
        """
        The wrapped [class`Gio`.IOStream].
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> TcpConnection | None: ...
    @builtins.property
    def priv(self) -> TcpWrapperConnectionPrivate | None: ...

    # gi Methods
    def __init__(self, base_io_stream: IOStream | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_base_io_stream(self) -> IOStream:
        """
        Gets `conn`'s base GIOStream
        """
    @classmethod
    def new(cls, base_io_stream: IOStream, socket: Socket) -> TcpWrapperConnection:
        """
        Wraps `base_io_stream` and `socket` together as a GSocketConnection.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_io_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TcpWrapperConnectionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> TcpConnectionClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TcpWrapperConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TestDBus(GObject.Object):
    """
    A helper class for testing code which uses D-Bus without touching the user’s
    session bus.

    Note that `GTestDBus` modifies the user’s environment, calling
    [``setenv``](man:setenv(3)). This is not thread-safe, so all `GTestDBus`
    calls should be completed before threads are spawned, or should have
    appropriate locking to ensure no access conflicts to environment variables
    shared between `GTestDBus` and other threads.

    ## Creating unit tests using `GTestDBus`

    Testing of D-Bus services can be tricky because normally we only ever run
    D-Bus services over an existing instance of the D-Bus daemon thus we
    usually don’t activate D-Bus services that are not yet installed into the
    target system. The `GTestDBus` object makes this easier for us by taking care
    of the lower level tasks such as running a private D-Bus daemon and looking
    up uninstalled services in customizable locations, typically in your source
    code tree.

    The first thing you will need is a separate service description file for the
    D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
    is a good place to put this file.

    The service file should list your service along with an absolute path to the
    uninstalled service executable in your source tree. Using autotools we would
    achieve this by adding a file such as `my-server.service.in` in the services
    directory and have it processed by configure.

    ```
    [D-BUS Service]
    Name=org.gtk.GDBus.Examples.ObjectManager
    Exec=`abs_top_builddir`@/gio/tests/gdbus-example-objectmanager-server
    ```

    You will also need to indicate this service directory in your test
    fixtures, so you will need to pass the path while compiling your
    test cases. Typically this is done with autotools with an added
    preprocessor flag specified to compile your tests such as:

    ```
    -DTEST_SERVICES=""$(abs_top_builddir)/tests/services""
    ```

    Once you have a service definition file which is local to your source tree,
    you can proceed to set up a GTest fixture using the `GTestDBus` scaffolding.

    An example of a test fixture for D-Bus services can be found
    here:
    [gdbus-test-fixture.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-test-fixture.c)

    Note that these examples only deal with isolating the D-Bus aspect of your
    service. To successfully run isolated unit tests on your service you may need
    some additional modifications to your test case fixture. For example; if your
    service uses [class`Gio`.Settings] and installs a schema then it is important
    that your test service not load the schema in the ordinary installed location
    (chances are that your service and schema files are not yet installed, or
    worse; there is an older version of the schema file sitting in the install
    location).

    Most of the time we can work around these obstacles using the
    environment. Since the environment is inherited by the D-Bus daemon
    created by `GTestDBus` and then in turn inherited by any services the
    D-Bus daemon activates, using the setup routine for your fixture is
    a practical place to help sandbox your runtime environment. For the
    rather typical GSettings case we can work around this by setting
    `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
    in the above ``fixture_setup`` routine.

    The GSettings schemas need to be locally pre-compiled for this to work. This
    can be achieved by compiling the schemas locally as a step before running
    test cases, an autotools setup might do the following in the directory
    holding schemas:

    ```
        all-am:
                $(GLIB_COMPILE_SCHEMAS) .

        CLEANFILES += gschemas.compiled
    ```
    """

    class Props(GObject.Object.Props):
        flags: TestDBusFlags
        """
        GTestDBusFlags specifying the behaviour of the D-Bus session.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, flags: TestDBusFlags = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def add_service_dir(self, path: str) -> None:
        """
            Add a path where dbus-daemon will look up .service files. This can't be
        called after `g_test_dbus_up`.
        """
    def down(self) -> None:
        """
            Stop the session bus started by `g_test_dbus_up`.

        This will wait for the singleton returned by `g_bus_get` or `g_bus_get_sync`
        to be destroyed. This is done to ensure that the next unit test won't get a
        leaked singleton from this test.
        """
    def get_bus_address(self) -> str | None:
        """
            Get the address on which dbus-daemon is running. If `g_test_dbus_up` has not
        been called yet, None is returned. This can be used with
        `g_dbus_connection_new_for_address`.
        """
    @builtins.property
    def get_flags(self) -> TestDBusFlags:
        """
        Get the flags of the GTestDBus object.
        """
    @classmethod
    def new(cls, flags: TestDBusFlags) -> TestDBus:
        """
        Create a new GTestDBus object.
        """
    def stop(self) -> None:
        """
            Stop the session bus started by `g_test_dbus_up`.

        Unlike `g_test_dbus_down`, this won't verify the GDBusConnection
        singleton returned by `g_bus_get` or `g_bus_get_sync` is destroyed. Unit
        tests wanting to verify behaviour after the session bus has been stopped
        can use this function but should still call `g_test_dbus_down` when done.
        """
    @staticmethod
    def unset() -> None:
        """
            Unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to ensure the test
        won't use user's session bus.

        This is useful for unit tests that want to verify behaviour when no session
        bus is running. It is not necessary to call this if unit test already calls
        `g_test_dbus_up` before acquiring the session bus.
        """
    def up(self) -> None:
        """
            Start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
        call, it is safe for unit tests to start sending messages on the session bus.

        If this function is called from setup callback of `g_test_add`,
        `g_test_dbus_down` must be called in its teardown callback.

        If this function is called from unit test's `main`, then `g_test_dbus_down`
        must be called after `g_test_run`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ThemedIcon(GObject.Object):
    """
    `GThemedIcon` is an implementation of [iface`Gio`.Icon] that supports icon
    themes.

    `GThemedIcon` contains a list of all of the icons present in an icon
    theme, so that icons can be looked up quickly. `GThemedIcon` does
    not provide actual pixmaps for icons, just the icon names.
    Ideally something like [method`Gtk`.IconTheme.choose_icon] should be used to
    resolve the list of names so that fallback icons work nicely with
    themes that inherit other themes.
    """

    class Props(GObject.Object.Props):
        name: str
        """
        The icon name.
        """
        names: list | None
        """
        A None-terminated array of icon names.
        """
        use_default_fallbacks: bool  # [use-default-fallbacks]: changed because contained invalid characters
        """
        Whether to use the default fallbacks found by shortening the icon name
        at '-' characters. If the "names" array has more than one element,
        ignores any past the first.

        For example, if the icon name was "gnome-dev-cdrom-audio", the array
        would become
        |[<!-- language="C" -->
        {
          "gnome-dev-cdrom-audio",
          "gnome-dev-cdrom",
          "gnome-dev",
          "gnome",
          None
        };
        ]|
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, name: str = ..., names: list | None = ..., use_default_fallbacks: bool = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append_name(self, iconname: str) -> None:
        """
            Append a name to the list of icons from within `icon`.

        Note that doing so invalidates the hash computed by prior calls
        to `g_icon_hash`.
        """
    @builtins.property
    def get_names(self) -> list:
        """
        Gets the names of icons from within `icon`.
        """
    @classmethod
    def new(cls, iconname: str) -> ThemedIcon:
        """
        Creates a new themed icon for `iconname`.
        """
    @classmethod
    def new_from_names(cls, iconnames: list, len: int) -> ThemedIcon:
        """
        Creates a new themed icon for `iconnames`.
        """
    @classmethod
    def new_with_default_fallbacks(cls, iconname: str) -> ThemedIcon:
        """
            Creates a new themed icon for `iconname`, and all the names
        that can be created by shortening `iconname` at '-' characters.

        In the following example, `icon1` and `icon2` are equivalent:
        |[<!-- language="C" -->
        const char *names[] = {
          "gnome-dev-cdrom-audio",
          "gnome-dev-cdrom",
          "gnome-dev",
          "gnome"
        };

        icon1 = g_themed_icon_new_from_names (names, 4);
        icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
        ]|
        """
    def prepend_name(self, iconname: str) -> None:
        """
            Prepend a name to the list of icons from within `icon`.

        Note that doing so invalidates the hash computed by prior calls
        to `g_icon_hash`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::names"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_default_fallbacks"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ThemedIconClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ThreadedResolver(Resolver):
    """
    GThreadedResolver is an implementation of GResolver which calls the libc
    lookup functions in threads to allow them to run asynchronously.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ThreadedResolverClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> ResolverClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ThreadedSocketService(SocketService):
    """
    A `GThreadedSocketService` is a simple subclass of [class`Gio`.SocketService]
    that handles incoming connections by creating a worker thread and
    dispatching the connection to it by emitting the
    [signal`Gio`.ThreadedSocketService::run signal] in the new thread.

    The signal handler may perform blocking I/O and need not return
    until the connection is closed.

    The service is implemented using a thread pool, so there is a
    limited amount of threads available to serve incoming requests.
    The service automatically stops the [class`Gio`.SocketService] from accepting
    new connections when all threads are busy.

    As with [class`Gio`.SocketService], you may connect to
    [signal`Gio`.ThreadedSocketService::run], or subclass and override the default
    handler.
    """

    class Props(SocketService.Props):
        max_threads: int  # [max-threads]: changed because contained invalid characters
        """
        The maximum number of threads handling clients for this service.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> SocketService | None: ...
    @builtins.property
    def priv(self) -> ThreadedSocketServicePrivate | None: ...

    # gi Methods
    def __init__(self, max_threads: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @classmethod
    def new(cls, max_threads: int) -> ThreadedSocketService:
        """
            Creates a new GThreadedSocketService with no listeners. Listeners
        must be added with one of the GSocketListener "add" methods.
        """

    # python methods (overrides?)
    def do_run(
        self,
        connection: SocketConnection,
        source_object: GObject.Object,
    ) -> bool:
        """
        run(self, connection:Gio.SocketConnection, source_object:GObject.Object) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["run"],
        handler: typing.Callable[[typing_extensions.Self, SocketConnection, GObject.Object | None], bool],
        *args: typing.Any,
    ) -> int:
        """
            The ::run signal is emitted in a worker thread in response to an
        incoming connection. This thread is dedicated to handling
        `connection` and may perform blocking IO. The signal handler need
        not return until the connection is closed.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::max_threads"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ThreadedSocketServiceClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> SocketServiceClass | None: ...
    @builtins.property
    def run(self) -> runThreadedSocketServiceClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ThreadedSocketServicePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsBackend(GObject.GInterface):
    """
    TLS (Transport Layer Security, aka SSL) and DTLS backend. This is an
    internal type used to coordinate the different classes implemented
    by a TLS backend.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def get_certificate_type(self) -> GObject.GType:
        """
        Gets the GType of `backend`'s GTlsCertificate implementation.
        """
    def get_client_connection_type(self) -> GObject.GType:
        """
        Gets the GType of `backend`'s GTlsClientConnection implementation.
        """
    @staticmethod
    def get_default() -> TlsBackend:
        """
        Gets the default GTlsBackend for the system.
        """
    def get_default_database(self) -> TlsDatabase:
        """
        Gets the default GTlsDatabase used to verify TLS connections.
        """
    def get_dtls_client_connection_type(self) -> GObject.GType:
        """
        Gets the GType of `backend`’s GDtlsClientConnection implementation.
        """
    def get_dtls_server_connection_type(self) -> GObject.GType:
        """
        Gets the GType of `backend`’s GDtlsServerConnection implementation.
        """
    def get_file_database_type(self) -> GObject.GType:
        """
        Gets the GType of `backend`'s GTlsFileDatabase implementation.
        """
    def get_server_connection_type(self) -> GObject.GType:
        """
        Gets the GType of `backend`'s GTlsServerConnection implementation.
        """
    def set_default_database(self, database: TlsDatabase | None = None) -> None:
        """
            Set the default GTlsDatabase used to verify TLS connections

        Any subsequent call to `g_tls_backend_get_default_database` will return
        the database set in this call.  Existing databases and connections are not
        modified.

        Setting a None default database will reset to using the system default
        database as if `g_tls_backend_set_default_database` had never been called.
        """
    def supports_dtls(self) -> bool:
        """
            Checks if DTLS is supported. DTLS support may not be available even if TLS
        support is available, and vice-versa.
        """
    def supports_tls(self) -> bool:
        """
            Checks if TLS is supported; if this returns False for the default
        GTlsBackend, it means no "real" TLS backend is available.
        """

class TlsBackendInterface(GObject.GPointer):
    """
    Provides an interface for describing TLS-related types.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def get_certificate_type(self) -> get_certificate_typeTlsBackendInterfaceCB:
        """
        returns the GTlsCertificate implementation type
        """
    @builtins.property
    def get_client_connection_type(self) -> get_client_connection_typeTlsBackendInterfaceCB:
        """
        returns the GTlsClientConnection implementation type
        """
    @builtins.property
    def get_default_database(self) -> get_default_databaseTlsBackendInterfaceCB:
        """
        returns a default GTlsDatabase instance.
        """
    @builtins.property
    def get_dtls_client_connection_type(self) -> get_dtls_client_connection_typeTlsBackendInterfaceCB:
        """
        returns the GDtlsClientConnection implementation type
        """
    @builtins.property
    def get_dtls_server_connection_type(self) -> get_dtls_server_connection_typeTlsBackendInterfaceCB:
        """
        returns the GDtlsServerConnection implementation type
        """
    @builtins.property
    def get_file_database_type(self) -> get_file_database_typeTlsBackendInterfaceCB:
        """
        returns the GTlsFileDatabase implementation type.
        """
    @builtins.property
    def get_server_connection_type(self) -> get_server_connection_typeTlsBackendInterfaceCB:
        """
        returns the GTlsServerConnection implementation type
        """
    @builtins.property
    def supports_dtls(self) -> supports_dtlsTlsBackendInterfaceCB:
        """
        returns whether the backend supports DTLS
        """
    @builtins.property
    def supports_tls(self) -> supports_tlsTlsBackendInterfaceCB:
        """
        returns whether the backend supports TLS.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsCertificate(GObject.Object):
    """
    A certificate used for TLS authentication and encryption.
    This can represent either a certificate only (eg, the certificate
    received by a client from a server), or the combination of
    a certificate and a private key (which is needed when acting as a
    [iface`Gio`.TlsServerConnection]).
    """

    class Props(GObject.Object.Props):
        certificate: list | None
        """
        The DER (binary) encoded representation of the certificate.
        This property and the GTlsCertificate:certificate-pem property
        represent the same data, just in different forms.
        """
        certificate_pem: str  # [certificate-pem]: changed because contained invalid characters
        """
        The PEM (ASCII) encoded representation of the certificate.
        This property and the GTlsCertificate:certificate
        property represent the same data, just in different forms.
        """
        dns_names: list | None  # [dns-names]: changed because contained invalid characters
        """
        The DNS names from the certificate's Subject Alternative Names (SANs),
        None if unavailable.
        """
        ip_addresses: list | None  # [ip-addresses]: changed because contained invalid characters
        """
        The IP addresses from the certificate's Subject Alternative Names (SANs),
        None if unavailable.
        """
        issuer: TlsCertificate | None
        """
        A GTlsCertificate representing the entity that issued this
        certificate. If None, this means that the certificate is either
        self-signed, or else the certificate of the issuer is not
        available.

        Beware the issuer certificate may not be the same as the
        certificate that would actually be used to construct a valid
        certification path during certificate verification.
        [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
        why an issuer certificate cannot be naively assumed to be part of the
        the certification path (though GLib's TLS backends may not follow the
        path building strategies outlined in this RFC). Due to the complexity
        of certification path building, GLib does not provide any way to know
        which certification path will actually be used. Accordingly, this
        property cannot be used to make security-related decisions. Only
        GLib itself should make security decisions about TLS certificates.
        """
        issuer_name: str  # [issuer-name]: changed because contained invalid characters
        """
        The issuer from the certificate,
        None if unavailable.
        """
        not_valid_after: GLib.DateTime | None  # [not-valid-after]: changed because contained invalid characters
        """
        The time at which this cert is no longer valid,
        None if unavailable.
        """
        not_valid_before: GLib.DateTime | None  # [not-valid-before]: changed because contained invalid characters
        """
        The time at which this cert is considered to be valid,
        None if unavailable.
        """
        password: str
        """
        An optional password used when constructed with GTlsCertificate:pkcs12-data.
        """
        pkcs11_uri: str  # [pkcs11-uri]: changed because contained invalid characters
        """
        A URI referencing the [PKCS #11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
        objects containing an X.509 certificate and optionally a private key.

        If None, the certificate is either not backed by PKCS #11 or the
        GTlsBackend does not support PKCS #11.
        """
        pkcs12_data: list | None  # [pkcs12-data]: changed because contained invalid characters
        """
        The PKCS #12 formatted data used to construct the object.

        See also: `g_tls_certificate_new_from_pkcs12`
        """
        private_key: list | None  # [private-key]: changed because contained invalid characters
        """
        The DER (binary) encoded representation of the certificate's
        private key, in either [PKCS #1 format](https://datatracker.ietf.org/doc/html/rfc8017)
        or unencrypted [PKCS #8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
        PKCS #8 format is supported since 2.32; earlier releases only
        support PKCS #1. You can use the `openssl rsa` tool to convert
        PKCS #8 keys to PKCS #1.

        This property (or the GTlsCertificate:private-key-pem property)
        can be set when constructing a key (for example, from a file).
        Since GLib 2.70, it is now also readable; however, be aware that if
        the private key is backed by a PKCS #11 URI – for example, if it
        is stored on a smartcard – then this property will be None. If so,
        the private key must be referenced via its PKCS #11 URI,
        GTlsCertificate:private-key-pkcs11-uri. You must check both
        properties to see if the certificate really has a private key.
        When this property is read, the output format will be unencrypted
        PKCS #8.
        """
        private_key_pem: str  # [private-key-pem]: changed because contained invalid characters
        """
        The PEM (ASCII) encoded representation of the certificate's
        private key in either [PKCS #1 format](https://datatracker.ietf.org/doc/html/rfc8017)
        ("`BEGIN RSA PRIVATE KEY`") or unencrypted
        [PKCS #8 format](https://datatracker.ietf.org/doc/html/rfc5208)
        ("`BEGIN PRIVATE KEY`"). PKCS #8 format is supported since 2.32;
        earlier releases only support PKCS #1. You can use the `openssl rsa`
        tool to convert PKCS #8 keys to PKCS #1.

        This property (or the GTlsCertificate:private-key property)
        can be set when constructing a key (for example, from a file).
        Since GLib 2.70, it is now also readable; however, be aware that if
        the private key is backed by a PKCS #11 URI - for example, if it
        is stored on a smartcard - then this property will be None. If so,
        the private key must be referenced via its PKCS #11 URI,
        GTlsCertificate:private-key-pkcs11-uri. You must check both
        properties to see if the certificate really has a private key.
        When this property is read, the output format will be unencrypted
        PKCS #8.
        """
        private_key_pkcs11_uri: str  # [private-key-pkcs11-uri]: changed because contained invalid characters
        """
        A URI referencing a [PKCS #11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
        object containing a private key.
        """
        subject_name: str  # [subject-name]: changed because contained invalid characters
        """
        The subject from the cert,
        None if unavailable.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> TlsCertificatePrivate | None: ...

    # gi Methods
    def __init__(
        self,
        certificate: list | None = ...,
        certificate_pem: str = ...,
        issuer: TlsCertificate | None = ...,
        password: str = ...,
        pkcs11_uri: str = ...,
        pkcs12_data: list | None = ...,
        private_key: list | None = ...,
        private_key_pem: str = ...,
        private_key_pkcs11_uri: str = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_dns_names(self) -> list | None:
        """
        Gets the value of GTlsCertificate:dns-names.
        """
    @builtins.property
    def get_ip_addresses(self) -> list | None:
        """
        Gets the value of GTlsCertificate:ip-addresses.
        """
    @builtins.property
    def get_issuer(self) -> TlsCertificate | None:
        """
        Gets the GTlsCertificate representing `cert`'s issuer, if known
        """
    @builtins.property
    def get_issuer_name(self) -> str | None:
        """
        Returns the issuer name from the certificate.
        """
    @builtins.property
    def get_not_valid_after(self) -> GLib.DateTime | None:
        """
        Returns the time at which the certificate became or will become invalid.
        """
    @builtins.property
    def get_not_valid_before(self) -> GLib.DateTime | None:
        """
        Returns the time at which the certificate became or will become valid.
        """
    @builtins.property
    def get_subject_name(self) -> str | None:
        """
        Returns the subject name from the certificate.
        """
    def is_same(self, cert_two: TlsCertificate) -> bool:
        """
            Check if two GTlsCertificate objects represent the same certificate.
        The raw DER byte data of the two certificates are checked for equality.
        This has the effect that two certificates may compare equal even if
        their GTlsCertificate:issuer, GTlsCertificate:private-key, or
        GTlsCertificate:private-key-pem properties differ.
        """
    @staticmethod
    def list_new_from_file(file: str) -> list:
        """
            Creates one or more GTlsCertificates from the PEM-encoded
        data in `file`. If `file` cannot be read or parsed, the function will
        return None and set `error`. If `file` does not contain any
        PEM-encoded certificates, this will return an empty list and not
        set `error`.
        """
    @classmethod
    def new_from_file(cls, file: str) -> TlsCertificate:
        """
            Creates a GTlsCertificate from the data in `file`.

        As of 2.72, if the filename ends in `.p12` or `.pfx` the data is loaded by
        `g_tls_certificate_new_from_pkcs12` otherwise it is loaded by
        `g_tls_certificate_new_from_pem`. See those functions for
        exact details.

        If `file` cannot be read or parsed, the function will return None and
        set `error`.
        """
    @classmethod
    def new_from_file_with_password(cls, file: str, password: str) -> TlsCertificate:
        """
            Creates a GTlsCertificate from the data in `file`.

        If `file` cannot be read or parsed, the function will return None and
        set `error`.

        Any unknown file types will error with G_IO_ERROR_NOT_SUPPORTED.
        Currently only `.p12` and `.pfx` files are supported.
        See `g_tls_certificate_new_from_pkcs12` for more details.
        """
    @classmethod
    def new_from_files(cls, cert_file: str, key_file: str) -> TlsCertificate:
        """
            Creates a GTlsCertificate from the PEM-encoded data in `cert_file`
        and `key_file`. The returned certificate will be the first certificate
        found in `cert_file`. As of GLib 2.44, if `cert_file` contains more
        certificates it will try to load a certificate chain. All
        certificates will be verified in the order found (top-level
        certificate should be the last one in the file) and the
        GTlsCertificate:issuer property of each certificate will be set
        accordingly if the verification succeeds. If any certificate in the
        chain cannot be verified, the first certificate in the file will
        still be returned.

        If either file cannot be read or parsed, the function will return
        None and set `error`. Otherwise, this behaves like
        `g_tls_certificate_new_from_pem`.
        """
    @classmethod
    def new_from_pem(cls, data: str, length: int) -> TlsCertificate:
        """
            Creates a GTlsCertificate from the PEM-encoded data in `data`. If
        `data` includes both a certificate and a private key, then the
        returned certificate will include the private key data as well. (See
        the GTlsCertificate:private-key-pem property for information about
        supported formats.)

        The returned certificate will be the first certificate found in
        `data`. As of GLib 2.44, if `data` contains more certificates it will
        try to load a certificate chain. All certificates will be verified in
        the order found (top-level certificate should be the last one in the
        file) and the GTlsCertificate:issuer property of each certificate
        will be set accordingly if the verification succeeds. If any
        certificate in the chain cannot be verified, the first certificate in
        the file will still be returned.
        """
    @classmethod
    def new_from_pkcs11_uris(cls, pkcs11_uri: str, private_key_pkcs11_uri: str | None = None) -> TlsCertificate:
        """
            Creates a GTlsCertificate from a
        [PKCS #11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) URI.

        An example `pkcs11_uri` would be `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01`

        Where the token’s layout is:

        |[
        Object 0:
          URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=private20key;type=private
          Type: Private key (RSA-2048)
          ID: 01

        Object 1:
          URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=Certificate20for20Authentication;type=cert
          Type: X.509 Certificate (RSA-2048)
          ID: 01
        ]|

        In this case the certificate and private key would both be detected and used as expected.
        `pkcs_uri` may also just reference an X.509 certificate object and then optionally
        `private_key_pkcs11_uri` allows using a private key exposed under a different URI.

        Note that the private key is not accessed until usage and may fail or require a PIN later.
        """
    @classmethod
    def new_from_pkcs12(cls, data: list, length: int, password: str | None = None) -> TlsCertificate:
        """
            Creates a GTlsCertificate from the data in `data`. It must contain
        a certificate and matching private key.

        If extra certificates are included they will be verified as a chain
        and the GTlsCertificate:issuer property will be set.
        All other data will be ignored.

        You can pass as single password for all of the data which will be
        used both for the PKCS #12 container as well as encrypted
        private keys. If decryption fails it will error with
        G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD.

        This constructor requires support in the current GTlsBackend.
        If support is missing it will error with
        G_IO_ERROR_NOT_SUPPORTED.

        Other parsing failures will error with G_TLS_ERROR_BAD_CERTIFICATE.
        """
    def verify(
        self, identity: SocketConnectable | None = None, trusted_ca: TlsCertificate | None = None
    ) -> TlsCertificateFlags:
        """
            This verifies `cert` and returns a set of GTlsCertificateFlags
        indicating any problems found with it. This can be used to verify a
        certificate outside the context of making a connection, or to
        check a certificate against a CA that is not part of the system
        CA database.

        If `cert` is valid, G_TLS_CERTIFICATE_NO_FLAGS is returned.

        If `identity` is not None, `cert`'s name(s) will be compared against
        it, and G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
        value if it does not match. If `identity` is None, that bit will
        never be set in the return value.

        If `trusted_ca` is not None, then `cert` (or one of the certificates
        in its chain) must be signed by it, or else
        G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
        `trusted_ca` is None, that bit will never be set in the return
        value.

        GLib guarantees that if certificate verification fails, at least one
        error will be set in the return value, but it does not guarantee
        that all possible errors will be set. Accordingly, you may not safely
        decide to ignore any particular type of error. For example, it would
        be incorrect to mask G_TLS_CERTIFICATE_EXPIRED if you want to allow
        expired certificates, because this could potentially be the only
        error flag set even if other problems exist with the certificate.

        Because TLS session context is not used, GTlsCertificate may not
        perform as many checks on the certificates as GTlsConnection would.
        For example, certificate constraints may not be honored, and
        revocation checks may not be performed. The best way to verify TLS
        certificates used by a TLS connection is to let GTlsConnection
        handle the verification.
        """

    # python methods (overrides?)
    def do_verify(
        self,
        identity: SocketConnectable | None = None,
        trusted_ca: TlsCertificate | None = None,
    ) -> TlsCertificateFlags:
        """
        verify(self, identity:Gio.SocketConnectable=None, trusted_ca:Gio.TlsCertificate=None) -> Gio.TlsCertificateFlags
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::certificate_pem"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::dns_names"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ip_addresses"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::issuer"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::issuer_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::not_valid_after"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::not_valid_before"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::password"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pkcs11_uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::pkcs12_data"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::private_key"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::private_key_pem"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::private_key_pkcs11_uri"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::subject_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TlsCertificateClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def verify(self) -> verifyTlsCertificateClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsCertificatePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsClientConnection(GObject.GInterface):
    """
    `GTlsClientConnection` is the client-side subclass of
    [class`Gio`.TlsConnection], representing a client-side TLS connection.
    """

    class Props(GObject.GInterface.Props):
        accepted_cas: list | None  # [accepted-cas]: changed because contained invalid characters
        """
        A list of the distinguished names of the Certificate Authorities
        that the server will accept client certificates signed by. If the
        server requests a client certificate during the handshake, then
        this property will be set after the handshake completes.

        Each item in the list is a GByteArray which contains the complete
        subject DN of the certificate authority.
        """
        server_identity: SocketConnectable | None  # [server-identity]: changed because contained invalid characters
        """
        A GSocketConnectable describing the identity of the server that
        is expected on the other end of the connection.

        If the G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
        GTlsClientConnection:validation-flags, this object will be used
        to determine the expected identify of the remote end of the
        connection; if GTlsClientConnection:server-identity is not set,
        or does not match the identity presented by the server, then the
        G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.

        In addition to its use in verifying the server certificate,
        this is also used to give a hint to the server about what
        certificate we expect, which is useful for servers that serve
        virtual hosts.
        """
        use_ssl3: bool  # [use-ssl3]: changed because contained invalid characters
        """
        SSL 3.0 is no longer supported. See
        `g_tls_client_connection_set_use_ssl3` for details.
        """
        validation_flags: TlsCertificateFlags  # [validation-flags]: changed because contained invalid characters
        """
        What steps to perform when validating a certificate received from
        a server. Server certificates that fail to validate in any of the
        ways indicated here will be rejected unless the application
        overrides the default via GTlsConnection::accept-certificate.

        GLib guarantees that if certificate verification fails, at least one
        flag will be set, but it does not guarantee that all possible flags
        will be set. Accordingly, you may not safely decide to ignore any
        particular type of error. For example, it would be incorrect to mask
        G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
        because this could potentially be the only error flag set even if
        other problems exist with the certificate. Therefore, there is no
        safe way to use this property. This is not a horrible problem,
        though, because you should not be attempting to ignore validation
        errors anyway. If you really must ignore TLS certificate errors,
        connect to GTlsConnection::accept-certificate.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(
        self,
        server_identity: SocketConnectable | None = ...,
        use_ssl3: bool = ...,
        validation_flags: TlsCertificateFlags = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def copy_session_state(self, source: TlsClientConnection) -> None:
        """
            Possibly copies session state from one connection to another, for use
        in TLS session resumption. This is not normally needed, but may be
        used when the same session needs to be used between different
        endpoints, as is required by some protocols, such as FTP over TLS.
        `source` should have already completed a handshake and, since TLS 1.3,
        it should have been used to read data at least once. `conn` should not
        have completed a handshake.

        It is not possible to know whether a call to this function will
        actually do anything. Because session resumption is normally used
        only for performance benefit, the TLS backend might not implement
        this function. Even if implemented, it may not actually succeed in
        allowing `conn` to resume `source`'s TLS session, because the server
        may not have sent a session resumption token to `source`, or it may
        refuse to accept the token from `conn`. There is no way to know
        whether a call to this function is actually successful.

        Using this function is not required to benefit from session
        resumption. If the TLS backend supports session resumption, the
        session will be resumed automatically if it is possible to do so
        without weakening the privacy guarantees normally provided by TLS,
        without need to call this function. For example, with TLS 1.3,
        a session ticket will be automatically copied from any
        GTlsClientConnection that has previously received session tickets
        from the server, provided a ticket is available that has not
        previously been used for session resumption, since session ticket
        reuse would be a privacy weakness. Using this function causes the
        ticket to be copied without regard for privacy considerations.
        """
    @builtins.property
    def get_accepted_cas(self) -> list:
        """
            Gets the list of distinguished names of the Certificate Authorities
        that the server will accept certificates from. This will be set
        during the TLS handshake if the server requests a certificate.
        Otherwise, it will be None.

        Each item in the list is a GByteArray which contains the complete
        subject DN of the certificate authority.
        """
    @builtins.property
    def get_server_identity(self) -> SocketConnectable | None:
        """
        Gets `conn`'s expected server identity
        """
    @deprecated("deprecated")
    @builtins.property
    def get_use_ssl3(self) -> bool:
        """
            SSL 3.0 is no longer supported. See
        `g_tls_client_connection_set_use_ssl3` for details.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_validation_flags(self) -> TlsCertificateFlags:
        """
            Gets `conn`'s validation flags

        This function does not work as originally designed and is impossible
        to use correctly. See GTlsClientConnection:validation-flags for more
        information.
        """
    @staticmethod
    def new(base_io_stream: IOStream, server_identity: SocketConnectable | None = None) -> TlsClientConnection:
        """
            Creates a new GTlsClientConnection wrapping `base_io_stream` (which
        must have pollable input and output streams) which is assumed to
        communicate with the server identified by `server_identity`.

        See the documentation for GTlsConnection:base-io-stream for restrictions
        on when application code can run operations on the `base_io_stream` after
        this function has returned.
        """
    def set_server_identity(self, identity: SocketConnectable) -> None:
        """
            Sets `conn`'s expected server identity, which is used both to tell
        servers on virtual hosts which certificate to present, and also
        to let `conn` know what name to look for in the certificate when
        performing G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
        """
    @deprecated("deprecated")
    def set_use_ssl3(self, use_ssl3: bool) -> None:
        """
            Since GLib 2.42.1, SSL 3.0 is no longer supported.

        From GLib 2.42.1 through GLib 2.62, this function could be used to
        force use of TLS 1.0, the lowest-supported TLS protocol version at
        the time. In the past, this was needed to connect to broken TLS
        servers that exhibited protocol version intolerance. Such servers
        are no longer common, and using TLS 1.0 is no longer considered
        acceptable.

        Since GLib 2.64, this function does nothing.
        """
    @deprecated("deprecated")
    def set_validation_flags(self, flags: TlsCertificateFlags) -> None:
        """
            Sets `conn`'s validation flags, to override the default set of
        checks performed when validating a server certificate. By default,
        G_TLS_CERTIFICATE_VALIDATE_ALL is used.

        This function does not work as originally designed and is impossible
        to use correctly. See GTlsClientConnection:validation-flags for more
        information.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::accepted_cas"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::server_identity"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_ssl3"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::validation_flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TlsClientConnectionInterface(GObject.GPointer):
    """
    vtable for a GTlsClientConnection implementation.
    """

    # gi Fields
    @builtins.property
    def copy_session_state(self) -> copy_session_stateTlsClientConnectionInterfaceCB:
        """
        Copies session state from one GTlsClientConnection to another.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsConnection(IOStream):
    """
    `GTlsConnection` is the base TLS connection class type, which wraps
    a [class`Gio`.IOStream] and provides TLS encryption on top of it. Its
    subclasses, [iface`Gio`.TlsClientConnection] and
    [iface`Gio`.TlsServerConnection], implement client-side and server-side TLS,
    respectively.

    For DTLS (Datagram TLS) support, see [iface`Gio`.DtlsConnection].
    """

    class Props(IOStream.Props):
        advertised_protocols: list | None  # [advertised-protocols]: changed because contained invalid characters
        """
        The list of application-layer protocols that the connection
        advertises that it is willing to speak. See
        `g_tls_connection_set_advertised_protocols`.
        """
        base_io_stream: IOStream | None  # [base-io-stream]: changed because contained invalid characters
        """
        The GIOStream that the connection wraps. The connection holds a reference
        to this stream, and may run operations on the stream from other threads
        throughout its lifetime. Consequently, after the GIOStream has been
        constructed, application code may only run its own operations on this
        stream when no GIOStream operations are running.
        """
        certificate: TlsCertificate | None
        """
        The connection's certificate; see
        `g_tls_connection_set_certificate`.
        """
        ciphersuite_name: str  # [ciphersuite-name]: changed because contained invalid characters
        """
        The name of the TLS ciphersuite in use. See `g_tls_connection_get_ciphersuite_name`.
        """
        database: TlsDatabase | None
        """
        The certificate database to use when verifying this TLS connection.
        If no certificate database is set, then the default database will be
        used. See `g_tls_backend_get_default_database`.

        When using a non-default database, GTlsConnection must fall back to using
        the GTlsDatabase to perform certificate verification using
        `g_tls_database_verify_chain`, which means certificate verification will
        not be able to make use of TLS session context. This may be less secure.
        For example, if you create your own GTlsDatabase that just wraps the
        default GTlsDatabase, you might expect that you have not changed anything,
        but this is not true because you may have altered the behavior of
        GTlsConnection by causing it to use `g_tls_database_verify_chain`. See the
        documentation of `g_tls_database_verify_chain` for more details on specific
        security checks that may not be performed. Accordingly, setting a
        non-default database is discouraged except for specialty applications with
        unusual security requirements.
        """
        interaction: TlsInteraction | None
        """
        A GTlsInteraction object to be used when the connection or certificate
        database need to interact with the user. This will be used to prompt the
        user for passwords where necessary.
        """
        negotiated_protocol: str  # [negotiated-protocol]: changed because contained invalid characters
        """
        The application-layer protocol negotiated during the TLS
        handshake. See `g_tls_connection_get_negotiated_protocol`.
        """
        peer_certificate: TlsCertificate | None  # [peer-certificate]: changed because contained invalid characters
        """
        The connection's peer's certificate, after the TLS handshake has
        completed or failed. Note in particular that this is not yet set
        during the emission of GTlsConnection::accept-certificate.

        (You can watch for a GObject::notify signal on this property to
        detect when a handshake has occurred.)
        """
        peer_certificate_errors: (
            TlsCertificateFlags  # [peer-certificate-errors]: changed because contained invalid characters
        )
        """
        The errors noticed while verifying
        GTlsConnection:peer-certificate. Normally this should be 0, but
        it may not be if GTlsClientConnection:validation-flags is not
        G_TLS_CERTIFICATE_VALIDATE_ALL, or if
        GTlsConnection::accept-certificate overrode the default
        behavior.

        GLib guarantees that if certificate verification fails, at least
        one error will be set, but it does not guarantee that all possible
        errors will be set. Accordingly, you may not safely decide to
        ignore any particular type of error. For example, it would be
        incorrect to mask G_TLS_CERTIFICATE_EXPIRED if you want to allow
        expired certificates, because this could potentially be the only
        error flag set even if other problems exist with the certificate.
        """
        protocol_version: TlsProtocolVersion  # [protocol-version]: changed because contained invalid characters
        """
        The TLS protocol version in use. See `g_tls_connection_get_protocol_version`.
        """
        rehandshake_mode: TlsRehandshakeMode  # [rehandshake-mode]: changed because contained invalid characters
        """
        The rehandshaking mode. See
        `g_tls_connection_set_rehandshake_mode`.
        """
        require_close_notify: bool  # [require-close-notify]: changed because contained invalid characters
        """
        Whether or not proper TLS close notification is required.
        See `g_tls_connection_set_require_close_notify`.
        """
        use_system_certdb: bool  # [use-system-certdb]: changed because contained invalid characters
        """
        Whether or not the system certificate database will be used to
        verify peer certificates. See
        `g_tls_connection_set_use_system_certdb`.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> IOStream | None: ...
    @builtins.property
    def priv(self) -> TlsConnectionPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        advertised_protocols: list | None = ...,
        base_io_stream: IOStream | None = ...,
        certificate: TlsCertificate | None = ...,
        database: TlsDatabase | None = ...,
        interaction: TlsInteraction | None = ...,
        rehandshake_mode: TlsRehandshakeMode = ...,
        require_close_notify: bool = ...,
        use_system_certdb: bool = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def emit_accept_certificate(self, peer_cert: TlsCertificate, errors: TlsCertificateFlags) -> bool:
        """
            Used by GTlsConnection implementations to emit the
        GTlsConnection::accept-certificate signal.
        """
    @builtins.property
    def get_certificate(self) -> TlsCertificate | None:
        """
            Gets `conn`'s certificate, as set by
        `g_tls_connection_set_certificate`.
        """
    def get_channel_binding_data(self, type: TlsChannelBindingType) -> tuple[bool, list]:
        """
            Query the TLS backend for TLS channel binding data of `type` for `conn`.

        This call retrieves TLS channel binding data as specified in RFC
        [5056](https://tools.ietf.org/html/rfc5056), RFC
        [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
        binding data is returned in `data`.  The `data` is resized by the callee
        using GByteArray buffer management and will be freed when the `data`
        is destroyed by `g_byte_array_unref`. If `data` is None, it will only
        check whether TLS backend is able to fetch the data (e.g. whether `type`
        is supported by the TLS backend). It does not guarantee that the data
        will be available though.  That could happen if TLS connection does not
        support `type` or the binding data is not available yet due to additional
        negotiation or input required.
        """
    @builtins.property
    def get_ciphersuite_name(self) -> str | None:
        """
            Returns the name of the current TLS ciphersuite, or None if the
        connection has not handshaked or has been closed. Beware that the TLS
        backend may use any of multiple different naming conventions, because
        OpenSSL and GnuTLS have their own ciphersuite naming conventions that
        are different from each other and different from the standard, IANA-
        registered ciphersuite names. The ciphersuite name is intended to be
        displayed to the user for informative purposes only, and parsing it
        is not recommended.
        """
    @builtins.property
    def get_database(self) -> TlsDatabase | None:
        """
            Gets the certificate database that `conn` uses to verify
        peer certificates. See `g_tls_connection_set_database`.
        """
    @builtins.property
    def get_interaction(self) -> TlsInteraction | None:
        """
            Get the object that will be used to interact with the user. It will be used
        for things like prompting the user for passwords. If None is returned, then
        no user interaction will occur for this connection.
        """
    @builtins.property
    def get_negotiated_protocol(self) -> str | None:
        """
            Gets the name of the application-layer protocol negotiated during
        the handshake.

        If the peer did not use the ALPN extension, or did not advertise a
        protocol that matched one of `conn`'s protocols, or the TLS backend
        does not support ALPN, then this will be None. See
        `g_tls_connection_set_advertised_protocols`.
        """
    @builtins.property
    def get_peer_certificate(self) -> TlsCertificate | None:
        """
            Gets `conn`'s peer's certificate after the handshake has completed
        or failed. (It is not set during the emission of
        GTlsConnection::accept-certificate.)
        """
    @builtins.property
    def get_peer_certificate_errors(self) -> TlsCertificateFlags:
        """
            Gets the errors associated with validating `conn`'s peer's
        certificate, after the handshake has completed or failed. (It is
        not set during the emission of GTlsConnection::accept-certificate.)

        See GTlsConnection:peer-certificate-errors for more information.
        """
    @builtins.property
    def get_protocol_version(self) -> TlsProtocolVersion:
        """
            Returns the current TLS protocol version, which may be
        G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
        has been closed, or if the TLS backend has implemented a protocol version
        that is not a recognized GTlsProtocolVersion.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_rehandshake_mode(self) -> TlsRehandshakeMode:
        """
            Gets `conn` rehandshaking mode. See
        `g_tls_connection_set_rehandshake_mode` for details.
        """
    @builtins.property
    def get_require_close_notify(self) -> bool:
        """
            Tests whether or not `conn` expects a proper TLS close notification
        when the connection is closed. See
        `g_tls_connection_set_require_close_notify` for details.
        """
    @deprecated("deprecated")
    @builtins.property
    def get_use_system_certdb(self) -> bool:
        """
            Gets whether `conn` uses the system certificate database to verify
        peer certificates. See `g_tls_connection_set_use_system_certdb`.
        """
    def handshake(self, cancellable: Cancellable | None = None) -> bool:
        """
            Attempts a TLS handshake on `conn`.

        On the client side, it is never necessary to call this method;
        although the connection needs to perform a handshake after
        connecting (or after sending a "STARTTLS"-type command),
        GTlsConnection will handle this for you automatically when you try
        to send or receive data on the connection. You can call
        `g_tls_connection_handshake` manually if you want to know whether
        the initial handshake succeeded or failed (as opposed to just
        immediately trying to use `conn` to read or write, in which case,
        if it fails, it may not be possible to tell if it failed before or
        after completing the handshake), but beware that servers may reject
        client authentication after the handshake has completed, so a
        successful handshake does not indicate the connection will be usable.

        Likewise, on the server side, although a handshake is necessary at
        the beginning of the communication, you do not need to call this
        function explicitly unless you want clearer error reporting.

        Previously, calling `g_tls_connection_handshake` after the initial
        handshake would trigger a rehandshake; however, this usage was
        deprecated in GLib 2.60 because rehandshaking was removed from the
        TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
        the initial handshake will no longer do anything.

        When using a GTlsConnection created by GSocketClient, the
        GSocketClient performs the initial handshake, so calling this
        function manually is not recommended.

        GTlsConnection::accept_certificate may be emitted during the
        handshake.
        """
    async def handshake_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously performs a TLS handshake on `conn`. See
        `g_tls_connection_handshake` for more information.
        """
    def handshake_finish(self, result: AsyncResult) -> bool:
        """
            Finish an asynchronous TLS handshake operation. See
        `g_tls_connection_handshake` for more information.
        """
    def set_advertised_protocols(self, protocols: list | None = None) -> None:
        """
            Sets the list of application-layer protocols to advertise that the
        caller is willing to speak on this connection. The
        Application-Layer Protocol Negotiation (ALPN) extension will be
        used to negotiate a compatible protocol with the peer; use
        `g_tls_connection_get_negotiated_protocol` to find the negotiated
        protocol after the handshake.  Specifying None for the the value
        of `protocols` will disable ALPN negotiation.

        See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
        for a list of registered protocol IDs.
        """
    def set_certificate(self, certificate: TlsCertificate) -> None:
        """
            This sets the certificate that `conn` will present to its peer
        during the TLS handshake. For a GTlsServerConnection, it is
        mandatory to set this, and that will normally be done at construct
        time.

        For a GTlsClientConnection, this is optional. If a handshake fails
        with G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
        requires a certificate, and if you try connecting again, you should
        call this method first. You can call
        `g_tls_client_connection_get_accepted_cas` on the failed connection
        to get a list of Certificate Authorities that the server will
        accept certificates from.

        (It is also possible that a server will allow the connection with
        or without a certificate; in that case, if you don't provide a
        certificate, you can tell that the server requested one by the fact
        that `g_tls_client_connection_get_accepted_cas` will return
        non-None.)
        """
    def set_database(self, database: TlsDatabase | None = None) -> None:
        """
            Sets the certificate database that is used to verify peer certificates.
        This is set to the default database by default. See
        `g_tls_backend_get_default_database`. If set to None, then
        peer certificate validation will always set the
        G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
        GTlsConnection::accept-certificate will always be emitted on
        client-side connections, unless that bit is not set in
        GTlsClientConnection:validation-flags).

        There are nonintuitive security implications when using a non-default
        database. See GTlsConnection:database for details.
        """
    def set_interaction(self, interaction: TlsInteraction | None = None) -> None:
        """
            Set the object that will be used to interact with the user. It will be used
        for things like prompting the user for passwords.

        The `interaction` argument will normally be a derived subclass of
        GTlsInteraction. None can also be provided if no user interaction
        should occur for this connection.
        """
    @deprecated("deprecated")
    def set_rehandshake_mode(self, mode: TlsRehandshakeMode) -> None:
        """
            Since GLib 2.64, changing the rehandshake mode is no longer supported
        and will have no effect. With TLS 1.3, rehandshaking has been removed from
        the TLS protocol, replaced by separate post-handshake authentication and
        rekey operations.
        """
    def set_require_close_notify(self, require_close_notify: bool) -> None:
        """
            Sets whether or not `conn` expects a proper TLS close notification
        before the connection is closed. If this is True (the default),
        then `conn` will expect to receive a TLS close notification from its
        peer before the connection is closed, and will return a
        G_TLS_ERROR_EOF error if the connection is closed without proper
        notification (since this may indicate a network error, or
        man-in-the-middle attack).

        In some protocols, the application will know whether or not the
        connection was closed cleanly based on application-level data
        (because the application-level data includes a length field, or is
        somehow self-delimiting); in this case, the close notify is
        redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
        in TLS 1.0 it is technically an error, but often done anyway.) You
        can use `g_tls_connection_set_require_close_notify` to tell `conn`
        to allow an "unannounced" connection close, in which case the close
        will show up as a 0-length read, as in a non-TLS
        GSocketConnection, and it is up to the application to check that
        the data has been fully received.

        Note that this only affects the behavior when the peer closes the
        connection; when the application calls `g_io_stream_close` itself
        on `conn`, this will send a close notification regardless of the
        setting of this property. If you explicitly want to do an unclean
        close, you can close `conn`'s GTlsConnection:base-io-stream rather
        than closing `conn` itself, but note that this may only be done when no other
        operations are pending on `conn` or the base I/O stream.
        """
    @deprecated("deprecated")
    def set_use_system_certdb(self, use_system_certdb: bool) -> None:
        """
            Sets whether `conn` uses the system certificate database to verify
        peer certificates. This is True by default. If set to False, then
        peer certificate validation will always set the
        G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
        GTlsConnection::accept-certificate will always be emitted on
        client-side connections, unless that bit is not set in
        GTlsClientConnection:validation-flags).
        """

    # python methods (overrides?)
    def do_accept_certificate(
        self,
        peer_cert: TlsCertificate,
        errors: TlsCertificateFlags,
    ) -> bool:
        """
        accept_certificate(self, peer_cert:Gio.TlsCertificate, errors:Gio.TlsCertificateFlags) -> bool
        """
    def do_get_binding_data(
        self,
        type: TlsChannelBindingType,
        data: list,
    ) -> bool:
        """
        get_binding_data(self, type:Gio.TlsChannelBindingType, data:list) -> bool
        """
    def do_get_negotiated_protocol(
        self,
    ) -> str | None:
        """
        get_negotiated_protocol(self) -> str or None
        """
    def do_handshake(
        self,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        handshake(self, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_handshake_async(
        self,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        handshake_async(self, io_priority:int, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_handshake_finish(
        self,
        result: AsyncResult,
    ) -> bool:
        """
        handshake_finish(self, result:Gio.AsyncResult) -> bool
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["accept-certificate"],
        handler: typing.Callable[[typing_extensions.Self, TlsCertificate, TlsCertificateFlags], bool],
        *args: typing.Any,
    ) -> int:
        """
            Emitted during the TLS handshake after the peer certificate has
        been received. You can examine `peer_cert`'s certification path by
        calling `g_tls_certificate_get_issuer` on it.

        For a client-side connection, `peer_cert` is the server's
        certificate, and the signal will only be emitted if the
        certificate was not acceptable according to `conn`'s
        GTlsClientConnection:validation_flags. If you would like the
        certificate to be accepted despite `errors`, return True from the
        signal handler. Otherwise, if no handler accepts the certificate,
        the handshake will fail with G_TLS_ERROR_BAD_CERTIFICATE.

        GLib guarantees that if certificate verification fails, this signal
        will be emitted with at least one error will be set in `errors`, but
        it does not guarantee that all possible errors will be set.
        Accordingly, you may not safely decide to ignore any particular
        type of error. For example, it would be incorrect to ignore
        G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
        certificates, because this could potentially be the only error flag
        set even if other problems exist with the certificate.

        For a server-side connection, `peer_cert` is the certificate
        presented by the client, if this was requested via the server's
        GTlsServerConnection:authentication_mode. On the server side,
        the signal is always emitted when the client presents a
        certificate, and the certificate will only be accepted if a
        handler returns True.

        Note that if this signal is emitted as part of asynchronous I/O
        in the main thread, then you should not attempt to interact with
        the user before returning from the signal handler. If you want to
        let the user decide whether or not to accept the certificate, you
        would have to return False from the signal handler on the first
        attempt, and then after the connection attempt returns a
        G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user, and
        if the user decides to accept the certificate, remember that fact,
        create a new connection, and return True from the signal handler
        the next time.

        If you are doing I/O in another thread, you do not
        need to worry about this, and can simply block in the signal
        handler until the UI thread returns an answer.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::advertised_protocols"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::base_io_stream"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::ciphersuite_name"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::database"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::interaction"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::negotiated_protocol"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::peer_certificate"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::peer_certificate_errors"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::protocol_version"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::rehandshake_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::require_close_notify"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::use_system_certdb"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TlsConnectionClass(GObject.GPointer):
    """
    The class structure for the GTlsConnection type.
    """

    # gi Fields
    @builtins.property
    def accept_certificate(self) -> accept_certificateTlsConnectionClassCB:
        """
        Check whether to accept a certificate.
        """
    @builtins.property
    def get_binding_data(self) -> get_binding_dataTlsConnectionClassCB:
        """
        Retrieve TLS channel binding data (Since: 2.66)
        """
    @builtins.property
    def get_negotiated_protocol(self) -> get_negotiated_protocolTlsConnectionClassCB | None:
        """
        Get ALPN-negotiated protocol (Since: 2.70)
        """
    @builtins.property
    def handshake(self) -> handshakeTlsConnectionClassCB:
        """
        Perform a handshake operation.
        """
    @builtins.property
    def handshake_async(self) -> handshake_asyncTlsConnectionClassCB:
        """
        Start an asynchronous handshake operation.
        """
    @builtins.property
    def handshake_finish(self) -> handshake_finishTlsConnectionClassCB:
        """
        Finish an asynchronous handshake operation.
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> IOStreamClass | None:
        """
        The parent class.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsDatabase(GObject.Object):
    """
    `GTlsDatabase` is used to look up certificates and other information
    from a certificate or key store. It is an abstract base class which
    TLS library specific subtypes override.

    A `GTlsDatabase` may be accessed from multiple threads by the TLS backend.
    All implementations are required to be fully thread-safe.

    Most common client applications will not directly interact with
    `GTlsDatabase`. It is used internally by [class`Gio`.TlsConnection].
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> TlsDatabasePrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def create_certificate_handle(self, certificate: TlsCertificate) -> str | None:
        """
            Create a handle string for the certificate. The database will only be able
        to create a handle for certificates that originate from the database. In
        cases where the database cannot create a handle for a certificate, None
        will be returned.

        This handle should be stable across various instances of the application,
        and between applications. If a certificate is modified in the database,
        then it is not guaranteed that this handle will continue to point to it.
        """
    def lookup_certificate_for_handle(
        self,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate | None:
        """
            Look up a certificate by its handle.

        The handle should have been created by calling
        `g_tls_database_create_certificate_handle` on a GTlsDatabase object of
        the same TLS backend. The handle is designed to remain valid across
        instantiations of the database.

        If the handle is no longer valid, or does not point to a certificate in
        this database, then None will be returned.

        This function can block, use `g_tls_database_lookup_certificate_for_handle_async` to perform
        the lookup operation asynchronously.
        """
    async def lookup_certificate_for_handle_async(
        self,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously look up a certificate by its handle in the database. See
        `g_tls_database_lookup_certificate_for_handle` for more information.
        """
    def lookup_certificate_for_handle_finish(self, result: AsyncResult) -> TlsCertificate:
        """
            Finish an asynchronous lookup of a certificate by its handle. See
        `g_tls_database_lookup_certificate_for_handle` for more information.

        If the handle is no longer valid, or does not point to a certificate in
        this database, then None will be returned.
        """
    def lookup_certificate_issuer(
        self,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate:
        """
            Look up the issuer of `certificate` in the database. The
        GTlsCertificate:issuer property of `certificate` is not modified, and
        the two certificates are not hooked into a chain.

        This function can block. Use `g_tls_database_lookup_certificate_issuer_async`
        to perform the lookup operation asynchronously.

        Beware this function cannot be used to build certification paths. The
        issuer certificate returned by this function may not be the same as
        the certificate that would actually be used to construct a valid
        certification path during certificate verification.
        [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
        why an issuer certificate cannot be naively assumed to be part of the
        the certification path (though GLib's TLS backends may not follow the
        path building strategies outlined in this RFC). Due to the complexity
        of certification path building, GLib does not provide any way to know
        which certification path will actually be used when verifying a TLS
        certificate. Accordingly, this function cannot be used to make
        security-related decisions. Only GLib itself should make security
        decisions about TLS certificates.
        """
    async def lookup_certificate_issuer_async(
        self,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously look up the issuer of `certificate` in the database. See
        `g_tls_database_lookup_certificate_issuer` for more information.
        """
    def lookup_certificate_issuer_finish(self, result: AsyncResult) -> TlsCertificate:
        """
            Finish an asynchronous lookup issuer operation. See
        `g_tls_database_lookup_certificate_issuer` for more information.
        """
    def lookup_certificates_issued_by(
        self,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list:
        """
            Look up certificates issued by this issuer in the database.

        This function can block, use `g_tls_database_lookup_certificates_issued_by_async` to perform
        the lookup operation asynchronously.
        """
    async def lookup_certificates_issued_by_async(
        self,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously look up certificates issued by this issuer in the database. See
        `g_tls_database_lookup_certificates_issued_by` for more information.

        The database may choose to hold a reference to the issuer byte array for the duration
        of this asynchronous operation. The byte array should not be modified during
        this time.
        """
    def lookup_certificates_issued_by_finish(self, result: AsyncResult) -> list:
        """
            Finish an asynchronous lookup of certificates. See
        `g_tls_database_lookup_certificates_issued_by` for more information.
        """
    def verify_chain(
        self,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificateFlags:
        """
            Determines the validity of a certificate chain, outside the context
        of a TLS session.

        `chain` is a chain of GTlsCertificate objects each pointing to the next
        certificate in the chain by its GTlsCertificate:issuer property.

        `purpose` describes the purpose (or usage) for which the certificate
        is being used. Typically `purpose` will be set to G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
        which means that the certificate is being used to authenticate a server
        (and we are acting as the client).

        The `identity` is used to ensure the server certificate is valid for
        the expected peer identity. If the identity does not match the
        certificate, G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
        return value. If `identity` is None, that bit will never be set in
        the return value. The peer identity may also be used to check for
        pinned certificates (trust exceptions) in the database. These may
        override the normal verification process on a host-by-host basis.

        Currently there are no `flags`, and G_TLS_DATABASE_VERIFY_NONE should be
        used.

        If `chain` is found to be valid, then the return value will be 0. If
        `chain` is found to be invalid, then the return value will indicate at
        least one problem found. If the function is unable to determine
        whether `chain` is valid (for example, because `cancellable` is
        triggered before it completes) then the return value will be
        G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set accordingly.
        `error` is not set when `chain` is successfully analyzed but found to
        be invalid.

        GLib guarantees that if certificate verification fails, at least one
        error will be set in the return value, but it does not guarantee
        that all possible errors will be set. Accordingly, you may not safely
        decide to ignore any particular type of error. For example, it would
        be incorrect to mask G_TLS_CERTIFICATE_EXPIRED if you want to allow
        expired certificates, because this could potentially be the only
        error flag set even if other problems exist with the certificate.

        Prior to GLib 2.48, GLib's default TLS backend modified `chain` to
        represent the certification path built by GTlsDatabase during
        certificate verification by adjusting the GTlsCertificate:issuer
        property of each certificate in `chain`. Since GLib 2.48, this no
        longer occurs, so you cannot rely on GTlsCertificate:issuer to
        represent the actual certification path used during certificate
        verification.

        Because TLS session context is not used, GTlsDatabase may not
        perform as many checks on the certificates as GTlsConnection would.
        For example, certificate constraints may not be honored, and
        revocation checks may not be performed. The best way to verify TLS
        certificates used by a TLS connection is to let GTlsConnection
        handle the verification.

        The TLS backend may attempt to look up and add missing certificates
        to the chain. This may involve HTTP requests to download missing
        certificates.

        This function can block. Use `g_tls_database_verify_chain_async` to
        perform the verification operation asynchronously.
        """
    async def verify_chain_async(
        self,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously determines the validity of a certificate chain after
        looking up and adding any missing certificates to the chain. See
        `g_tls_database_verify_chain` for more information.
        """
    def verify_chain_finish(self, result: AsyncResult) -> TlsCertificateFlags:
        """
            Finish an asynchronous verify chain operation. See
        `g_tls_database_verify_chain` for more information.

        If `chain` is found to be valid, then the return value will be 0. If
        `chain` is found to be invalid, then the return value will indicate
        the problems found. If the function is unable to determine whether
        `chain` is valid or not (eg, because `cancellable` is triggered
        before it completes) then the return value will be
        G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set
        accordingly. `error` is not set when `chain` is successfully analyzed
        but found to be invalid.
        """

    # python methods (overrides?)
    def do_create_certificate_handle(
        self,
        certificate: TlsCertificate,
    ) -> str | None:
        """
        create_certificate_handle(self, certificate:Gio.TlsCertificate) -> str or None
        """
    def do_lookup_certificate_for_handle(
        self,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate | None:
        """
        lookup_certificate_for_handle(self, handle:str, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None) -> Gio.TlsCertificate or None
        """
    def do_lookup_certificate_for_handle_async(
        self,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_certificate_for_handle_async(self, handle:str, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_certificate_for_handle_finish(
        self,
        result: AsyncResult,
    ) -> TlsCertificate:
        """
        lookup_certificate_for_handle_finish(self, result:Gio.AsyncResult) -> Gio.TlsCertificate
        """
    def do_lookup_certificate_issuer(
        self,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate:
        """
        lookup_certificate_issuer(self, certificate:Gio.TlsCertificate, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None) -> Gio.TlsCertificate
        """
    def do_lookup_certificate_issuer_async(
        self,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_certificate_issuer_async(self, certificate:Gio.TlsCertificate, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_certificate_issuer_finish(
        self,
        result: AsyncResult,
    ) -> TlsCertificate:
        """
        lookup_certificate_issuer_finish(self, result:Gio.AsyncResult) -> Gio.TlsCertificate
        """
    def do_lookup_certificates_issued_by(
        self,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list:
        """
        lookup_certificates_issued_by(self, issuer_raw_dn:list, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None) -> list
        """
    def do_lookup_certificates_issued_by_async(
        self,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        lookup_certificates_issued_by_async(self, issuer_raw_dn:list, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseLookupFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_lookup_certificates_issued_by_finish(
        self,
        result: AsyncResult,
    ) -> list:
        """
        lookup_certificates_issued_by_finish(self, result:Gio.AsyncResult) -> list
        """
    def do_verify_chain(
        self,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificateFlags:
        """
        verify_chain(self, chain:Gio.TlsCertificate, purpose:str, identity:Gio.SocketConnectable=None, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseVerifyFlags, cancellable:Gio.Cancellable=None) -> Gio.TlsCertificateFlags
        """
    def do_verify_chain_async(
        self,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        verify_chain_async(self, chain:Gio.TlsCertificate, purpose:str, identity:Gio.SocketConnectable=None, interaction:Gio.TlsInteraction=None, flags:Gio.TlsDatabaseVerifyFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_verify_chain_finish(
        self,
        result: AsyncResult,
    ) -> TlsCertificateFlags:
        """
        verify_chain_finish(self, result:Gio.AsyncResult) -> Gio.TlsCertificateFlags
        """

class TlsDatabaseClass(GObject.GPointer):
    """
    The class for GTlsDatabase. Derived classes should implement the various
    virtual methods. _async and _finish methods have a default
    implementation that runs the corresponding sync method in a thread.
    """

    # gi Fields
    @builtins.property
    def create_certificate_handle(self) -> create_certificate_handleTlsDatabaseClassCB | None:
        """
           Virtual method implementing
        `g_tls_database_create_certificate_handle`.
        """
    @builtins.property
    def lookup_certificate_for_handle(self) -> lookup_certificate_for_handleTlsDatabaseClassCB | None:
        """
           Virtual method implementing
        `g_tls_database_lookup_certificate_for_handle`.
        """
    @builtins.property
    def lookup_certificate_for_handle_async(self) -> lookup_certificate_for_handle_asyncTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_lookup_certificate_for_handle_async`.
        """
    @builtins.property
    def lookup_certificate_for_handle_finish(self) -> lookup_certificate_for_handle_finishTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_lookup_certificate_for_handle_finish`.
        """
    @builtins.property
    def lookup_certificate_issuer(self) -> lookup_certificate_issuerTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_lookup_certificate_issuer`.
        """
    @builtins.property
    def lookup_certificate_issuer_async(self) -> lookup_certificate_issuer_asyncTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_lookup_certificate_issuer_async`.
        """
    @builtins.property
    def lookup_certificate_issuer_finish(self) -> lookup_certificate_issuer_finishTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_lookup_certificate_issuer_finish`.
        """
    @builtins.property
    def lookup_certificates_issued_by(self) -> lookup_certificates_issued_byTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_lookup_certificates_issued_by`.
        """
    @builtins.property
    def lookup_certificates_issued_by_async(self) -> lookup_certificates_issued_by_asyncTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_lookup_certificates_issued_by_async`.
        """
    @builtins.property
    def lookup_certificates_issued_by_finish(self) -> lookup_certificates_issued_by_finishTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_lookup_certificates_issued_by_finish`.
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def verify_chain(self) -> verify_chainTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_verify_chain`.
        """
    @builtins.property
    def verify_chain_async(self) -> verify_chain_asyncTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_verify_chain_async`.
        """
    @builtins.property
    def verify_chain_finish(self) -> verify_chain_finishTlsDatabaseClassCB:
        """
           Virtual method implementing
        `g_tls_database_verify_chain_finish`.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsDatabasePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsFileDatabase(GObject.GInterface):
    """
    `GTlsFileDatabase` is implemented by [class`Gio`.TlsDatabase] objects which
    load their certificate information from a file. It is an interface which
    TLS library specific subtypes implement.
    """

    class Props(GObject.GInterface.Props):
        anchors: str
        """
        The path to a file containing PEM encoded certificate authority
        root anchors. The certificates in this file will be treated as
        root authorities for the purpose of verifying other certificates
        via the `g_tls_database_verify_chain` operation.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, anchors: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def new(anchors: str) -> TlsFileDatabase:
        """
            Creates a new GTlsFileDatabase which uses anchor certificate authorities
        in `anchors` to verify certificate chains.

        The certificates in `anchors` must be PEM encoded.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::anchors"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TlsFileDatabaseInterface(GObject.GPointer):
    """
    Provides an interface for GTlsFileDatabase implementations.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def padding(self) -> list | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsInteraction(GObject.Object):
    """
    `GTlsInteraction` provides a mechanism for the TLS connection and database
    code to interact with the user. It can be used to ask the user for passwords.

    To use a `GTlsInteraction` with a TLS connection use
    [method`Gio`.TlsConnection.set_interaction].

    Callers should instantiate a derived class that implements the various
    interaction methods to show the required dialogs.

    Callers should use the 'invoke' functions like
    [method`Gio`.TlsInteraction.invoke_ask_password] to run interaction methods.
    These functions make sure that the interaction is invoked in the main loop
    and not in the current thread, if the current thread is not running the
    main loop.

    Derived classes can choose to implement whichever interactions methods they’d
    like to support by overriding those virtual methods in their class
    initialization function. Any interactions not implemented will return
    `G_TLS_INTERACTION_UNHANDLED`. If a derived class implements an async method,
    it must also implement the corresponding finish method.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> TlsInteractionPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def ask_password(self, password: TlsPassword, cancellable: Cancellable | None = None) -> TlsInteractionResult:
        """
            Run synchronous interaction to ask the user for a password. In general,
        `g_tls_interaction_invoke_ask_password` should be used instead of this
        function.

        Derived subclasses usually implement a password prompt, although they may
        also choose to provide a password from elsewhere. The `password` value will
        be filled in and then `callback` will be called. Alternatively the user may
        abort this password request, which will usually abort the TLS connection.

        If the interaction is cancelled by the cancellation object, or by the
        user then G_TLS_INTERACTION_FAILED will be returned with an error that
        contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
        not support immediate cancellation.
        """
    async def ask_password_async(
        self,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Run asynchronous interaction to ask the user for a password. In general,
        `g_tls_interaction_invoke_ask_password` should be used instead of this
        function.

        Derived subclasses usually implement a password prompt, although they may
        also choose to provide a password from elsewhere. The `password` value will
        be filled in and then `callback` will be called. Alternatively the user may
        abort this password request, which will usually abort the TLS connection.

        If the interaction is cancelled by the cancellation object, or by the
        user then G_TLS_INTERACTION_FAILED will be returned with an error that
        contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
        not support immediate cancellation.

        Certain implementations may not support immediate cancellation.
        """
    def ask_password_finish(self, result: AsyncResult) -> TlsInteractionResult:
        """
            Complete an ask password user interaction request. This should be once
        the `g_tls_interaction_ask_password_async` completion callback is called.

        If G_TLS_INTERACTION_HANDLED is returned, then the GTlsPassword passed
        to `g_tls_interaction_ask_password` will have its password filled in.

        If the interaction is cancelled by the cancellation object, or by the
        user then G_TLS_INTERACTION_FAILED will be returned with an error that
        contains a G_IO_ERROR_CANCELLED error code.
        """
    def invoke_ask_password(
        self, password: TlsPassword, cancellable: Cancellable | None = None
    ) -> TlsInteractionResult:
        """
            Invoke the interaction to ask the user for a password. It invokes this
        interaction in the main loop, specifically the GMainContext returned by
        `g_main_context_get_thread_default` when the interaction is created. This
        is called by called by GTlsConnection or GTlsDatabase to ask the user
        for a password.

        Derived subclasses usually implement a password prompt, although they may
        also choose to provide a password from elsewhere. The `password` value will
        be filled in and then `callback` will be called. Alternatively the user may
        abort this password request, which will usually abort the TLS connection.

        The implementation can either be a synchronous (eg: modal dialog) or an
        asynchronous one (eg: modeless dialog). This function will take care of
        calling which ever one correctly.

        If the interaction is cancelled by the cancellation object, or by the
        user then G_TLS_INTERACTION_FAILED will be returned with an error that
        contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
        not support immediate cancellation.
        """
    def invoke_request_certificate(
        self, connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | None = None
    ) -> TlsInteractionResult:
        """
            Invoke the interaction to ask the user to choose a certificate to
        use with the connection. It invokes this interaction in the main
        loop, specifically the GMainContext returned by
        `g_main_context_get_thread_default` when the interaction is
        created. This is called by called by GTlsConnection when the peer
        requests a certificate during the handshake.

        Derived subclasses usually implement a certificate selector,
        although they may also choose to provide a certificate from
        elsewhere. Alternatively the user may abort this certificate
        request, which may or may not abort the TLS connection.

        The implementation can either be a synchronous (eg: modal dialog) or an
        asynchronous one (eg: modeless dialog). This function will take care of
        calling which ever one correctly.

        If the interaction is cancelled by the cancellation object, or by the
        user then G_TLS_INTERACTION_FAILED will be returned with an error that
        contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
        not support immediate cancellation.
        """
    def request_certificate(
        self, connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | None = None
    ) -> TlsInteractionResult:
        """
            Run synchronous interaction to ask the user to choose a certificate to use
        with the connection. In general, `g_tls_interaction_invoke_request_certificate`
        should be used instead of this function.

        Derived subclasses usually implement a certificate selector, although they may
        also choose to provide a certificate from elsewhere. Alternatively the user may
        abort this certificate request, which will usually abort the TLS connection.

        If G_TLS_INTERACTION_HANDLED is returned, then the GTlsConnection
        passed to `g_tls_interaction_request_certificate` will have had its
        GTlsConnection:certificate filled in.

        If the interaction is cancelled by the cancellation object, or by the
        user then G_TLS_INTERACTION_FAILED will be returned with an error that
        contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
        not support immediate cancellation.
        """
    async def request_certificate_async(
        self,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Run asynchronous interaction to ask the user for a certificate to use with
        the connection. In general, `g_tls_interaction_invoke_request_certificate` should
        be used instead of this function.

        Derived subclasses usually implement a certificate selector, although they may
        also choose to provide a certificate from elsewhere. `callback` will be called
        when the operation completes. Alternatively the user may abort this certificate
        request, which will usually abort the TLS connection.
        """
    def request_certificate_finish(self, result: AsyncResult) -> TlsInteractionResult:
        """
            Complete a request certificate user interaction request. This should be once
        the `g_tls_interaction_request_certificate_async` completion callback is called.

        If G_TLS_INTERACTION_HANDLED is returned, then the GTlsConnection
        passed to `g_tls_interaction_request_certificate_async` will have had its
        GTlsConnection:certificate filled in.

        If the interaction is cancelled by the cancellation object, or by the
        user then G_TLS_INTERACTION_FAILED will be returned with an error that
        contains a G_IO_ERROR_CANCELLED error code.
        """

    # python methods (overrides?)
    def do_ask_password(
        self,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
    ) -> TlsInteractionResult:
        """
        ask_password(self, password:Gio.TlsPassword, cancellable:Gio.Cancellable=None) -> Gio.TlsInteractionResult
        """
    def do_ask_password_async(
        self,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        ask_password_async(self, password:Gio.TlsPassword, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_ask_password_finish(
        self,
        result: AsyncResult,
    ) -> TlsInteractionResult:
        """
        ask_password_finish(self, result:Gio.AsyncResult) -> Gio.TlsInteractionResult
        """
    def do_request_certificate(
        self,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsInteractionResult:
        """
        request_certificate(self, connection:Gio.TlsConnection, flags:Gio.TlsCertificateRequestFlags, cancellable:Gio.Cancellable=None) -> Gio.TlsInteractionResult
        """
    def do_request_certificate_async(
        self,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
        callback: typing.Callable | None = None,
        user_data: typing.Any = None,
    ) -> None:
        """
        request_certificate_async(self, connection:Gio.TlsConnection, flags:Gio.TlsCertificateRequestFlags, cancellable:Gio.Cancellable=None, callback:Gio.AsyncReadyCallback=None, user_data=None)
        """
    def do_request_certificate_finish(
        self,
        result: AsyncResult,
    ) -> TlsInteractionResult:
        """
        request_certificate_finish(self, result:Gio.AsyncResult) -> Gio.TlsInteractionResult
        """

class TlsInteractionClass(GObject.GPointer):
    """
    The class for GTlsInteraction. Derived classes implement the various
    virtual interaction methods to handle TLS interactions.

    Derived classes can choose to implement whichever interactions methods they'd
    like to support by overriding those virtual methods in their class
    initialization function. If a derived class implements an async method,
    it must also implement the corresponding finish method.

    The synchronous interaction methods should implement to display modal dialogs,
    and the asynchronous methods to display modeless dialogs.

    If the user cancels an interaction, then the result should be
    G_TLS_INTERACTION_FAILED and the error should be set with a domain of
    G_IO_ERROR and code of G_IO_ERROR_CANCELLED.
    """

    # gi Fields
    @builtins.property
    def ask_password(self) -> ask_passwordTlsInteractionClassCB:
        """
        ask for a password synchronously. If the implementation
        returns G_TLS_INTERACTION_HANDLED, then the password argument should
        have been filled in by using `g_tls_password_set_value` or a similar
        function.
        """
    @builtins.property
    def ask_password_async(self) -> ask_password_asyncTlsInteractionClassCB:
        """
        ask for a password asynchronously.
        """
    @builtins.property
    def ask_password_finish(self) -> ask_password_finishTlsInteractionClassCB:
        """
        complete operation to ask for a password asynchronously.
        If the implementation returns G_TLS_INTERACTION_HANDLED, then the
        password argument of the async method should have been filled in by using
        `g_tls_password_set_value` or a similar function.
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def request_certificate(self) -> request_certificateTlsInteractionClassCB:
        """
        ask for a certificate synchronously. If the
        implementation returns G_TLS_INTERACTION_HANDLED, then the connection
        argument should have been filled in by using
        `g_tls_connection_set_certificate`.
        """
    @builtins.property
    def request_certificate_async(self) -> request_certificate_asyncTlsInteractionClassCB:
        """
        ask for a certificate asynchronously.
        """
    @builtins.property
    def request_certificate_finish(self) -> request_certificate_finishTlsInteractionClassCB:
        """
        complete operation to ask for a certificate
        asynchronously. If the implementation returns G_TLS_INTERACTION_HANDLED,
        then the connection argument of the async method should have been
        filled in by using `g_tls_connection_set_certificate`.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsInteractionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsPassword(GObject.Object):
    """
    An abstract interface representing a password used in TLS. Often used in
    user interaction such as unlocking a key storage token.
    """

    class Props(GObject.Object.Props):
        description: str
        """
        Description of what the password is for.
        """
        flags: TlsPasswordFlags
        """
        Flags about the password.
        """
        warning: str
        """
        Warning about the password.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> TlsPasswordPrivate | None: ...

    # gi Methods
    def __init__(self, description: str = ..., flags: TlsPasswordFlags = ..., warning: str = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_description(self) -> str:
        """
        Get a description string about what the password will be used for.
        """
    @builtins.property
    def get_flags(self) -> TlsPasswordFlags:
        """
        Get flags about the password.
        """
    def get_value(self) -> tuple[list, int]:
        """
            Get the password value. If `length` is not None then it will be
        filled in with the length of the password value. (Note that the
        password value is not nul-terminated, so you can only pass None
        for `length` in contexts where you know the password will have a
        certain fixed length.)
        """
    @builtins.property
    def get_warning(self) -> str:
        """
            Get a user readable translated warning. Usually this warning is a
        representation of the password flags returned from
        `g_tls_password_get_flags`.
        """
    @classmethod
    def new(cls, flags: TlsPasswordFlags, description: str) -> TlsPassword:
        """
        Create a new GTlsPassword object.
        """
    def set_description(self, description: str) -> None:
        """
        Set a description string about what the password will be used for.
        """
    def set_flags(self, flags: TlsPasswordFlags) -> None:
        """
        Set flags about the password.
        """
    def set_value(self, value: list, length: int) -> None:
        """
            Set the value for this password. The `value` will be copied by the password
        object.

        Specify the `length`, for a non-nul-terminated password. Pass -1 as
        `length` if using a nul-terminated password, and `length` will be
        calculated automatically. (Note that the terminating nul is not
        considered part of the password in this case.)
        """
    def set_value_full(self, value: list, length: int, destroy: GLib.DestroyNotify | None = None) -> None:
        """
            Provide the value for this password.

        The `value` will be owned by the password object, and later freed using
        the `destroy` function callback.

        Specify the `length`, for a non-nul-terminated password. Pass -1 as
        `length` if using a nul-terminated password, and `length` will be
        calculated automatically. (Note that the terminating nul is not
        considered part of the password in this case.)
        """
    def set_warning(self, warning: str) -> None:
        """
            Set a user readable translated warning. Usually this warning is a
        representation of the password flags returned from
        `g_tls_password_get_flags`.
        """

    # python methods (overrides?)
    def do_get_default_warning(
        self,
    ) -> str:
        """
        get_default_warning(self) -> str
        """
    def do_get_value(
        self,
    ) -> list:
        """
        get_value(self) -> list
        """
    def do_set_value(
        self,
        value: list,
        destroy: typing.Callable | None = None,
    ) -> None:
        """
        set_value(self, value:list, destroy:GLib.DestroyNotify=None)
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::description"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::flags"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::warning"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TlsPasswordClass(GObject.GPointer):
    """
    Class structure for GTlsPassword.
    """

    # gi Fields
    @builtins.property
    def get_default_warning(self) -> get_default_warningTlsPasswordClassCB:
        """
           virtual method for `g_tls_password_get_warning` if no
        value has been set using `g_tls_password_set_warning`
        """
    @builtins.property
    def get_value(self) -> get_valueTlsPasswordClassCB:
        """
        virtual method for `g_tls_password_get_value`
        """
    @builtins.property
    def padding(self) -> list | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def set_value(self) -> set_valueTlsPasswordClassCB:
        """
        virtual method for `g_tls_password_set_value`
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsPasswordPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class TlsServerConnection(GObject.GInterface):
    """
    `GTlsServerConnection` is the server-side subclass of
    [class`Gio`.TlsConnection], representing a server-side TLS connection.
    """

    class Props(GObject.GInterface.Props):
        authentication_mode: (
            TlsAuthenticationMode  # [authentication-mode]: changed because contained invalid characters
        )
        """
        The GTlsAuthenticationMode for the server. This can be changed
        before calling `g_tls_connection_handshake` if you want to
        rehandshake with a different mode from the initial handshake.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, authentication_mode: TlsAuthenticationMode = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def new(base_io_stream: IOStream, certificate: TlsCertificate | None = None) -> TlsServerConnection:
        """
            Creates a new GTlsServerConnection wrapping `base_io_stream` (which
        must have pollable input and output streams).

        See the documentation for GTlsConnection:base-io-stream for restrictions
        on when application code can run operations on the `base_io_stream` after
        this function has returned.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::authentication_mode"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class TlsServerConnectionInterface(GObject.GPointer):
    """
    vtable for a GTlsServerConnection implementation.
    """

    # gi Fields
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixConnection(SocketConnection):
    """
    This is the subclass of [class`Gio`.SocketConnection] that is created
    for UNIX domain sockets.

    It contains functions to do some of the UNIX socket specific
    functionality like passing file descriptors.

    Since GLib 2.72, `GUnixConnection` is available on all platforms. It requires
    underlying system support (such as Windows 10 with `AF_UNIX`) at run time.

    Before GLib 2.72, `<gio/gunixconnection.h>` belonged to the UNIX-specific GIO
    interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
    using it. This is no longer necessary since GLib 2.72.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> SocketConnection | None: ...
    @builtins.property
    def priv(self) -> UnixConnectionPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def receive_credentials(self, cancellable: Cancellable | None = None) -> Credentials:
        """
            Receives credentials from the sending end of the connection.  The
        sending end has to call `g_unix_connection_send_credentials` (or
        similar) for this to work.

        As well as reading the credentials this also reads (and discards) a
        single byte from the stream, as this is required for credentials
        passing to work on some implementations.

        This method can be expected to be available on the following platforms:

        - Linux since GLib 2.26
        - FreeBSD since GLib 2.26
        - GNU/kFreeBSD since GLib 2.36
        - Solaris, Illumos and OpenSolaris since GLib 2.40
        - GNU/Hurd since GLib 2.40

        Other ways to exchange credentials with a foreign peer includes the
        GUnixCredentialsMessage type and `g_socket_get_credentials` function.
        """
    async def receive_credentials_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously receive credentials.

        For more details, see `g_unix_connection_receive_credentials` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called. You can then call
        `g_unix_connection_receive_credentials_finish` to get the result of the operation.
        """
    def receive_credentials_finish(self, result: AsyncResult) -> Credentials:
        """
            Finishes an asynchronous receive credentials operation started with
        `g_unix_connection_receive_credentials_async`.
        """
    def receive_fd(self, cancellable: Cancellable | None = None) -> int:
        """
            Receives a file descriptor from the sending end of the connection.
        The sending end has to call `g_unix_connection_send_fd` for this
        to work.

        As well as reading the fd this also reads a single byte from the
        stream, as this is required for fd passing to work on some
        implementations.
        """
    def send_credentials(self, cancellable: Cancellable | None = None) -> bool:
        """
            Passes the credentials of the current user the receiving side
        of the connection. The receiving end has to call
        `g_unix_connection_receive_credentials` (or similar) to accept the
        credentials.

        As well as sending the credentials this also writes a single NUL
        byte to the stream, as this is required for credentials passing to
        work on some implementations.

        This method can be expected to be available on the following platforms:

        - Linux since GLib 2.26
        - FreeBSD since GLib 2.26
        - GNU/kFreeBSD since GLib 2.36
        - Solaris, Illumos and OpenSolaris since GLib 2.40
        - GNU/Hurd since GLib 2.40

        Other ways to exchange credentials with a foreign peer includes the
        GUnixCredentialsMessage type and `g_socket_get_credentials` function.
        """
    async def send_credentials_async(
        self,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Asynchronously send credentials.

        For more details, see `g_unix_connection_send_credentials` which is
        the synchronous version of this call.

        When the operation is finished, `callback` will be called. You can then call
        `g_unix_connection_send_credentials_finish` to get the result of the operation.
        """
    def send_credentials_finish(self, result: AsyncResult) -> bool:
        """
            Finishes an asynchronous send credentials operation started with
        `g_unix_connection_send_credentials_async`.
        """
    def send_fd(self, fd: int, cancellable: Cancellable | None = None) -> bool:
        """
            Passes a file descriptor to the receiving side of the
        connection. The receiving end has to call `g_unix_connection_receive_fd`
        to accept the file descriptor.

        As well as sending the fd this also writes a single byte to the
        stream, as this is required for fd passing to work on some
        implementations.
        """

class UnixConnectionClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SocketConnectionClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixConnectionPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixCredentialsMessage(SocketControlMessage):
    """
    This [class`Gio`.SocketControlMessage] contains a [class`Gio`.Credentials]
    instance.  It may be sent using [method`Gio`.Socket.send_message] and received
    using [method`Gio`.Socket.receive_message] over UNIX sockets (ie: sockets in
    the `G_SOCKET_FAMILY_UNIX` family).

    For an easier way to send and receive credentials over
    stream-oriented UNIX sockets, see
    [method`Gio`.UnixConnection.send_credentials] and
    [method`Gio`.UnixConnection.receive_credentials]. To receive credentials of
    a foreign process connected to a socket, use
    [method`Gio`.Socket.get_credentials].

    Since GLib 2.72, `GUnixCredentialMessage` is available on all platforms. It
    requires underlying system support (such as Windows 10 with `AF_UNIX`) at run
    time.

    Before GLib 2.72, `<gio/gunixcredentialsmessage.h>` belonged to the UNIX-specific
    GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
    when using it. This is no longer necessary since GLib 2.72.
    """

    class Props(SocketControlMessage.Props):
        credentials: Credentials | None
        """
        The credentials stored in the message.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> SocketControlMessage | None: ...
    @builtins.property
    def priv(self) -> UnixCredentialsMessagePrivate | None: ...

    # gi Methods
    def __init__(self, credentials: Credentials | None = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_credentials(self) -> Credentials:
        """
        Gets the credentials stored in `message`.
        """
    @staticmethod
    def is_supported() -> bool:
        """
        Checks if passing GCredentials on a GSocket is supported on this platform.
        """
    @classmethod
    def new(cls) -> UnixCredentialsMessage:
        """
        Creates a new GUnixCredentialsMessage with credentials matching the current processes.
        """
    @classmethod
    def new_with_credentials(cls, credentials: Credentials) -> UnixCredentialsMessage:
        """
        Creates a new GUnixCredentialsMessage holding `credentials`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::credentials"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class UnixCredentialsMessageClass(GObject.GPointer):
    """
    Class structure for GUnixCredentialsMessage.
    """

    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> SocketControlMessageClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixCredentialsMessagePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixFDList(GObject.Object):
    """
    A `GUnixFDList` contains a list of file descriptors.  It owns the file
    descriptors that it contains, closing them when finalized.

    It may be wrapped in a
    [`GUnixFDMessage`](../gio-unix/class.UnixFDMessage.html) and sent over a
    [class`Gio`.Socket] in the `G_SOCKET_FAMILY_UNIX` family by using
    [method`Gio`.Socket.send_message] and received using
    [method`Gio`.Socket.receive_message].

    Before 2.74, `<gio/gunixfdlist.h>` belonged to the UNIX-specific GIO
    interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
    using it.

    Since 2.74, the API is available for Windows.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> UnixFDListPrivate | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def append(self, fd: int) -> int:
        """
            Adds a file descriptor to `list`.

        The file descriptor is duplicated using `dup`. You keep your copy
        of the descriptor and the copy contained in `list` will be closed
        when `list` is finalized.

        A possible cause of failure is exceeding the per-process or
        system-wide file descriptor limit.

        The index of the file descriptor in the list is returned.  If you use
        this index with `g_unix_fd_list_get` then you will receive back a
        duplicated copy of the same file descriptor.
        """
    def get(self, index_: int) -> int:
        """
            Gets a file descriptor out of `list`.

        `index_` specifies the index of the file descriptor to get.  It is a
        programmer error for `index_` to be out of range; see
        `g_unix_fd_list_get_length`.

        The file descriptor is duplicated using `dup` and set as
        close-on-exec before being returned.  You must call `close` on it
        when you are done.

        A possible cause of failure is exceeding the per-process or
        system-wide file descriptor limit.
        """
    def get_length(self) -> int:
        """
            Gets the length of `list` (ie: the number of file descriptors
        contained within).
        """
    @classmethod
    def new(cls) -> UnixFDList:
        """
        Creates a new GUnixFDList containing no file descriptors.
        """
    @classmethod
    def new_from_array(cls, fds: list, n_fds: int) -> UnixFDList:
        """
            Creates a new GUnixFDList containing the file descriptors given in
        `fds`.  The file descriptors become the property of the new list and
        may no longer be used by the caller.  The array itself is owned by
        the caller.

        Each file descriptor in the array should be set to close-on-exec.

        If `n_fds` is -1 then `fds` must be terminated with -1.
        """
    def peek_fds(self) -> tuple[list, int]:
        """
            Returns the array of file descriptors that is contained in this
        object.

        After this call, the descriptors remain the property of `list`.  The
        caller must not close them and must not free the array.  The array is
        valid only until `list` is changed in any way.

        If `length` is non-None then it is set to the number of file
        descriptors in the returned array. The returned array is also
        terminated with -1.

        This function never returns None. In case there are no file
        descriptors contained in `list`, an empty array is returned.
        """
    def steal_fds(self) -> tuple[list, int]:
        """
            Returns the array of file descriptors that is contained in this
        object.

        After this call, the descriptors are no longer contained in
        `list`. Further calls will return an empty list (unless more
        descriptors have been added).

        The return result of this function must be freed with `g_free`.
        The caller is also responsible for closing all of the file
        descriptors.  The file descriptors in the array are set to
        close-on-exec.

        If `length` is non-None then it is set to the number of file
        descriptors in the returned array. The returned array is also
        terminated with -1.

        This function never returns None. In case there are no file
        descriptors contained in `list`, an empty array is returned.
        """

class UnixFDListClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixFDListPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixFDMessageClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> SocketControlMessageClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixFDMessagePrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixInputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> InputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixInputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixMountMonitorClass(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixOutputStreamClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def parent_class(self) -> OutputStreamClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixOutputStreamPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixSocketAddress(SocketAddress):
    """
    Support for UNIX-domain (also known as local) sockets, corresponding to
    `struct sockaddr_un`.

    UNIX domain sockets are generally visible in the filesystem.
    However, some systems support abstract socket names which are not
    visible in the filesystem and not affected by the filesystem
    permissions, visibility, etc. Currently this is only supported
    under Linux. If you attempt to use abstract sockets on other
    systems, function calls may return `G_IO_ERROR_NOT_SUPPORTED`
    errors. You can use [func`Gio`.UnixSocketAddress.abstract_names_supported]
    to see if abstract names are supported.

    Since GLib 2.72, `GUnixSocketAddress` is available on all platforms. It
    requires underlying system support (such as Windows 10 with `AF_UNIX`) at
    run time.

    Before GLib 2.72, `<gio/gunixsocketaddress.h>` belonged to the UNIX-specific
    GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
    when using it. This is no longer necessary since GLib 2.72.
    """

    class Props(SocketAddress.Props):
        abstract: bool
        """
        Whether or not this is an abstract address
        """
        address_type: UnixSocketAddressType  # [address-type]: changed because contained invalid characters
        """
        The type of Unix socket address.
        """
        path: str
        """
        Unix socket path.
        """
        path_as_array: list | None  # [path-as-array]: changed because contained invalid characters
        """
        Unix socket path, as a byte array.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Fields
    @builtins.property
    def parent_instance(self) -> SocketAddress | None: ...
    @builtins.property
    def priv(self) -> UnixSocketAddressPrivate | None: ...

    # gi Methods
    def __init__(
        self,
        abstract: bool = ...,
        address_type: UnixSocketAddressType = ...,
        path: str = ...,
        path_as_array: list | None = ...,
    ) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def abstract_names_supported() -> bool:
        """
        Checks if abstract UNIX domain socket names are supported.
        """
    @builtins.property
    def get_address_type(self) -> UnixSocketAddressType:
        """
        Gets `address`'s type.
        """
    @deprecated("deprecated")
    def get_is_abstract(self) -> bool:
        """
        Tests if `address` is abstract.
        """
    @builtins.property
    def get_path(self) -> str:
        """
            Gets `address`'s path, or for abstract sockets the "name".

        Guaranteed to be zero-terminated, but an abstract socket
        may contain embedded zeros, and thus you should use
        `g_unix_socket_address_get_path_len` to get the true length
        of this string.
        """
    def get_path_len(self) -> int:
        """
            Gets the length of `address`'s path.

        For details, see `g_unix_socket_address_get_path`.
        """
    @classmethod
    def new(cls, path: str) -> UnixSocketAddress:
        """
            Creates a new GUnixSocketAddress for `path`.

        To create abstract socket addresses, on systems that support that,
        use `g_unix_socket_address_new_abstract`.
        """
    @deprecated("deprecated")
    @classmethod
    def new_abstract(cls, path: list, path_len: int) -> UnixSocketAddress:
        """
            Creates a new G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED
        GUnixSocketAddress for `path`.
        """
    @classmethod
    def new_with_type(cls, path: list, path_len: int, type: UnixSocketAddressType) -> UnixSocketAddress:
        """
            Creates a new GUnixSocketAddress of type `type` with name `path`.

        If `type` is G_UNIX_SOCKET_ADDRESS_PATH, this is equivalent to
        calling `g_unix_socket_address_new`.

        If `type` is G_UNIX_SOCKET_ADDRESS_ANONYMOUS, `path` and `path_len` will be
        ignored.

        If `path_type` is G_UNIX_SOCKET_ADDRESS_ABSTRACT, then `path_len`
        bytes of `path` will be copied to the socket's path, and only those
        bytes will be considered part of the name. (If `path_len` is -1,
        then `path` is assumed to be NUL-terminated.) For example, if `path`
        was "test", then calling `g_socket_address_get_native_size` on the
        returned socket would return 7 (2 bytes of overhead, 1 byte for the
        abstract-socket indicator byte, and 4 bytes for the name "test").

        If `path_type` is G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, then
        `path_len` bytes of `path` will be copied to the socket's path, the
        rest of the path will be padded with 0 bytes, and the entire
        zero-padded buffer will be considered the name. (As above, if
        `path_len` is -1, then `path` is assumed to be NUL-terminated.) In
        this case, `g_socket_address_get_native_size` will always return
        the full size of a `struct sockaddr_un`, although
        `g_unix_socket_address_get_path_len` will still return just the
        length of `path`.

        G_UNIX_SOCKET_ADDRESS_ABSTRACT is preferred over
        G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED for new programs. Of course,
        when connecting to a server created by another process, you must
        use the appropriate type corresponding to how that process created
        its listening socket.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::abstract"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::address_type"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::path"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::path_as_array"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class UnixSocketAddressClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> SocketAddressClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class UnixSocketAddressPrivate(GObject.GPointer):
    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Vfs(GObject.Object):
    """
    Entry point for using GIO functionality.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @staticmethod
    def get_default() -> Vfs:
        """
        Gets the default GVfs for the system.
        """
    def get_file_for_path(self, path: str) -> File:
        """
        Gets a GFile for `path`.
        """
    def get_file_for_uri(self, uri: str) -> File:
        """
            Gets a GFile for `uri`.

        This operation never fails, but the returned object
        might not support any I/O operation if the URI
        is malformed or if the URI scheme is not supported.
        """
    @staticmethod
    def get_local() -> Vfs:
        """
        Gets the local GVfs for the system.
        """
    def get_supported_uri_schemes(self) -> list:
        """
        Gets a list of URI schemes supported by `vfs`.
        """
    def is_active(self) -> bool:
        """
        Checks if the VFS is active.
        """
    def parse_name(self, parse_name: str) -> File:
        """
            This operation never fails, but the returned object might
        not support any I/O operations if the `parse_name` cannot
        be parsed by the GVfs module.
        """
    def register_uri_scheme(
        self,
        scheme: str,
        uri_func: VfsFileLookupFunc | None | typing.Callable[..., File] = None,
        uri_data: object | None = None,
        parse_name_func: VfsFileLookupFunc | None | typing.Callable[..., File] = None,
        *parse_name_data: object | None,
    ) -> bool:
        """
            Registers `uri_func` and `parse_name_func` as the GFile URI and parse name
        lookup functions for URIs with a scheme matching `scheme`.
        Note that `scheme` is registered only within the running application, as
        opposed to desktop-wide as it happens with GVfs backends.

        When a GFile is requested with an URI containing `scheme` (e.g. through
        `g_file_new_for_uri`), `uri_func` will be called to allow a custom
        constructor. The implementation of `uri_func` should not be blocking, and
        must not call `g_vfs_register_uri_scheme` or `g_vfs_unregister_uri_scheme`.

        When `g_file_parse_name` is called with a parse name obtained from such file,
        `parse_name_func` will be called to allow the GFile to be created again. In
        that case, it's responsibility of `parse_name_func` to make sure the parse
        name matches what the custom GFile implementation returned when
        `g_file_get_parse_name` was previously called. The implementation of
        `parse_name_func` should not be blocking, and must not call
        `g_vfs_register_uri_scheme` or `g_vfs_unregister_uri_scheme`.

        It's an error to call this function twice with the same scheme. To unregister
        a custom URI scheme, use `g_vfs_unregister_uri_scheme`.
        """
    def unregister_uri_scheme(self, scheme: str) -> bool:
        """
            Unregisters the URI handler for `scheme` previously registered with
        `g_vfs_register_uri_scheme`.
        """

    # python methods (overrides?)
    def do_add_writable_namespaces(
        self,
        list: FileAttributeInfoList,
    ) -> None:
        """
        add_writable_namespaces(self, list:Gio.FileAttributeInfoList)
        """
    def do_get_file_for_path(
        self,
        path: str,
    ) -> File:
        """
        get_file_for_path(self, path:str) -> Gio.File
        """
    def do_get_file_for_uri(
        self,
        uri: str,
    ) -> File:
        """
        get_file_for_uri(self, uri:str) -> Gio.File
        """
    def do_get_supported_uri_schemes(
        self,
    ) -> list:
        """
        get_supported_uri_schemes(self) -> list
        """
    def do_is_active(
        self,
    ) -> bool:
        """
        is_active(self) -> bool
        """
    def do_local_file_add_info(
        self,
        filename: str,
        device: int,
        attribute_matcher: FileAttributeMatcher,
        info: FileInfo,
        cancellable: Cancellable | None,
        extra_data: typing.Any,
        free_extra_data: typing.Callable,
    ) -> None:
        """
        local_file_add_info(self, filename:str, device:int, attribute_matcher:Gio.FileAttributeMatcher, info:Gio.FileInfo, cancellable:Gio.Cancellable=None, extra_data=None, free_extra_data:GLib.DestroyNotify)
        """
    def do_local_file_moved(
        self,
        source: str,
        dest: str,
    ) -> None:
        """
        local_file_moved(self, source:str, dest:str)
        """
    def do_local_file_removed(
        self,
        filename: str,
    ) -> None:
        """
        local_file_removed(self, filename:str)
        """
    def do_local_file_set_attributes(
        self,
        filename: str,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool:
        """
        local_file_set_attributes(self, filename:str, info:Gio.FileInfo, flags:Gio.FileQueryInfoFlags, cancellable:Gio.Cancellable=None) -> bool
        """
    def do_parse_name(
        self,
        parse_name: str,
    ) -> File:
        """
        parse_name(self, parse_name:str) -> Gio.File
        """

class VfsClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def add_writable_namespaces(self) -> add_writable_namespacesVfsClassCB: ...
    @builtins.property
    def deserialize_icon(self) -> object | None: ...
    @builtins.property
    def get_file_for_path(self) -> get_file_for_pathVfsClassCB: ...
    @builtins.property
    def get_file_for_uri(self) -> get_file_for_uriVfsClassCB: ...
    @builtins.property
    def get_supported_uri_schemes(self) -> get_supported_uri_schemesVfsClassCB: ...
    @builtins.property
    def is_active(self) -> is_activeVfsClassCB: ...
    @builtins.property
    def local_file_add_info(self) -> local_file_add_infoVfsClassCB: ...
    @builtins.property
    def local_file_moved(self) -> local_file_movedVfsClassCB: ...
    @builtins.property
    def local_file_removed(self) -> local_file_removedVfsClassCB: ...
    @builtins.property
    def local_file_set_attributes(self) -> local_file_set_attributesVfsClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def parse_name(self) -> parse_nameVfsClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class Volume(GObject.GInterface):
    """
    The `GVolume` interface represents user-visible objects that can be
    mounted. For example, a file system partition on a USB flash drive, or an
    optical disc inserted into a disc drive.

    If a `GVolume` is currently mounted, the corresponding [iface`Gio`.Mount] can
    be retrieved using [method`Gio`.Volume.get_mount].

    Mounting a `GVolume` instance is an asynchronous operation. For more
    information about asynchronous operations, see [iface`Gio`.AsyncResult] and
    [class`Gio`.Task]. To mount a `GVolume`, first call [method`Gio`.Volume.mount]
    with (at least) the `GVolume` instance, optionally a
    [class`Gio`.MountOperation] object and a [type`Gio`.AsyncReadyCallback].

    Typically, one will only want to pass `None` for the
    [class`Gio`.MountOperation] if automounting all volumes when a desktop session
    starts since it’s not desirable to put up a lot of dialogs asking
    for credentials.

    The callback will be fired when the operation has resolved (either
    with success or failure), and a [iface`Gio`.AsyncResult] instance will be
    passed to the callback.  That callback should then call
    [method`Gio`.Volume.mount_finish] with the `GVolume` instance and the
    [iface`Gio`.AsyncResult] data to see if the operation was completed
    successfully.  If a [type`GLib`.Error] is present when
    [method`Gio`.Volume.mount_finish] is called, then it will be filled with any
    error information.

    Note, when [porting from GnomeVFS](migrating-gnome-vfs.html),
    `GVolume` is the moral equivalent of `GnomeVFSDrive`.

    ## Volume Identifiers

    It is sometimes necessary to directly access the underlying
    operating system object behind a volume (e.g. for passing a volume
    to an application via the command line). For this purpose, GIO
    allows to obtain an ‘identifier’ for the volume. There can be
    different kinds of identifiers, such as Hal UDIs, filesystem labels,
    traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO uses predefined
    strings as names for the different kinds of identifiers:
    `G_VOLUME_IDENTIFIER_KIND_UUID`, `G_VOLUME_IDENTIFIER_KIND_LABEL`, etc.
    Use [method`Gio`.Volume.get_identifier] to obtain an identifier for a volume.

    Note that `G_VOLUME_IDENTIFIER_KIND_HAL_UDI` will only be available
    when the GVFS hal volume monitor is in use. Other volume monitors
    will generally be able to provide the `G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE`
    identifier, which can be used to obtain a hal device by means of
    ``libhal_manager_find_device_string_match``.
    """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    def can_eject(self) -> bool:
        """
        Checks if a volume can be ejected.
        """
    def can_mount(self) -> bool:
        """
        Checks if a volume can be mounted.
        """
    @deprecated("deprecated")
    async def eject(
        self,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Ejects a volume. This is an asynchronous operation, and is
        finished by calling `g_volume_eject_finish` with the `volume`
        and GAsyncResult returned in the `callback`.
        """
    @deprecated("deprecated")
    def eject_finish(self, result: AsyncResult) -> bool:
        """
            Finishes ejecting a volume. If any errors occurred during the operation,
        `error` will be set to contain the errors and False will be returned.
        """
    async def eject_with_operation(
        self,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Ejects a volume. This is an asynchronous operation, and is
        finished by calling `g_volume_eject_with_operation_finish` with the `volume`
        and GAsyncResult data returned in the `callback`.
        """
    def eject_with_operation_finish(self, result: AsyncResult) -> bool:
        """
            Finishes ejecting a volume. If any errors occurred during the operation,
        `error` will be set to contain the errors and False will be returned.
        """
    def enumerate_identifiers(self) -> list:
        """
            Gets the kinds of [identifiers](#volume-identifiers) that `volume` has.
        Use `g_volume_get_identifier` to obtain the identifiers themselves.
        """
    def get_activation_root(self) -> File | None:
        """
            Gets the activation root for a GVolume if it is known ahead of
        mount time. Returns None otherwise. If not None and if `volume`
        is mounted, then the result of `g_mount_get_root` on the
        GMount object obtained from `g_volume_get_mount` will always
        either be equal or a prefix of what this function returns. In
        other words, in code

        |[<!-- language="C" -->
          GMount *mount;
          GFile *mount_root
          GFile *volume_activation_root;

          mount = g_volume_get_mount (volume); // mounted, so never None
          mount_root = g_mount_get_root (mount);
          volume_activation_root = g_volume_get_activation_root (volume); // assume not None
        ]|
        then the expression
        |[<!-- language="C" -->
          (g_file_has_prefix (volume_activation_root, mount_root) ||
           g_file_equal (volume_activation_root, mount_root))
        ]|
        will always be True.

        Activation roots are typically used in GVolumeMonitor
        implementations to find the underlying mount to shadow, see
        `g_mount_is_shadowed` for more details.
        """
    def get_drive(self) -> Drive | None:
        """
        Gets the drive for the `volume`.
        """
    def get_icon(self) -> Icon:
        """
        Gets the icon for `volume`.
        """
    def get_identifier(self, kind: str) -> str | None:
        """
            Gets the identifier of the given kind for `volume`.
        See the [introduction](#volume-identifiers) for more
        information about volume identifiers.
        """
    def get_mount(self) -> Mount | None:
        """
        Gets the mount for the `volume`.
        """
    def get_name(self) -> str:
        """
        Gets the name of `volume`.
        """
    def get_sort_key(self) -> str | None:
        """
        Gets the sort key for `volume`, if any.
        """
    def get_symbolic_icon(self) -> Icon:
        """
        Gets the symbolic icon for `volume`.
        """
    def get_uuid(self) -> str | None:
        """
            Gets the UUID for the `volume`. The reference is typically based on
        the file system UUID for the volume in question and should be
        considered an opaque string. Returns None if there is no UUID
        available.
        """
    async def mount(
        self,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None:
        """
            Mounts a volume. This is an asynchronous operation, and is
        finished by calling `g_volume_mount_finish` with the `volume`
        and GAsyncResult returned in the `callback`.
        """
    def mount_finish(self, result: AsyncResult) -> bool:
        """
            Finishes mounting a volume. If any errors occurred during the operation,
        `error` will be set to contain the errors and False will be returned.

        If the mount operation succeeded, `g_volume_get_mount` on `volume`
        is guaranteed to return the mount right after calling this
        function; there's no need to listen for the 'mount-added' signal on
        GVolumeMonitor.
        """
    def should_automount(self) -> bool:
        """
        Returns whether the volume should be automatically mounted.
        """

    # Signals
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["changed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
        Emitted when the volume has been changed.
        """
    @typing.overload
    def connect(
        self, detailed_signal: typing.Literal["removed"], handler: typing.Callable[..., None], *args: typing.Any
    ) -> int:
        """
            This signal is emitted when the GVolume have been removed. If
        the recipient is holding references to the object they should
        release them so the object can be finalized.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class VolumeIface(GObject.GPointer):
    """
    Interface for implementing operations for mountable volumes.
    """

    # gi Fields
    @builtins.property
    def can_eject(self) -> can_ejectVolumeIfaceCB:
        """
        Checks if a GVolume can be ejected.
        """
    @builtins.property
    def can_mount(self) -> can_mountVolumeIfaceCB:
        """
        Returns True if the GVolume can be mounted.
        """
    @builtins.property
    def changed(self) -> changedVolumeIfaceCB:
        """
        Changed signal that is emitted when the volume's state has changed.
        """
    @builtins.property
    def eject(self) -> ejectVolumeIfaceCB:
        """
        Ejects a given GVolume.
        """
    @builtins.property
    def eject_finish(self) -> eject_finishVolumeIfaceCB:
        """
        Finishes an eject operation.
        """
    @builtins.property
    def eject_with_operation(self) -> eject_with_operationVolumeIfaceCB:
        """
        Starts ejecting a GVolume using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def eject_with_operation_finish(self) -> eject_with_operation_finishVolumeIfaceCB:
        """
        Finishes an eject operation using a GMountOperation. Since 2.22.
        """
    @builtins.property
    def enumerate_identifiers(self) -> enumerate_identifiersVolumeIfaceCB:
        """
         Returns an array strings listing the kinds
        of [identifiers](#volume-identifiers) which the GVolume has.
        """
    @builtins.property
    def g_iface(self) -> GObject.TypeInterface | None:
        """
        The parent interface.
        """
    @builtins.property
    def get_activation_root(self) -> get_activation_rootVolumeIfaceCB | None:
        """
          Returns the activation root for the GVolume if it is known in advance or None if
        it is not known.
        """
    @builtins.property
    def get_drive(self) -> get_driveVolumeIfaceCB | None:
        """
        Gets a GDrive the volume is located on. Returns None if the GVolume is not associated with a GDrive.
        """
    @builtins.property
    def get_icon(self) -> get_iconVolumeIfaceCB:
        """
        Gets a GIcon for the GVolume.
        """
    @builtins.property
    def get_identifier(self) -> get_identifierVolumeIfaceCB | None:
        """
         Returns the [identifier](#volume-identifiers) of the given kind, or None if
        the GVolume doesn't have one.
        """
    @builtins.property
    def get_mount(self) -> get_mountVolumeIfaceCB | None:
        """
        Gets a GMount representing the mounted volume. Returns None if the GVolume is not mounted.
        """
    @builtins.property
    def get_name(self) -> get_nameVolumeIfaceCB:
        """
        Gets a string containing the name of the GVolume.
        """
    @builtins.property
    def get_sort_key(self) -> get_sort_keyVolumeIfaceCB | None:
        """
        Gets a key used for sorting GVolume instance or None if no such key exists. Since 2.32.
        """
    @builtins.property
    def get_symbolic_icon(self) -> get_symbolic_iconVolumeIfaceCB:
        """
        Gets a symbolic GIcon for the GVolume. Since 2.34.
        """
    @builtins.property
    def get_uuid(self) -> get_uuidVolumeIfaceCB | None:
        """
        Gets the UUID for the GVolume. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns None if there is no UUID available.
        """
    @builtins.property
    def mount_finish(self) -> mount_finishVolumeIfaceCB:
        """
        Finishes a mount operation.
        """
    @builtins.property
    def mount_fn(self) -> mount_fnVolumeIfaceCB:
        """
        Mounts a given GVolume.
        GVolume implementations must emit the GMountOperation::aborted
        signal before completing a mount operation that is aborted while
        awaiting input from the user through a GMountOperation instance.
        """
    @builtins.property
    def removed(self) -> removedVolumeIfaceCB:
        """
        The removed signal that is emitted when the GVolume have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.
        """
    @builtins.property
    def should_automount(self) -> should_automountVolumeIfaceCB:
        """
        Returns True if the GVolume should be automatically mounted.
        """

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class VolumeMonitor(GObject.Object):
    """
    `GVolumeMonitor` is for listing the user interesting devices and volumes
    on the computer. In other words, what a file selector or file manager
    would show in a sidebar.

    `GVolumeMonitor` is not
    thread-default-context aware (see
    [method`GLib`.MainContext.push_thread_default]), and so should not be used
    other than from the main thread, with no thread-default-context active.

    In order to receive updates about volumes and mounts monitored through GVFS,
    a main loop must be running.
    """

    # gi Fields
    @builtins.property
    def parent_instance(self) -> GObject.Object | None: ...
    @builtins.property
    def priv(self) -> object | None: ...

    # gi Methods
    @deprecated("deprecated")
    @staticmethod
    def adopt_orphan_mount(mount: Mount) -> Volume:
        """
            This function should be called by any GVolumeMonitor
        implementation when a new GMount object is created that is not
        associated with a GVolume object. It must be called just before
        emitting the `mount_added` signal.

        If the return value is not None, the caller must associate the
        returned GVolume object with the GMount. This involves returning
        it in its `g_mount_get_volume` implementation. The caller must
        also listen for the "removed" signal on the returned object
        and give up its reference when handling that signal

        Similarly, if implementing `g_volume_monitor_adopt_orphan_mount`,
        the implementor must take a reference to `mount` and return it in
        its `g_volume_get_mount` implemented. Also, the implementor must
        listen for the "unmounted" signal on `mount` and give up its
        reference upon handling that signal.

        There are two main use cases for this function.

        One is when implementing a user space file system driver that reads
        blocks of a block device that is already represented by the native
        volume monitor (for example a CD Audio file system driver). Such
        a driver will generate its own GMount object that needs to be
        associated with the GVolume object that represents the volume.

        The other is for implementing a GVolumeMonitor whose sole purpose
        is to return GVolume objects representing entries in the users
        "favorite servers" list or similar.
        """
    @staticmethod
    def get() -> VolumeMonitor:
        """
        Gets the volume monitor used by gio.
        """
    def get_connected_drives(self) -> list:
        """
            Gets a list of drives connected to the system.

        The returned list should be freed with `g_list_free`, after
        its elements have been unreffed with `g_object_unref`.
        """
    def get_mount_for_uuid(self, uuid: str) -> Mount | None:
        """
        Finds a GMount object by its UUID (see `g_mount_get_uuid`)
        """
    def get_mounts(self) -> list:
        """
            Gets a list of the mounts on the system.

        The returned list should be freed with `g_list_free`, after
        its elements have been unreffed with `g_object_unref`.
        """
    def get_volume_for_uuid(self, uuid: str) -> Volume | None:
        """
        Finds a GVolume object by its UUID (see `g_volume_get_uuid`)
        """
    def get_volumes(self) -> list:
        """
            Gets a list of the volumes on the system.

        The returned list should be freed with `g_list_free`, after
        its elements have been unreffed with `g_object_unref`.
        """

    # python methods (overrides?)
    def __init__(
        self,
        *args: typing.Any,
        **kwargs: typing.Any,
    ) -> None: ...

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-changed"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when a drive changes.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-connected"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when a drive is connected to the system.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-disconnected"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when a drive is disconnected from the system.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-eject-button"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when the eject button is pressed on `drive`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["drive-stop-button"],
        handler: typing.Callable[[typing_extensions.Self, Drive], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when the stop button is pressed on `drive`.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mount-added"],
        handler: typing.Callable[[typing_extensions.Self, Mount], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when a mount is added.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mount-changed"],
        handler: typing.Callable[[typing_extensions.Self, Mount], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when a mount changes.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mount-pre-unmount"],
        handler: typing.Callable[[typing_extensions.Self, Mount], None],
        *args: typing.Any,
    ) -> int:
        """
            May be emitted when a mount is about to be removed.

        This signal depends on the backend and is only emitted if
        GIO was used to unmount.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["mount-removed"],
        handler: typing.Callable[[typing_extensions.Self, Mount], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when a mount is removed.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["volume-added"],
        handler: typing.Callable[[typing_extensions.Self, Volume], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when a mountable volume is added to the system.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["volume-changed"],
        handler: typing.Callable[[typing_extensions.Self, Volume], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when mountable volume is changed.
        """
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["volume-removed"],
        handler: typing.Callable[[typing_extensions.Self, Volume], None],
        *args: typing.Any,
    ) -> int:
        """
        Emitted when a mountable volume is removed from the system.
        """
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class VolumeMonitorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def _g_reserved1(self) -> object | None: ...
    @builtins.property
    def _g_reserved2(self) -> object | None: ...
    @builtins.property
    def _g_reserved3(self) -> object | None: ...
    @builtins.property
    def _g_reserved4(self) -> object | None: ...
    @builtins.property
    def _g_reserved5(self) -> object | None: ...
    @builtins.property
    def _g_reserved6(self) -> object | None: ...
    @builtins.property
    def adopt_orphan_mount(self) -> object | None: ...
    @builtins.property
    def drive_changed(self) -> drive_changedVolumeMonitorClassCB: ...
    @builtins.property
    def drive_connected(self) -> drive_connectedVolumeMonitorClassCB: ...
    @builtins.property
    def drive_disconnected(self) -> drive_disconnectedVolumeMonitorClassCB: ...
    @builtins.property
    def drive_eject_button(self) -> drive_eject_buttonVolumeMonitorClassCB: ...
    @builtins.property
    def drive_stop_button(self) -> drive_stop_buttonVolumeMonitorClassCB: ...
    @builtins.property
    def get_connected_drives(self) -> get_connected_drivesVolumeMonitorClassCB: ...
    @builtins.property
    def get_mount_for_uuid(self) -> get_mount_for_uuidVolumeMonitorClassCB | None: ...
    @builtins.property
    def get_mounts(self) -> get_mountsVolumeMonitorClassCB: ...
    @builtins.property
    def get_volume_for_uuid(self) -> get_volume_for_uuidVolumeMonitorClassCB | None: ...
    @builtins.property
    def get_volumes(self) -> get_volumesVolumeMonitorClassCB: ...
    @builtins.property
    def is_supported(self) -> is_supportedVolumeMonitorClassCB: ...
    @builtins.property
    def mount_added(self) -> mount_addedVolumeMonitorClassCB: ...
    @builtins.property
    def mount_changed(self) -> mount_changedVolumeMonitorClassCB: ...
    @builtins.property
    def mount_pre_unmount(self) -> mount_pre_unmountVolumeMonitorClassCB: ...
    @builtins.property
    def mount_removed(self) -> mount_removedVolumeMonitorClassCB: ...
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...
    @builtins.property
    def volume_added(self) -> volume_addedVolumeMonitorClassCB: ...
    @builtins.property
    def volume_changed(self) -> volume_changedVolumeMonitorClassCB: ...
    @builtins.property
    def volume_removed(self) -> volume_removedVolumeMonitorClassCB: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ZlibCompressor(GObject.Object):
    """
    `GZlibCompressor` is an implementation of [iface`Gio`.Converter] that
    compresses data using zlib.
    """

    class Props(GObject.Object.Props):
        file_info: FileInfo | None  # [file-info]: changed because contained invalid characters
        """
        If set to a non-None GFileInfo object, and GZlibCompressor:format is
        G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
        and modification time from the file info to the GZIP header.
        """
        format: ZlibCompressorFormat
        """
        The format of the compressed data.
        """
        level: int
        """
        The level of compression from `0` (no compression) to `9` (most
        compression). `-1` for the default level.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, file_info: FileInfo | None = ..., format: ZlibCompressorFormat = ..., level: int = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_file_info(self) -> FileInfo | None:
        """
        Returns the GZlibCompressor:file-info property.
        """
    @classmethod
    def new(cls, format: ZlibCompressorFormat, level: int) -> ZlibCompressor:
        """
        Creates a new GZlibCompressor.
        """
    def set_file_info(self, file_info: FileInfo | None = None) -> None:
        """
            Sets `file_info` in `compressor`. If non-None, and `compressor`'s
        GZlibCompressor:format property is G_ZLIB_COMPRESSOR_FORMAT_GZIP,
        it will be used to set the file name and modification time in
        the GZIP header of the compressed data.

        Note: it is an error to call this function while a compression is in
        progress; it may only be called immediately after creation of `compressor`,
        or after resetting it with `g_converter_reset`.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file_info"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::format"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::level"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ZlibCompressorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

class ZlibDecompressor(GObject.Object):
    """
    `GZlibDecompressor` is an implementation of [iface`Gio`.Converter] that
    decompresses data compressed with zlib.
    """

    class Props(GObject.Object.Props):
        file_info: FileInfo | None  # [file-info]: changed because contained invalid characters
        """
        A GFileInfo containing the information found in the GZIP header
        of the data stream processed, or None if the header was not yet
        fully processed, is not present at all, or the compressor's
        GZlibDecompressor:format property is not G_ZLIB_COMPRESSOR_FORMAT_GZIP.
        """
        format: ZlibCompressorFormat
        """
        The format of the compressed data.
        """

    @builtins.property
    def props(self) -> Props: ...

    # gi Methods
    def __init__(self, format: ZlibCompressorFormat = ...) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """
    @builtins.property
    def get_file_info(self) -> FileInfo | None:
        """
            Retrieves the GFileInfo constructed from the GZIP header data
        of compressed data processed by `compressor`, or None if `decompressor`'s
        GZlibDecompressor:format property is not G_ZLIB_COMPRESSOR_FORMAT_GZIP,
        or the header data was not fully processed yet, or it not present in the
        data stream at all.
        """
    @classmethod
    def new(cls, format: ZlibCompressorFormat) -> ZlibDecompressor:
        """
        Creates a new GZlibDecompressor.
        """

    # Signals
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::file_info"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(
        self,
        detailed_signal: typing.Literal["notify::format"],
        handler: typing.Callable[[typing_extensions.Self, GObject.ParamSpec, typing.Any], None],
        *args: typing.Any,
    ) -> int: ...
    @typing.overload
    def connect(  # type: ignore otherwise pylance will complain and we should repeat all parent overloads here..
        self, detailed_signal: str, handler: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> int: ...

class ZlibDecompressorClass(GObject.GPointer):
    # gi Fields
    @builtins.property
    def parent_class(self) -> GObject.ObjectClass | None: ...

    # gi Methods
    def __init__(self) -> None:
        """
        Generated __init__ stub method. order not guaranteed.
        """

###############################################################
# Callbacks
###############################################################

class activateActionEntryCB(typing.Protocol):
    """
    This callback was used in:
        ActionEntry.activate
    """
    #  action
    def __call__(
        self,
        action: SimpleAction,
        parameter: GLib.Variant,
        *user_data: object | None,
    ) -> None: ...

class change_stateActionEntryCB(typing.Protocol):
    """
    This callback was used in:
        ActionEntry.change_state
    """
    #  action
    def __call__(
        self,
        action: SimpleAction,
        value: GLib.Variant,
        *user_data: object | None,
    ) -> None: ...

class has_actionActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.has_action
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> bool: ...

class list_actionsActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.list_actions
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
    ) -> list: ...

class get_action_enabledActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_enabled
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> bool: ...

class get_action_parameter_typeActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_parameter_type
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> GLib.VariantType | None: ...

class get_action_state_typeActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_state_type
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> GLib.VariantType | None: ...

class get_action_state_hintActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_state_hint
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> GLib.Variant | None: ...

class get_action_stateActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.get_action_state
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> GLib.Variant | None: ...

class change_action_stateActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.change_action_state
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
        value: GLib.Variant,
    ) -> None: ...

class activate_actionActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.activate_action
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
        parameter: GLib.Variant | None = None,
    ) -> None: ...

class action_addedActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.action_added
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> None: ...

class action_removedActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.action_removed
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> None: ...

class action_enabled_changedActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.action_enabled_changed
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
        enabled: bool,
    ) -> None: ...

class action_state_changedActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.action_state_changed
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
        state: GLib.Variant,
    ) -> None: ...

class query_actionActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionGroupInterface.query_action
    """
    #  action_group
    def __call__(
        self,
        action_group: ActionGroup,
        action_name: str,
    ) -> tuple[bool, bool, GLib.VariantType, GLib.VariantType, GLib.Variant, GLib.Variant]: ...

class get_nameActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_name
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> str: ...

class get_parameter_typeActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_parameter_type
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> GLib.VariantType | None: ...

class get_state_typeActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_state_type
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> GLib.VariantType | None: ...

class get_state_hintActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_state_hint
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> GLib.Variant | None: ...

class get_enabledActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_enabled
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> bool: ...

class get_stateActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.get_state
    """
    #  action
    def __call__(
        self,
        action: Action,
    ) -> GLib.Variant | None: ...

class change_stateActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.change_state
    """
    #  action
    def __call__(
        self,
        action: Action,
        value: GLib.Variant,
    ) -> None: ...

class activateActionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionInterface.activate
    """
    #  action
    def __call__(
        self,
        action: Action,
        parameter: GLib.Variant | None = None,
    ) -> None: ...

class lookup_actionActionMapInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionMapInterface.lookup_action
    """
    #  action_map
    def __call__(
        self,
        action_map: ActionMap,
        action_name: str,
    ) -> Action | None: ...

class add_actionActionMapInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionMapInterface.add_action
    """
    #  action_map
    def __call__(
        self,
        action_map: ActionMap,
        action: Action,
    ) -> None: ...

class remove_actionActionMapInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ActionMapInterface.remove_action
    """
    #  action_map
    def __call__(
        self,
        action_map: ActionMap,
        action_name: str,
    ) -> None: ...

class AsyncReadyCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.accept_async, Gio.accept_socket_async, Gio.acquire_async, Gio.app_info_get_default_for_type_async, Gio.app_info_get_default_for_uri_scheme_async, Gio.app_info_launch_default_for_uri_async, Gio.append_to_async, Gio.ask_password_async, Gio.async_initable_newv_async, Gio.bus_get, Gio.call, Gio.call_with_unix_fd_list, Gio.can_reach_async, Gio.close, Gio.close_async, Gio.communicate_async, Gio.communicate_utf8_async, Gio.connect_async, Gio.connect_to_host_async, Gio.connect_to_service_async, Gio.connect_to_uri_async, Gio.create_async, Gio.create_readwrite_async, Gio.dbus_address_get_stream, Gio.delete_async, Gio.eject, Gio.eject_mountable, Gio.eject_mountable_with_operation, Gio.eject_with_operation, Gio.enumerate_children_async, Gio.file_new_tmp_async, Gio.file_new_tmp_dir_async, Gio.fill_async, Gio.find_enclosing_mount_async, Gio.flush, Gio.flush_async, Gio.get_default_for_type_async, Gio.get_default_for_uri_scheme_async, Gio.guess_content_type, Gio.handshake_async, Gio.init_async, Gio.launch_default_for_uri_async, Gio.launch_uris_async, Gio.load_async, Gio.load_bytes_async, Gio.load_contents_async, Gio.lookup_async, Gio.lookup_by_address_async, Gio.lookup_by_name_async, Gio.lookup_by_name_with_flags_async, Gio.lookup_certificate_for_handle_async, Gio.lookup_certificate_issuer_async, Gio.lookup_certificates_issued_by_async, Gio.lookup_records_async, Gio.lookup_service_async, Gio.make_directory_async, Gio.make_symbolic_link_async, Gio.mount, Gio.mount_enclosing_volume, Gio.mount_mountable, Gio.new, Gio.new_for_address, Gio.new_for_bus, Gio.new_from_error, Gio.new_tmp_async, Gio.new_tmp_dir_async, Gio.newv_async, Gio.next_async, Gio.next_files_async, Gio.open_readwrite_async, Gio.poll_for_media, Gio.poll_mountable, Gio.query_default_handler_async, Gio.query_filesystem_info_async, Gio.query_info_async, Gio.read_all_async, Gio.read_async, Gio.read_bytes_async, Gio.read_line_async, Gio.read_until_async, Gio.read_upto_async, Gio.receive_credentials_async, Gio.release_async, Gio.remount, Gio.replace_async, Gio.replace_contents_async, Gio.replace_contents_bytes_async, Gio.replace_readwrite_async, Gio.report_error, Gio.request_certificate_async, Gio.send_credentials_async, Gio.send_message_with_reply, Gio.set_attributes_async, Gio.set_display_name_async, Gio.shutdown_async, Gio.simple_async_report_gerror_in_idle, Gio.skip_async, Gio.splice_async, Gio.start, Gio.start_mountable, Gio.stop, Gio.stop_mountable, Gio.trash_async, Gio.unmount, Gio.unmount_mountable, Gio.unmount_mountable_with_operation, Gio.unmount_with_operation, Gio.verify_chain_async, Gio.wait_async, Gio.wait_check_async, Gio.write_all_async, Gio.write_async, Gio.write_bytes_async, Gio.writev_all_async, Gio.writev_async
    """
    #  source_object
    def __call__(
        self,
        source_object: GObject.Object | None,
        res: AsyncResult,
        data: object | None = None,
    ) -> None: ...

class dupAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.dup
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> AppInfo: ...

class equalAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.equal
    """
    #  appinfo1
    def __call__(
        self,
        appinfo1: AppInfo,
        appinfo2: AppInfo,
    ) -> bool: ...

class get_idAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_id
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str | None: ...

class get_nameAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_name
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str: ...

class get_descriptionAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_description
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str | None: ...

class get_executableAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_executable
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str: ...

class get_iconAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_icon
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> Icon | None: ...

class launchAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.launch
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        files: list | None = None,
        context: AppLaunchContext | None = None,
    ) -> bool: ...

class supports_urisAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.supports_uris
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class supports_filesAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.supports_files
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class launch_urisAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.launch_uris
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        uris: list | None = None,
        context: AppLaunchContext | None = None,
    ) -> bool: ...

class should_showAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.should_show
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class set_as_default_for_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.set_as_default_for_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        content_type: str,
    ) -> bool: ...

class set_as_default_for_extensionAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.set_as_default_for_extension
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        extension: str,
    ) -> bool: ...

class add_supports_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.add_supports_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        content_type: str,
    ) -> bool: ...

class can_remove_supports_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.can_remove_supports_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class remove_supports_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.remove_supports_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        content_type: str,
    ) -> bool: ...

class can_deleteAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.can_delete
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class do_deleteAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.do_delete
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> bool: ...

class get_commandlineAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_commandline
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str | None: ...

class get_display_nameAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_display_name
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> str: ...

class set_as_last_used_for_typeAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.set_as_last_used_for_type
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        content_type: str,
    ) -> bool: ...

class get_supported_typesAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.get_supported_types
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
    ) -> list: ...

class launch_uris_asyncAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.launch_uris_async
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        uris: list | None = None,
        context: AppLaunchContext | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class launch_uris_finishAppInfoIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AppInfoIface.launch_uris_finish
    """
    #  appinfo
    def __call__(
        self,
        appinfo: AppInfo,
        result: AsyncResult,
    ) -> bool: ...

class get_displayAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.get_display
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        info: AppInfo,
        files: list,
    ) -> str | None: ...

class get_startup_notify_idAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.get_startup_notify_id
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        info: AppInfo | None = None,
        files: list | None = None,
    ) -> str | None: ...

class launch_failedAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.launch_failed
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        startup_notify_id: str,
    ) -> None: ...

class launchedAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.launched
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        info: AppInfo,
        platform_data: GLib.Variant,
    ) -> None: ...

class launch_startedAppLaunchContextClassCB(typing.Protocol):
    """
    This callback was used in:
        AppLaunchContextClass.launch_started
    """
    #  context
    def __call__(
        self,
        context: AppLaunchContext,
        info: AppInfo,
        platform_data: GLib.Variant,
    ) -> None: ...

class startupApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.startup
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class activateApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.activate
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class openApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.open
    """
    #  application
    def __call__(
        self,
        application: Application,
        files: list,
        n_files: int,
        hint: str,
    ) -> None: ...

class command_lineApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.command_line
    """
    #  application
    def __call__(
        self,
        application: Application,
        command_line: ApplicationCommandLine,
    ) -> int: ...

class local_command_lineApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.local_command_line
    """
    #  application
    def __call__(
        self,
        application: Application,
        arguments: list,
    ) -> tuple[bool, list, int]: ...

class before_emitApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.before_emit
    """
    #  application
    def __call__(
        self,
        application: Application,
        platform_data: GLib.Variant,
    ) -> None: ...

class after_emitApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.after_emit
    """
    #  application
    def __call__(
        self,
        application: Application,
        platform_data: GLib.Variant,
    ) -> None: ...

class add_platform_dataApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.add_platform_data
    """
    #  application
    def __call__(
        self,
        application: Application,
        builder: GLib.VariantBuilder,
    ) -> None: ...

class quit_mainloopApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.quit_mainloop
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class run_mainloopApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.run_mainloop
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class shutdownApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.shutdown
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> None: ...

class dbus_registerApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.dbus_register
    """
    #  application
    def __call__(
        self,
        application: Application,
        connection: DBusConnection,
        object_path: str,
    ) -> bool: ...

class dbus_unregisterApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.dbus_unregister
    """
    #  application
    def __call__(
        self,
        application: Application,
        connection: DBusConnection,
        object_path: str,
    ) -> None: ...

class handle_local_optionsApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.handle_local_options
    """
    #  application
    def __call__(
        self,
        application: Application,
        options: GLib.VariantDict,
    ) -> int: ...

class name_lostApplicationClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationClass.name_lost
    """
    #  application
    def __call__(
        self,
        application: Application,
    ) -> bool: ...

class print_literalApplicationCommandLineClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationCommandLineClass.print_literal
    """
    #  cmdline
    def __call__(
        self,
        cmdline: ApplicationCommandLine,
        message: str,
    ) -> None: ...

class printerr_literalApplicationCommandLineClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationCommandLineClass.printerr_literal
    """
    #  cmdline
    def __call__(
        self,
        cmdline: ApplicationCommandLine,
        message: str,
    ) -> None: ...

class get_stdinApplicationCommandLineClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationCommandLineClass.get_stdin
    """
    #  cmdline
    def __call__(
        self,
        cmdline: ApplicationCommandLine,
    ) -> InputStream | None: ...

class doneApplicationCommandLineClassCB(typing.Protocol):
    """
    This callback was used in:
        ApplicationCommandLineClass.done
    """
    #  cmdline
    def __call__(
        self,
        cmdline: ApplicationCommandLine,
    ) -> None: ...

class init_asyncAsyncInitableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncInitableIface.init_async
    """
    #  initable
    def __call__(
        self,
        initable: AsyncInitable,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class init_finishAsyncInitableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncInitableIface.init_finish
    """
    #  initable
    def __call__(
        self,
        initable: AsyncInitable,
        res: AsyncResult,
    ) -> bool: ...

class get_user_dataAsyncResultIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncResultIface.get_user_data
    """
    #  res
    def __call__(
        self,
        res: AsyncResult,
    ) -> object | None: ...

class get_source_objectAsyncResultIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncResultIface.get_source_object
    """
    #  res
    def __call__(
        self,
        res: AsyncResult,
    ) -> GObject.Object | None: ...

class is_taggedAsyncResultIfaceCB(typing.Protocol):
    """
    This callback was used in:
        AsyncResultIface.is_tagged
    """
    #  res
    def __call__(
        self,
        res: AsyncResult,
        source_tag: object | None = None,
    ) -> bool: ...

class fillBufferedInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferedInputStreamClass.fill
    """
    #  stream
    def __call__(
        self,
        stream: BufferedInputStream,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class fill_asyncBufferedInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferedInputStreamClass.fill_async
    """
    #  stream
    def __call__(
        self,
        stream: BufferedInputStream,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class fill_finishBufferedInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        BufferedInputStreamClass.fill_finish
    """
    #  stream
    def __call__(
        self,
        stream: BufferedInputStream,
        result: AsyncResult,
    ) -> int: ...

class cancelledCancellableClassCB(typing.Protocol):
    """
    This callback was used in:
        CancellableClass.cancelled
    """
    #  cancellable
    def __call__(
        self,
        cancellable: Cancellable | None = None,
    ) -> None: ...

class convertConverterIfaceCB(typing.Protocol):
    """
    This callback was used in:
        ConverterIface.convert
    """
    #  converter
    def __call__(
        self,
        converter: Converter,
        inbuf: list | None,
        inbuf_size: int,
        outbuf: list,
        outbuf_size: int,
        flags: ConverterFlags,
    ) -> tuple[ConverterResult, int, int]: ...

class resetConverterIfaceCB(typing.Protocol):
    """
    This callback was used in:
        ConverterIface.reset
    """
    #  converter
    def __call__(
        self,
        converter: Converter,
    ) -> None: ...

class DBusMessageFilterFunction(typing.Protocol):
    """
    This callback was used in:
        Gio.add_filter
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        message: DBusMessage,
        incoming: bool,
        *user_data: object | None,
    ) -> DBusMessage | None: ...

class DBusSignalCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.signal_subscribe
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender_name: str | None,
        object_path: str,
        interface_name: str,
        signal_name: str,
        parameters: GLib.Variant,
        *user_data: object | None,
    ) -> None: ...

class get_infoDBusInterfaceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceIface.get_info
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterface,
    ) -> DBusInterfaceInfo: ...

class get_objectDBusInterfaceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceIface.get_object
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterface,
    ) -> DBusObject | None: ...

class set_objectDBusInterfaceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceIface.set_object
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterface,
        object: DBusObject | None = None,
    ) -> None: ...

class dup_objectDBusInterfaceIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceIface.dup_object
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterface,
    ) -> DBusObject | None: ...

class get_infoDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.get_info
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
    ) -> DBusInterfaceInfo: ...

class get_vtableDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.get_vtable
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
    ) -> DBusInterfaceVTable: ...

class get_propertiesDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.get_properties
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
    ) -> GLib.Variant: ...

class flushDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.flush
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
    ) -> None: ...

class g_authorize_methodDBusInterfaceSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceSkeletonClass.g_authorize_method
    """
    #  interface_
    def __call__(
        self,
        interface_: DBusInterfaceSkeleton,
        invocation: DBusMethodInvocation,
    ) -> bool: ...

class DBusInterfaceMethodCallFuncDBusInterfaceVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceVTable.method_call
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str | None,
        object_path: str,
        interface_name: str | None,
        method_name: str,
        parameters: GLib.Variant,
        invocation: DBusMethodInvocation,
        *user_data: object | None,
    ) -> None: ...

class DBusInterfaceGetPropertyFuncDBusInterfaceVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceVTable.get_property
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str | None,
        object_path: str,
        interface_name: str,
        property_name: str,
        error: GLib.Error,
        *user_data: object | None,
    ) -> GLib.Variant: ...

class DBusInterfaceSetPropertyFuncDBusInterfaceVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusInterfaceVTable.set_property
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str | None,
        object_path: str,
        interface_name: str,
        property_name: str,
        value: GLib.Variant,
        error: GLib.Error,
        *user_data: object | None,
    ) -> bool: ...

class get_object_pathDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.get_object_path
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
    ) -> str: ...

class get_interfacesDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.get_interfaces
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
    ) -> list: ...

class get_interfaceDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.get_interface
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
        interface_name: str,
    ) -> DBusInterface | None: ...

class interface_addedDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.interface_added
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
        interface_: DBusInterface,
    ) -> None: ...

class interface_removedDBusObjectIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectIface.interface_removed
    """
    #  object
    def __call__(
        self,
        object: DBusObject,
        interface_: DBusInterface,
    ) -> None: ...

class DBusProxyTypeFunc(typing.Protocol):
    """
    This callback was used in:
        Gio.new, Gio.new_for_bus, Gio.new_for_bus_sync, Gio.new_sync
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManagerClient,
        object_path: str,
        interface_name: str | None = None,
        data: object | None = None,
    ) -> GObject.GType: ...

class interface_proxy_signalDBusObjectManagerClientClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerClientClass.interface_proxy_signal
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManagerClient,
        object_proxy: DBusObjectProxy,
        interface_proxy: DBusProxy,
        sender_name: str,
        signal_name: str,
        parameters: GLib.Variant,
    ) -> None: ...

class interface_proxy_properties_changedDBusObjectManagerClientClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerClientClass.interface_proxy_properties_changed
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManagerClient,
        object_proxy: DBusObjectProxy,
        interface_proxy: DBusProxy,
        changed_properties: GLib.Variant,
        invalidated_properties: str,
    ) -> None: ...

class get_object_pathDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.get_object_path
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
    ) -> str: ...

class get_objectsDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.get_objects
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
    ) -> list: ...

class get_objectDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.get_object
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object_path: str,
    ) -> DBusObject | None: ...

class get_interfaceDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.get_interface
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object_path: str,
        interface_name: str,
    ) -> DBusInterface | None: ...

class object_addedDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.object_added
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object: DBusObject,
    ) -> None: ...

class object_removedDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.object_removed
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object: DBusObject,
    ) -> None: ...

class interface_addedDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.interface_added
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object: DBusObject,
        interface_: DBusInterface,
    ) -> None: ...

class interface_removedDBusObjectManagerIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectManagerIface.interface_removed
    """
    #  manager
    def __call__(
        self,
        manager: DBusObjectManager,
        object: DBusObject,
        interface_: DBusInterface,
    ) -> None: ...

class authorize_methodDBusObjectSkeletonClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusObjectSkeletonClass.authorize_method
    """
    #  object
    def __call__(
        self,
        object: DBusObjectSkeleton,
        interface_: DBusInterfaceSkeleton,
        invocation: DBusMethodInvocation,
    ) -> bool: ...

class g_properties_changedDBusProxyClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusProxyClass.g_properties_changed
    """
    #  proxy
    def __call__(
        self,
        proxy: DBusProxy,
        changed_properties: GLib.Variant,
        invalidated_properties: str,
    ) -> None: ...

class g_signalDBusProxyClassCB(typing.Protocol):
    """
    This callback was used in:
        DBusProxyClass.g_signal
    """
    #  proxy
    def __call__(
        self,
        proxy: DBusProxy,
        sender_name: str,
        signal_name: str,
        parameters: GLib.Variant,
    ) -> None: ...

class DBusSubtreeEnumerateFuncDBusSubtreeVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusSubtreeVTable.enumerate
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str,
        object_path: str,
        *user_data: object | None,
    ) -> list: ...

class DBusSubtreeIntrospectFuncDBusSubtreeVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusSubtreeVTable.introspect
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str,
        object_path: str,
        node: str,
        *user_data: object | None,
    ) -> list | None: ...

class DBusSubtreeDispatchFuncDBusSubtreeVTableCB(typing.Protocol):
    """
    This callback was used in:
        DBusSubtreeVTable.dispatch
    """
    #  connection
    def __call__(
        self,
        connection: DBusConnection,
        sender: str,
        object_path: str,
        interface_name: str,
        node: str,
        out_user_data: object,
        *user_data: object | None,
    ) -> DBusInterfaceVTable | None: ...

class receive_messagesDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.receive_messages
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        messages: list,
        num_messages: int,
        flags: int,
        timeout: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class send_messagesDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.send_messages
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        messages: list,
        num_messages: int,
        flags: int,
        timeout: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class create_sourceDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.create_source
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        condition: GLib.IOCondition,
        cancellable: Cancellable | None = None,
    ) -> GLib.Source: ...

class condition_checkDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.condition_check
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        condition: GLib.IOCondition,
    ) -> GLib.IOCondition: ...

class condition_waitDatagramBasedInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DatagramBasedInterface.condition_wait
    """
    #  datagram_based
    def __call__(
        self,
        datagram_based: DatagramBased,
        condition: GLib.IOCondition,
        timeout: int,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class authorizeDebugControllerDBusClassCB(typing.Protocol):
    """
    This callback was used in:
        DebugControllerDBusClass.authorize
    """
    #  controller
    def __call__(
        self,
        controller: DebugControllerDBus,
        invocation: DBusMethodInvocation,
    ) -> bool: ...

class DesktopAppLaunchCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.launch_uris_as_manager, Gio.launch_uris_as_manager_with_fds
    """
    #  appinfo
    def __call__(
        self,
        appinfo: DesktopAppInfo,
        pid: int,
        *user_data: object | None,
    ) -> None: ...

class get_default_for_uri_schemeDesktopAppInfoLookupIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DesktopAppInfoLookupIface.get_default_for_uri_scheme
    """
    #  lookup
    def __call__(
        self,
        lookup: DesktopAppInfoLookup,
        uri_scheme: str,
    ) -> AppInfo | None: ...

class changedDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.changed
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> None: ...

class disconnectedDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.disconnected
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> None: ...

class eject_buttonDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject_button
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> None: ...

class get_nameDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_name
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> str: ...

class get_iconDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_icon
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> Icon: ...

class has_volumesDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.has_volumes
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class get_volumesDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_volumes
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> list: ...

class is_media_removableDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.is_media_removable
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class has_mediaDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.has_media
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class is_media_check_automaticDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.is_media_check_automatic
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class can_ejectDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_eject
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class can_poll_for_mediaDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_poll_for_media
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class ejectDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class eject_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class poll_for_mediaDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.poll_for_media
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class poll_for_media_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.poll_for_media_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class get_identifierDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_identifier
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        kind: str,
    ) -> str | None: ...

class enumerate_identifiersDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.enumerate_identifiers
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> list: ...

class get_start_stop_typeDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_start_stop_type
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> DriveStartStopType: ...

class can_startDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_start
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class can_start_degradedDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_start_degraded
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class startDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.start
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        flags: DriveStartFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class start_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.start_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class can_stopDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.can_stop
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class stopDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.stop
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class stop_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.stop_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class stop_buttonDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.stop_button
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> None: ...

class eject_with_operationDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject_with_operation
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class eject_with_operation_finishDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.eject_with_operation_finish
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
        result: AsyncResult,
    ) -> bool: ...

class get_sort_keyDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_sort_key
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> str | None: ...

class get_symbolic_iconDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.get_symbolic_icon
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> Icon: ...

class is_removableDriveIfaceCB(typing.Protocol):
    """
    This callback was used in:
        DriveIface.is_removable
    """
    #  drive
    def __call__(
        self,
        drive: Drive,
    ) -> bool: ...

class accept_certificateDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.accept_certificate
    """
    #  connection
    def __call__(
        self,
        connection: DtlsConnection,
        peer_cert: TlsCertificate,
        errors: TlsCertificateFlags,
    ) -> bool: ...

class handshakeDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.handshake
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class handshake_asyncDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.handshake_async
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class handshake_finishDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.handshake_finish
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        result: AsyncResult,
    ) -> bool: ...

class shutdownDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.shutdown
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        shutdown_read: bool,
        shutdown_write: bool,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class shutdown_asyncDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.shutdown_async
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        shutdown_read: bool,
        shutdown_write: bool,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class shutdown_finishDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.shutdown_finish
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        result: AsyncResult,
    ) -> bool: ...

class set_advertised_protocolsDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.set_advertised_protocols
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        protocols: list | None = None,
    ) -> None: ...

class get_negotiated_protocolDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.get_negotiated_protocol
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
    ) -> str | None: ...

class get_binding_dataDtlsConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        DtlsConnectionInterface.get_binding_data
    """
    #  conn
    def __call__(
        self,
        conn: DtlsConnection,
        type: TlsChannelBindingType,
        data: list,
    ) -> bool: ...

class FileProgressCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.copy, Gio.move
    """
    #  current_num_bytes
    def __call__(
        self,
        current_num_bytes: int,
        total_num_bytes: int,
        data: object | None = None,
    ) -> None: ...

class FileMeasureProgressCallback(typing.Protocol):
    """
    This callback was used in:
        Gio.measure_disk_usage
    """
    #  reporting
    def __call__(
        self,
        reporting: bool,
        current_size: int,
        num_dirs: int,
        num_files: int,
        data: object | None = None,
    ) -> None: ...

class get_fdFileDescriptorBasedIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileDescriptorBasedIface.get_fd
    """
    #  fd_based
    def __call__(
        self,
        fd_based: FileDescriptorBased,
    ) -> int: ...

class next_fileFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.next_file
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        cancellable: Cancellable | None = None,
    ) -> FileInfo | None: ...

class close_fnFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.close_fn
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class next_files_asyncFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.next_files_async
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        num_files: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class next_files_finishFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.next_files_finish
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        result: AsyncResult,
    ) -> list: ...

class close_asyncFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.close_async
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class close_finishFileEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileEnumeratorClass.close_finish
    """
    #  enumerator
    def __call__(
        self,
        enumerator: FileEnumerator,
        result: AsyncResult,
    ) -> bool: ...

class tellFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.tell
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
    ) -> int: ...

class can_seekFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.can_seek
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
    ) -> bool: ...

class seekFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.seek
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class can_truncateFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.can_truncate
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
    ) -> bool: ...

class truncate_fnFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.truncate_fn
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class query_infoFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.query_info
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_info_asyncFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.query_info_async
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class query_info_finishFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.query_info_finish
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
        result: AsyncResult,
    ) -> FileInfo: ...

class get_etagFileIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileIOStreamClass.get_etag
    """
    #  stream
    def __call__(
        self,
        stream: FileIOStream,
    ) -> str | None: ...

class dupFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.dup
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> File: ...

class hashFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.hash
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> int: ...

class equalFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.equal
    """
    #  file1
    def __call__(
        self,
        file1: File,
        file2: File,
    ) -> bool: ...

class is_nativeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.is_native
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> bool: ...

class has_uri_schemeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.has_uri_scheme
    """
    #  file
    def __call__(
        self,
        file: File,
        uri_scheme: str,
    ) -> bool: ...

class get_uri_schemeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_uri_scheme
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str | None: ...

class get_basenameFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_basename
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str | None: ...

class get_pathFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_path
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str | None: ...

class get_uriFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_uri
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str: ...

class get_parse_nameFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_parse_name
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> str: ...

class get_parentFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_parent
    """
    #  file
    def __call__(
        self,
        file: File,
    ) -> File | None: ...

class prefix_matchesFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.prefix_matches
    """
    #  prefix
    def __call__(
        self,
        prefix: File,
        file: File,
    ) -> bool: ...

class get_relative_pathFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_relative_path
    """
    #  parent
    def __call__(
        self,
        parent: File,
        descendant: File,
    ) -> str | None: ...

class resolve_relative_pathFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.resolve_relative_path
    """
    #  file
    def __call__(
        self,
        file: File,
        relative_path: str,
    ) -> File: ...

class get_child_for_display_nameFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.get_child_for_display_name
    """
    #  file
    def __call__(
        self,
        file: File,
        display_name: str,
    ) -> File: ...

class enumerate_childrenFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.enumerate_children
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> FileEnumerator: ...

class enumerate_children_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.enumerate_children_async
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class enumerate_children_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.enumerate_children_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileEnumerator: ...

class query_infoFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_info
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_info_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_info_async
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class query_info_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_info_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileInfo: ...

class query_filesystem_infoFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_filesystem_info
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_filesystem_info_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_filesystem_info_async
    """
    #  file
    def __call__(
        self,
        file: File,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class query_filesystem_info_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_filesystem_info_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileInfo: ...

class find_enclosing_mountFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.find_enclosing_mount
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> Mount: ...

class find_enclosing_mount_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.find_enclosing_mount_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class find_enclosing_mount_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.find_enclosing_mount_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> Mount: ...

class set_display_nameFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_display_name
    """
    #  file
    def __call__(
        self,
        file: File,
        display_name: str,
        cancellable: Cancellable | None = None,
    ) -> File: ...

class set_display_name_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_display_name_async
    """
    #  file
    def __call__(
        self,
        file: File,
        display_name: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class set_display_name_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_display_name_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> File: ...

class query_settable_attributesFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_settable_attributes
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> FileAttributeInfoList: ...

class query_writable_namespacesFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_writable_namespaces
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> FileAttributeInfoList: ...

class set_attributeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_attribute
    """
    #  file
    def __call__(
        self,
        file: File,
        attribute: str,
        type: FileAttributeType,
        value_p: object | None,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class set_attributes_from_infoFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_attributes_from_info
    """
    #  file
    def __call__(
        self,
        file: File,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class set_attributes_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_attributes_async
    """
    #  file
    def __call__(
        self,
        file: File,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class set_attributes_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.set_attributes_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> tuple[bool, FileInfo]: ...

class read_fnFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.read_fn
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> FileInputStream: ...

class read_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.read_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class read_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.read_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileInputStream: ...

class append_toFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.append_to
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileOutputStream: ...

class append_to_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.append_to_async
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class append_to_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.append_to_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileOutputStream: ...

class createFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileOutputStream: ...

class create_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_async
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class create_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileOutputStream: ...

class replaceFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace
    """
    #  file
    def __call__(
        self,
        file: File,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileOutputStream: ...

class replace_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_async
    """
    #  file
    def __call__(
        self,
        file: File,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class replace_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileOutputStream: ...

class delete_fileFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.delete_file
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class delete_file_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.delete_file_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class delete_file_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.delete_file_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class trashFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.trash
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class trash_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.trash_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class trash_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.trash_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class make_directoryFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_directory
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class make_directory_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_directory_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class make_directory_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_directory_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class make_symbolic_linkFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_symbolic_link
    """
    #  file
    def __call__(
        self,
        file: File,
        symlink_value: str,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class make_symbolic_link_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_symbolic_link_async
    """
    #  file
    def __call__(
        self,
        file: File,
        symlink_value: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class make_symbolic_link_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.make_symbolic_link_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class copyFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.copy
    """
    #  source
    def __call__(
        self,
        source: File,
        destination: File,
        flags: FileCopyFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        *progress_callback_data: object | None,
    ) -> bool: ...

class copy_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.copy_async
    """
    #  source
    def __call__(
        self,
        source: File,
        destination: File,
        flags: FileCopyFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        progress_callback_data: object | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class copy_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.copy_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> bool: ...

class moveFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.move
    """
    #  source
    def __call__(
        self,
        source: File,
        destination: File,
        flags: FileCopyFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        *progress_callback_data: object | None,
    ) -> bool: ...

class move_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.move_async
    """
    #  source
    def __call__(
        self,
        source: File,
        destination: File,
        flags: FileCopyFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        progress_callback: FileProgressCallback | None = None,
        progress_callback_data: object | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class move_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.move_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class mount_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.mount_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class mount_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.mount_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> File: ...

class unmount_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.unmount_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class unmount_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.unmount_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class eject_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.eject_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class eject_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.eject_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class mount_enclosing_volumeFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.mount_enclosing_volume
    """
    #  location
    def __call__(
        self,
        location: File,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class mount_enclosing_volume_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.mount_enclosing_volume_finish
    """
    #  location
    def __call__(
        self,
        location: File,
        result: AsyncResult,
    ) -> bool: ...

class monitor_dirFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.monitor_dir
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileMonitorFlags,
        cancellable: Cancellable | None = None,
    ) -> FileMonitor: ...

class monitor_fileFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.monitor_file
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileMonitorFlags,
        cancellable: Cancellable | None = None,
    ) -> FileMonitor: ...

class open_readwriteFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.open_readwrite
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> FileIOStream: ...

class open_readwrite_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.open_readwrite_async
    """
    #  file
    def __call__(
        self,
        file: File,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class open_readwrite_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.open_readwrite_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileIOStream: ...

class create_readwriteFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_readwrite
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileIOStream: ...

class create_readwrite_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_readwrite_async
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class create_readwrite_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.create_readwrite_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileIOStream: ...

class replace_readwriteFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_readwrite
    """
    #  file
    def __call__(
        self,
        file: File,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        cancellable: Cancellable | None = None,
    ) -> FileIOStream: ...

class replace_readwrite_asyncFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_readwrite_async
    """
    #  file
    def __call__(
        self,
        file: File,
        etag: str | None,
        make_backup: bool,
        flags: FileCreateFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class replace_readwrite_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.replace_readwrite_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        res: AsyncResult,
    ) -> FileIOStream: ...

class start_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.start_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: DriveStartFlags,
        start_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class start_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.start_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class stop_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.stop_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class stop_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.stop_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class unmount_mountable_with_operationFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.unmount_mountable_with_operation
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class unmount_mountable_with_operation_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.unmount_mountable_with_operation_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class eject_mountable_with_operationFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.eject_mountable_with_operation
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class eject_mountable_with_operation_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.eject_mountable_with_operation_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class poll_mountableFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.poll_mountable
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class poll_mountable_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.poll_mountable_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> bool: ...

class measure_disk_usageFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.measure_disk_usage
    """
    #  file
    def __call__(
        self,
        file: File,
        flags: FileMeasureFlags,
        cancellable: Cancellable | None = None,
        progress_callback: FileMeasureProgressCallback | None = None,
        *progress_data: object | None,
    ) -> tuple[bool, int, int, int]: ...

class measure_disk_usage_finishFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.measure_disk_usage_finish
    """
    #  file
    def __call__(
        self,
        file: File,
        result: AsyncResult,
    ) -> tuple[bool, int, int, int]: ...

class query_existsFileIfaceCB(typing.Protocol):
    """
    This callback was used in:
        FileIface.query_exists
    """
    #  file
    def __call__(
        self,
        file: File,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class tellFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.tell
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
    ) -> int: ...

class can_seekFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.can_seek
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
    ) -> bool: ...

class seekFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.seek
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class query_infoFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.query_info
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_info_asyncFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.query_info_async
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class query_info_finishFileInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileInputStreamClass.query_info_finish
    """
    #  stream
    def __call__(
        self,
        stream: FileInputStream,
        result: AsyncResult,
    ) -> FileInfo: ...

class changedFileMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileMonitorClass.changed
    """
    #  monitor
    def __call__(
        self,
        monitor: FileMonitor,
        file: File,
        other_file: File,
        event_type: FileMonitorEvent,
    ) -> None: ...

class cancelFileMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        FileMonitorClass.cancel
    """
    #  monitor
    def __call__(
        self,
        monitor: FileMonitor,
    ) -> bool: ...

class tellFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.tell
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
    ) -> int: ...

class can_seekFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.can_seek
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
    ) -> bool: ...

class seekFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.seek
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class can_truncateFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.can_truncate
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
    ) -> bool: ...

class truncate_fnFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.truncate_fn
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class query_infoFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.query_info
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        attributes: str,
        cancellable: Cancellable | None = None,
    ) -> FileInfo: ...

class query_info_asyncFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.query_info_async
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        attributes: str,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class query_info_finishFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.query_info_finish
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
        result: AsyncResult,
    ) -> FileInfo: ...

class get_etagFileOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        FileOutputStreamClass.get_etag
    """
    #  stream
    def __call__(
        self,
        stream: FileOutputStream,
    ) -> str | None: ...

class got_completion_dataFilenameCompleterClassCB(typing.Protocol):
    """
    This callback was used in:
        FilenameCompleterClass.got_completion_data
    """
    #  filename_completer
    def __call__(
        self,
        filename_completer: FilenameCompleter,
    ) -> None: ...

class get_input_streamIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.get_input_stream
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
    ) -> InputStream: ...

class get_output_streamIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.get_output_stream
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
    ) -> OutputStream: ...

class close_fnIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.close_fn
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class close_asyncIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.close_async
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class close_finishIOStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        IOStreamClass.close_finish
    """
    #  stream
    def __call__(
        self,
        stream: IOStream,
        result: AsyncResult,
    ) -> bool: ...

class hashIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        IconIface.hash
    """
    #  icon
    def __call__(
        self,
        icon: Icon,
    ) -> int: ...

class equalIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        IconIface.equal
    """
    #  icon1
    def __call__(
        self,
        icon1: Icon | None = None,
        icon2: Icon | None = None,
    ) -> bool: ...

class to_tokensIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        IconIface.to_tokens
    """
    #  icon
    def __call__(
        self,
        icon: Icon,
    ) -> tuple[bool, list, int]: ...

class serializeIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        IconIface.serialize
    """
    #  icon
    def __call__(
        self,
        icon: Icon,
    ) -> GLib.Variant | None: ...

class to_stringInetAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        InetAddressClass.to_string
    """
    #  address
    def __call__(
        self,
        address: InetAddress,
    ) -> str: ...

class to_bytesInetAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        InetAddressClass.to_bytes
    """
    #  address
    def __call__(
        self,
        address: InetAddress,
    ) -> int: ...

class initInitableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        InitableIface.init
    """
    #  initable
    def __call__(
        self,
        initable: Initable,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class read_fnInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.read_fn
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        buffer: object | None,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class skipInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.skip
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class close_fnInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.close_fn
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class read_asyncInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.read_async
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> list | None: ...

class read_finishInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.read_finish
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        result: AsyncResult,
    ) -> int: ...

class skip_asyncInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.skip_async
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class skip_finishInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.skip_finish
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        result: AsyncResult,
    ) -> int: ...

class close_asyncInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.close_async
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class close_finishInputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        InputStreamClass.close_finish
    """
    #  stream
    def __call__(
        self,
        stream: InputStream,
        result: AsyncResult,
    ) -> bool: ...

class get_item_typeListModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ListModelInterface.get_item_type
    """
    #  list
    def __call__(
        self,
        list: ListModel,
    ) -> GObject.GType: ...

class get_n_itemsListModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ListModelInterface.get_n_items
    """
    #  list
    def __call__(
        self,
        list: ListModel,
    ) -> int: ...

class get_itemListModelInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ListModelInterface.get_item
    """
    #  list
    def __call__(
        self,
        list: ListModel,
        position: int,
    ) -> GObject.Object | None: ...

class loadLoadableIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        LoadableIconIface.load
    """
    #  icon
    def __call__(
        self,
        icon: LoadableIcon,
        size: int,
        cancellable: Cancellable | None = None,
    ) -> tuple[InputStream, str]: ...

class load_asyncLoadableIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        LoadableIconIface.load_async
    """
    #  icon
    def __call__(
        self,
        icon: LoadableIcon,
        size: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class load_finishLoadableIconIfaceCB(typing.Protocol):
    """
    This callback was used in:
        LoadableIconIface.load_finish
    """
    #  icon
    def __call__(
        self,
        icon: LoadableIcon,
        res: AsyncResult,
    ) -> tuple[InputStream, str]: ...

class low_memory_warningMemoryMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        MemoryMonitorInterface.low_memory_warning
    """
    #  monitor
    def __call__(
        self,
        monitor: MemoryMonitor,
        level: MemoryMonitorWarningLevel,
    ) -> None: ...

class get_nextMenuAttributeIterClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuAttributeIterClass.get_next
    """
    #  iter
    def __call__(
        self,
        iter: MenuAttributeIter,
    ) -> tuple[bool, str, GLib.Variant]: ...

class get_nextMenuLinkIterClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuLinkIterClass.get_next
    """
    #  iter
    def __call__(
        self,
        iter: MenuLinkIter,
    ) -> tuple[bool, str, MenuModel]: ...

class is_mutableMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.is_mutable
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
    ) -> bool: ...

class get_n_itemsMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_n_items
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
    ) -> int: ...

class get_item_attributesMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_item_attributes
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
    ) -> dict: ...

class iterate_item_attributesMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.iterate_item_attributes
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
    ) -> MenuAttributeIter: ...

class get_item_attribute_valueMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_item_attribute_value
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
        attribute: str,
        expected_type: GLib.VariantType | None = None,
    ) -> GLib.Variant | None: ...

class get_item_linksMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_item_links
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
    ) -> dict: ...

class iterate_item_linksMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.iterate_item_links
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
    ) -> MenuLinkIter: ...

class get_item_linkMenuModelClassCB(typing.Protocol):
    """
    This callback was used in:
        MenuModelClass.get_item_link
    """
    #  model
    def __call__(
        self,
        model: MenuModel,
        item_index: int,
        link: str,
    ) -> MenuModel | None: ...

class changedMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.changed
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> None: ...

class unmountedMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmounted
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> None: ...

class get_rootMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_root
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> File: ...

class get_nameMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_name
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> str: ...

class get_iconMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_icon
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> Icon: ...

class get_uuidMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_uuid
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> str | None: ...

class get_volumeMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_volume
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> Volume | None: ...

class get_driveMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_drive
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> Drive | None: ...

class can_unmountMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.can_unmount
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> bool: ...

class can_ejectMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.can_eject
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> bool: ...

class unmountMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmount
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class unmount_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmount_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class ejectMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.eject
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class eject_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.eject_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class remountMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.remount
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class remount_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.remount_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class guess_content_typeMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.guess_content_type
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        force_rescan: bool,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class guess_content_type_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.guess_content_type_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> list: ...

class guess_content_type_syncMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.guess_content_type_sync
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        force_rescan: bool,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class pre_unmountMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.pre_unmount
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> None: ...

class unmount_with_operationMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmount_with_operation
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class unmount_with_operation_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.unmount_with_operation_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class eject_with_operationMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.eject_with_operation
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class eject_with_operation_finishMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.eject_with_operation_finish
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
        result: AsyncResult,
    ) -> bool: ...

class get_default_locationMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_default_location
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> File: ...

class get_sort_keyMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_sort_key
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> str | None: ...

class get_symbolic_iconMountIfaceCB(typing.Protocol):
    """
    This callback was used in:
        MountIface.get_symbolic_icon
    """
    #  mount
    def __call__(
        self,
        mount: Mount,
    ) -> Icon: ...

class ask_passwordMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.ask_password
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        message: str,
        default_user: str,
        default_domain: str,
        flags: AskPasswordFlags,
    ) -> None: ...

class ask_questionMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.ask_question
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        message: str,
        choices: list,
    ) -> None: ...

class replyMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.reply
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        result: MountOperationResult,
    ) -> None: ...

class abortedMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.aborted
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
    ) -> None: ...

class show_processesMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.show_processes
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        message: str,
        processes: list,
        choices: list,
    ) -> None: ...

class show_unmount_progressMountOperationClassCB(typing.Protocol):
    """
    This callback was used in:
        MountOperationClass.show_unmount_progress
    """
    #  op
    def __call__(
        self,
        op: MountOperation,
        message: str,
        time_left: int,
        bytes_left: int,
    ) -> None: ...

class network_changedNetworkMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        NetworkMonitorInterface.network_changed
    """
    #  monitor
    def __call__(
        self,
        monitor: NetworkMonitor,
        network_available: bool,
    ) -> None: ...

class can_reachNetworkMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        NetworkMonitorInterface.can_reach
    """
    #  monitor
    def __call__(
        self,
        monitor: NetworkMonitor,
        connectable: SocketConnectable,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class can_reach_asyncNetworkMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        NetworkMonitorInterface.can_reach_async
    """
    #  monitor
    def __call__(
        self,
        monitor: NetworkMonitor,
        connectable: SocketConnectable,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class can_reach_finishNetworkMonitorInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        NetworkMonitorInterface.can_reach_finish
    """
    #  monitor
    def __call__(
        self,
        monitor: NetworkMonitor,
        result: AsyncResult,
    ) -> bool: ...

class write_fnOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.write_fn
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        buffer: list | None,
        count: int,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class spliceOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.splice
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        cancellable: Cancellable | None = None,
    ) -> int: ...

class flushOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.flush
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class close_fnOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.close_fn
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class write_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.write_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        buffer: list | None,
        count: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class write_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.write_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> int: ...

class splice_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.splice_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        source: InputStream,
        flags: OutputStreamSpliceFlags,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class splice_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.splice_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> int: ...

class flush_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.flush_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class flush_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.flush_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> bool: ...

class close_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.close_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class close_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.close_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> bool: ...

class writev_fnOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.writev_fn
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        vectors: list,
        n_vectors: int,
        cancellable: Cancellable | None = None,
    ) -> tuple[bool, int]: ...

class writev_asyncOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.writev_async
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        vectors: list,
        n_vectors: int,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class writev_finishOutputStreamClassCB(typing.Protocol):
    """
    This callback was used in:
        OutputStreamClass.writev_finish
    """
    #  stream
    def __call__(
        self,
        stream: OutputStream,
        result: AsyncResult,
    ) -> tuple[bool, int]: ...

class acquirePermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.acquire
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class acquire_asyncPermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.acquire_async
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class acquire_finishPermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.acquire_finish
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        result: AsyncResult,
    ) -> bool: ...

class releasePermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.release
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class release_asyncPermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.release_async
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class release_finishPermissionClassCB(typing.Protocol):
    """
    This callback was used in:
        PermissionClass.release_finish
    """
    #  permission
    def __call__(
        self,
        permission: Permission,
        result: AsyncResult,
    ) -> bool: ...

class can_pollPollableInputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableInputStreamInterface.can_poll
    """
    #  stream
    def __call__(
        self,
        stream: PollableInputStream,
    ) -> bool: ...

class is_readablePollableInputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableInputStreamInterface.is_readable
    """
    #  stream
    def __call__(
        self,
        stream: PollableInputStream,
    ) -> bool: ...

class create_sourcePollableInputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableInputStreamInterface.create_source
    """
    #  stream
    def __call__(
        self,
        stream: PollableInputStream,
        cancellable: Cancellable | None = None,
    ) -> GLib.Source: ...

class read_nonblockingPollableInputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableInputStreamInterface.read_nonblocking
    """
    #  stream
    def __call__(
        self,
        stream: PollableInputStream,
        count: int,
    ) -> tuple[int, list | None]: ...

class can_pollPollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.can_poll
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
    ) -> bool: ...

class is_writablePollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.is_writable
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
    ) -> bool: ...

class create_sourcePollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.create_source
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
        cancellable: Cancellable | None = None,
    ) -> GLib.Source: ...

class write_nonblockingPollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.write_nonblocking
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
        buffer: list | None,
        count: int,
    ) -> int: ...

class writev_nonblockingPollableOutputStreamInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        PollableOutputStreamInterface.writev_nonblocking
    """
    #  stream
    def __call__(
        self,
        stream: PollableOutputStream,
        vectors: list,
        n_vectors: int,
    ) -> tuple[PollableReturn, int]: ...

class connectProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyInterface.connect
    """
    #  proxy
    def __call__(
        self,
        proxy: Proxy,
        connection: IOStream,
        proxy_address: ProxyAddress,
        cancellable: Cancellable | None = None,
    ) -> IOStream: ...

class connect_asyncProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyInterface.connect_async
    """
    #  proxy
    def __call__(
        self,
        proxy: Proxy,
        connection: IOStream,
        proxy_address: ProxyAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class connect_finishProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyInterface.connect_finish
    """
    #  proxy
    def __call__(
        self,
        proxy: Proxy,
        result: AsyncResult,
    ) -> IOStream: ...

class supports_hostnameProxyInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyInterface.supports_hostname
    """
    #  proxy
    def __call__(
        self,
        proxy: Proxy,
    ) -> bool: ...

class is_supportedProxyResolverInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyResolverInterface.is_supported
    """
    #  resolver
    def __call__(
        self,
        resolver: ProxyResolver,
    ) -> bool: ...

class lookupProxyResolverInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyResolverInterface.lookup
    """
    #  resolver
    def __call__(
        self,
        resolver: ProxyResolver,
        uri: str,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class lookup_asyncProxyResolverInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyResolverInterface.lookup_async
    """
    #  resolver
    def __call__(
        self,
        resolver: ProxyResolver,
        uri: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class lookup_finishProxyResolverInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        ProxyResolverInterface.lookup_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: ProxyResolver,
        result: AsyncResult,
    ) -> list: ...

class activate_action_fullRemoteActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        RemoteActionGroupInterface.activate_action_full
    """
    #  remote
    def __call__(
        self,
        remote: RemoteActionGroup,
        action_name: str,
        parameter: GLib.Variant | None,
        platform_data: GLib.Variant,
    ) -> None: ...

class change_action_state_fullRemoteActionGroupInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        RemoteActionGroupInterface.change_action_state_full
    """
    #  remote
    def __call__(
        self,
        remote: RemoteActionGroup,
        action_name: str,
        value: GLib.Variant,
        platform_data: GLib.Variant,
    ) -> None: ...

class reloadResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.reload
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
    ) -> None: ...

class lookup_by_nameResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        hostname: str,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class lookup_by_name_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        hostname: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class lookup_by_name_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> list: ...

class lookup_by_addressResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_address
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        address: InetAddress,
        cancellable: Cancellable | None = None,
    ) -> str: ...

class lookup_by_address_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_address_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        address: InetAddress,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class lookup_by_address_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_address_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> str: ...

class lookup_service_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_service_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        rrname: str,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class lookup_service_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_service_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> list: ...

class lookup_recordsResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_records
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class lookup_records_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_records_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        rrname: str,
        record_type: ResolverRecordType,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class lookup_records_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_records_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> list: ...

class lookup_by_name_with_flags_asyncResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_with_flags_async
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class lookup_by_name_with_flags_finishResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_with_flags_finish
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        result: AsyncResult,
    ) -> list: ...

class lookup_by_name_with_flagsResolverClassCB(typing.Protocol):
    """
    This callback was used in:
        ResolverClass.lookup_by_name_with_flags
    """
    #  resolver
    def __call__(
        self,
        resolver: Resolver,
        hostname: str,
        flags: ResolverNameLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class tellSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.tell
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
    ) -> int: ...

class can_seekSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.can_seek
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
    ) -> bool: ...

class seekSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.seek
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
        offset: int,
        type: GLib.SeekType,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class can_truncateSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.can_truncate
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
    ) -> bool: ...

class truncate_fnSeekableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SeekableIface.truncate_fn
    """
    #  seekable
    def __call__(
        self,
        seekable: Seekable,
        offset: int,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class SettingsGetMapping(typing.Protocol):
    """
    This callback was used in:
        Gio.get_mapped
    """
    #  value
    def __call__(
        self,
        value: GLib.Variant | None = None,
        *user_data: object | None,
    ) -> tuple[bool, object | None]: ...

class readSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.read
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
        expected_type: GLib.VariantType,
        default_value: bool,
    ) -> GLib.Variant: ...

class get_writableSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.get_writable
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
    ) -> bool: ...

class writeSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.write
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
        value: GLib.Variant,
        origin_tag: object | None = None,
    ) -> bool: ...

class write_treeSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.write_tree
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        tree: GLib.Tree,
        origin_tag: object | None = None,
    ) -> bool: ...

class resetSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.reset
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
        origin_tag: object | None = None,
    ) -> None: ...

class subscribeSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.subscribe
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        name: str,
    ) -> None: ...

class unsubscribeSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.unsubscribe
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        name: str,
    ) -> None: ...

class syncSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.sync
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
    ) -> None: ...

class read_user_valueSettingsBackendClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsBackendClass.read_user_value
    """
    #  backend
    def __call__(
        self,
        backend: SettingsBackend,
        key: str,
        expected_type: GLib.VariantType,
    ) -> GLib.Variant: ...

class writable_changedSettingsClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsClass.writable_changed
    """
    #  settings
    def __call__(
        self,
        settings: Settings,
        key: str,
    ) -> None: ...

class changedSettingsClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsClass.changed
    """
    #  settings
    def __call__(
        self,
        settings: Settings,
        key: str,
    ) -> None: ...

class writable_change_eventSettingsClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsClass.writable_change_event
    """
    #  settings
    def __call__(
        self,
        settings: Settings,
        key: int,
    ) -> bool: ...

class change_eventSettingsClassCB(typing.Protocol):
    """
    This callback was used in:
        SettingsClass.change_event
    """
    #  settings
    def __call__(
        self,
        settings: Settings,
        keys: int,
        n_keys: int,
    ) -> bool: ...

class get_familySocketAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressClass.get_family
    """
    #  address
    def __call__(
        self,
        address: SocketAddress,
    ) -> SocketFamily: ...

class get_native_sizeSocketAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressClass.get_native_size
    """
    #  address
    def __call__(
        self,
        address: SocketAddress,
    ) -> int: ...

class to_nativeSocketAddressClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressClass.to_native
    """
    #  address
    def __call__(
        self,
        address: SocketAddress,
        dest: object | None,
        destlen: int,
    ) -> bool: ...

class nextSocketAddressEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressEnumeratorClass.next
    """
    #  enumerator
    def __call__(
        self,
        enumerator: SocketAddressEnumerator,
        cancellable: Cancellable | None = None,
    ) -> SocketAddress | None: ...

class next_asyncSocketAddressEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressEnumeratorClass.next_async
    """
    #  enumerator
    def __call__(
        self,
        enumerator: SocketAddressEnumerator,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class next_finishSocketAddressEnumeratorClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketAddressEnumeratorClass.next_finish
    """
    #  enumerator
    def __call__(
        self,
        enumerator: SocketAddressEnumerator,
        result: AsyncResult,
    ) -> SocketAddress | None: ...

class eventSocketClientClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketClientClass.event
    """
    #  client
    def __call__(
        self,
        client: SocketClient,
        event: SocketClientEvent,
        connectable: SocketConnectable,
        connection: IOStream,
    ) -> None: ...

class enumerateSocketConnectableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SocketConnectableIface.enumerate
    """
    #  connectable
    def __call__(
        self,
        connectable: SocketConnectable,
    ) -> SocketAddressEnumerator: ...

class proxy_enumerateSocketConnectableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SocketConnectableIface.proxy_enumerate
    """
    #  connectable
    def __call__(
        self,
        connectable: SocketConnectable,
    ) -> SocketAddressEnumerator: ...

class to_stringSocketConnectableIfaceCB(typing.Protocol):
    """
    This callback was used in:
        SocketConnectableIface.to_string
    """
    #  connectable
    def __call__(
        self,
        connectable: SocketConnectable,
    ) -> str: ...

class get_sizeSocketControlMessageClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketControlMessageClass.get_size
    """
    #  message
    def __call__(
        self,
        message: SocketControlMessage,
    ) -> int: ...

class get_levelSocketControlMessageClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketControlMessageClass.get_level
    """
    #  message
    def __call__(
        self,
        message: SocketControlMessage,
    ) -> int: ...

class get_typeSocketControlMessageClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketControlMessageClass.get_type
    """
    #  message
    def __call__(
        self,
        message: SocketControlMessage,
    ) -> int: ...

class serializeSocketControlMessageClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketControlMessageClass.serialize
    """
    #  message
    def __call__(
        self,
        message: SocketControlMessage,
        data: object,
    ) -> None: ...

class changedSocketListenerClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketListenerClass.changed
    """
    #  listener
    def __call__(
        self,
        listener: SocketListener,
    ) -> None: ...

class eventSocketListenerClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketListenerClass.event
    """
    #  listener
    def __call__(
        self,
        listener: SocketListener,
        event: SocketListenerEvent,
        socket: Socket,
    ) -> None: ...

class incomingSocketServiceClassCB(typing.Protocol):
    """
    This callback was used in:
        SocketServiceClass.incoming
    """
    #  service
    def __call__(
        self,
        service: SocketService,
        connection: SocketConnection,
        source_object: GObject.Object,
    ) -> bool: ...

class TaskThreadFunc(typing.Protocol):
    """
    This callback was used in:
        Gio.run_in_thread, Gio.run_in_thread_sync
    """
    #  task
    def __call__(
        self,
        task: Task,
        source_object: GObject.Object,
        task_data: object | None = None,
        cancellable: Cancellable | None = None,
    ) -> None: ...

class runThreadedSocketServiceClassCB(typing.Protocol):
    """
    This callback was used in:
        ThreadedSocketServiceClass.run
    """
    #  service
    def __call__(
        self,
        service: ThreadedSocketService,
        connection: SocketConnection,
        source_object: GObject.Object,
    ) -> bool: ...

class supports_tlsTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.supports_tls
    """
    #  backend
    def __call__(
        self,
        backend: TlsBackend,
    ) -> bool: ...

class get_certificate_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_certificate_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_client_connection_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_client_connection_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_server_connection_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_server_connection_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_file_database_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_file_database_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_default_databaseTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_default_database
    """
    #  backend
    def __call__(
        self,
        backend: TlsBackend,
    ) -> TlsDatabase: ...

class supports_dtlsTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.supports_dtls
    """
    #  backend
    def __call__(
        self,
        backend: TlsBackend,
    ) -> bool: ...

class get_dtls_client_connection_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_dtls_client_connection_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class get_dtls_server_connection_typeTlsBackendInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsBackendInterface.get_dtls_server_connection_type
    """
    #
    def __call__(
        self,
    ) -> GObject.GType: ...

class verifyTlsCertificateClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsCertificateClass.verify
    """
    #  cert
    def __call__(
        self,
        cert: TlsCertificate,
        identity: SocketConnectable | None = None,
        trusted_ca: TlsCertificate | None = None,
    ) -> TlsCertificateFlags: ...

class copy_session_stateTlsClientConnectionInterfaceCB(typing.Protocol):
    """
    This callback was used in:
        TlsClientConnectionInterface.copy_session_state
    """
    #  conn
    def __call__(
        self,
        conn: TlsClientConnection,
        source: TlsClientConnection,
    ) -> None: ...

class accept_certificateTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.accept_certificate
    """
    #  connection
    def __call__(
        self,
        connection: TlsConnection,
        peer_cert: TlsCertificate,
        errors: TlsCertificateFlags,
    ) -> bool: ...

class handshakeTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.handshake
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class handshake_asyncTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.handshake_async
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
        io_priority: int,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class handshake_finishTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.handshake_finish
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
        result: AsyncResult,
    ) -> bool: ...

class get_binding_dataTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.get_binding_data
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
        type: TlsChannelBindingType,
        data: list,
    ) -> bool: ...

class get_negotiated_protocolTlsConnectionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsConnectionClass.get_negotiated_protocol
    """
    #  conn
    def __call__(
        self,
        conn: TlsConnection,
    ) -> str | None: ...

class verify_chainTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.verify_chain
    """
    #  self
    def __call__(
        self: TlsDatabase,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificateFlags: ...

class verify_chain_asyncTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.verify_chain_async
    """
    #  self
    def __call__(
        self: TlsDatabase,
        chain: TlsCertificate,
        purpose: str,
        identity: SocketConnectable | None,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseVerifyFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class verify_chain_finishTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.verify_chain_finish
    """
    #  self
    def __call__(
        self: TlsDatabase,
        result: AsyncResult,
    ) -> TlsCertificateFlags: ...

class create_certificate_handleTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.create_certificate_handle
    """
    #  self
    def __call__(
        self: TlsDatabase,
        certificate: TlsCertificate,
    ) -> str | None: ...

class lookup_certificate_for_handleTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_for_handle
    """
    #  self
    def __call__(
        self: TlsDatabase,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate | None: ...

class lookup_certificate_for_handle_asyncTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_for_handle_async
    """
    #  self
    def __call__(
        self: TlsDatabase,
        handle: str,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class lookup_certificate_for_handle_finishTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_for_handle_finish
    """
    #  self
    def __call__(
        self: TlsDatabase,
        result: AsyncResult,
    ) -> TlsCertificate: ...

class lookup_certificate_issuerTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_issuer
    """
    #  self
    def __call__(
        self: TlsDatabase,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsCertificate: ...

class lookup_certificate_issuer_asyncTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_issuer_async
    """
    #  self
    def __call__(
        self: TlsDatabase,
        certificate: TlsCertificate,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class lookup_certificate_issuer_finishTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificate_issuer_finish
    """
    #  self
    def __call__(
        self: TlsDatabase,
        result: AsyncResult,
    ) -> TlsCertificate: ...

class lookup_certificates_issued_byTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificates_issued_by
    """
    #  self
    def __call__(
        self: TlsDatabase,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
    ) -> list: ...

class lookup_certificates_issued_by_asyncTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificates_issued_by_async
    """
    #  self
    def __call__(
        self: TlsDatabase,
        issuer_raw_dn: list,
        interaction: TlsInteraction | None,
        flags: TlsDatabaseLookupFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class lookup_certificates_issued_by_finishTlsDatabaseClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsDatabaseClass.lookup_certificates_issued_by_finish
    """
    #  self
    def __call__(
        self: TlsDatabase,
        result: AsyncResult,
    ) -> list: ...

class ask_passwordTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.ask_password
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
    ) -> TlsInteractionResult: ...

class ask_password_asyncTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.ask_password_async
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        password: TlsPassword,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class ask_password_finishTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.ask_password_finish
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        result: AsyncResult,
    ) -> TlsInteractionResult: ...

class request_certificateTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.request_certificate
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
    ) -> TlsInteractionResult: ...

class request_certificate_asyncTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.request_certificate_async
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        connection: TlsConnection,
        flags: TlsCertificateRequestFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class request_certificate_finishTlsInteractionClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsInteractionClass.request_certificate_finish
    """
    #  interaction
    def __call__(
        self,
        interaction: TlsInteraction,
        result: AsyncResult,
    ) -> TlsInteractionResult: ...

class get_valueTlsPasswordClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsPasswordClass.get_value
    """
    #  password
    def __call__(
        self,
        password: TlsPassword,
    ) -> tuple[list, int]: ...

class set_valueTlsPasswordClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsPasswordClass.set_value
    """
    #  password
    def __call__(
        self,
        password: TlsPassword,
        value: list,
        length: int,
        destroy: GLib.DestroyNotify | None = None,  # type: ignore
    ) -> None: ...

class get_default_warningTlsPasswordClassCB(typing.Protocol):
    """
    This callback was used in:
        TlsPasswordClass.get_default_warning
    """
    #  password
    def __call__(
        self,
        password: TlsPassword,
    ) -> str: ...

class VfsFileLookupFunc(typing.Protocol):
    """
    This callback was used in:
        Gio.register_uri_scheme
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        identifier: str,
        *user_data: object | None,
    ) -> File | None: ...

class is_activeVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.is_active
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
    ) -> bool: ...

class get_file_for_pathVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.get_file_for_path
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        path: str,
    ) -> File: ...

class get_file_for_uriVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.get_file_for_uri
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        uri: str,
    ) -> File: ...

class get_supported_uri_schemesVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.get_supported_uri_schemes
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
    ) -> list: ...

class parse_nameVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.parse_name
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        parse_name: str,
    ) -> File: ...

class local_file_add_infoVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.local_file_add_info
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        filename: str,
        device: int,
        attribute_matcher: FileAttributeMatcher,
        info: FileInfo,
        cancellable: Cancellable | None,
        extra_data: object | None,
        free_extra_data: GLib.DestroyNotify,  # type: ignore
    ) -> None: ...

class add_writable_namespacesVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.add_writable_namespaces
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        list: FileAttributeInfoList,
    ) -> None: ...

class local_file_set_attributesVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.local_file_set_attributes
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        filename: str,
        info: FileInfo,
        flags: FileQueryInfoFlags,
        cancellable: Cancellable | None = None,
    ) -> bool: ...

class local_file_removedVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.local_file_removed
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        filename: str,
    ) -> None: ...

class local_file_movedVfsClassCB(typing.Protocol):
    """
    This callback was used in:
        VfsClass.local_file_moved
    """
    #  vfs
    def __call__(
        self,
        vfs: Vfs,
        source: str,
        dest: str,
    ) -> None: ...

class changedVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.changed
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> None: ...

class removedVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.removed
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> None: ...

class get_nameVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_name
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> str: ...

class get_iconVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_icon
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> Icon: ...

class get_uuidVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_uuid
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> str | None: ...

class get_driveVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_drive
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> Drive | None: ...

class get_mountVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_mount
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> Mount | None: ...

class can_mountVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.can_mount
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> bool: ...

class can_ejectVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.can_eject
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> bool: ...

class mount_fnVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.mount_fn
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        flags: MountMountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class mount_finishVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.mount_finish
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        result: AsyncResult,
    ) -> bool: ...

class ejectVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.eject
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        flags: MountUnmountFlags,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class eject_finishVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.eject_finish
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        result: AsyncResult,
    ) -> bool: ...

class get_identifierVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_identifier
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        kind: str,
    ) -> str | None: ...

class enumerate_identifiersVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.enumerate_identifiers
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> list: ...

class should_automountVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.should_automount
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> bool: ...

class get_activation_rootVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_activation_root
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> File | None: ...

class eject_with_operationVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.eject_with_operation
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        flags: MountUnmountFlags,
        mount_operation: MountOperation | None = None,
        cancellable: Cancellable | None = None,
        callback: AsyncReadyCallback | None = None,
        *user_data: object | None,
    ) -> None: ...

class eject_with_operation_finishVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.eject_with_operation_finish
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
        result: AsyncResult,
    ) -> bool: ...

class get_sort_keyVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_sort_key
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> str | None: ...

class get_symbolic_iconVolumeIfaceCB(typing.Protocol):
    """
    This callback was used in:
        VolumeIface.get_symbolic_icon
    """
    #  volume
    def __call__(
        self,
        volume: Volume,
    ) -> Icon: ...

class volume_addedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.volume_added
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        volume: Volume,
    ) -> None: ...

class volume_removedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.volume_removed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        volume: Volume,
    ) -> None: ...

class volume_changedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.volume_changed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        volume: Volume,
    ) -> None: ...

class mount_addedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.mount_added
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        mount: Mount,
    ) -> None: ...

class mount_removedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.mount_removed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        mount: Mount,
    ) -> None: ...

class mount_pre_unmountVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.mount_pre_unmount
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        mount: Mount,
    ) -> None: ...

class mount_changedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.mount_changed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        mount: Mount,
    ) -> None: ...

class drive_connectedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_connected
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class drive_disconnectedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_disconnected
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class drive_changedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_changed
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class is_supportedVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.is_supported
    """
    #
    def __call__(
        self,
    ) -> bool: ...

class get_connected_drivesVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_connected_drives
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
    ) -> list: ...

class get_volumesVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_volumes
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
    ) -> list: ...

class get_mountsVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_mounts
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
    ) -> list: ...

class get_volume_for_uuidVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_volume_for_uuid
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        uuid: str,
    ) -> Volume | None: ...

class get_mount_for_uuidVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.get_mount_for_uuid
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        uuid: str,
    ) -> Mount | None: ...

class drive_eject_buttonVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_eject_button
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class drive_stop_buttonVolumeMonitorClassCB(typing.Protocol):
    """
    This callback was used in:
        VolumeMonitorClass.drive_stop_button
    """
    #  volume_monitor
    def __call__(
        self,
        volume_monitor: VolumeMonitor,
        drive: Drive,
    ) -> None: ...

class IOSchedulerJobFunc(typing.Protocol):
    """
    This callback was used in:
        Gio.io_scheduler_push_job
    """
    #  job
    def __call__(
        self,
        job: IOSchedulerJob,
        cancellable: Cancellable | None = None,
        data: object | None = None,
    ) -> bool: ...

###############################################################
# Aliases
###############################################################

FDMessage = GioUnix.FDMessage
"""
[DEPRECATED] Gio.FDMessage is deprecated; use GioUnix.FDMessage instead
"""
FDMessageClass = GioUnix.FDMessageClass
"""
[DEPRECATED] Gio.FDMessageClass is deprecated; use GioUnix.FDMessageClass instead
"""
FDMessagePrivate = GioUnix.FDMessagePrivate
"""
[DEPRECATED] Gio.FDMessagePrivate is deprecated; use GioUnix.FDMessagePrivate instead
"""
MountEntry = GioUnix.MountEntry
"""
[DEPRECATED] Gio.MountEntry is deprecated; use GioUnix.MountEntry instead
"""
MountMonitor = GioUnix.MountMonitor
"""
[DEPRECATED] Gio.MountMonitor is deprecated; use GioUnix.MountMonitor instead
"""
MountMonitorClass = GioUnix.MountMonitorClass
"""
[DEPRECATED] Gio.MountMonitorClass is deprecated; use GioUnix.MountMonitorClass instead
"""
MountPoint = GioUnix.MountPoint
"""
[DEPRECATED] Gio.MountPoint is deprecated; use GioUnix.MountPoint instead
"""
UnixFDMessage = FDMessage
UnixInputStream = InputStream
UnixMountEntry = MountEntry
UnixMountMonitor = MountMonitor
UnixMountPoint = MountPoint
UnixOutputStream = OutputStream
_lock = _thread._lock  # type: ignore
_overrides_module = ...  # this very module ...
desktop_app_info_lookup_get_default_for_uri_scheme = GioUnix.desktop_app_info_lookup_get_default_for_uri_scheme
"""
[DEPRECATED] Gio.desktop_app_info_lookup_get_default_for_uri_scheme is deprecated; use GioUnix.desktop_app_info_lookup_get_default_for_uri_scheme instead
"""
file_descriptor_based_get_fd = GioUnix.file_descriptor_based_get_fd
"""
[DEPRECATED] Gio.file_descriptor_based_get_fd is deprecated; use GioUnix.file_descriptor_based_get_fd instead
"""
is_mount_path_system_internal = GioUnix.is_mount_path_system_internal
"""
[DEPRECATED] Gio.is_mount_path_system_internal is deprecated; use GioUnix.is_mount_path_system_internal instead
"""
is_system_device_path = GioUnix.is_system_device_path
"""
[DEPRECATED] Gio.is_system_device_path is deprecated; use GioUnix.is_system_device_path instead
"""
is_system_fs_type = GioUnix.is_system_fs_type
"""
[DEPRECATED] Gio.is_system_fs_type is deprecated; use GioUnix.is_system_fs_type instead
"""
mount_at = GioUnix.mount_at
"""
[DEPRECATED] Gio.mount_at is deprecated; use GioUnix.mount_at instead
"""
mount_compare = GioUnix.mount_compare
"""
[DEPRECATED] Gio.mount_compare is deprecated; use GioUnix.mount_compare instead
"""
mount_copy = GioUnix.mount_copy
"""
[DEPRECATED] Gio.mount_copy is deprecated; use GioUnix.mount_copy instead
"""
mount_entries_changed_since = GioUnix.mount_entries_changed_since
"""
[DEPRECATED] Gio.mount_entries_changed_since is deprecated; use GioUnix.mount_entries_changed_since instead
"""
mount_entries_get = GioUnix.mount_entries_get
"""
[DEPRECATED] Gio.mount_entries_get is deprecated; use GioUnix.mount_entries_get instead
"""
mount_entries_get_from_file = GioUnix.mount_entries_get_from_file
"""
[DEPRECATED] Gio.mount_entries_get_from_file is deprecated; use GioUnix.mount_entries_get_from_file instead
"""
mount_entry_at = GioUnix.mount_entry_at
"""
[DEPRECATED] Gio.mount_entry_at is deprecated; use GioUnix.mount_entry_at instead
"""
mount_entry_compare = GioUnix.mount_entry_compare
"""
[DEPRECATED] Gio.mount_entry_compare is deprecated; use GioUnix.mount_entry_compare instead
"""
mount_entry_copy = GioUnix.mount_entry_copy
"""
[DEPRECATED] Gio.mount_entry_copy is deprecated; use GioUnix.mount_entry_copy instead
"""
mount_entry_for = GioUnix.mount_entry_for
"""
[DEPRECATED] Gio.mount_entry_for is deprecated; use GioUnix.mount_entry_for instead
"""
mount_entry_free = GioUnix.mount_entry_free
"""
[DEPRECATED] Gio.mount_entry_free is deprecated; use GioUnix.mount_entry_free instead
"""
mount_entry_get_device_path = GioUnix.mount_entry_get_device_path
"""
[DEPRECATED] Gio.mount_entry_get_device_path is deprecated; use GioUnix.mount_entry_get_device_path instead
"""
mount_entry_get_fs_type = GioUnix.mount_entry_get_fs_type
"""
[DEPRECATED] Gio.mount_entry_get_fs_type is deprecated; use GioUnix.mount_entry_get_fs_type instead
"""
mount_entry_get_mount_path = GioUnix.mount_entry_get_mount_path
"""
[DEPRECATED] Gio.mount_entry_get_mount_path is deprecated; use GioUnix.mount_entry_get_mount_path instead
"""
mount_entry_get_options = GioUnix.mount_entry_get_options
"""
[DEPRECATED] Gio.mount_entry_get_options is deprecated; use GioUnix.mount_entry_get_options instead
"""
mount_entry_get_root_path = GioUnix.mount_entry_get_root_path
"""
[DEPRECATED] Gio.mount_entry_get_root_path is deprecated; use GioUnix.mount_entry_get_root_path instead
"""
mount_entry_guess_can_eject = GioUnix.mount_entry_guess_can_eject
"""
[DEPRECATED] Gio.mount_entry_guess_can_eject is deprecated; use GioUnix.mount_entry_guess_can_eject instead
"""
mount_entry_guess_icon = GioUnix.mount_entry_guess_icon
"""
[DEPRECATED] Gio.mount_entry_guess_icon is deprecated; use GioUnix.mount_entry_guess_icon instead
"""
mount_entry_guess_name = GioUnix.mount_entry_guess_name
"""
[DEPRECATED] Gio.mount_entry_guess_name is deprecated; use GioUnix.mount_entry_guess_name instead
"""
mount_entry_guess_should_display = GioUnix.mount_entry_guess_should_display
"""
[DEPRECATED] Gio.mount_entry_guess_should_display is deprecated; use GioUnix.mount_entry_guess_should_display instead
"""
mount_entry_guess_symbolic_icon = GioUnix.mount_entry_guess_symbolic_icon
"""
[DEPRECATED] Gio.mount_entry_guess_symbolic_icon is deprecated; use GioUnix.mount_entry_guess_symbolic_icon instead
"""
mount_entry_is_readonly = GioUnix.mount_entry_is_readonly
"""
[DEPRECATED] Gio.mount_entry_is_readonly is deprecated; use GioUnix.mount_entry_is_readonly instead
"""
mount_entry_is_system_internal = GioUnix.mount_entry_is_system_internal
"""
[DEPRECATED] Gio.mount_entry_is_system_internal is deprecated; use GioUnix.mount_entry_is_system_internal instead
"""
mount_for = GioUnix.mount_for
"""
[DEPRECATED] Gio.mount_for is deprecated; use GioUnix.mount_for instead
"""
mount_free = GioUnix.mount_free
"""
[DEPRECATED] Gio.mount_free is deprecated; use GioUnix.mount_free instead
"""
mount_get_device_path = GioUnix.mount_get_device_path
"""
[DEPRECATED] Gio.mount_get_device_path is deprecated; use GioUnix.mount_get_device_path instead
"""
mount_get_fs_type = GioUnix.mount_get_fs_type
"""
[DEPRECATED] Gio.mount_get_fs_type is deprecated; use GioUnix.mount_get_fs_type instead
"""
mount_get_mount_path = GioUnix.mount_get_mount_path
"""
[DEPRECATED] Gio.mount_get_mount_path is deprecated; use GioUnix.mount_get_mount_path instead
"""
mount_get_options = GioUnix.mount_get_options
"""
[DEPRECATED] Gio.mount_get_options is deprecated; use GioUnix.mount_get_options instead
"""
mount_get_root_path = GioUnix.mount_get_root_path
"""
[DEPRECATED] Gio.mount_get_root_path is deprecated; use GioUnix.mount_get_root_path instead
"""
mount_guess_can_eject = GioUnix.mount_guess_can_eject
"""
[DEPRECATED] Gio.mount_guess_can_eject is deprecated; use GioUnix.mount_guess_can_eject instead
"""
mount_guess_icon = GioUnix.mount_guess_icon
"""
[DEPRECATED] Gio.mount_guess_icon is deprecated; use GioUnix.mount_guess_icon instead
"""
mount_guess_name = GioUnix.mount_guess_name
"""
[DEPRECATED] Gio.mount_guess_name is deprecated; use GioUnix.mount_guess_name instead
"""
mount_guess_should_display = GioUnix.mount_guess_should_display
"""
[DEPRECATED] Gio.mount_guess_should_display is deprecated; use GioUnix.mount_guess_should_display instead
"""
mount_guess_symbolic_icon = GioUnix.mount_guess_symbolic_icon
"""
[DEPRECATED] Gio.mount_guess_symbolic_icon is deprecated; use GioUnix.mount_guess_symbolic_icon instead
"""
mount_is_readonly = GioUnix.mount_is_readonly
"""
[DEPRECATED] Gio.mount_is_readonly is deprecated; use GioUnix.mount_is_readonly instead
"""
mount_is_system_internal = GioUnix.mount_is_system_internal
"""
[DEPRECATED] Gio.mount_is_system_internal is deprecated; use GioUnix.mount_is_system_internal instead
"""
mount_point_at = GioUnix.mount_point_at
"""
[DEPRECATED] Gio.mount_point_at is deprecated; use GioUnix.mount_point_at instead
"""
mount_point_compare = GioUnix.mount_point_compare
"""
[DEPRECATED] Gio.mount_point_compare is deprecated; use GioUnix.mount_point_compare instead
"""
mount_point_copy = GioUnix.mount_point_copy
"""
[DEPRECATED] Gio.mount_point_copy is deprecated; use GioUnix.mount_point_copy instead
"""
mount_point_free = GioUnix.mount_point_free
"""
[DEPRECATED] Gio.mount_point_free is deprecated; use GioUnix.mount_point_free instead
"""
mount_point_get_device_path = GioUnix.mount_point_get_device_path
"""
[DEPRECATED] Gio.mount_point_get_device_path is deprecated; use GioUnix.mount_point_get_device_path instead
"""
mount_point_get_fs_type = GioUnix.mount_point_get_fs_type
"""
[DEPRECATED] Gio.mount_point_get_fs_type is deprecated; use GioUnix.mount_point_get_fs_type instead
"""
mount_point_get_mount_path = GioUnix.mount_point_get_mount_path
"""
[DEPRECATED] Gio.mount_point_get_mount_path is deprecated; use GioUnix.mount_point_get_mount_path instead
"""
mount_point_get_options = GioUnix.mount_point_get_options
"""
[DEPRECATED] Gio.mount_point_get_options is deprecated; use GioUnix.mount_point_get_options instead
"""
mount_point_guess_can_eject = GioUnix.mount_point_guess_can_eject
"""
[DEPRECATED] Gio.mount_point_guess_can_eject is deprecated; use GioUnix.mount_point_guess_can_eject instead
"""
mount_point_guess_icon = GioUnix.mount_point_guess_icon
"""
[DEPRECATED] Gio.mount_point_guess_icon is deprecated; use GioUnix.mount_point_guess_icon instead
"""
mount_point_guess_name = GioUnix.mount_point_guess_name
"""
[DEPRECATED] Gio.mount_point_guess_name is deprecated; use GioUnix.mount_point_guess_name instead
"""
mount_point_guess_symbolic_icon = GioUnix.mount_point_guess_symbolic_icon
"""
[DEPRECATED] Gio.mount_point_guess_symbolic_icon is deprecated; use GioUnix.mount_point_guess_symbolic_icon instead
"""
mount_point_is_loopback = GioUnix.mount_point_is_loopback
"""
[DEPRECATED] Gio.mount_point_is_loopback is deprecated; use GioUnix.mount_point_is_loopback instead
"""
mount_point_is_readonly = GioUnix.mount_point_is_readonly
"""
[DEPRECATED] Gio.mount_point_is_readonly is deprecated; use GioUnix.mount_point_is_readonly instead
"""
mount_point_is_user_mountable = GioUnix.mount_point_is_user_mountable
"""
[DEPRECATED] Gio.mount_point_is_user_mountable is deprecated; use GioUnix.mount_point_is_user_mountable instead
"""
mount_points_changed_since = GioUnix.mount_points_changed_since
"""
[DEPRECATED] Gio.mount_points_changed_since is deprecated; use GioUnix.mount_points_changed_since instead
"""
mount_points_get = GioUnix.mount_points_get
"""
[DEPRECATED] Gio.mount_points_get is deprecated; use GioUnix.mount_points_get instead
"""
mount_points_get_from_file = GioUnix.mount_points_get_from_file
"""
[DEPRECATED] Gio.mount_points_get_from_file is deprecated; use GioUnix.mount_points_get_from_file instead
"""
mounts_changed_since = GioUnix.mounts_changed_since
"""
[DEPRECATED] Gio.mounts_changed_since is deprecated; use GioUnix.mounts_changed_since instead
"""
mounts_get = GioUnix.mounts_get
"""
[DEPRECATED] Gio.mounts_get is deprecated; use GioUnix.mounts_get instead
"""
mounts_get_from_file = GioUnix.mounts_get_from_file
"""
[DEPRECATED] Gio.mounts_get_from_file is deprecated; use GioUnix.mounts_get_from_file instead
"""
###############################################################
# Constants
###############################################################

DBUS_METHOD_INVOCATION_HANDLED: bool = ...
DBUS_METHOD_INVOCATION_UNHANDLED: bool = ...
DEBUG_CONTROLLER_EXTENSION_POINT_NAME: str = ...
DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: str = ...
DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_DELETE: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_READ: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_RENAME: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_TRASH: str = ...
FILE_ATTRIBUTE_ACCESS_CAN_WRITE: str = ...
FILE_ATTRIBUTE_DOS_IS_ARCHIVE: str = ...
FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: str = ...
FILE_ATTRIBUTE_DOS_IS_SYSTEM: str = ...
FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: str = ...
FILE_ATTRIBUTE_ETAG_VALUE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_FREE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_READONLY: str = ...
FILE_ATTRIBUTE_FILESYSTEM_REMOTE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_SIZE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_TYPE: str = ...
FILE_ATTRIBUTE_FILESYSTEM_USED: str = ...
FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: str = ...
FILE_ATTRIBUTE_GVFS_BACKEND: str = ...
FILE_ATTRIBUTE_ID_FILE: str = ...
FILE_ATTRIBUTE_ID_FILESYSTEM: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_START: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: str = ...
FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: str = ...
FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: str = ...
FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: str = ...
FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: str = ...
FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: str = ...
FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: str = ...
FILE_ATTRIBUTE_OWNER_GROUP: str = ...
FILE_ATTRIBUTE_OWNER_USER: str = ...
FILE_ATTRIBUTE_OWNER_USER_REAL: str = ...
FILE_ATTRIBUTE_PREVIEW_ICON: str = ...
FILE_ATTRIBUTE_RECENT_MODIFIED: str = ...
FILE_ATTRIBUTE_SELINUX_CONTEXT: str = ...
FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: str = ...
FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: str = ...
FILE_ATTRIBUTE_STANDARD_COPY_NAME: str = ...
FILE_ATTRIBUTE_STANDARD_DESCRIPTION: str = ...
FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: str = ...
FILE_ATTRIBUTE_STANDARD_EDIT_NAME: str = ...
FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: str = ...
FILE_ATTRIBUTE_STANDARD_ICON: str = ...
FILE_ATTRIBUTE_STANDARD_IS_BACKUP: str = ...
FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: str = ...
FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: str = ...
FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: str = ...
FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: str = ...
FILE_ATTRIBUTE_STANDARD_NAME: str = ...
FILE_ATTRIBUTE_STANDARD_SIZE: str = ...
FILE_ATTRIBUTE_STANDARD_SORT_ORDER: str = ...
FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: str = ...
FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: str = ...
FILE_ATTRIBUTE_STANDARD_TARGET_URI: str = ...
FILE_ATTRIBUTE_STANDARD_TYPE: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: str = ...
FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: str = ...
FILE_ATTRIBUTE_TIME_ACCESS: str = ...
FILE_ATTRIBUTE_TIME_ACCESS_NSEC: str = ...
FILE_ATTRIBUTE_TIME_ACCESS_USEC: str = ...
FILE_ATTRIBUTE_TIME_CHANGED: str = ...
FILE_ATTRIBUTE_TIME_CHANGED_NSEC: str = ...
FILE_ATTRIBUTE_TIME_CHANGED_USEC: str = ...
FILE_ATTRIBUTE_TIME_CREATED: str = ...
FILE_ATTRIBUTE_TIME_CREATED_NSEC: str = ...
FILE_ATTRIBUTE_TIME_CREATED_USEC: str = ...
FILE_ATTRIBUTE_TIME_MODIFIED: str = ...
FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: str = ...
FILE_ATTRIBUTE_TIME_MODIFIED_USEC: str = ...
FILE_ATTRIBUTE_TRASH_DELETION_DATE: str = ...
FILE_ATTRIBUTE_TRASH_ITEM_COUNT: str = ...
FILE_ATTRIBUTE_TRASH_ORIG_PATH: str = ...
FILE_ATTRIBUTE_UNIX_BLOCKS: str = ...
FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: str = ...
FILE_ATTRIBUTE_UNIX_DEVICE: str = ...
FILE_ATTRIBUTE_UNIX_GID: str = ...
FILE_ATTRIBUTE_UNIX_INODE: str = ...
FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: str = ...
FILE_ATTRIBUTE_UNIX_MODE: str = ...
FILE_ATTRIBUTE_UNIX_NLINK: str = ...
FILE_ATTRIBUTE_UNIX_RDEV: str = ...
FILE_ATTRIBUTE_UNIX_UID: str = ...
MEMORY_MONITOR_EXTENSION_POINT_NAME: str = ...
MENU_ATTRIBUTE_ACTION: str = ...
MENU_ATTRIBUTE_ACTION_NAMESPACE: str = ...
MENU_ATTRIBUTE_ICON: str = ...
MENU_ATTRIBUTE_LABEL: str = ...
MENU_ATTRIBUTE_TARGET: str = ...
MENU_EXPORTER_MAX_SECTION_SIZE: int = ...
MENU_LINK_SECTION: str = ...
MENU_LINK_SUBMENU: str = ...
NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: str = ...
NETWORK_MONITOR_EXTENSION_POINT_NAME: str = ...
POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: str = ...
PROXY_EXTENSION_POINT_NAME: str = ...
PROXY_RESOLVER_EXTENSION_POINT_NAME: str = ...
SETTINGS_BACKEND_EXTENSION_POINT_NAME: str = ...
TLS_BACKEND_EXTENSION_POINT_NAME: str = ...
TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: str = ...
TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: str = ...
VFS_EXTENSION_POINT_NAME: str = ...
VOLUME_IDENTIFIER_KIND_CLASS: str = ...
VOLUME_IDENTIFIER_KIND_HAL_UDI: str = ...
VOLUME_IDENTIFIER_KIND_LABEL: str = ...
VOLUME_IDENTIFIER_KIND_NFS_MOUNT: str = ...
VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: str = ...
VOLUME_IDENTIFIER_KIND_UUID: str = ...
VOLUME_MONITOR_EXTENSION_POINT_NAME: str = ...
_namespace: str = ...
_version: str = ...
###############################################################
# Unknowns/Not Parsed
###############################################################
